diff -urN /develop/source/01boot/u-boot-1.1.6/board/apus/apus.c u-boot-1.1.6/board/apus/apus.c
--- /develop/source/01boot/u-boot-1.1.6/board/apus/apus.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/apus/apus.c	2008-12-17 19:14:26.000000000 +0800
@@ -0,0 +1,71 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4750.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+#if CONFIG_NR_DRAM_BANKS == 2   /*Use Two Banks SDRAM*/
+	__gpio_as_sdram_x2_32bit();
+#else
+	__gpio_as_sdram_32bit();
+#endif
+
+#ifdef CONFIG_MSC_U_BOOT
+	if(CFG_NAND_IS_SHARE)
+		REG_EMC_BCR &= ~EMC_BCR_BSR_UNSHARE;
+	else
+		REG_EMC_BCR |= EMC_BCR_BSR_UNSHARE;	
+
+	__gpio_as_nand_8bit(1);
+#endif
+
+	/*
+	 * Initialize UART pins
+	 */
+	__gpio_as_uart3();
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic APUS (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/apus/config.mk u-boot-1.1.6/board/apus/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/apus/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/apus/config.mk	2008-10-31 17:26:09.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's lib4750 board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
\ No newline at end of file
diff -urN /develop/source/01boot/u-boot-1.1.6/board/apus/flash.c u-boot-1.1.6/board/apus/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/apus/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/apus/flash.c	2008-09-24 02:41:50.000000000 +0800
@@ -0,0 +1,543 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This file supports SST 16-bit Flashes:
+ * 39xF1601, 39xF1602, 39xF3201, 39xF3202, 39xF6401, 39xF6402,
+ * 39xF6401B, 39xF6402B.
+ */
+
+#include <common.h>
+
+#define SST_ID_xF6401B	0x236D236D	/* 39xF6401B ID (64M =	4M x 16 )	*/
+#define SST_ID_xF6402B	0x236C236C	/* 39xF6402B ID (64M =	4M x 16 )	*/
+#define AMD_ID_DL640	0x227E227E	/* 29DL640D ID (64 M, dual boot sectors)*/
+
+#define AMD_SECT_SIZE     0x10000
+#define SST_SECT_SIZE     0x1000
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+static ulong flash_base = 0xa8000000;    /* base address of CS4 */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+ulong flash_init(void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)flash_base, &flash_info[0]);
+		}
+		else
+			panic("configured too many flash banks!\n");
+		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+
+ 		switch (flash_info[i].flash_id & FLASH_VENDMASK) {
+ 		case (AMD_MANUFACT & FLASH_VENDMASK):
+			for (j = 0; j < flash_info[i].sector_count; j++) {
+#if 1
+				if (j < 8) {     // 8 x 8k boot sectors	
+					flash_info[i].start[j] = flash_base + j * 0x2000;
+				}
+				else {
+					flash_info[i].start[j] = flash_base + (j-7) * AMD_SECT_SIZE;
+				}
+#else
+				flash_info[i].start[j] = flash_base + j * AMD_SECT_SIZE;
+#endif
+					
+			}
+			break;
+
+ 		case (SST_MANUFACT & FLASH_VENDMASK): 
+			for (j = 0; j < flash_info[i].sector_count; j++) { 
+				flash_info[i].start[j] = flash_base + j * SST_SECT_SIZE;
+			}
+			break;
+
+		default:
+			break;
+  		}
+ 	} 
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_MONITOR_BASE,
+			CFG_MONITOR_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+#endif
+
+	return size;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST ");
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_DL640 & FLASH_TYPEMASK):
+		printf ("29DL640D (64Mbit)\n");
+		break;
+	case (AMD_ID_DL640G_2 & FLASH_TYPEMASK):
+		printf ("AM29DL640G2 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1601 & FLASH_TYPEMASK):
+		printf ("39xF1601 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1602 & FLASH_TYPEMASK):
+		printf ("39xF1602 (16Mbit)\n");
+		break;
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		printf ("39xF3201 (32Mbit)\n");
+		break;
+	case (SST_ID_xF3202 & FLASH_TYPEMASK):
+		printf ("39xF3202 (32Mbit)\n");
+		break;
+	case (SST_ID_xF6401 & FLASH_TYPEMASK):
+		printf ("39xF6401 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402 & FLASH_TYPEMASK):
+		printf ("39xF6402 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6401B & FLASH_TYPEMASK):
+		printf ("39xF6401B (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402B & FLASH_TYPEMASK):
+		printf ("39xF6402B (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	ushort vid, did;
+	vu_short *saddr = (vu_short *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	if (vid != (SST_MANUFACT & 0xFFFF)) {
+		/* 39xF640xB stuff */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0x90;
+
+		vid = saddr[0];
+		did = saddr[1];
+
+		/* Exit Read IDs */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0xF0;
+	}
+
+	switch (vid) {
+	case (AMD_MANUFACT & 0xFFFF):
+		info->flash_id = (AMD_MANUFACT & 0xFFFF0000);
+       		break;
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case (AMD_ID_DL640 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640 & 0xFFFF); 
+		info->sector_count = 135;
+		info->size = 0x00800000;
+		break;
+	case (AMD_ID_DL640G_2 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640G_2 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF1601 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1601 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		break;
+	case (SST_ID_xF1602 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1602 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		break;
+	case (SST_ID_xF3201 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3201 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		break;
+	case (SST_ID_xF3202 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3202 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		break;
+	case (SST_ID_xF6401 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6402 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6401B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6402B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (SST_MANUFACT & FLASH_VENDMASK) &&
+	    (info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+			switch (info->flash_id & FLASH_VENDMASK) {
+			case (SST_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+				    ((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			case (AMD_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (AMD_ID_DL640 & FLASH_TYPEMASK))  
+					)
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			}
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		if (((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+		    ((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0;
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		if ((info->flash_id & FLASH_TYPEMASK) == 
+		    (AMD_ID_DL640 & FLASH_TYPEMASK)) 
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0; 
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	}
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/apus/Makefile u-boot-1.1.6/board/apus/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/apus/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/apus/Makefile	2008-09-24 02:41:50.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/apus/u-boot.lds u-boot-1.1.6/board/apus/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/apus/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/apus/u-boot.lds	2008-09-24 02:41:50.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/apus/u-boot-nand.lds u-boot-1.1.6/board/apus/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/apus/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/apus/u-boot-nand.lds	2008-09-24 02:41:50.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/dipper/config.mk u-boot-1.1.6/board/dipper/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/dipper/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/dipper/config.mk	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's pavo board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
diff -urN /develop/source/01boot/u-boot-1.1.6/board/dipper/dipper.c u-boot-1.1.6/board/dipper/dipper.c
--- /develop/source/01boot/u-boot-1.1.6/board/dipper/dipper.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/dipper/dipper.c	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,101 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4740.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize NAND Flash Pins
+	 */
+	__gpio_as_nand();
+
+	/*
+	 * Initialize SDRAM pins
+	 */
+	__gpio_as_sdram_16bit_4725();
+
+	/*
+	 * Initialize UART0 pins
+	 */
+	__gpio_as_uart0();
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize LCD pins
+	 */
+//	__gpio_as_lcd_18bit();
+
+	/*
+	 * Initialize SSI pins
+	 */
+	__gpio_as_ssi();
+
+	/*
+	 * Initialize I2C pins
+	 */
+	__gpio_as_i2c();
+
+	/*
+	 * Initialize Other pins
+	 */
+	__gpio_as_output(GPIO_SD_VCC_EN_N);
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);
+
+	__gpio_as_input(GPIO_SD_CD_N);
+	__gpio_disable_pull(GPIO_SD_CD_N);
+
+	__gpio_as_input(GPIO_SD_WP);
+	__gpio_disable_pull(GPIO_SD_WP);
+
+	__gpio_as_input(GPIO_DC_DETE_N);
+	__gpio_as_input(GPIO_CHARG_STAT_N);
+	__gpio_as_input(GPIO_USB_DETE);
+
+	__gpio_as_output(GPIO_DISP_OFF_N);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic DIPPER (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/dipper/flash.c u-boot-1.1.6/board/dipper/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/dipper/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/dipper/flash.c	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	return (0);
+}
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	printf ("flash_erase not implemented\n");
+	return 0;
+}
+
+void flash_print_info (flash_info_t * info)
+{
+	printf ("flash_print_info not implemented\n");
+}
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	printf ("write_buff not implemented\n");
+	return (-1);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/dipper/Makefile u-boot-1.1.6/board/dipper/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/dipper/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/dipper/Makefile	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/dipper/u-boot.lds u-boot-1.1.6/board/dipper/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/dipper/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/dipper/u-boot.lds	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/dipper/u-boot-nand.lds u-boot-1.1.6/board/dipper/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/dipper/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/dipper/u-boot-nand.lds	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/emurus/config.mk u-boot-1.1.6/board/emurus/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/emurus/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/emurus/config.mk	2007-05-23 11:21:20.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's emurus FPGA board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/emurus/emurus.c u-boot-1.1.6/board/emurus/emurus.c
--- /develop/source/01boot/u-boot-1.1.6/board/emurus/emurus.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/emurus/emurus.c	2008-01-11 16:58:13.000000000 +0800
@@ -0,0 +1,132 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4740.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+
+	/* PORT A: D0 ~ D31 */
+	REG_GPIO_PXFUNS(0) = 0xffffffff;
+	REG_GPIO_PXSELC(0) = 0xffffffff;
+
+	/* PORT B: A0 ~ A16, DCS#, RAS#, CAS#, CKE#, RDWE#, CKO#, WE0# */
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;
+
+	/* PORT C: WE1#, WE2#, WE3# */
+	REG_GPIO_PXFUNS(2) = 0x07000000;
+	REG_GPIO_PXSELC(2) = 0x07000000;
+
+
+	/*
+	 * Initialize Static Memory Pins
+	 */
+
+	/* CS4# */
+	REG_GPIO_PXFUNS(1) = 0x10000000;
+	REG_GPIO_PXSELC(1) = 0x10000000;
+
+
+	/*
+	 * Initialize UART0 pins
+	 */
+
+	/* PORT D: TXD/RXD */
+	REG_GPIO_PXFUNS(3) = 0x06000000;
+	REG_GPIO_PXSELS(3) = 0x06000000;
+
+	/*
+	 * Initialize LED pins
+	 */
+
+	/* PORT B: CS2# */
+	REG_GPIO_PXFUNS(1) = 0x04000000;
+	REG_GPIO_PXSELC(1) = 0x04000000;
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//#define LED_ADDR 0xb6000058
+#define LED_ADDR 0xb6000016
+
+static const unsigned char digits[16] = "0123456789abcdef";
+
+void led_puts(const unsigned char *s)
+{
+	volatile unsigned char* leds = (volatile unsigned char *)LED_ADDR;
+	unsigned int i = 0;
+
+	while ( s[i] && (i<8)) {
+		leds[i] = s[i];
+		i++;
+	}
+	while (i<8)
+		leds[i++] = ' ';
+}
+
+void led_putb(unsigned char val)
+{
+	volatile unsigned char* leds = (unsigned char *)LED_ADDR+8;
+	unsigned int i;
+    
+	for (i = 0; i < 2; i++) {
+		*--leds = digits[(unsigned char)(val &0x0f)];
+		val >>= 4;
+	}
+	while (i<8)
+		*--leds = ' ';
+}
+
+void led_putl(unsigned int val)
+{
+	volatile unsigned char* leds = (unsigned char *)LED_ADDR+8;
+	unsigned int i;
+
+	for (i = 0; i < 8; i++) {
+		*--leds = digits[(unsigned char)(val &0x0f)];
+		val >>= 4;
+	}
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic EMURUS (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/emurus/flash.c u-boot-1.1.6/board/emurus/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/emurus/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/emurus/flash.c	2007-05-23 11:21:20.000000000 +0800
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	return (0);
+}
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	printf ("flash_erase not implemented\n");
+	return 0;
+}
+
+void flash_print_info (flash_info_t * info)
+{
+	printf ("flash_print_info not implemented\n");
+}
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	printf ("write_buff not implemented\n");
+	return (-1);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/emurus/Makefile u-boot-1.1.6/board/emurus/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/emurus/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/emurus/Makefile	2007-05-23 11:21:20.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/emurus/u-boot.lds u-boot-1.1.6/board/emurus/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/emurus/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/emurus/u-boot.lds	2007-05-23 11:21:20.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fcr/config.mk u-boot-1.1.6/board/fcr/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/fcr/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fcr/config.mk	2007-05-23 12:16:05.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's FCR board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fcr/fcr.c u-boot-1.1.6/board/fcr/fcr.c
--- /develop/source/01boot/u-boot-1.1.6/board/fcr/fcr.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fcr/fcr.c	2007-05-23 12:16:05.000000000 +0800
@@ -0,0 +1,85 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+static void gpio_init(void)
+{
+	/* board led pins */
+	__gpio_as_output(0);
+	__gpio_as_output(1);
+	__gpio_as_output(2);
+	__gpio_as_output(3);
+
+	__gpio_as_emc();
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+	__gpio_as_scc();
+	__gpio_as_lcd_master();
+	__gpio_as_usb();
+	__gpio_as_eth();
+	__gpio_as_pwm();
+	__gpio_as_ps2();
+	__gpio_as_uprt();
+
+	__gpio_as_output(9);		/* Mem R/B */
+	__gpio_as_output(10);		/* M/CPU Select */
+	__gpio_as_output(13);		/* LCDM Backlight */
+	__gpio_as_output(14);		/* C/D Pin of LCDM */
+	__gpio_as_output(88);		/* Beeper */
+	__gpio_as_output(89);		/* Cash Box */
+//	__gpio_as_output(90);		/* Modem Enable */
+//	__gpio_as_output(91);		/* INTA_N, external RTC irq */
+
+	__harb_usb0_uhc(); /* USB port 0 as host */
+//	__harb_usb0_udc(); /* USB port 0 as device */
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+	REG_EMC_SMCR1 = 0x0bbb6600;	/* optimization for LCM */
+}
+
+void board_led(char ch)
+{
+	__gpio_port_data(0) = 
+		((ch ^ 0x0f)&0x0f) | (__gpio_port_data(0) & 0xfffffff0);
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic FCR (CPU Speed %d MHz)\n", gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fcr/flash.c u-boot-1.1.6/board/fcr/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/fcr/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fcr/flash.c	2007-05-23 12:16:05.000000000 +0800
@@ -0,0 +1,253 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+/*
+ * SST39VF020: 4KB * 64 = 256KB
+ */
+#define FLASH_BANK_SIZE 0x40000
+#define MAIN_SECT_SIZE  0x1000
+
+#define SST_ID_xF020	0xBFD6BFD6	/* 39xF020 ID */
+
+flash_info_t    flash_info[CFG_MAX_FLASH_BANKS];
+
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+				(SST_MANUFACT & FLASH_VENDMASK) |
+				(SST_ID_xF020 & FLASH_TYPEMASK);
+		flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			flash_info[i].start[j] = flashbase + j * MAIN_SECT_SIZE;
+		}
+		size += flash_info[i].size;
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_FLASH_BASE,
+			CFG_FLASH_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (SST_ID_xF020 & FLASH_TYPEMASK):
+		printf ("39VF020 (256KB)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? "(RO) " : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u8 *base = (volatile u8 *) CFG_FLASH_BASE;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+		(SST_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u8 *addr = (volatile u8 *) (info->start[sect]);
+
+			*(base + 0x5555) = 0xAA;
+			*(base + 0x2AAA) = 0x55;
+			*(base + 0x5555) = 0x80;
+			*(base + 0x5555) = 0xAA;
+			*(base + 0x2AAA) = 0x55;
+
+			*addr = 0x30;
+
+			timeout = 1000000;
+			while (((*addr & 0x80) != 0x80) && timeout--);
+			if (!timeout) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, unchar data)
+{
+	volatile u8 *base = (volatile u8 *) CFG_FLASH_BASE;
+	volatile u8 *addr = (volatile u8 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data) {
+		return ERR_NOT_ERASED;
+	}
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	*(base + 0x5555) = 0xAA;
+	*(base + 0x2AAA) = 0x55;
+	*(base + 0x5555) = 0xA0;
+
+	/* load address/data */
+	*addr = data;
+
+	timeout = 500000;
+	while (((*addr & 0x80) != 0x80) && timeout--);
+	if (!timeout) {
+		rc = ERR_TIMOUT;
+		goto outahere;
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 20 us */
+	timeout = 10000;
+	while (timeout--);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, unchar * src, ulong addr, ulong cnt)
+{
+	unchar data;
+	int rc;
+
+	while (cnt > 0) {
+		data = *((volatile u8 *) src);
+		if ((rc = write_word (info, addr, data)) != 0) {
+			return (rc);
+		}
+		src ++;
+		addr++;
+		cnt --;
+	}
+
+	return ERR_OK;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fcr/Makefile u-boot-1.1.6/board/fcr/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/fcr/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fcr/Makefile	2007-05-23 12:16:05.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fcr/u-boot.lds u-boot-1.1.6/board/fcr/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/fcr/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fcr/u-boot.lds	2007-05-23 12:16:05.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fprint/config.mk u-boot-1.1.6/board/fprint/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/fprint/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fprint/config.mk	2007-05-23 13:57:17.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's LIBRA board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fprint/flash.c u-boot-1.1.6/board/fprint/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/fprint/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fprint/flash.c	2007-05-23 13:57:17.000000000 +0800
@@ -0,0 +1,295 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+flash_info_t    flash_info[CFG_MAX_FLASH_BANKS];
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+
+		flash_info[i].flash_id =
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV320B & FLASH_TYPEMASK);
+		flash_info[i].size = 0x00400000;
+		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
+		for (j = 0; j < 8; j++) {
+			flash_info[i].start[j] = flashbase + j * 0x2000;
+		}
+		flashbase = flashbase + 8 * 0x2000;
+		for (j = 8; j < CFG_MAX_FLASH_SECT; j++) {
+			flash_info[i].start[j] = flashbase + (j-8) * 0x10000;
+		}
+		size += flash_info[i].size;
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_FLASH_BASE,
+			CFG_FLASH_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV320B & FLASH_TYPEMASK):
+		printf ("AMLV320DB (32Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) CFG_FLASH_BASE;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+		(AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x0080;
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			addr[0x000] = 0x0030;
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) CFG_FLASH_BASE;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	base[0x555] = 0x00AA;
+	base[0x2AA] = 0x0055;
+	base[0x555] = 0x00A0;
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fprint/fprint.c u-boot-1.1.6/board/fprint/fprint.c
--- /develop/source/01boot/u-boot-1.1.6/board/fprint/fprint.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fprint/fprint.c	2007-05-23 13:57:17.000000000 +0800
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+static void gpio_init(void)
+{
+	__gpio_as_output(96);	/* board led */
+	__gpio_as_output(104);	/* cim */
+	__gpio_as_output(105);	/* lcd module backlight */
+	__gpio_as_output(106);	/* ac97 */
+	__gpio_as_output(107);	/* uart */
+
+	__gpio_clear_pin(104);	/* enable cim power */
+	__gpio_clear_pin(105);	/* turn on lcd module backlight */
+	__gpio_set_pin(106);	/* ac97 enable */
+	__gpio_set_pin(107);	/* uart enable */
+
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+	__gpio_as_emc();
+	__gpio_as_lcd_master();
+	__gpio_as_usb();
+	__gpio_as_ac97();
+	__gpio_as_cim();
+	__gpio_as_eth();
+	__harb_usb0_uhc(); /* USB port 0 as host port */
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+void board_led(unsigned char ch)
+{
+	if (ch)
+		__gpio_clear_pin(96); /* led on */
+	else
+		__gpio_set_pin(96);   /* led off */
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic FPRINT (CPU Speed %d MHz)\n", gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fprint/Makefile u-boot-1.1.6/board/fprint/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/fprint/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fprint/Makefile	2007-05-23 13:57:17.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fprint/u-boot.lds u-boot-1.1.6/board/fprint/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/fprint/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fprint/u-boot.lds	2007-05-23 13:57:17.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa/config.mk u-boot-1.1.6/board/fuwa/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa/config.mk	2008-01-23 12:15:54.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's fuwa FPGA board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa/flash.c u-boot-1.1.6/board/fuwa/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa/flash.c	2008-01-23 12:15:54.000000000 +0800
@@ -0,0 +1,336 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+/* Support flashes:
+ *
+ * SST39VF020: 4KB * 64 = 256KB
+ * SST39SF020: 4KB * 64 = 256KB
+ * SST39VF040: 4KB * 128 = 512KB
+ * SST39SF040: 4KB * 128 = 512KB
+ */
+#define FLASH_SECT_SIZE  0x1000		/* sector size */
+
+#define SST_ID_39VF020	0xD6		/* 39VF020 ID */
+#define SST_ID_39SF020	0xB6		/* 39SF020 ID */
+#define SST_ID_39VF040	0xD7		/* 39VF040 ID */
+#define SST_ID_39SF040	0xB7		/* 39SF040 ID */
+
+flash_info_t    flash_info[CFG_MAX_FLASH_BANKS];
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)CFG_FLASH_BASE, &flash_info[0]);
+		}
+		else
+			panic("configured too many flash banks!\n");
+
+		memset(flash_info[i].protect, 0, flash_info[i].sector_count);
+
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			flash_info[i].start[j] = CFG_FLASH_BASE + j * FLASH_SECT_SIZE;
+		}
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_FLASH_BASE,
+			CFG_FLASH_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (SST_ID_39VF020 & FLASH_TYPEMASK):
+		printf ("39VF020 (256KB)\n");
+		break;
+	case (SST_ID_39SF020 & FLASH_TYPEMASK):
+		printf ("39SF020 (256KB)\n");
+		break;
+	case (SST_ID_39VF040 & FLASH_TYPEMASK):
+		printf ("39VF040 (512KB)\n");
+		break;
+	case (SST_ID_39SF040 & FLASH_TYPEMASK):
+		printf ("39SF040 (512KB)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? "(RO) " : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	u8 vid, did;
+	volatile u8 *saddr = (volatile u8 *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	switch (vid) {
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case SST_ID_39VF020:
+		info->flash_id += (SST_ID_39VF020 & 0xFFFF);
+		info->sector_count = 64;
+		info->size = 0x00040000;
+		break;
+	case SST_ID_39SF020:
+		info->flash_id += (SST_ID_39SF020 & 0xFFFF);
+		info->sector_count = 64;
+		info->size = 0x00040000;
+		break;
+	case SST_ID_39VF040:
+		info->flash_id += (SST_ID_39VF040 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00080000;
+		break;
+	case SST_ID_39SF040:
+		info->flash_id += (SST_ID_39SF040 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00080000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u8 *base = (volatile u8 *) CFG_FLASH_BASE;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+		(SST_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u8 *addr = (volatile u8 *) (info->start[sect]);
+
+			*(base + 0x5555) = 0xAA;
+			*(base + 0x2AAA) = 0x55;
+			*(base + 0x5555) = 0x80;
+			*(base + 0x5555) = 0xAA;
+			*(base + 0x2AAA) = 0x55;
+
+			*addr = 0x30;
+
+			timeout = 0x100000;
+			while (((*addr & 0x80) != 0x80) && timeout--);
+			if (!timeout) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, unchar data)
+{
+	volatile u8 *base = (volatile u8 *) CFG_FLASH_BASE;
+	volatile u8 *addr = (volatile u8 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data) {
+		return ERR_NOT_ERASED;
+	}
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	*(base + 0x5555) = 0xAA;
+	*(base + 0x2AAA) = 0x55;
+	*(base + 0x5555) = 0xA0;
+
+	/* load address/data */
+	*addr = data;
+
+	timeout = 500000;
+	while (((*addr & 0x80) != 0x80) && timeout--);
+	if (!timeout) {
+		rc = ERR_TIMOUT;
+		goto outahere;
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 20 us */
+	timeout = 10000;
+	while (timeout--);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, unchar * src, ulong addr, ulong cnt)
+{
+	unchar data;
+	int rc;
+
+	while (cnt > 0) {
+		data = *((volatile u8 *) src);
+		if ((rc = write_word (info, addr, data)) != 0) {
+			return (rc);
+		}
+		src ++;
+		addr++;
+		cnt --;
+	}
+
+	return ERR_OK;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa/fuwa.c u-boot-1.1.6/board/fuwa/fuwa.c
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa/fuwa.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa/fuwa.c	2008-05-23 11:25:53.000000000 +0800
@@ -0,0 +1,104 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4750.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+#if CONFIG_NR_DRAM_BANKS == 2   /*Use Two Banks SDRAM*/
+	__gpio_as_sdram_x2_32bit();
+#else
+	__gpio_as_sdram_32bit();
+#endif
+
+	/*
+	 * Initialize UART1 pins
+	 */
+	__gpio_as_uart1();
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//#define LED_ADDR 0xb6000058
+#define LED_ADDR 0xb6000016
+
+static const unsigned char digits[16] = "0123456789abcdef";
+
+void led_puts(const unsigned char *s)
+{
+	volatile unsigned char* leds = (volatile unsigned char *)LED_ADDR;
+	unsigned int i = 0;
+
+	while ( s[i] && (i<8)) {
+		leds[i] = s[i];
+		i++;
+	}
+	while (i<8)
+		leds[i++] = ' ';
+}
+
+void led_putb(unsigned char val)
+{
+	volatile unsigned char* leds = (unsigned char *)LED_ADDR+8;
+	unsigned int i;
+    
+	for (i = 0; i < 2; i++) {
+		*--leds = digits[(unsigned char)(val &0x0f)];
+		val >>= 4;
+	}
+	while (i<8)
+		*--leds = ' ';
+}
+
+void led_putl(unsigned int val)
+{
+	volatile unsigned char* leds = (unsigned char *)LED_ADDR+8;
+	unsigned int i;
+
+	for (i = 0; i < 8; i++) {
+		*--leds = digits[(unsigned char)(val &0x0f)];
+		val >>= 4;
+	}
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic FUWA (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa/Makefile u-boot-1.1.6/board/fuwa/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa/Makefile	2008-01-23 12:15:54.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa/u-boot.lds u-boot-1.1.6/board/fuwa/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa/u-boot.lds	2008-01-23 12:15:54.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa/u-boot-nand.lds u-boot-1.1.6/board/fuwa/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa/u-boot-nand.lds	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa1/config.mk u-boot-1.1.6/board/fuwa1/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa1/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa1/config.mk	2008-12-23 01:52:04.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's fuwa FPGA board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa1/flash.c u-boot-1.1.6/board/fuwa1/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa1/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa1/flash.c	2008-12-23 01:52:04.000000000 +0800
@@ -0,0 +1,336 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+/* Support flashes:
+ *
+ * SST39VF020: 4KB * 64 = 256KB
+ * SST39SF020: 4KB * 64 = 256KB
+ * SST39VF040: 4KB * 128 = 512KB
+ * SST39SF040: 4KB * 128 = 512KB
+ */
+#define FLASH_SECT_SIZE  0x1000		/* sector size */
+
+#define SST_ID_39VF020	0xD6		/* 39VF020 ID */
+#define SST_ID_39SF020	0xB6		/* 39SF020 ID */
+#define SST_ID_39VF040	0xD7		/* 39VF040 ID */
+#define SST_ID_39SF040	0xB7		/* 39SF040 ID */
+
+flash_info_t    flash_info[CFG_MAX_FLASH_BANKS];
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)CFG_FLASH_BASE, &flash_info[0]);
+		}
+		else
+			panic("configured too many flash banks!\n");
+
+		memset(flash_info[i].protect, 0, flash_info[i].sector_count);
+
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			flash_info[i].start[j] = CFG_FLASH_BASE + j * FLASH_SECT_SIZE;
+		}
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_FLASH_BASE,
+			CFG_FLASH_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (SST_ID_39VF020 & FLASH_TYPEMASK):
+		printf ("39VF020 (256KB)\n");
+		break;
+	case (SST_ID_39SF020 & FLASH_TYPEMASK):
+		printf ("39SF020 (256KB)\n");
+		break;
+	case (SST_ID_39VF040 & FLASH_TYPEMASK):
+		printf ("39VF040 (512KB)\n");
+		break;
+	case (SST_ID_39SF040 & FLASH_TYPEMASK):
+		printf ("39SF040 (512KB)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? "(RO) " : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	u8 vid, did;
+	volatile u8 *saddr = (volatile u8 *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	switch (vid) {
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case SST_ID_39VF020:
+		info->flash_id += (SST_ID_39VF020 & 0xFFFF);
+		info->sector_count = 64;
+		info->size = 0x00040000;
+		break;
+	case SST_ID_39SF020:
+		info->flash_id += (SST_ID_39SF020 & 0xFFFF);
+		info->sector_count = 64;
+		info->size = 0x00040000;
+		break;
+	case SST_ID_39VF040:
+		info->flash_id += (SST_ID_39VF040 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00080000;
+		break;
+	case SST_ID_39SF040:
+		info->flash_id += (SST_ID_39SF040 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00080000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u8 *base = (volatile u8 *) CFG_FLASH_BASE;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+		(SST_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u8 *addr = (volatile u8 *) (info->start[sect]);
+
+			*(base + 0x5555) = 0xAA;
+			*(base + 0x2AAA) = 0x55;
+			*(base + 0x5555) = 0x80;
+			*(base + 0x5555) = 0xAA;
+			*(base + 0x2AAA) = 0x55;
+
+			*addr = 0x30;
+
+			timeout = 0x100000;
+			while (((*addr & 0x80) != 0x80) && timeout--);
+			if (!timeout) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, unchar data)
+{
+	volatile u8 *base = (volatile u8 *) CFG_FLASH_BASE;
+	volatile u8 *addr = (volatile u8 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data) {
+		return ERR_NOT_ERASED;
+	}
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	*(base + 0x5555) = 0xAA;
+	*(base + 0x2AAA) = 0x55;
+	*(base + 0x5555) = 0xA0;
+
+	/* load address/data */
+	*addr = data;
+
+	timeout = 500000;
+	while (((*addr & 0x80) != 0x80) && timeout--);
+	if (!timeout) {
+		rc = ERR_TIMOUT;
+		goto outahere;
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 20 us */
+	timeout = 10000;
+	while (timeout--);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, unchar * src, ulong addr, ulong cnt)
+{
+	unchar data;
+	int rc;
+
+	while (cnt > 0) {
+		data = *((volatile u8 *) src);
+		if ((rc = write_word (info, addr, data)) != 0) {
+			return (rc);
+		}
+		src ++;
+		addr++;
+		cnt --;
+	}
+
+	return ERR_OK;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa1/fuwa1.c u-boot-1.1.6/board/fuwa1/fuwa1.c
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa1/fuwa1.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa1/fuwa1.c	2008-12-23 01:52:04.000000000 +0800
@@ -0,0 +1,104 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4750d.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+#if CONFIG_NR_DRAM_BANKS == 2   /*Use Two Banks SDRAM*/
+	__gpio_as_sdram_x2_32bit();
+#else
+	__gpio_as_sdram_32bit();
+#endif
+
+	/*
+	 * Initialize UART1 pins
+	 */
+	__gpio_as_uart0();
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//#define LED_ADDR 0xb6000058
+#define LED_ADDR 0xb6000016
+
+static const unsigned char digits[16] = "0123456789abcdef";
+
+void led_puts(const unsigned char *s)
+{
+	volatile unsigned char* leds = (volatile unsigned char *)LED_ADDR;
+	unsigned int i = 0;
+
+	while ( s[i] && (i<8)) {
+		leds[i] = s[i];
+		i++;
+	}
+	while (i<8)
+		leds[i++] = ' ';
+}
+
+void led_putb(unsigned char val)
+{
+	volatile unsigned char* leds = (unsigned char *)LED_ADDR+8;
+	unsigned int i;
+    
+	for (i = 0; i < 2; i++) {
+		*--leds = digits[(unsigned char)(val &0x0f)];
+		val >>= 4;
+	}
+	while (i<8)
+		*--leds = ' ';
+}
+
+void led_putl(unsigned int val)
+{
+	volatile unsigned char* leds = (unsigned char *)LED_ADDR+8;
+	unsigned int i;
+
+	for (i = 0; i < 8; i++) {
+		*--leds = digits[(unsigned char)(val &0x0f)];
+		val >>= 4;
+	}
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic FUWA1 (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa1/Makefile u-boot-1.1.6/board/fuwa1/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa1/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa1/Makefile	2008-12-23 01:52:04.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa1/u-boot.lds u-boot-1.1.6/board/fuwa1/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa1/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa1/u-boot.lds	2008-12-23 01:52:04.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/fuwa1/u-boot-nand.lds u-boot-1.1.6/board/fuwa1/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/fuwa1/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/fuwa1/u-boot-nand.lds	2008-12-23 01:52:04.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/gps/config.mk u-boot-1.1.6/board/gps/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/gps/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/gps/config.mk	2007-05-23 14:00:31.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <seeger.chin@gmail.com>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's GPS board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/gps/flash.c u-boot-1.1.6/board/gps/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/gps/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/gps/flash.c	2007-05-23 14:00:31.000000000 +0800
@@ -0,0 +1,459 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This file supports SST 16-bit Flashes:
+ * 39xF1601, 39xF1602, 39xF3201, 39xF3202, 39xF6401, 39xF6402,
+ * 39xF6401B, 39xF6402B.
+ */
+
+#include <common.h>
+
+#define SST_ID_xF6401B	0x236D236D	/* 39xF6401B ID (64M =	4M x 16 )	*/
+#define SST_ID_xF6402B	0x236C236C	/* 39xF6402B ID (64M =	4M x 16 )	*/
+
+#define SECT_SIZE       0x1000
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+
+static ulong flash_base = 0xbc000000;    /* base address of CS0 */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)flash_base, &flash_info[0]);
+		}
+		else
+			panic ("configured too many flash banks!\n");
+
+		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			flash_info[i].start[j] = flash_base + j * SECT_SIZE;
+		}
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_MONITOR_BASE,
+			CFG_MONITOR_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (SST_ID_xF1601 & FLASH_TYPEMASK):
+		printf ("39xF1601 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1602 & FLASH_TYPEMASK):
+		printf ("39xF1602 (16Mbit)\n");
+		break;
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		printf ("39xF3201 (32Mbit)\n");
+		break;
+	case (SST_ID_xF3202 & FLASH_TYPEMASK):
+		printf ("39xF3202 (32Mbit)\n");
+		break;
+	case (SST_ID_xF6401 & FLASH_TYPEMASK):
+		printf ("39xF6401 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402 & FLASH_TYPEMASK):
+		printf ("39xF6402 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6401B & FLASH_TYPEMASK):
+		printf ("39xF6401B (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402B & FLASH_TYPEMASK):
+		printf ("39xF6402B (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	ushort vid, did;
+	vu_short *saddr = (vu_short *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	if (vid != (SST_MANUFACT & 0xFFFF)) {
+		/* 39xF640xB stuff */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0x90;
+
+		vid = saddr[0];
+		did = saddr[1];
+
+		/* Exit Read IDs */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0xF0;
+	}
+
+	switch (vid) {
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case (SST_ID_xF1601 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1601 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF1602 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1602 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF3201 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3201 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF3202 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3202 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF6401 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6402 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6401B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6402B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+		(SST_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+
+			if (((info->flash_id & FLASH_TYPEMASK) == 
+			    (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+			    ((info->flash_id & FLASH_TYPEMASK) == 
+			     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+			{
+				base[0x555] = 0x00AA;
+				base[0x2AA] = 0x0055;
+				base[0x555] = 0x0080;
+				base[0x555] = 0x00AA;
+				base[0x2AA] = 0x0055;
+				addr[0x000] = 0x0030;
+			}
+			else {
+				base[0x5555] = 0x00AA;
+				base[0x2AAA] = 0x0055;
+				base[0x5555] = 0x0080;
+				base[0x5555] = 0x00AA;
+				base[0x2AAA] = 0x0055;
+				addr[0x0000] = 0x0030;
+			}
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	if (((info->flash_id & FLASH_TYPEMASK) == 
+	     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+	    ((info->flash_id & FLASH_TYPEMASK) == 
+	     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+	{
+		base[0x555] = 0x00AA;
+		base[0x2AA] = 0x0055;
+		base[0x555] = 0x00A0;
+	}
+	else {
+		base[0x5555] = 0x00AA;
+		base[0x2AAA] = 0x0055;
+		base[0x5555] = 0x00A0;
+	}
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/gps/gps.c u-boot-1.1.6/board/gps/gps.c
--- /develop/source/01boot/u-boot-1.1.6/board/gps/gps.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/gps/gps.c	2007-05-23 14:00:31.000000000 +0800
@@ -0,0 +1,77 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <seeger.chin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+static void gpio_init(void)
+{
+	/* board led pins */
+	__gpio_as_output(96);
+	__gpio_as_output(97);
+	__gpio_as_output(98);
+	__gpio_as_output(99);
+
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+	__gpio_as_emc();
+	__gpio_as_ssi();
+	__gpio_as_scc();
+	__gpio_as_msc();
+	__gpio_as_lcd_master();
+	__gpio_as_usb();
+	__gpio_as_ac97();
+	__gpio_as_eth();
+	__gpio_as_ps2();
+
+	__gpio_as_output(27);	// LED D12 low light
+	__gpio_set_pin(27);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+void board_led(char ch)
+{
+	__gpio_port_data(3) = 
+		((ch ^ 0x0f)&0x0f) | (__gpio_port_data(3) & 0xfffffff0);
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic GPS (CPU Speed %d MHz)\n", gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
+
diff -urN /develop/source/01boot/u-boot-1.1.6/board/gps/Makefile u-boot-1.1.6/board/gps/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/gps/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/gps/Makefile	2007-05-23 14:00:31.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <seeger.chin@gmail.com>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/gps/u-boot.lds u-boot-1.1.6/board/gps/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/gps/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/gps/u-boot.lds	2007-05-23 14:00:31.000000000 +0800
@@ -0,0 +1,64 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <seeger.chin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
+
diff -urN /develop/source/01boot/u-boot-1.1.6/board/iptv/config.mk u-boot-1.1.6/board/iptv/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/iptv/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/iptv/config.mk	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's IPTV board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/iptv/flash.c u-boot-1.1.6/board/iptv/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/iptv/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/iptv/flash.c	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,513 @@
+/*
+ * (C) Copyright 2003-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2004
+ * Martin Krause, TQ-Systems GmbH, martin.krause@tqs.de
+ *
+ * Modified for the CMC PU2 by (C) Copyright 2004 Gary Jennejohn
+ * garyj@denx.de
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#define AMD_ID_GL032M_2	0x221D221D
+#define AMD_ID_GL032M_3 0x22002200
+#define AMD_ID_GL128N   0x22212221
+#define AMD_ID_GL128N_1 0x22012201
+#define FLASH_S29GL128N 0x00F0
+
+#ifndef	CFG_ENV_ADDR
+#define CFG_ENV_ADDR	(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#endif
+
+#if 0//def debug
+#undef debug
+#define debug(x...)	printf(x)
+#endif
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips */
+
+#define FLASH_CYCLE1	0x0555
+#define FLASH_CYCLE2	0x02AA
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size(vu_short *addr, flash_info_t *info);
+static void flash_reset(flash_info_t *info);
+static int write_word_amd(flash_info_t *info, vu_short *dest, ushort data);
+static flash_info_t *flash_get_info(ulong base);
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	ulong flashbase = CFG_FLASH_BASE;
+
+	/* Init: no FLASHes known */
+	memset(&flash_info[0], 0, sizeof(flash_info_t));
+
+	flash_info[0].size = flash_get_size((vu_short *)flashbase, &flash_info[0]);
+
+	size = flash_info[0].size;
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	/* monitor protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+monitor_flash_len-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+#endif
+
+#ifdef	CFG_ENV_IS_IN_FLASH
+	/* ENV protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+#endif
+
+	return size ? size : 1;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_reset(flash_info_t *info)
+{
+	vu_short *base = (vu_short *)(info->start[0]);
+
+	/* Put FLASH back in read mode */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*base = 0x00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*base = 0x00F0;	/* AMD Read Mode */
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info;
+
+	info = NULL;
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size && info->start[0] <= base &&
+		    base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("AMD ");		break;
+	case FLASH_MAN_BM:	printf ("BRIGHT MICRO ");	break;
+	case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+	case FLASH_MAN_INTEL:	printf ("INTEL ");		break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_S29GL064M:
+		printf ("S29GL064M-R6 (64Mbit, uniform sector size)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20,
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+
+	for (i=0; i<info->sector_count; ++i) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s",
+			info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+
+ulong flash_get_size (vu_short *addr, flash_info_t *info)
+{
+	int i;
+	ushort value;
+	ulong base = (ulong)addr;
+
+	/* Write auto select command sequence */
+	addr[FLASH_CYCLE1] = 0x00AA;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE2] = 0x0055;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE1] = 0x0090;	/* selects Intel or AMD */
+
+	/* read Manufacturer ID */
+	udelay(100);
+	value = addr[0];
+	debug ("Manufacturer ID: %04X\n", value);
+
+	switch (value) {
+
+	case (AMD_MANUFACT & 0xFFFF):
+		debug ("Manufacturer: AMD (Spansion)\n");
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+
+	case (INTEL_MANUFACT & 0xFFFF):
+		debug ("Manufacturer: Intel (not supported yet)\n");
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		printf ("Unknown Manufacturer ID: %04X\n", value);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		goto out;
+	}
+
+	value = addr[1];
+	debug ("Device ID: %04X\n", value);
+
+	switch (addr[1]) {
+
+	case (AMD_ID_MIRROR & 0xFFFF):
+		debug ("Mirror Bit flash: addr[14] = %08X  addr[15] = %08X\n",
+			addr[14], addr[15]);
+
+		switch(addr[14]) {
+		case (AMD_ID_GL128N & 0xFFFF):
+			if (addr[15] != (AMD_ID_GL128N_1 & 0xffff)) {
+				printf ("Chip: S29GLxxxN -> unknown\n");
+				info->flash_id = FLASH_UNKNOWN;
+				info->sector_count = 0;
+				info->size = 0;
+			} else {
+				debug ("Chip: S29GL128N\n");
+				info->flash_id += FLASH_S29GL128N;
+				info->sector_count = 128;
+				info->size = 0x00800000;
+				for (i = 0; i < info->sector_count; i++) {
+					info->start[i] = base;
+					base += 0x10000;
+				}
+			}
+			break;
+		case (AMD_ID_GL064M_2 & 0xFFFF):
+			if (addr[15] != (AMD_ID_GL064M_3 & 0xffff)) {
+				printf ("Chip: S29GLxxxM -> unknown\n");
+				info->flash_id = FLASH_UNKNOWN;
+				info->sector_count = 0;
+				info->size = 0;
+			} else {
+				debug ("Chip: S29GL064M-R6\n");
+				info->flash_id += FLASH_S29GL064M;
+				info->sector_count = 128;
+				info->size = 0x00800000;
+				for (i = 0; i < info->sector_count; i++) {
+					info->start[i] = base;
+					base += 0x10000;
+				}
+			}
+			break;	/* => 16 MB	*/
+		case (AMD_ID_GL032M_2 & 0xFFFF):
+			if (addr[15] != (AMD_ID_GL032M_3 & 0xffff)) {
+				printf ("Chip: S29GLxxxM -> unknown\n");
+				info->flash_id = FLASH_UNKNOWN;
+				info->sector_count = 0;
+				info->size = 0;
+			} else {
+				debug ("Chip: S29GL032M\n");
+				info->flash_id += FLASH_S29GL064M;
+				info->sector_count = 64;
+				info->size = 0x00400000;
+				for (i = 0; i < info->sector_count; i++) {
+					info->start[i] = base;
+					base += 0x10000;
+				}
+			}
+			break;
+		default:
+			printf ("Chip: *** unknown ***\n");
+			info->flash_id = FLASH_UNKNOWN;
+			info->sector_count = 0;
+			info->size = 0;
+			break;
+		}
+		break;
+
+	default:
+		printf ("Unknown Device ID: %04X\n", value);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		break;
+	}
+
+out:
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	vu_short *addr = (vu_short *)(info->start[0]);
+	int flag, prot, sect, ssect, l_sect;
+	ulong now, last;
+
+	debug ("flash_erase: first: %d last: %d\n", s_first, s_last);
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	if ((info->flash_id == FLASH_UNKNOWN) ||
+	    (info->flash_id > FLASH_AMD_COMP)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/*
+	 * Start erase on unprotected sectors.
+	 * Since the flash can erase multiple sectors with one command
+	 * we take advantage of that by doing the erase in chunks of
+	 * 3 sectors.
+	 */
+	for (sect = s_first; sect <= s_last; ) {
+		l_sect = -1;
+
+		addr[FLASH_CYCLE1] = 0x00AA;
+		addr[FLASH_CYCLE2] = 0x0055;
+		addr[FLASH_CYCLE1] = 0x0080;
+		addr[FLASH_CYCLE1] = 0x00AA;
+		addr[FLASH_CYCLE2] = 0x0055;
+
+		/* do the erase in chunks of at most 3 sectors */
+		for (ssect = 0; ssect < 3; ssect++) {
+			if ((sect + ssect) > s_last)
+				break;
+			if (info->protect[sect + ssect] == 0) {	/* not protected */
+				addr = (vu_short *)(info->start[sect + ssect]);
+				addr[0] = 0x0030;
+				l_sect = sect + ssect;
+			}
+		}
+		/* wait at least 80us - let's wait 1 ms */
+		udelay (1000);
+
+		/*
+		 * We wait for the last triggered sector
+		 */
+		if (l_sect < 0)
+			goto DONE;
+
+		reset_timer_masked ();
+		last  = 0;
+		addr = (vu_short *)(info->start[l_sect]);
+		while ((addr[0] & 0x0080) != 0x0080) {
+			if ((now = get_timer_masked ()) > CFG_FLASH_ERASE_TOUT) {
+				printf ("Timeout\n");
+				return 1;
+			}
+			/* show that we're waiting */
+			if ((now - last) > 1000000) {	/* every second */
+				putc ('.');
+				last = now;
+			}
+		}
+		addr = (vu_short *)info->start[0];
+		addr[0] = 0x00F0;	/* reset bank */
+		sect += ssect;
+	}
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts();
+
+DONE:
+	/* reset to read mode */
+	addr = (vu_short *)info->start[0];
+	addr[0] = 0x00F0;	/* reset bank */
+
+	printf (" done\n");
+	return 0;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	ulong wp, data;
+	int rc;
+
+	if (addr & 1) {
+		printf ("unaligned destination not supported\n");
+		return ERR_ALIGN;
+	};
+
+	if ((int) src & 1) {
+		printf ("unaligned source not supported\n");
+		return ERR_ALIGN;
+	};
+
+	wp = addr;
+
+	while (cnt >= 2) {
+		data = *((vu_short *)src);
+		if ((rc = write_word_amd(info, (vu_short *)wp, data)) != 0) {
+printf ("write_buff 1: write_word_amd() rc=%d\n", rc);
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return (ERR_OK);
+	}
+
+	if (cnt == 1) {
+		data = (*((volatile u8 *) src)) | (*((volatile u8 *) (wp + 1)) << 8);
+		if ((rc = write_word_amd(info, (vu_short *)wp, data)) != 0) {
+printf ("write_buff 1: write_word_amd() rc=%d\n", rc);
+			return (rc);
+		}
+		src += 1;
+		wp += 1;
+		cnt -= 1;
+	}
+
+	return ERR_OK;
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash for AMD FLASH
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word_amd (flash_info_t *info, vu_short *dest, ushort data)
+{
+	int flag;
+	vu_short *base;		/* first address in flash bank	*/
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*dest & data) != data) {
+		return (2);
+	}
+
+	base = (vu_short *)(info->start[0]);
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	base[FLASH_CYCLE1] = 0x00AA;	/* unlock */
+	base[FLASH_CYCLE2] = 0x0055;	/* unlock */
+	base[FLASH_CYCLE1] = 0x00A0;	/* selects program mode */
+
+	*dest = data;		/* start programming the data	*/
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts();
+
+	reset_timer_masked ();
+
+	/* data polling for D7 */
+	while ((*dest & 0x0080) != (data & 0x0080)) {
+		if (get_timer_masked () > CFG_FLASH_WRITE_TOUT) {
+			*dest = 0x00F0;	/* reset bank */
+			return (1);
+		}
+	}
+	return (0);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/iptv/iptv.c u-boot-1.1.6/board/iptv/iptv.c
--- /develop/source/01boot/u-boot-1.1.6/board/iptv/iptv.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/iptv/iptv.c	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,67 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz5730.h>
+
+static void gpio_init(void)
+{
+	/* board led pins */
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_emc(0);
+	__gpio_as_dma();
+	__gpio_as_eth();
+	__gpio_as_pci();
+	__gpio_as_usbclk();
+
+	__gpio_as_output(67);
+	__gpio_as_output(68);
+	__gpio_as_output(69);
+	__gpio_as_output(70);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+void board_led(char ch)
+{
+	REG32(0xa8000000) = (ch << 24) | (ch << 16) | (ch << 8) | ch;
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic IPTV (CPU Speed %d MHz)\n", gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
+
diff -urN /develop/source/01boot/u-boot-1.1.6/board/iptv/Makefile u-boot-1.1.6/board/iptv/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/iptv/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/iptv/Makefile	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/iptv/u-boot.lds u-boot-1.1.6/board/iptv/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/iptv/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/iptv/u-boot.lds	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/jdi/config.mk u-boot-1.1.6/board/jdi/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/jdi/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/jdi/config.mk	2007-05-23 13:57:17.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's LIBRA board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/jdi/flash.c u-boot-1.1.6/board/jdi/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/jdi/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/jdi/flash.c	2007-06-27 11:23:25.000000000 +0800
@@ -0,0 +1,430 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This file supports SST 39xF3201 and AMD S29GL032M-R4
+ */
+
+#define AMD_ID_GL032	0x227E227E	/* S29GL032 ID (32Mb, bottom boot sectors) */
+
+#include <common.h>
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		if (i == 0) {
+			flashbase = CFG_FLASH_BASE;
+			size += flash_get_size((vu_long *)flashbase, &flash_info[0]);
+		}
+		else
+			panic ("configured too many flash banks!\n");
+
+		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+
+		switch (flash_info[i].flash_id & FLASH_TYPEMASK) {
+		case (AMD_ID_GL032 & FLASH_TYPEMASK):
+			for (j = 0; j < flash_info[i].sector_count; j++) {
+				if (j < 8) { /* 8 x 8KB bottom boot sectors */
+					flash_info[i].start[j] = flashbase;
+					flashbase += 0x2000;
+				}
+				else { /* 63 x 64KB */
+					flash_info[i].start[j] = flashbase + (j-8) * 0x10000;
+				}
+			}
+			break;
+		case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		default:
+			for (j = 0; j < flash_info[i].sector_count; j++) {
+				/* 1024 * 4KB */
+				flash_info[i].start[j] = flashbase + j * 0x1000;
+			}
+			break;
+		}
+	}
+
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_FLASH_BASE,
+			CFG_FLASH_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST ");
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		printf ("39xF3201 (32Mbit)\n");
+		break;
+	case (AMD_ID_GL032 & FLASH_TYPEMASK):
+		printf ("29GL032 (32Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	ushort vid, did;
+	vu_short *saddr = (vu_short *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	/* AMD Flash stuff */
+	saddr[0x555] = 0xAA;
+	saddr[0x2AA] = 0x55;
+	saddr[0x555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x555] = 0xAA;
+	saddr[0x2AA] = 0x55;
+	saddr[0x555] = 0xF0;
+
+	if (vid != (AMD_MANUFACT & 0xFFFF)) {
+		saddr[0x5555] = 0xAA;
+		saddr[0x2AAA] = 0x55;
+		saddr[0x5555] = 0x90;
+
+		vid = saddr[0];
+		did = saddr[1];
+
+		/* Exit Read IDs */
+		saddr[0x5555] = 0xAA;
+		saddr[0x2AAA] = 0x55;
+		saddr[0x5555] = 0xF0;
+
+		/* SST Flash bug */
+		vid = SST_MANUFACT & 0xFFFF;
+		did = SST_ID_xF3201 & 0xFFFF;
+	}
+
+	switch (vid) {
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	case (AMD_MANUFACT & 0xFFFF):
+		info->flash_id = (AMD_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case (SST_ID_xF3201 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3201 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		break;
+	case (AMD_ID_GL032 & 0xFFFF):
+		info->flash_id += (AMD_ID_GL032 & 0xFFFF);
+		info->sector_count = 71; /* 8 x 8KB + 63 x 64KB */
+		info->size = 0x00400000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) CFG_FLASH_BASE;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+#if 0
+	if ((info->flash_id & FLASH_VENDMASK) !=
+		(SST_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+#endif
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+
+			switch (info->flash_id & FLASH_TYPEMASK) {
+			case (SST_ID_xF3201 & FLASH_TYPEMASK):
+				base[0x5555] = 0x00AA;
+				base[0x2AAA] = 0x0055;
+				base[0x5555] = 0x0080;
+				base[0x5555] = 0x00AA;
+				base[0x2AAA] = 0x0055;
+				addr[0x0000] = 0x0030;
+				break;
+			case (AMD_ID_GL032 & FLASH_TYPEMASK):
+				base[0x555] = 0x00AA;
+				base[0x2AA] = 0x0055;
+				base[0x555] = 0x0080;
+				base[0x555] = 0x00AA;
+				base[0x2AA] = 0x0055;
+				addr[0x000] = 0x0030;
+				break;
+			default:
+				printf ("Unknown Chip Type\n");
+				break;
+			}
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) CFG_FLASH_BASE;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		base[0x5555] = 0x00AA;
+		base[0x2AAA] = 0x0055;
+		base[0x5555] = 0x00A0;
+		break;
+	case (AMD_ID_GL032 & FLASH_TYPEMASK):
+		base[0x555] = 0x00AA;
+		base[0x2AA] = 0x0055;
+		base[0x555] = 0x00A0;
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/jdi/jdi.c u-boot-1.1.6/board/jdi/jdi.c
--- /develop/source/01boot/u-boot-1.1.6/board/jdi/jdi.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/jdi/jdi.c	2009-02-20 19:38:24.000000000 +0800
@@ -0,0 +1,234 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+static void gpio_init(void)
+{
+	/* GPIO led */
+	__gpio_as_output(62);
+	__gpio_as_output(63);
+
+	__gpio_set_pin(0);   /* low active */
+	__gpio_clear_pin(5); /* high active */
+
+	/* JTAG port */
+	__gpio_as_output(0); /* TRSTN */
+	__gpio_as_output(1); /* TDI */
+	__gpio_as_input(2);  /* TDO */
+	__gpio_as_output(3); /* TMS */
+	__gpio_as_output(4); /* TCK */
+	__gpio_as_output(5); /* RSTN */
+	__gpio_as_input(6);  /* DINT */
+	__gpio_as_output(7);  /* Buffer Enable */
+
+	__gpio_set_pin(7);    /* Disable Buffer */
+
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+	__gpio_as_emc();
+	__gpio_as_eth();
+	__gpio_as_usb();
+	__harb_usb0_udc(); /* USB port 0 as device port */
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+void board_led(char ch)
+{
+	if (ch)
+		__gpio_set_pin(62);
+	else
+		__gpio_clear_pin(62);
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic JDI (CPU Speed %d MHz)\n", gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
+
+extern void i2c_open(void);
+extern void i2c_close(void);
+extern void i2c_setclk(unsigned int i2cclk);
+extern int i2c_read(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+
+#define EEPROM_MAC_START  0
+#define EEPROM_IP_START   6
+#define NETMASK_IP_START  14
+#define GATEWAY_IP_START  18
+
+U_BOOT_CMD(
+	0,	0,	0,	0,
+	"\n",
+	NULL
+	);
+/*
+ * Get ip-address...
+ */
+int do_get_ip(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	bd_t *bd = gd->bd;
+	unsigned char device, address, data[256], str[32];
+	IPaddr_t ipaddr;
+
+	device = (0xA << 3) | 7; /* EEPROM 7 */
+	address = 0;
+
+	i2c_open();
+	i2c_setclk(100000);
+	i2c_read(device, data, address, 256);
+	i2c_close();
+
+	ipaddr = (data[6] << 24) | (data[7] << 16) | (data[8] << 8) | (data[9]);
+
+	/*
+	 * Update whole ip-addr
+	 */
+	bd->bi_ip_addr = ipaddr;
+	sprintf(str, "%ld.%ld.%ld.%ld",
+		(bd->bi_ip_addr & 0xff000000) >> 24,
+		(bd->bi_ip_addr & 0x00ff0000) >> 16,
+		(bd->bi_ip_addr & 0x0000ff00) >> 8,
+		(bd->bi_ip_addr & 0x000000ff));
+	setenv("ipaddr", str);
+	printf("Updated ipaddr from eeprom to %s\n", str);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	getip,	2,	1,	do_get_ip,
+	"getip   - Get IP-Address\n",
+	NULL
+	);
+
+/*
+ * Get mac-address...
+ */
+int do_get_mac(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	unsigned char device, address, data[256], str[32];
+
+	device = (0xA << 3) | 7; /* EEPROM 7 */
+	address = 0;
+
+	i2c_open();
+	i2c_setclk(100000);
+	i2c_read(device, data, address, 256);
+	i2c_close();
+
+	/* Now setup ethaddr */
+	sprintf (str, "%02x:%02x:%02x:%02x:%02x:%02x",
+		 data[0], data[1], data[2], data[3], data[4],
+		 data[5]);
+	setenv ("ethaddr", str);
+	memcpy (gd->bd->bi_enetaddr, data, 6);
+	printf("Updated ethaddr from eeprom to %s\n", str);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	getmac,	2,	1,	do_get_mac,
+	"getmac  - Get MAC-Address\n",
+	NULL
+	);
+
+/*
+ * Get netmask...
+ */
+int do_get_netmask(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unsigned char device, address, data[256], str[32];
+
+	device = (0xA << 3) | 7; /* EEPROM 7 */
+	address = 0;
+
+	i2c_open();
+	i2c_setclk(100000);
+	i2c_read(device, data, address, 256);
+	i2c_close();
+
+	sprintf(str, "%ld.%ld.%ld.%ld",
+		data[14], data[15], data[16], data[17]);
+	setenv("netmask", str);
+	printf("Updated netmask from eeprom to %s\n", str);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	getnetmask,	2,	1,	do_get_netmask,
+	"getnetmask  - Get NETMASK\n",
+	NULL
+	);
+
+/*
+ * Get gateway...
+ */
+int do_get_gateway(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unsigned char device, address, data[256], str[32];
+
+	device = (0xA << 3) | 7; /* EEPROM 7 */
+	address = 0;
+
+	i2c_open();
+	i2c_setclk(100000);
+	i2c_read(device, data, address, 256);
+	i2c_close();
+
+	sprintf(str, "%ld.%ld.%ld.%ld",
+		data[18], data[19], data[20], data[21]);
+	setenv("gateway", str);
+	printf("Updated gateway from eeprom to %s\n", str);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	getgateway,	2,	1,	do_get_gateway,
+	"getgateway  - Get GATEWAY\n",
+	NULL
+	);
diff -urN /develop/source/01boot/u-boot-1.1.6/board/jdi/Makefile u-boot-1.1.6/board/jdi/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/jdi/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/jdi/Makefile	2007-05-23 13:57:17.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/jdi/u-boot.lds u-boot-1.1.6/board/jdi/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/jdi/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/jdi/u-boot.lds	2007-05-23 13:57:17.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/kaifa/config.mk u-boot-1.1.6/board/kaifa/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/kaifa/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/kaifa/config.mk	2007-05-23 14:23:38.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's FCR board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/kaifa/flash.c u-boot-1.1.6/board/kaifa/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/kaifa/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/kaifa/flash.c	2007-05-23 14:23:38.000000000 +0800
@@ -0,0 +1,493 @@
+/*
+ * (C) Copyright 2003-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2004
+ * Martin Krause, TQ-Systems GmbH, martin.krause@tqs.de
+ *
+ * Modified for the CMC PU2 by (C) Copyright 2004 Gary Jennejohn
+ * garyj@denx.de
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#define AMD_ID_GL032M_2	0x221D221D
+#define AMD_ID_GL032M_3 0x22002200
+
+#ifndef	CFG_ENV_ADDR
+#define CFG_ENV_ADDR	(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#endif
+
+#if 0//def debug
+#undef debug
+#define debug(x...)	printf(x)
+#endif
+
+flash_info_t	flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips */
+
+#define FLASH_CYCLE1	0x0555
+#define FLASH_CYCLE2	0x02AA
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size(vu_short *addr, flash_info_t *info);
+static void flash_reset(flash_info_t *info);
+static int write_word_amd(flash_info_t *info, vu_short *dest, ushort data);
+static flash_info_t *flash_get_info(ulong base);
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	ulong flashbase = CFG_FLASH_BASE;
+
+	/* Init: no FLASHes known */
+	memset(&flash_info[0], 0, sizeof(flash_info_t));
+
+	flash_info[0].size = flash_get_size((vu_short *)flashbase, &flash_info[0]);
+
+	size = flash_info[0].size;
+
+#if CFG_MONITOR_BASE >= CFG_FLASH_BASE
+	/* monitor protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_MONITOR_BASE,
+		      CFG_MONITOR_BASE+monitor_flash_len-1,
+		      flash_get_info(CFG_MONITOR_BASE));
+#endif
+
+#ifdef	CFG_ENV_IS_IN_FLASH
+	/* ENV protection ON by default */
+	flash_protect(FLAG_PROTECT_SET,
+		      CFG_ENV_ADDR,
+		      CFG_ENV_ADDR+CFG_ENV_SIZE-1,
+		      flash_get_info(CFG_ENV_ADDR));
+#endif
+
+	return size ? size : 1;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_reset(flash_info_t *info)
+{
+	vu_short *base = (vu_short *)(info->start[0]);
+
+	/* Put FLASH back in read mode */
+	if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_INTEL)
+		*base = 0x00FF;	/* Intel Read Mode */
+	else if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD)
+		*base = 0x00F0;	/* AMD Read Mode */
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info;
+
+	info = NULL;
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size && info->start[0] <= base &&
+		    base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CFG_MAX_FLASH_BANKS ? 0 : info;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+void flash_print_info (flash_info_t *info)
+{
+	int i;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:	printf ("AMD ");		break;
+	case FLASH_MAN_BM:	printf ("BRIGHT MICRO ");	break;
+	case FLASH_MAN_FUJ:	printf ("FUJITSU ");		break;
+	case FLASH_MAN_SST:	printf ("SST ");		break;
+	case FLASH_MAN_STM:	printf ("STM ");		break;
+	case FLASH_MAN_INTEL:	printf ("INTEL ");		break;
+	default:		printf ("Unknown Vendor ");	break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_S29GL064M:
+		printf ("S29GL064M-R6 (64Mbit, uniform sector size)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20,
+		info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+
+	for (i=0; i<info->sector_count; ++i) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s",
+			info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+
+ulong flash_get_size (vu_short *addr, flash_info_t *info)
+{
+	int i;
+	ushort value;
+	ulong base = (ulong)addr;
+
+	/* Write auto select command sequence */
+	addr[FLASH_CYCLE1] = 0x00AA;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE2] = 0x0055;	/* for AMD, Intel ignores this */
+	addr[FLASH_CYCLE1] = 0x0090;	/* selects Intel or AMD */
+
+	/* read Manufacturer ID */
+	udelay(100);
+	value = addr[0];
+	debug ("Manufacturer ID: %04X\n", value);
+
+	switch (value) {
+
+	case (AMD_MANUFACT & 0xFFFF):
+		debug ("Manufacturer: AMD (Spansion)\n");
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+
+	case (INTEL_MANUFACT & 0xFFFF):
+		debug ("Manufacturer: Intel (not supported yet)\n");
+		info->flash_id = FLASH_MAN_INTEL;
+		break;
+
+	default:
+		printf ("Unknown Manufacturer ID: %04X\n", value);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		goto out;
+	}
+
+	value = addr[1];
+	debug ("Device ID: %04X\n", value);
+
+	switch (addr[1]) {
+
+	case (AMD_ID_MIRROR & 0xFFFF):
+		debug ("Mirror Bit flash: addr[14] = %08X  addr[15] = %08X\n",
+			addr[14], addr[15]);
+
+		switch(addr[14]) {
+		case (AMD_ID_GL064M_2 & 0xFFFF):
+			if (addr[15] != (AMD_ID_GL064M_3 & 0xffff)) {
+				printf ("Chip: S29GLxxxM -> unknown\n");
+				info->flash_id = FLASH_UNKNOWN;
+				info->sector_count = 0;
+				info->size = 0;
+			} else {
+				debug ("Chip: S29GL064M-R6\n");
+				info->flash_id += FLASH_S29GL064M;
+				info->sector_count = 128;
+				info->size = 0x00800000;
+				for (i = 0; i < info->sector_count; i++) {
+					info->start[i] = base;
+					base += 0x10000;
+				}
+			}
+			break;	/* => 16 MB	*/
+		case (AMD_ID_GL032M_2 & 0xFFFF):
+			if (addr[15] != (AMD_ID_GL032M_3 & 0xffff)) {
+				printf ("Chip: S29GLxxxM -> unknown\n");
+				info->flash_id = FLASH_UNKNOWN;
+				info->sector_count = 0;
+				info->size = 0;
+			} else {
+				debug ("Chip: S29GL032M\n");
+				info->flash_id += FLASH_S29GL064M;
+				info->sector_count = 64;
+				info->size = 0x00400000;
+				for (i = 0; i < info->sector_count; i++) {
+					info->start[i] = base;
+					base += 0x10000;
+				}
+			}
+			break;
+		default:
+			printf ("Chip: *** unknown ***\n");
+			info->flash_id = FLASH_UNKNOWN;
+			info->sector_count = 0;
+			info->size = 0;
+			break;
+		}
+		break;
+
+	default:
+		printf ("Unknown Device ID: %04X\n", value);
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		break;
+	}
+
+out:
+	/* Put FLASH back in read mode */
+	flash_reset(info);
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int	flash_erase (flash_info_t *info, int s_first, int s_last)
+{
+	vu_short *addr = (vu_short *)(info->start[0]);
+	int flag, prot, sect, ssect, l_sect;
+	ulong now, last;
+
+	debug ("flash_erase: first: %d last: %d\n", s_first, s_last);
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf ("- missing\n");
+		} else {
+			printf ("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	if ((info->flash_id == FLASH_UNKNOWN) ||
+	    (info->flash_id > FLASH_AMD_COMP)) {
+		printf ("Can't erase unknown flash type %08lx - aborted\n",
+			info->flash_id);
+		return 1;
+	}
+
+	prot = 0;
+	for (sect=s_first; sect<=s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n",
+			prot);
+	} else {
+		printf ("\n");
+	}
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/*
+	 * Start erase on unprotected sectors.
+	 * Since the flash can erase multiple sectors with one command
+	 * we take advantage of that by doing the erase in chunks of
+	 * 3 sectors.
+	 */
+	for (sect = s_first; sect <= s_last; ) {
+		l_sect = -1;
+
+		addr[FLASH_CYCLE1] = 0x00AA;
+		addr[FLASH_CYCLE2] = 0x0055;
+		addr[FLASH_CYCLE1] = 0x0080;
+		addr[FLASH_CYCLE1] = 0x00AA;
+		addr[FLASH_CYCLE2] = 0x0055;
+
+		/* do the erase in chunks of at most 3 sectors */
+		for (ssect = 0; ssect < 3; ssect++) {
+			if ((sect + ssect) > s_last)
+				break;
+			if (info->protect[sect + ssect] == 0) {	/* not protected */
+				addr = (vu_short *)(info->start[sect + ssect]);
+				addr[0] = 0x0030;
+				l_sect = sect + ssect;
+			}
+		}
+		/* wait at least 80us - let's wait 1 ms */
+		udelay (1000);
+
+		/*
+		 * We wait for the last triggered sector
+		 */
+		if (l_sect < 0)
+			goto DONE;
+
+		reset_timer_masked ();
+		last  = 0;
+		addr = (vu_short *)(info->start[l_sect]);
+		while ((addr[0] & 0x0080) != 0x0080) {
+			if ((now = get_timer_masked ()) > CFG_FLASH_ERASE_TOUT) {
+				printf ("Timeout\n");
+				return 1;
+			}
+			/* show that we're waiting */
+			if ((now - last) > 1000000) {	/* every second */
+				putc ('.');
+				last = now;
+			}
+		}
+		addr = (vu_short *)info->start[0];
+		addr[0] = 0x00F0;	/* reset bank */
+		sect += ssect;
+	}
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts();
+
+DONE:
+	/* reset to read mode */
+	addr = (vu_short *)info->start[0];
+	addr[0] = 0x00F0;	/* reset bank */
+
+	printf (" done\n");
+	return 0;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+
+int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+	ulong wp, data;
+	int rc;
+
+	if (addr & 1) {
+		printf ("unaligned destination not supported\n");
+		return ERR_ALIGN;
+	};
+
+	if ((int) src & 1) {
+		printf ("unaligned source not supported\n");
+		return ERR_ALIGN;
+	};
+
+	wp = addr;
+
+	while (cnt >= 2) {
+		data = *((vu_short *)src);
+		if ((rc = write_word_amd(info, (vu_short *)wp, data)) != 0) {
+printf ("write_buff 1: write_word_amd() rc=%d\n", rc);
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return (ERR_OK);
+	}
+
+	if (cnt == 1) {
+		data = (*((volatile u8 *) src)) | (*((volatile u8 *) (wp + 1)) << 8);
+		if ((rc = write_word_amd(info, (vu_short *)wp, data)) != 0) {
+printf ("write_buff 1: write_word_amd() rc=%d\n", rc);
+			return (rc);
+		}
+		src += 1;
+		wp += 1;
+		cnt -= 1;
+	}
+
+	return ERR_OK;
+}
+
+/*-----------------------------------------------------------------------
+ * Write a word to Flash for AMD FLASH
+ * A word is 16 or 32 bits, whichever the bus width of the flash bank
+ * (not an individual chip) is.
+ *
+ * returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word_amd (flash_info_t *info, vu_short *dest, ushort data)
+{
+	int flag;
+	vu_short *base;		/* first address in flash bank	*/
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*dest & data) != data) {
+		return (2);
+	}
+
+	base = (vu_short *)(info->start[0]);
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	base[FLASH_CYCLE1] = 0x00AA;	/* unlock */
+	base[FLASH_CYCLE2] = 0x0055;	/* unlock */
+	base[FLASH_CYCLE1] = 0x00A0;	/* selects program mode */
+
+	*dest = data;		/* start programming the data	*/
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts();
+
+	reset_timer_masked ();
+
+	/* data polling for D7 */
+	while ((*dest & 0x0080) != (data & 0x0080)) {
+		if (get_timer_masked () > CFG_FLASH_WRITE_TOUT) {
+			*dest = 0x00F0;	/* reset bank */
+			return (1);
+		}
+	}
+	return (0);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/kaifa/kaifa.c u-boot-1.1.6/board/kaifa/kaifa.c
--- /develop/source/01boot/u-boot-1.1.6/board/kaifa/kaifa.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/kaifa/kaifa.c	2007-05-23 14:23:38.000000000 +0800
@@ -0,0 +1,85 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+static void gpio_init(void)
+{
+	/* board led pins */
+	__gpio_as_output(0);
+	__gpio_as_output(1);
+	__gpio_as_output(2);
+	__gpio_as_output(3);
+
+	__gpio_as_emc();
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+	__gpio_as_scc();
+	__gpio_as_lcd_master();
+	__gpio_as_usb();
+	__gpio_as_eth();
+	__gpio_as_pwm();
+	__gpio_as_ps2();
+	__gpio_as_uprt();
+
+	__gpio_as_output(9);		/* Mem R/B */
+	__gpio_as_output(10);		/* M/CPU Select */
+	__gpio_as_output(13);		/* LCDM Backlight */
+	__gpio_as_output(14);		/* C/D Pin of LCDM */
+	__gpio_as_output(88);		/* Beeper */
+	__gpio_as_output(89);		/* Cash Box */
+//	__gpio_as_output(90);		/* Modem Enable */
+//	__gpio_as_output(91);		/* INTA_N, external RTC irq */
+
+	__harb_usb0_uhc(); /* USB port 0 as host */
+//	__harb_usb0_udc(); /* USB port 0 as device */
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+	REG_EMC_SMCR1 = 0x0bbb6600;	/* optimization for LCM */
+}
+
+void board_led(char ch)
+{
+	__gpio_port_data(0) = 
+		((ch ^ 0x0f)&0x0f) | (__gpio_port_data(0) & 0xfffffff0);
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic KAIFA (CPU Speed %d MHz)\n", gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/kaifa/Makefile u-boot-1.1.6/board/kaifa/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/kaifa/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/kaifa/Makefile	2007-05-23 14:23:38.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/kaifa/u-boot.lds u-boot-1.1.6/board/kaifa/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/kaifa/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/kaifa/u-boot.lds	2007-05-23 14:23:38.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/leo/config.mk u-boot-1.1.6/board/leo/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/leo/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/leo/config.mk	2007-06-12 17:15:48.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's leo board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
diff -urN /develop/source/01boot/u-boot-1.1.6/board/leo/flash.c u-boot-1.1.6/board/leo/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/leo/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/leo/flash.c	2007-05-23 11:06:30.000000000 +0800
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	return (0);
+}
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	printf ("flash_erase not implemented\n");
+	return 0;
+}
+
+void flash_print_info (flash_info_t * info)
+{
+	printf ("flash_print_info not implemented\n");
+}
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	printf ("write_buff not implemented\n");
+	return (-1);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/leo/leo.c u-boot-1.1.6/board/leo/leo.c
--- /develop/source/01boot/u-boot-1.1.6/board/leo/leo.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/leo/leo.c	2007-06-19 17:33:22.000000000 +0800
@@ -0,0 +1,85 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4740.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+	__gpio_as_sdram_32bit();
+
+	/*
+	 * Initialize UART0 pins
+	 */
+	__gpio_as_uart0();
+
+	/*
+	 * Initialize NAND Flash Pins
+	 */
+	__gpio_as_nand();
+
+	/*
+	 * Initialize LCD pins
+	 */
+	__gpio_as_lcd_18bit();
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize other pins
+	 */
+	__gpio_as_output(GPIO_SD_VCC_EN_N);
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);
+
+	__gpio_as_input(GPIO_SD_CD_N);
+	__gpio_disable_pull(GPIO_SD_CD_N);
+
+	__gpio_as_input(GPIO_SD_WP);
+	__gpio_disable_pull(GPIO_SD_WP);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic LEO (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/leo/Makefile u-boot-1.1.6/board/leo/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/leo/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/leo/Makefile	2007-05-23 11:06:30.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/leo/u-boot.lds u-boot-1.1.6/board/leo/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/leo/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/leo/u-boot.lds	2007-05-23 11:06:30.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/leo/u-boot-nand.lds u-boot-1.1.6/board/leo/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/leo/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/leo/u-boot-nand.lds	2007-06-12 17:14:25.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/lib4750/config.mk u-boot-1.1.6/board/lib4750/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/lib4750/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/lib4750/config.mk	2008-09-09 00:23:52.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's lib4750 board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/lib4750/flash.c u-boot-1.1.6/board/lib4750/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/lib4750/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/lib4750/flash.c	2008-09-10 19:43:35.000000000 +0800
@@ -0,0 +1,543 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This file supports SST 16-bit Flashes:
+ * 39xF1601, 39xF1602, 39xF3201, 39xF3202, 39xF6401, 39xF6402,
+ * 39xF6401B, 39xF6402B.
+ */
+
+#include <common.h>
+
+#define SST_ID_xF6401B	0x236D236D	/* 39xF6401B ID (64M =	4M x 16 )	*/
+#define SST_ID_xF6402B	0x236C236C	/* 39xF6402B ID (64M =	4M x 16 )	*/
+#define AMD_ID_DL640	0x227E227E	/* 29DL640D ID (64 M, dual boot sectors)*/
+
+#define AMD_SECT_SIZE     0x10000
+#define SST_SECT_SIZE     0x1000
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+static ulong flash_base = 0xa8000000;    /* base address of CS4 */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+ulong flash_init(void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)flash_base, &flash_info[0]);
+		}
+		else
+			panic("configured too many flash banks!\n");
+		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+
+ 		switch (flash_info[i].flash_id & FLASH_VENDMASK) {
+ 		case (AMD_MANUFACT & FLASH_VENDMASK):
+			for (j = 0; j < flash_info[i].sector_count; j++) {
+#if 1
+				if (j < 8) {     // 8 x 8k boot sectors	
+					flash_info[i].start[j] = flash_base + j * 0x2000;
+				}
+				else {
+					flash_info[i].start[j] = flash_base + (j-7) * AMD_SECT_SIZE;
+				}
+#else
+				flash_info[i].start[j] = flash_base + j * AMD_SECT_SIZE;
+#endif
+					
+			}
+			break;
+
+ 		case (SST_MANUFACT & FLASH_VENDMASK): 
+			for (j = 0; j < flash_info[i].sector_count; j++) { 
+				flash_info[i].start[j] = flash_base + j * SST_SECT_SIZE;
+			}
+			break;
+
+		default:
+			break;
+  		}
+ 	} 
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_MONITOR_BASE,
+			CFG_MONITOR_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+#endif
+
+	return size;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST ");
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_DL640 & FLASH_TYPEMASK):
+		printf ("29DL640D (64Mbit)\n");
+		break;
+	case (AMD_ID_DL640G_2 & FLASH_TYPEMASK):
+		printf ("AM29DL640G2 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1601 & FLASH_TYPEMASK):
+		printf ("39xF1601 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1602 & FLASH_TYPEMASK):
+		printf ("39xF1602 (16Mbit)\n");
+		break;
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		printf ("39xF3201 (32Mbit)\n");
+		break;
+	case (SST_ID_xF3202 & FLASH_TYPEMASK):
+		printf ("39xF3202 (32Mbit)\n");
+		break;
+	case (SST_ID_xF6401 & FLASH_TYPEMASK):
+		printf ("39xF6401 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402 & FLASH_TYPEMASK):
+		printf ("39xF6402 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6401B & FLASH_TYPEMASK):
+		printf ("39xF6401B (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402B & FLASH_TYPEMASK):
+		printf ("39xF6402B (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	ushort vid, did;
+	vu_short *saddr = (vu_short *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	if (vid != (SST_MANUFACT & 0xFFFF)) {
+		/* 39xF640xB stuff */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0x90;
+
+		vid = saddr[0];
+		did = saddr[1];
+
+		/* Exit Read IDs */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0xF0;
+	}
+
+	switch (vid) {
+	case (AMD_MANUFACT & 0xFFFF):
+		info->flash_id = (AMD_MANUFACT & 0xFFFF0000);
+       		break;
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case (AMD_ID_DL640 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640 & 0xFFFF); 
+		info->sector_count = 135;
+		info->size = 0x00800000;
+		break;
+	case (AMD_ID_DL640G_2 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640G_2 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF1601 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1601 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		break;
+	case (SST_ID_xF1602 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1602 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		break;
+	case (SST_ID_xF3201 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3201 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		break;
+	case (SST_ID_xF3202 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3202 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		break;
+	case (SST_ID_xF6401 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6402 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6401B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6402B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (SST_MANUFACT & FLASH_VENDMASK) &&
+	    (info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+			switch (info->flash_id & FLASH_VENDMASK) {
+			case (SST_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+				    ((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			case (AMD_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (AMD_ID_DL640 & FLASH_TYPEMASK))  
+					)
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			}
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		if (((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+		    ((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0;
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		if ((info->flash_id & FLASH_TYPEMASK) == 
+		    (AMD_ID_DL640 & FLASH_TYPEMASK)) 
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0; 
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	}
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/lib4750/lib4750.c u-boot-1.1.6/board/lib4750/lib4750.c
--- /develop/source/01boot/u-boot-1.1.6/board/lib4750/lib4750.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/lib4750/lib4750.c	2008-09-09 00:23:52.000000000 +0800
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4750.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+#if CONFIG_NR_DRAM_BANKS == 2   /*Use Two Banks SDRAM*/
+	__gpio_as_sdram_x2_32bit();
+#else
+	__gpio_as_sdram_32bit();
+#endif
+
+	/*
+	 * Initialize UART1 pins
+	 */
+	__gpio_as_uart1();
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic FUWA (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/lib4750/Makefile u-boot-1.1.6/board/lib4750/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/lib4750/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/lib4750/Makefile	2008-09-09 00:23:52.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/lib4750/u-boot.lds u-boot-1.1.6/board/lib4750/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/lib4750/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/lib4750/u-boot.lds	2008-09-09 00:23:52.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/lib4750/u-boot-nand.lds u-boot-1.1.6/board/lib4750/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/lib4750/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/lib4750/u-boot-nand.lds	2008-09-09 00:23:52.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/libra/config.mk u-boot-1.1.6/board/libra/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/libra/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/libra/config.mk	2007-03-01 15:15:50.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's LIBRA board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/libra/libra.c u-boot-1.1.6/board/libra/libra.c
--- /develop/source/01boot/u-boot-1.1.6/board/libra/libra.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/libra/libra.c	2007-05-23 10:05:57.000000000 +0800
@@ -0,0 +1,73 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+static void gpio_init(void)
+{
+	/* board led pins */
+	__gpio_as_output(96);
+	__gpio_as_output(97);
+	__gpio_as_output(98);
+	__gpio_as_output(99);
+
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+	__gpio_as_emc();
+	__gpio_as_ssi();
+	__gpio_as_scc();
+	__gpio_as_msc();
+	__gpio_as_lcd_master();
+	__gpio_as_usb();
+	__gpio_as_ac97();
+	__gpio_as_eth();
+	__gpio_as_ps2();
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+void board_led(char ch)
+{
+	__gpio_port_data(3) = 
+		((ch ^ 0x0f)&0x0f) | (__gpio_port_data(3) & 0xfffffff0);
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic LIBRA (CPU Speed %d MHz)\n", gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/libra/Makefile u-boot-1.1.6/board/libra/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/libra/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/libra/Makefile	2007-03-01 15:24:16.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/libra/u-boot.lds u-boot-1.1.6/board/libra/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/libra/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/libra/u-boot.lds	2007-03-01 15:24:16.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pavo/config.mk u-boot-1.1.6/board/pavo/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/pavo/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pavo/config.mk	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's pavo board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pavo/flash.c u-boot-1.1.6/board/pavo/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/pavo/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pavo/flash.c	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	return (0);
+}
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	printf ("flash_erase not implemented\n");
+	return 0;
+}
+
+void flash_print_info (flash_info_t * info)
+{
+	printf ("flash_print_info not implemented\n");
+}
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	printf ("write_buff not implemented\n");
+	return (-1);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pavo/Makefile u-boot-1.1.6/board/pavo/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/pavo/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pavo/Makefile	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pavo/pavo.c u-boot-1.1.6/board/pavo/pavo.c
--- /develop/source/01boot/u-boot-1.1.6/board/pavo/pavo.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pavo/pavo.c	2007-06-21 12:07:06.000000000 +0800
@@ -0,0 +1,101 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4740.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize NAND Flash Pins
+	 */
+	__gpio_as_nand();
+
+	/*
+	 * Initialize SDRAM pins
+	 */
+	__gpio_as_sdram_32bit();
+
+	/*
+	 * Initialize UART0 pins
+	 */
+	__gpio_as_uart0();
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize LCD pins
+	 */
+	__gpio_as_lcd_18bit();
+
+	/*
+	 * Initialize SSI pins
+	 */
+	__gpio_as_ssi();
+
+	/*
+	 * Initialize I2C pins
+	 */
+	__gpio_as_i2c();
+
+	/*
+	 * Initialize Other pins
+	 */
+	__gpio_as_output(GPIO_SD_VCC_EN_N);
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);
+
+	__gpio_as_input(GPIO_SD_CD_N);
+	__gpio_disable_pull(GPIO_SD_CD_N);
+
+	__gpio_as_input(GPIO_SD_WP);
+	__gpio_disable_pull(GPIO_SD_WP);
+
+	__gpio_as_input(GPIO_DC_DETE_N);
+	__gpio_as_input(GPIO_CHARG_STAT_N);
+	__gpio_as_input(GPIO_USB_DETE);
+
+	__gpio_as_output(GPIO_DISP_OFF_N);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic PAVO (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pavo/u-boot.lds u-boot-1.1.6/board/pavo/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/pavo/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pavo/u-boot.lds	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pavo/u-boot-nand.lds u-boot-1.1.6/board/pavo/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/pavo/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pavo/u-boot-nand.lds	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv1/config.mk u-boot-1.1.6/board/pmpv1/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv1/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv1/config.mk	2007-05-28 14:56:43.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's PMP ver 1.x board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv1/flash.c u-boot-1.1.6/board/pmpv1/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv1/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv1/flash.c	2007-05-28 14:56:43.000000000 +0800
@@ -0,0 +1,550 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This file supports SST 16-bit Flashes:
+ * 39xF1601, 39xF1602, 39xF3201, 39xF3202, 39xF6401, 39xF6402,
+ * 39xF6401B, 39xF6402B.
+ */
+
+#include <common.h>
+
+#define SST_ID_xF6401B	0x236D236D	/* 39xF6401B ID (64M =	4M x 16 )	*/
+#define SST_ID_xF6402B	0x236C236C	/* 39xF6402B ID (64M =	4M x 16 )	*/
+#define AMD_ID_DL640	0x227E227E	/* 29DL640D ID (64 M, dual boot sectors)*/
+
+#define AMD_SECT_SIZE     0x10000
+#define SST_SECT_SIZE     0x1000
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+static ulong flash_base = 0xbc000000;    /* base address of CS0 */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+ulong flash_init(void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)flash_base, &flash_info[0]);
+		}
+		else
+			panic("configured too many flash banks!\n");
+		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+
+ 		switch (flash_info[i].flash_id & FLASH_VENDMASK) {
+ 		case (AMD_MANUFACT & FLASH_VENDMASK):
+			for (j = 0; j < flash_info[i].sector_count; j++) {
+				/*if (j < 8) {     // 8 x 8k boot sectors	
+					flash_info[i].start[j] = flash_base;
+					flash_base += 8 << 10;
+				}
+				else  
+					flash_info[i].start[j] = flash_base + (j-8) * AMD_SECT_SIZE;*/
+					flash_info[i].start[j] = flash_base + j * AMD_SECT_SIZE;
+					
+			}
+			break;
+
+ 		case (SST_MANUFACT & FLASH_VENDMASK): 
+			for (j = 0; j < flash_info[i].sector_count; j++) { 
+				flash_info[i].start[j] = flash_base + j * SST_SECT_SIZE;
+			}
+			break;
+
+		default:
+			break;
+  		}
+ 	} 
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_MONITOR_BASE,
+			CFG_MONITOR_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+#endif
+
+	return size;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST ");
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_DL640 & FLASH_TYPEMASK):
+		printf ("29DL640D (16Mbit)\n");
+		break;
+	case (AMD_ID_DL640G_2 & FLASH_TYPEMASK):
+		printf ("AM29DL640G2 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1601 & FLASH_TYPEMASK):
+		printf ("39xF1601 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1602 & FLASH_TYPEMASK):
+		printf ("39xF1602 (16Mbit)\n");
+		break;
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		printf ("39xF3201 (32Mbit)\n");
+		break;
+	case (SST_ID_xF3202 & FLASH_TYPEMASK):
+		printf ("39xF3202 (32Mbit)\n");
+		break;
+	case (SST_ID_xF6401 & FLASH_TYPEMASK):
+		printf ("39xF6401 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402 & FLASH_TYPEMASK):
+		printf ("39xF6402 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6401B & FLASH_TYPEMASK):
+		printf ("39xF6401B (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402B & FLASH_TYPEMASK):
+		printf ("39xF6402B (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	ushort vid, did;
+	vu_short *saddr = (vu_short *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	if (vid != (SST_MANUFACT & 0xFFFF)) {
+		/* 39xF640xB stuff */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0x90;
+
+		vid = saddr[0];
+		did = saddr[1];
+
+		/* Exit Read IDs */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0xF0;
+	}
+
+	switch (vid) {
+	case (AMD_MANUFACT & 0xFFFF):
+		info->flash_id = (AMD_MANUFACT & 0xFFFF0000);
+       		break;
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case (AMD_ID_DL640 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640 & 0xFFFF); 
+		info->sector_count = 256;   
+		info->size = 0x01000000;
+		flash_base = 0xbf000000;
+		break;
+	case (AMD_ID_DL640G_2 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640G_2 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF1601 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1601 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF1602 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1602 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF3201 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3201 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF3202 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3202 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF6401 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6402 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6401B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6402B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (SST_MANUFACT & FLASH_VENDMASK) &&
+	    (info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+			switch (info->flash_id & FLASH_VENDMASK) {
+			case (SST_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+				    ((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			case (AMD_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (AMD_ID_DL640 & FLASH_TYPEMASK))  
+					)
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			}
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		if (((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+		    ((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0;
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		if ((info->flash_id & FLASH_TYPEMASK) == 
+		    (AMD_ID_DL640 & FLASH_TYPEMASK)) 
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0; 
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	}
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv1/Makefile u-boot-1.1.6/board/pmpv1/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv1/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv1/Makefile	2007-05-23 10:04:46.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv1/pmpv1.c u-boot-1.1.6/board/pmpv1/pmpv1.c
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv1/pmpv1.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv1/pmpv1.c	2007-06-15 16:03:03.000000000 +0800
@@ -0,0 +1,105 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+static void gpio_init(void)
+{
+	/* LED enable */
+	__gpio_as_output(GPIO_LED_EN);
+	__gpio_set_pin(GPIO_LED_EN);
+
+	__harb_usb0_uhc();
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+	__gpio_as_emc();
+	__gpio_as_dma();
+	__gpio_as_msc();
+	__gpio_as_lcd_master();
+	__gpio_as_usb();
+	__gpio_as_ac97();
+	__gpio_as_cim();
+	__gpio_as_eth();
+
+	/* First PW_I output high */
+	__gpio_as_output(GPIO_PW_I);
+	__gpio_set_pin(GPIO_PW_I);
+
+	/* Then PW_O output high */
+	__gpio_as_output(GPIO_PW_O);
+	__gpio_set_pin(GPIO_PW_O);
+
+	/* Last PW_I output low and as input */
+	__gpio_clear_pin(GPIO_PW_I);
+	__gpio_as_input(GPIO_PW_I);
+
+	/* make PW_I work properly */
+	__gpio_disable_pull(GPIO_PW_I);
+
+	/* USB clock enable */
+	__gpio_as_output(GPIO_USB_CLK_EN);
+	__gpio_set_pin(GPIO_USB_CLK_EN);
+
+	/* LCD display off */
+	__gpio_as_output(GPIO_DISP_OFF_N);
+	__gpio_clear_pin(GPIO_DISP_OFF_N);
+
+	/* No backlight */
+	__gpio_as_output(94); /* PWM0 */
+	__gpio_clear_pin(94);
+
+	/* RTC IRQ input */
+	__gpio_as_input(GPIO_RTC_IRQ);
+
+	/* CHARG_STAT input */
+	__gpio_as_input(GPIO_CHARG_STAT);
+	__gpio_disable_pull(GPIO_CHARG_STAT);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+void board_led(char ch)
+{
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic PMP Ver 1.x (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv1/u-boot.lds u-boot-1.1.6/board/pmpv1/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv1/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv1/u-boot.lds	2007-05-23 10:04:46.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv1/u-boot-nand.lds u-boot-1.1.6/board/pmpv1/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv1/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv1/u-boot-nand.lds	2007-05-28 14:56:43.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv2/config.mk u-boot-1.1.6/board/pmpv2/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv2/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv2/config.mk	2007-05-28 14:55:53.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's PMP ver 2.x board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv2/flash.c u-boot-1.1.6/board/pmpv2/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv2/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv2/flash.c	2007-05-28 14:55:53.000000000 +0800
@@ -0,0 +1,550 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This file supports SST 16-bit Flashes:
+ * 39xF1601, 39xF1602, 39xF3201, 39xF3202, 39xF6401, 39xF6402,
+ * 39xF6401B, 39xF6402B.
+ */
+
+#include <common.h>
+
+#define SST_ID_xF6401B	0x236D236D	/* 39xF6401B ID (64M =	4M x 16 )	*/
+#define SST_ID_xF6402B	0x236C236C	/* 39xF6402B ID (64M =	4M x 16 )	*/
+#define AMD_ID_DL640	0x227E227E	/* 29DL640D ID (64 M, dual boot sectors)*/
+
+#define AMD_SECT_SIZE     0x10000
+#define SST_SECT_SIZE     0x1000
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+static ulong flash_base = 0xbc000000;    /* base address of CS0 */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+ulong flash_init(void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)flash_base, &flash_info[0]);
+		}
+		else
+			panic("configured too many flash banks!\n");
+		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+
+ 		switch (flash_info[i].flash_id & FLASH_VENDMASK) {
+ 		case (AMD_MANUFACT & FLASH_VENDMASK):
+			for (j = 0; j < flash_info[i].sector_count; j++) {
+				/*if (j < 8) {     // 8 x 8k boot sectors	
+					flash_info[i].start[j] = flash_base;
+					flash_base += 8 << 10;
+				}
+				else  
+					flash_info[i].start[j] = flash_base + (j-8) * AMD_SECT_SIZE;*/
+					flash_info[i].start[j] = flash_base + j * AMD_SECT_SIZE;
+					
+			}
+			break;
+
+ 		case (SST_MANUFACT & FLASH_VENDMASK): 
+			for (j = 0; j < flash_info[i].sector_count; j++) { 
+				flash_info[i].start[j] = flash_base + j * SST_SECT_SIZE;
+			}
+			break;
+
+		default:
+			break;
+  		}
+ 	} 
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_MONITOR_BASE,
+			CFG_MONITOR_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+#endif
+
+	return size;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST ");
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_DL640 & FLASH_TYPEMASK):
+		printf ("29DL640D (16Mbit)\n");
+		break;
+	case (AMD_ID_DL640G_2 & FLASH_TYPEMASK):
+		printf ("AM29DL640G2 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1601 & FLASH_TYPEMASK):
+		printf ("39xF1601 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1602 & FLASH_TYPEMASK):
+		printf ("39xF1602 (16Mbit)\n");
+		break;
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		printf ("39xF3201 (32Mbit)\n");
+		break;
+	case (SST_ID_xF3202 & FLASH_TYPEMASK):
+		printf ("39xF3202 (32Mbit)\n");
+		break;
+	case (SST_ID_xF6401 & FLASH_TYPEMASK):
+		printf ("39xF6401 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402 & FLASH_TYPEMASK):
+		printf ("39xF6402 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6401B & FLASH_TYPEMASK):
+		printf ("39xF6401B (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402B & FLASH_TYPEMASK):
+		printf ("39xF6402B (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	ushort vid, did;
+	vu_short *saddr = (vu_short *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	if (vid != (SST_MANUFACT & 0xFFFF)) {
+		/* 39xF640xB stuff */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0x90;
+
+		vid = saddr[0];
+		did = saddr[1];
+
+		/* Exit Read IDs */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0xF0;
+	}
+
+	switch (vid) {
+	case (AMD_MANUFACT & 0xFFFF):
+		info->flash_id = (AMD_MANUFACT & 0xFFFF0000);
+       		break;
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case (AMD_ID_DL640 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640 & 0xFFFF); 
+		info->sector_count = 256;   
+		info->size = 0x01000000;
+		flash_base = 0xbf000000;
+		break;
+	case (AMD_ID_DL640G_2 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640G_2 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF1601 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1601 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF1602 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1602 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF3201 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3201 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF3202 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3202 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF6401 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6402 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6401B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6402B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (SST_MANUFACT & FLASH_VENDMASK) &&
+	    (info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+			switch (info->flash_id & FLASH_VENDMASK) {
+			case (SST_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+				    ((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			case (AMD_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (AMD_ID_DL640 & FLASH_TYPEMASK))  
+					)
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			}
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		if (((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+		    ((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0;
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		if ((info->flash_id & FLASH_TYPEMASK) == 
+		    (AMD_ID_DL640 & FLASH_TYPEMASK)) 
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0; 
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	}
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv2/Makefile u-boot-1.1.6/board/pmpv2/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv2/Makefile	2007-05-23 10:04:46.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv2/pmpv2.c u-boot-1.1.6/board/pmpv2/pmpv2.c
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv2/pmpv2.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv2/pmpv2.c	2008-05-23 11:06:57.000000000 +0800
@@ -0,0 +1,116 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+static void gpio_init(void)
+{
+	/* LED enable */
+	__gpio_as_output(GPIO_LED_EN);
+	__gpio_set_pin(GPIO_LED_EN);
+
+	__harb_usb0_uhc();
+
+#if (CFG_UART_BASE == UART0_BASE)
+	__gpio_as_uart0();
+#endif
+#if (CFG_UART_BASE == UART1_BASE)
+	__gpio_as_uart1();
+#endif
+#if (CFG_UART_BASE == UART2_BASE)
+	__gpio_as_uart2();
+#endif
+#if (CFG_UART_BASE == UART3_BASE)
+	__gpio_as_uart3();
+#endif
+
+	__gpio_as_emc();
+	__gpio_as_dma();
+	__gpio_as_msc();
+	__gpio_as_lcd_master();
+	__gpio_as_usb();
+	__gpio_as_ac97();
+	__gpio_as_cim();
+	__gpio_as_eth();
+
+	/* First PW_I output high */
+	__gpio_as_output(GPIO_PW_I);
+	__gpio_set_pin(GPIO_PW_I);
+
+	/* Then PW_O output high */
+	__gpio_as_output(GPIO_PW_O);
+	__gpio_set_pin(GPIO_PW_O);
+
+	/* Last PW_I output low and as input */
+	__gpio_clear_pin(GPIO_PW_I);
+	__gpio_as_input(GPIO_PW_I);
+
+	/* make PW_I work properly */
+	__gpio_disable_pull(GPIO_PW_I);
+
+	/* USB clock enable */
+	__gpio_as_output(GPIO_USB_CLK_EN);
+	__gpio_set_pin(GPIO_USB_CLK_EN);
+
+	/* LCD display off */
+	__gpio_as_output(GPIO_DISP_OFF_N);
+	__gpio_clear_pin(GPIO_DISP_OFF_N);
+
+	/* No backlight */
+	__gpio_as_output(94); /* PWM0 */
+	__gpio_clear_pin(94);
+
+	/* RTC IRQ input */
+	__gpio_as_input(GPIO_RTC_IRQ);
+
+	/* CHARG_STAT input */
+	__gpio_as_input(GPIO_CHARG_STAT);
+	__gpio_disable_pull(GPIO_CHARG_STAT);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+	REG_EMC_SMCR0 = 0x03a33340;
+}
+
+void board_led(char ch)
+{
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic PMP Ver 2.x (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv2/u-boot.lds u-boot-1.1.6/board/pmpv2/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv2/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv2/u-boot.lds	2007-05-23 10:04:46.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/pmpv2/u-boot-nand.lds u-boot-1.1.6/board/pmpv2/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/pmpv2/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/pmpv2/u-boot-nand.lds	2007-05-28 14:55:53.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt/chip_count.c u-boot-1.1.6/board/slt/chip_count.c
--- /develop/source/01boot/u-boot-1.1.6/board/slt/chip_count.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt/chip_count.c	2007-09-14 17:13:13.000000000 +0800
@@ -0,0 +1,325 @@
+/*
+ *  Jz4730 System Level Test
+ *
+ *  Copyright (c) 2007
+ *  Ingenic Semiconductor, <lgwang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#elif defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#else
+#error "chip type not defined."
+#endif
+
+#if defined(CFG_CHIP_COUNT)
+
+
+//#define CHIP_COUNT_DEBUG 1
+#undef CHIP_COUNT_DEBUG
+
+#define CFG_EEPROM_DATA_BACKUP_ENABLE 		1
+
+#if defined(CFG_EEPROM_AT24C02A)		/* Old board: 256 bytes */
+
+#define eeprom_size     256	/* AT24C02A: 256byte, AT24C16A: 2048byte */
+#define section_size    64	/* 32, 64, 128, 256 bytes */
+#define section_num     (eeprom_size/section_size) /* 4,8,16 */
+#define cpu_clk_type    (section_num/2) 
+#define page_size       8 //bytes
+#define check_max       60000
+
+#elif defined(CFG_EEPROM_AT24C16A)		/* Old board: 256 bytes */
+#define eeprom_size     2048	/* AT24C02A: 256byte, AT24C16A: 2048byte */
+#define section_size    64	/* 32, 64, 128, 256 bytes */
+#define section_num     (eeprom_size/section_size) /* 4,8,16 */
+#define cpu_clk_type    (section_num/2) 
+#define page_size       16 //bytes
+#define check_max       60000
+
+#else
+#error "unknown eeprom type"
+#endif
+
+#if defined(CHIP_COUNT_DEBUG)
+#undef check_max
+#define check_max       6
+#endif
+
+struct section_info {
+	unsigned short cpuclk;	/* 2bytes */
+	unsigned char sum_offset; /* 1byte */
+	unsigned char pass_offset; /* 1byte */
+	unsigned short summary;	/* 2bytes */
+	unsigned short pass;	/* 2bytes */
+};
+
+
+extern void i2c_open(void);
+extern void i2c_close(void);
+extern void i2c_setclk(unsigned int i2cclk);
+extern int i2c_read(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+extern int i2c_write(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+extern inline int get_cpu_speed(void);
+
+/* used for stage: nandboot -- new pll_init , cpu speed is 100MHz. */
+static inline void my_udelay(int n )
+{
+	int i;
+	i=n*100;
+	while ( i-- )
+		;
+}
+
+static inline void mdelay ( int n )
+{
+	while ( n-- ) 
+		my_udelay(1000);
+}
+
+
+static void led_dancing( void )
+{
+	int i;
+	while (1) {
+		for ( i=0; i<8; i++ ) 
+			__gpio_set_pin(i);
+		mdelay(500);
+		for ( i=0; i<8; i++ ) 
+			__gpio_clear_pin(i);
+		mdelay(500);
+	}
+}
+
+
+unsigned short encrypt(unsigned short org)
+{
+	unsigned short an_val, pos21, pos65, posa9, posed;
+
+	an_val = ~org;
+	pos21 = an_val & 0x6;
+	pos65 = an_val & 0x60;
+	posa9 = an_val & 0x600;
+	posed = an_val & 0x6000;
+	an_val = an_val & 0x9999;
+	an_val = an_val | (pos21 << 12) | (pos65 << 4) | (posa9 >> 4) | (posed >> 12);
+
+	return(an_val);
+}
+
+unsigned short decrypt(unsigned short an_val)
+{
+	unsigned short org, pos21, pos65, posa9, posed;
+
+	pos21 = an_val & 0x6000;pos21 = pos21 >> 12;
+	pos65 = an_val & 0x600;pos65 = pos65 >> 4;
+	posa9 = an_val & 0x60;posa9 = posa9 << 4;
+	posed = an_val & 0x6;posed = posed << 12;
+	an_val = an_val & 0x9999;
+	an_val = an_val | (pos21) | (pos65) | (posa9) | (posed);
+	org = ~an_val;
+
+	return(org);
+}
+
+
+static struct section_info section_info[1];
+/* 
+ * chip count increase 1
+ * NOTES: calculate deviceid before i2c_read or i2c_write.
+ */
+int chip_count( void )
+{
+	struct section_info *p_section_info = &section_info[0];
+	int section_cnt = 0;
+	int section_base_addr = 0;
+	int buf_size = section_size;
+	unsigned char buf[buf_size];
+	int i, ret;
+	unsigned short cpu_speed_test, cpu_speed_now;
+	unsigned short summary_backup;
+	
+	memset(buf, 0, buf_size);
+#if defined(CFG_EEPROM_AT24C02A)
+	int device_id = (0xA<<3) | 7;
+#elif defined(CFG_EEPROM_AT24C16A)
+	int device_id = (0xA<<3) | 0;
+#else
+#error ""
+#endif
+
+	i2c_open();
+
+//	i2c_setclk(100000);	/* 100 k */
+	/* check cpu speed is right */
+	cpu_speed_now = get_cpu_speed()/100000;
+
+	cpu_speed_test = 0;
+	/* section 1's firt 2bypte, cpu_speed is 3340 *100kHz */
+	ret = i2c_read(device_id, (unsigned char *)&cpu_speed_test, 1*section_size, 2); 
+	if ( ret < 0 ) 
+		goto i2c_read_failed;
+
+	
+	if ( cpu_speed_now != cpu_speed_test ) {
+		printf("cpu_speed(%d) is not correct.\n", cpu_speed_now);
+		printf("cpu_speed should be %d.\n", cpu_speed_test);
+		i2c_close();
+		led_dancing();
+	}
+	
+	
+	/* find the correct section */
+	for (i=0; i< section_num; i+=2 ) {
+		section_base_addr = i*section_size;
+#if defined(CFG_EEPROM_AT24C16A)
+		device_id = (0xA<<3) | (((section_base_addr) >> 8) &0x7);
+#endif
+		ret = i2c_read(device_id, buf, section_base_addr, 4); /*  */
+		if ( ret < 0 ) {
+			goto i2c_read_failed;
+		}
+		p_section_info->cpuclk = *((unsigned short *) &buf[0]);
+		
+		if ( p_section_info->cpuclk == cpu_speed_test ) {
+			section_cnt = i;
+			p_section_info->sum_offset = *((unsigned char *) &buf[2]);
+			p_section_info->pass_offset = *((unsigned char *) &buf[3]);
+			break;
+		}
+		
+	}
+#if defined(CHIP_COUNT_DEBUG)
+	printf("cpuspeed=%d, cpuclk=%d\n", cpu_speed_test, p_section_info->cpuclk);
+	printf("sum_offset=%d\n", p_section_info->sum_offset);
+	printf("pass_offset=%d\n", p_section_info->pass_offset);
+#endif
+	if ( i >= section_num ) {
+		printf("no cpu speed %d, please added it first.\n", cpu_speed_test);
+		i2c_close();
+		led_dancing();
+	}
+	if ( p_section_info->sum_offset >= section_size - 2 ) {
+		printf("EEPROM's sector[%d], sector_size=%d.\n", i, section_size);
+		printf("sum_offset=%d, should be less than sector_size\n", 
+		       p_section_info->sum_offset);
+	}
+	if ( p_section_info->sum_offset >= p_section_info->pass_offset-1 ) {
+		printf("*****************************\n");
+		printf("EEPROM's speed %d sector is full.\n", cpu_speed_now);
+		printf("no space to save speed %d count.\n", cpu_speed_now);
+		printf("*****************************\n");
+		led_dancing();
+	}
+
+	
+	/* read data summary */
+#if defined(CFG_EEPROM_AT24C16A)
+	device_id = (0xA<<3) | (((section_base_addr) >> 8) &0x7);
+#endif
+	ret = i2c_read(device_id, (unsigned char *)&p_section_info->summary,
+		       section_base_addr+p_section_info->sum_offset, 2); /*  */
+
+	if ( ret < 0 ) 
+		goto i2c_read_failed;
+
+#if defined(CFG_EEPROM_DATA_BACKUP_ENABLE)
+	/* read backup data */
+	ret = i2c_read(device_id, (unsigned char *)&summary_backup,
+		       section_base_addr+p_section_info->sum_offset+section_size, 2); /*  */
+	if ( ret < 0 ) 
+		goto i2c_read_failed;
+
+	/* decrypt summary_backup format??? */
+	summary_backup = decrypt(summary_backup);
+
+	/* check data */
+	if ( !(p_section_info->sum_offset == 4 && /* skip the first data */
+	       p_section_info->summary == 0)  ) {
+		if ( p_section_info->summary != summary_backup ) {
+			printf("data check error...\n");
+			led_dancing();
+		}
+	}
+#endif
+	
+	p_section_info->summary++;
+
+	if ( p_section_info->summary > check_max ) {
+		p_section_info->summary = 1;
+		p_section_info->sum_offset +=2;
+		if ( p_section_info->sum_offset >= p_section_info->pass_offset-1 ) {
+			printf("*****************************\n");
+			printf("EEPROM's speed %d sector is full.\n", cpu_speed_now);
+			printf("no space to save speed %d count.\n", cpu_speed_now);
+			printf("*****************************\n");
+			led_dancing();
+		}
+		if ( p_section_info->sum_offset >= section_size - 2 ) {
+			printf("EEPROM's sector[%d], sector_size=%d.\n", i, section_size);
+			printf("sum_offset=%d, should be less than sector_size\n", 
+			       p_section_info->sum_offset);
+		}
+
+		ret = i2c_write(device_id, 
+				(unsigned char *)&p_section_info->sum_offset,
+				section_base_addr+2, 1); /*  */
+		ret = i2c_write(device_id, 
+				(unsigned char *)&p_section_info->sum_offset,
+				section_base_addr+2+section_size, 1); /*  */
+		if ( ret < 0 ) 
+			goto i2c_write_failed;
+		
+	}
+
+	/* save data summary  */
+	ret = i2c_write(device_id, (unsigned char *)&p_section_info->summary,
+			section_base_addr+p_section_info->sum_offset, 2); /*  */
+	if ( ret < 0 ) 
+		goto i2c_write_failed;
+	
+#if defined(CFG_EEPROM_DATA_BACKUP_ENABLE)	
+	/* convert summary_backup format??? */
+	summary_backup = p_section_info->summary;
+	summary_backup = encrypt(summary_backup);
+
+	/* save backup data */
+	ret = i2c_write(device_id, (unsigned char *)&summary_backup,
+			section_base_addr+p_section_info->sum_offset+section_size, 2);
+	if ( ret < 0 ) 
+		goto i2c_write_failed;
+#endif	
+
+	i2c_close();
+	return 0;
+	
+ i2c_read_failed:
+ i2c_write_failed:
+	printf("i2c read or write error.\n");
+	i2c_close();
+	return -1;
+	
+}
+
+#endif /* #if defined(CFG_CHIP_COUNT) */
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt/config.mk u-boot-1.1.6/board/slt/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/slt/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt/config.mk	2007-08-29 14:14:57.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's SLT board, System Level Test(Jz4730 chip sorting)
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt/flash.c u-boot-1.1.6/board/slt/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/slt/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt/flash.c	2007-08-29 14:14:57.000000000 +0800
@@ -0,0 +1,550 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This file supports SST 16-bit Flashes:
+ * 39xF1601, 39xF1602, 39xF3201, 39xF3202, 39xF6401, 39xF6402,
+ * 39xF6401B, 39xF6402B.
+ */
+
+#include <common.h>
+
+#define SST_ID_xF6401B	0x236D236D	/* 39xF6401B ID (64M =	4M x 16 )	*/
+#define SST_ID_xF6402B	0x236C236C	/* 39xF6402B ID (64M =	4M x 16 )	*/
+#define AMD_ID_DL640	0x227E227E	/* 29DL640D ID (64 M, dual boot sectors)*/
+
+#define AMD_SECT_SIZE     0x10000
+#define SST_SECT_SIZE     0x1000
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+static ulong flash_base = 0xbc000000;    /* base address of CS0 */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+ulong flash_init(void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)flash_base, &flash_info[0]);
+		}
+		else
+			panic("configured too many flash banks!\n");
+		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+
+ 		switch (flash_info[i].flash_id & FLASH_VENDMASK) {
+ 		case (AMD_MANUFACT & FLASH_VENDMASK):
+			for (j = 0; j < flash_info[i].sector_count; j++) {
+				/*if (j < 8) {     // 8 x 8k boot sectors	
+					flash_info[i].start[j] = flash_base;
+					flash_base += 8 << 10;
+				}
+				else  
+					flash_info[i].start[j] = flash_base + (j-8) * AMD_SECT_SIZE;*/
+					flash_info[i].start[j] = flash_base + j * AMD_SECT_SIZE;
+					
+			}
+			break;
+
+ 		case (SST_MANUFACT & FLASH_VENDMASK): 
+			for (j = 0; j < flash_info[i].sector_count; j++) { 
+				flash_info[i].start[j] = flash_base + j * SST_SECT_SIZE;
+			}
+			break;
+
+		default:
+			break;
+  		}
+ 	} 
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_MONITOR_BASE,
+			CFG_MONITOR_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+#endif
+
+	return size;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST ");
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_DL640 & FLASH_TYPEMASK):
+		printf ("29DL640D (16Mbit)\n");
+		break;
+	case (AMD_ID_DL640G_2 & FLASH_TYPEMASK):
+		printf ("AM29DL640G2 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1601 & FLASH_TYPEMASK):
+		printf ("39xF1601 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1602 & FLASH_TYPEMASK):
+		printf ("39xF1602 (16Mbit)\n");
+		break;
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		printf ("39xF3201 (32Mbit)\n");
+		break;
+	case (SST_ID_xF3202 & FLASH_TYPEMASK):
+		printf ("39xF3202 (32Mbit)\n");
+		break;
+	case (SST_ID_xF6401 & FLASH_TYPEMASK):
+		printf ("39xF6401 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402 & FLASH_TYPEMASK):
+		printf ("39xF6402 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6401B & FLASH_TYPEMASK):
+		printf ("39xF6401B (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402B & FLASH_TYPEMASK):
+		printf ("39xF6402B (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	ushort vid, did;
+	vu_short *saddr = (vu_short *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	if (vid != (SST_MANUFACT & 0xFFFF)) {
+		/* 39xF640xB stuff */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0x90;
+
+		vid = saddr[0];
+		did = saddr[1];
+
+		/* Exit Read IDs */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0xF0;
+	}
+
+	switch (vid) {
+	case (AMD_MANUFACT & 0xFFFF):
+		info->flash_id = (AMD_MANUFACT & 0xFFFF0000);
+       		break;
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case (AMD_ID_DL640 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640 & 0xFFFF); 
+		info->sector_count = 256;   
+		info->size = 0x01000000;
+		flash_base = 0xbf000000;
+		break;
+	case (AMD_ID_DL640G_2 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640G_2 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF1601 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1601 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF1602 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1602 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF3201 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3201 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF3202 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3202 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		flash_base = 0xbfc00000;
+		break;
+	case (SST_ID_xF6401 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6402 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6401B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	case (SST_ID_xF6402B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		flash_base = 0xbf800000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (SST_MANUFACT & FLASH_VENDMASK) &&
+	    (info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+			switch (info->flash_id & FLASH_VENDMASK) {
+			case (SST_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+				    ((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			case (AMD_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (AMD_ID_DL640 & FLASH_TYPEMASK))  
+					)
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			}
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		if (((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+		    ((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0;
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		if ((info->flash_id & FLASH_TYPEMASK) == 
+		    (AMD_ID_DL640 & FLASH_TYPEMASK)) 
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0; 
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	}
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt/Makefile u-boot-1.1.6/board/slt/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/slt/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt/Makefile	2007-08-29 14:14:57.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o chip_count.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt/slt.c u-boot-1.1.6/board/slt/slt.c
--- /develop/source/01boot/u-boot-1.1.6/board/slt/slt.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt/slt.c	2007-09-14 17:13:13.000000000 +0800
@@ -0,0 +1,149 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+#if defined(CFG_CHIP_COUNT)
+extern int chip_count( void );
+#endif
+
+inline int get_cpu_speed(void)
+{
+	unsigned int speed, cfg;
+
+	/* set gpio as input??? */
+	cfg = (REG_GPIO_GPDR(3) >> 12) & 0x7; /* read GP110,GP109,GP108 */
+
+	switch ( cfg ) {
+	case 0:
+		speed = 200000000;
+		break;
+	case 2:
+		speed = 334000000;
+		break;
+	case 4:
+		speed = 366000000;
+		break;
+	default:
+		speed = 300000000; /* default speed */
+		break;
+	}
+
+	return speed;
+}
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+static void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 3, 3, 3, 3}; /* divisors of I:S:P:L:M */
+//	int div[5] = {1, 4, 4, 4, 4}; /* divisors of I:S:P:L:M */
+	int nf;
+
+	cfcr = CPM_CFCR_CKOEN1;
+	cfcr |=  ((CFG_CPU_SPEED/48000000 - 1) << 25); /* USB clock divider */
+
+	cfcr |= (n2FR[div[0]] << CPM_CFCR_IFR_BIT) | 
+		(n2FR[div[1]] << CPM_CFCR_SFR_BIT) | 
+		(n2FR[div[2]] << CPM_CFCR_PFR_BIT) |
+		(n2FR[div[3]] << CPM_CFCR_LFR_BIT) |
+		(n2FR[div[4]] << CPM_CFCR_MFR_BIT);
+
+	nf = get_cpu_speed() * 2 / CFG_EXTAL + 1;
+
+	plcr1 = ((nf - 2) << CPM_PLCR1_PLL1FD_BIT) | /* FD=NF-2 */
+		(0 << CPM_PLCR1_PLL1RD_BIT) |	   /* RD=0, NR=2, 1.8432 = 3.6864/2 */
+		(0 << CPM_PLCR1_PLL1OD_BIT) |      /* OD=0, NO=1 */
+		(0x20 << CPM_PLCR1_PLL1ST_BIT) |   /* PLL stable time */
+		CPM_PLCR1_PLL1EN;                  /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CFCR = cfcr;
+	REG_CPM_PLCR1 = plcr1;
+}
+
+/* see u-boot-1.1.6/nand_spl/board/slt/nand_boot_jz4730.c, gpio_init() */
+static void gpio_init(void)
+{
+	int i;
+
+	/* LED enable */
+	for ( i=0; i< 8; ++i) {	/* LED light */
+		__gpio_as_output(i);
+		__gpio_clear_pin(i); /* 0: on, 1: off */
+	}
+
+	__gpio_as_eth();
+	__gpio_as_dma();
+
+}
+
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+
+	gpio_init();
+
+#if defined(CFG_CHIP_COUNT)
+	{
+		unsigned int cfg;
+		cfg = (REG_GPIO_GPDR(3) >> 12) & 0x7; /* read GP110,GP109,GP108 */
+		if ( cfg != 0 ) 		/* if cfg == 7, skip chip count */
+			chip_count();		/* chip count increase */
+	}
+#endif
+	pll_init();
+
+}
+
+void board_led(char ch)
+{
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic SLT Board, System Level Test Board\n");
+	printf("For JZ4730 Chip-Sorting ");
+	printf("CPU Speed [%d] MHz\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt/u-boot.lds u-boot-1.1.6/board/slt/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/slt/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt/u-boot.lds	2007-08-29 14:14:57.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt/u-boot-nand.lds u-boot-1.1.6/board/slt/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/slt/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt/u-boot-nand.lds	2007-08-29 14:14:57.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt_50/chip_count.c u-boot-1.1.6/board/slt_50/chip_count.c
--- /develop/source/01boot/u-boot-1.1.6/board/slt_50/chip_count.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt_50/chip_count.c	2008-12-10 19:50:38.000000000 +0800
@@ -0,0 +1,341 @@
+/*
+ *  Jz4730 System Level Test
+ *
+ *  Copyright (c) 2007
+ *  Ingenic Semiconductor, <lgwang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+#include <asm/jz4750.h>
+
+#if defined(CFG_CHIP_COUNT)
+
+
+//#define CHIP_COUNT_DEBUG 1
+#undef CHIP_COUNT_DEBUG
+
+#define CFG_EEPROM_DATA_BACKUP_ENABLE 		1
+
+#if defined(CFG_EEPROM_AT24C02A)		/* Old board: 256 bytes */
+
+#define eeprom_size     256	/* AT24C02A: 256byte, AT24C16A: 2048byte */
+#define section_size    64	/* 32, 64, 128, 256 bytes */
+#define section_num     (eeprom_size/section_size) /* 4,8,16 */
+#define cpu_clk_type    (section_num/2) 
+#define page_size       8 //bytes
+//#define check_max       6
+#define check_max       60000
+
+#elif defined(CFG_EEPROM_AT24C16A)		/* Old board: 256 bytes */
+#define eeprom_size     2048	/* AT24C02A: 256byte, AT24C16A: 2048byte */
+#define section_size    64	/* 32, 64, 128, 256 bytes */
+#define section_num     (eeprom_size/section_size) /* 4,8,16 */
+#define cpu_clk_type    (section_num/2) 
+#define page_size       16 //bytes
+#define check_max       60000
+
+#else
+#error "unknown eeprom type"
+#endif
+
+#if defined(CHIP_COUNT_DEBUG)
+#undef check_max
+#define check_max       6
+#endif
+
+struct section_info {
+	unsigned short cpuclk;	/* 2bytes */
+	unsigned char sum_offset; /* 1byte */
+	unsigned char pass_offset; /* 1byte */
+	unsigned short summary;	/* 2bytes */
+	unsigned short pass;	/* 2bytes */
+};
+
+
+extern void i2c_open(void);
+extern void i2c_close(void);
+extern void i2c_setclk(unsigned int i2cclk);
+extern int i2c_read(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+extern int i2c_write(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+extern inline int get_cpu_speed(void);
+
+/* used for stage: nandboot -- new pll_init , cpu speed is 100MHz. */
+static inline void my_udelay(int n )
+{
+	int i;
+	i=n*100;
+	while ( i-- )
+		;
+}
+
+static inline void mdelay ( int n )
+{
+	while ( n-- ) 
+		my_udelay(1000);
+}
+
+static void led_dancing( void )
+{
+	int i;
+#if 1
+	while (1) {
+		__gpio_set_pin(102);
+		mdelay(500);
+		__gpio_clear_pin(102);
+		mdelay(500);
+	}
+#endif
+}
+
+unsigned short encrypt(unsigned short org)
+{
+	unsigned short an_val, pos21, pos65, posa9, posed;
+
+	an_val = ~org;
+	pos21 = an_val & 0x6;
+	pos65 = an_val & 0x60;
+	posa9 = an_val & 0x600;
+	posed = an_val & 0x6000;
+	an_val = an_val & 0x9999;
+	an_val = an_val | (pos21 << 12) | (pos65 << 4) | (posa9 >> 4) | (posed >> 12);
+
+	return(an_val);
+}
+
+unsigned short decrypt(unsigned short an_val)
+{
+	unsigned short org, pos21, pos65, posa9, posed;
+
+	pos21 = an_val & 0x6000;pos21 = pos21 >> 12;
+	pos65 = an_val & 0x600;pos65 = pos65 >> 4;
+	posa9 = an_val & 0x60;posa9 = posa9 << 4;
+	posed = an_val & 0x6;posed = posed << 12;
+	an_val = an_val & 0x9999;
+	an_val = an_val | (pos21) | (pos65) | (posa9) | (posed);
+	org = ~an_val;
+
+	return(org);
+}
+
+
+static struct section_info section_info[1];
+/* 
+ * chip count increase 1
+ * NOTES: calculate deviceid before i2c_read or i2c_write.
+ */
+int chip_count( void )
+{
+	struct section_info *p_section_info = &section_info[0];
+	int section_cnt = 0;
+	int section_base_addr = 0;
+	int buf_size = section_size;
+	unsigned char buf[buf_size];
+	int i, ret;
+	unsigned short cpu_speed_test, cpu_speed_now,testcpu;
+	unsigned short summary_backup;
+	
+	memset(buf, 0, buf_size);
+#if defined(CFG_EEPROM_AT24C02A)
+	int device_id = (0xA<<3) | 7;
+#elif defined(CFG_EEPROM_AT24C16A)
+	int device_id = (0xA<<3) | 0;
+#else
+#error ""
+#endif
+
+
+	i2c_open();
+
+	i2c_setclk(100000);	/* 100 k */
+	/* check cpu speed is right */
+	cpu_speed_now = get_cpu_speed()/100000;
+
+	testcpu = 2000;
+	cpu_speed_test = 1000;
+
+	/* section 1's firt 2bypte, cpu_speed is 3340 *100kHz */
+	ret = i2c_read(device_id, (unsigned char *)&cpu_speed_test, 1*section_size, 2); 
+	if ( ret < 0 ) {
+		printf("here is erro\n");
+//		goto i2c_read_failed;
+		goto gpio_failed;
+	}
+
+	if ( cpu_speed_now != cpu_speed_test ) {
+		printf("cpu_speed(%d) is not correct.\n", cpu_speed_now);
+		printf("cpu_speed should be %d.\n", cpu_speed_test);
+		i2c_close();
+		led_dancing();
+	}
+	
+	/* find the correct section */
+	for (i=0; i< section_num; i+=2 ) {
+		section_base_addr = i*section_size;
+#if defined(CFG_EEPROM_AT24C16A)
+		device_id = (0xA<<3) | (((section_base_addr) >> 8) &0x7);
+#endif
+		ret = i2c_read(device_id, buf, section_base_addr, 4); /*  */
+		if ( ret < 0 ) {
+			goto i2c_read_failed;
+		}
+		p_section_info->cpuclk = *((unsigned short *) &buf[0]);
+		
+		if ( p_section_info->cpuclk == cpu_speed_test ) {
+			section_cnt = i;
+			p_section_info->sum_offset = *((unsigned char *) &buf[2]);
+			p_section_info->pass_offset = *((unsigned char *) &buf[3]);
+			break;
+		}
+		
+	}
+#if defined(CHIP_COUNT_DEBUG)
+	printf("cpuspeed=%d, cpuclk=%d\n", cpu_speed_test, p_section_info->cpuclk);
+	printf("sum_offset=%d\n", p_section_info->sum_offset);
+	printf("pass_offset=%d\n", p_section_info->pass_offset);
+#endif
+	if ( i >= section_num ) {
+		printf("no cpu speed %d, please added it first.\n", cpu_speed_test);
+		i2c_close();
+		led_dancing();
+	}
+	if ( p_section_info->sum_offset >= section_size - 2 ) {
+		printf("EEPROM's sector[%d], sector_size=%d.\n", i, section_size);
+		printf("sum_offset=%d, should be less than sector_size\n", 
+		       p_section_info->sum_offset);
+	}
+	if ( p_section_info->sum_offset >= p_section_info->pass_offset-1 ) {
+		printf("*****************************\n");
+		printf("EEPROM's speed %d sector is full.\n", cpu_speed_now);
+		printf("no space to save speed %d count.\n", cpu_speed_now);
+		printf("*****************************\n");
+		led_dancing();
+	}
+
+	
+	/* read data summary */
+#if defined(CFG_EEPROM_AT24C16A)
+	device_id = (0xA<<3) | (((section_base_addr) >> 8) &0x7);
+#endif
+	ret = i2c_read(device_id, (unsigned char *)&p_section_info->summary,
+		       section_base_addr+p_section_info->sum_offset, 2); /*  */
+
+	if ( ret < 0 ) 
+		goto i2c_read_failed;
+
+#if defined(CFG_EEPROM_DATA_BACKUP_ENABLE)
+	/* read backup data */
+	ret = i2c_read(device_id, (unsigned char *)&summary_backup,
+		       section_base_addr+p_section_info->sum_offset+section_size, 2); /*  */
+	if ( ret < 0 ) 
+		goto i2c_read_failed;
+
+	/* decrypt summary_backup format??? */
+	summary_backup = decrypt(summary_backup);
+
+	/* check data */
+	if ( !(p_section_info->sum_offset == 4 && /* skip the first data */
+	       p_section_info->summary == 0)  ) {
+		if ( p_section_info->summary != summary_backup ) {
+			printf("data check p_section_info->summary===%d\n",p_section_info->summary);
+			printf("data check summary_backup ===%d\n",summary_backup);
+			printf("data check error...\n");
+			led_dancing();
+		}
+	}
+#endif
+	
+	p_section_info->summary++;
+
+	if ( p_section_info->summary > check_max ) {
+		p_section_info->summary = 1;
+		p_section_info->sum_offset +=2;
+		if ( p_section_info->sum_offset >= p_section_info->pass_offset-1 ) {
+			printf("*****************************\n");
+			printf("EEPROM's speed %d sector is full.\n", cpu_speed_now);
+			printf("no space to save speed %d count.\n", cpu_speed_now);
+			printf("*****************************\n");
+			led_dancing();
+		}
+		if ( p_section_info->sum_offset >= section_size - 2 ) {
+			printf("EEPROM's sector[%d], sector_size=%d.\n", i, section_size);
+			printf("sum_offset=%d, should be less than sector_size\n", 
+			       p_section_info->sum_offset);
+		}
+
+		ret = i2c_write(device_id, 
+				(unsigned char *)&p_section_info->sum_offset,
+				section_base_addr+2, 1); /*  */
+		ret = i2c_write(device_id, 
+				(unsigned char *)&p_section_info->sum_offset,
+				section_base_addr+2+section_size, 1); /*  */
+		if ( ret < 0 ) 
+			goto i2c_write_failed;
+		
+	}
+
+	/* save data summary  */
+	ret = i2c_write(device_id, (unsigned char *)&p_section_info->summary,
+			section_base_addr+p_section_info->sum_offset, 2); /*  */
+	if ( ret < 0 ) 
+		goto i2c_write_failed;
+#if defined(CFG_EEPROM_DATA_BACKUP_ENABLE)	
+	/* convert summary_backup format??? */
+	summary_backup = p_section_info->summary;
+
+	summary_backup = encrypt(summary_backup);
+
+	/* save backup data */
+	ret = i2c_write(device_id, (unsigned char *)&summary_backup,
+			section_base_addr+p_section_info->sum_offset+section_size, 2);
+	if ( ret < 0 ) 
+		goto i2c_write_failed;
+
+	/* read backup data */
+	ret = i2c_read(device_id, (unsigned char *)&summary_backup,
+		       section_base_addr+p_section_info->sum_offset+section_size, 2); /*  */
+	if ( ret < 0 ) 
+		goto i2c_read_failed;
+
+	/* decrypt summary_backup format??? */
+	summary_backup = decrypt(summary_backup);
+
+
+	i2c_close();
+	return 0;
+	
+ i2c_read_failed:
+ i2c_write_failed:
+	printf("i2c read or write error.\n");
+	i2c_close();
+	return -1;
+#endif
+
+gpio_failed:
+	printf("gpio test i2c failed");
+	for (i = 64; i < 72; i++) {
+		__gpio_as_output(i); //gpd26
+		__gpio_clear_pin(i);
+	}
+	while(1);
+}
+
+#endif /* #if defined(CFG_CHIP_COUNT) */
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt_50/config.mk u-boot-1.1.6/board/slt_50/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/slt_50/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt_50/config.mk	2008-12-10 19:50:38.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's slt_50 board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
\ No newline at end of file
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt_50/flash.c u-boot-1.1.6/board/slt_50/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/slt_50/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt_50/flash.c	2008-12-10 19:50:38.000000000 +0800
@@ -0,0 +1,543 @@
+/*
+ * (C) Copyright 2005 Ingenic Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This file supports SST 16-bit Flashes:
+ * 39xF1601, 39xF1602, 39xF3201, 39xF3202, 39xF6401, 39xF6402,
+ * 39xF6401B, 39xF6402B.
+ */
+
+#include <common.h>
+
+#define SST_ID_xF6401B	0x236D236D	/* 39xF6401B ID (64M =	4M x 16 )	*/
+#define SST_ID_xF6402B	0x236C236C	/* 39xF6402B ID (64M =	4M x 16 )	*/
+#define AMD_ID_DL640	0x227E227E	/* 29DL640D ID (64 M, dual boot sectors)*/
+
+#define AMD_SECT_SIZE     0x10000
+#define SST_SECT_SIZE     0x1000
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS]; /* info for FLASH chips	*/
+static ulong flash_base = 0xa8000000;    /* base address of CS4 */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static ulong flash_get_size (vu_long *addr, flash_info_t *info);
+
+/*-----------------------------------------------------------------------
+ */
+ulong flash_init(void)
+{
+	int i, j;
+	ulong size = 0;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		if (i == 0) {
+			size += flash_get_size((vu_long *)flash_base, &flash_info[0]);
+		}
+		else
+			panic("configured too many flash banks!\n");
+		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
+
+ 		switch (flash_info[i].flash_id & FLASH_VENDMASK) {
+ 		case (AMD_MANUFACT & FLASH_VENDMASK):
+			for (j = 0; j < flash_info[i].sector_count; j++) {
+#if 1
+				if (j < 8) {     // 8 x 8k boot sectors	
+					flash_info[i].start[j] = flash_base + j * 0x2000;
+				}
+				else {
+					flash_info[i].start[j] = flash_base + (j-7) * AMD_SECT_SIZE;
+				}
+#else
+				flash_info[i].start[j] = flash_base + j * AMD_SECT_SIZE;
+#endif
+					
+			}
+			break;
+
+ 		case (SST_MANUFACT & FLASH_VENDMASK): 
+			for (j = 0; j < flash_info[i].sector_count; j++) { 
+				flash_info[i].start[j] = flash_base + j * SST_SECT_SIZE;
+			}
+			break;
+
+		default:
+			break;
+  		}
+ 	} 
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	/* Protect monitor and environment sectors
+	 */
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_MONITOR_BASE,
+			CFG_MONITOR_BASE + monitor_flash_len - 1,
+			&flash_info[0]);
+
+	flash_protect ( FLAG_PROTECT_SET,
+			CFG_ENV_ADDR,
+			CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+#endif
+
+	return size;
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		printf ("SST ");
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_DL640 & FLASH_TYPEMASK):
+		printf ("29DL640D (64Mbit)\n");
+		break;
+	case (AMD_ID_DL640G_2 & FLASH_TYPEMASK):
+		printf ("AM29DL640G2 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1601 & FLASH_TYPEMASK):
+		printf ("39xF1601 (16Mbit)\n");
+		break;
+	case (SST_ID_xF1602 & FLASH_TYPEMASK):
+		printf ("39xF1602 (16Mbit)\n");
+		break;
+	case (SST_ID_xF3201 & FLASH_TYPEMASK):
+		printf ("39xF3201 (32Mbit)\n");
+		break;
+	case (SST_ID_xF3202 & FLASH_TYPEMASK):
+		printf ("39xF3202 (32Mbit)\n");
+		break;
+	case (SST_ID_xF6401 & FLASH_TYPEMASK):
+		printf ("39xF6401 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402 & FLASH_TYPEMASK):
+		printf ("39xF6402 (64Mbit)\n");
+		break;
+	case (SST_ID_xF6401B & FLASH_TYPEMASK):
+		printf ("39xF6401B (64Mbit)\n");
+		break;
+	case (SST_ID_xF6402B & FLASH_TYPEMASK):
+		printf ("39xF6402B (64Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+			info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+				info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+static ulong flash_get_size (vu_long *addr, flash_info_t *info)
+{
+	ushort vid, did;
+	vu_short *saddr = (vu_short *)addr;
+
+	/* Read Manufacturer ID and Device ID */
+
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0x90;
+
+	vid = saddr[0];
+	did = saddr[1];
+
+	/* Exit Read IDs */
+	saddr[0x5555] = 0xAA;
+	saddr[0x2AAA] = 0x55;
+	saddr[0x5555] = 0xF0;
+
+	if (vid != (SST_MANUFACT & 0xFFFF)) {
+		/* 39xF640xB stuff */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0x90;
+
+		vid = saddr[0];
+		did = saddr[1];
+
+		/* Exit Read IDs */
+		saddr[0x555] = 0xAA;
+		saddr[0x2AA] = 0x55;
+		saddr[0x555] = 0xF0;
+	}
+
+	switch (vid) {
+	case (AMD_MANUFACT & 0xFFFF):
+		info->flash_id = (AMD_MANUFACT & 0xFFFF0000);
+       		break;
+	case (SST_MANUFACT & 0xFFFF):
+		info->flash_id = (SST_MANUFACT & 0xFFFF0000);
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	switch (did) {
+	case (AMD_ID_DL640 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640 & 0xFFFF); 
+		info->sector_count = 135;
+		info->size = 0x00800000;
+		break;
+	case (AMD_ID_DL640G_2 & 0xFFFF):
+		info->flash_id += (AMD_ID_DL640G_2 & 0xFFFF);
+		info->sector_count = 128;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF1601 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1601 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		break;
+	case (SST_ID_xF1602 & 0xFFFF):
+		info->flash_id += (SST_ID_xF1602 & 0xFFFF);
+		info->sector_count = 512;
+		info->size = 0x00200000;
+		break;
+	case (SST_ID_xF3201 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3201 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		break;
+	case (SST_ID_xF3202 & 0xFFFF):
+		info->flash_id += (SST_ID_xF3202 & 0xFFFF);
+		info->sector_count = 1024;
+		info->size = 0x00400000;
+		break;
+	case (SST_ID_xF6401 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6402 & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402 & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6401B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6401B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	case (SST_ID_xF6402B & 0xFFFF):
+		info->flash_id += (SST_ID_xF6402B & 0xFFFF);
+		info->sector_count = 2048;
+		info->size = 0x00800000;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);			/* no or unknown flash	*/
+	}
+
+	return (info->size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	int flag, prot, sect;
+	int rc = ERR_OK;
+	unsigned int timeout;
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (SST_MANUFACT & FLASH_VENDMASK) &&
+	    (info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+
+		printf ("Erasing sector %3d ... ", sect);
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
+			switch (info->flash_id & FLASH_VENDMASK) {
+			case (SST_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+				    ((info->flash_id & FLASH_TYPEMASK) == 
+				     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			case (AMD_MANUFACT & FLASH_VENDMASK):
+				if (((info->flash_id & FLASH_TYPEMASK) == 
+				     (AMD_ID_DL640 & FLASH_TYPEMASK))  
+					)
+				{
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					base[0x555] = 0x0080;
+					base[0x555] = 0x00AA;
+					base[0x2AA] = 0x0055;
+					addr[0x000] = 0x0030;
+				}
+				else {
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					base[0x5555] = 0x0080;
+					base[0x5555] = 0x00AA;
+					base[0x2AAA] = 0x0055;
+					addr[0x0000] = 0x0030;
+				}
+				break;
+			}
+
+			timeout = 0x3ffffff;
+			while ((*base & 0x40) != (*base & 0x40)) {
+				if ((timeout--) == 0) {
+					rc = ERR_TIMOUT;
+					goto outahere;
+				}
+			}
+		}
+		printf ("ok.\n");
+	}
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+  outahere:
+
+	/* allow flash to settle - wait 20 ms */
+	udelay(20000);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+static int write_word (flash_info_t * info, ulong dest, ushort data)
+{
+	volatile u16 *base = (volatile u16 *) flash_base;
+	volatile u16 *addr = (volatile u16 *) dest;
+	int rc = ERR_OK;
+	int flag;
+	unsigned int timeout;
+
+	/* Check if Flash is (sufficiently) erased
+	 */
+	if ((*addr & data) != data)
+		return ERR_NOT_ERASED;
+
+	/* Disable interrupts which might cause a timeout here. */
+	flag = disable_interrupts ();
+
+	/* program set-up command */
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (SST_MANUFACT & FLASH_VENDMASK):
+		if (((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6401B & FLASH_TYPEMASK)) || 
+		    ((info->flash_id & FLASH_TYPEMASK) == 
+		     (SST_ID_xF6402B & FLASH_TYPEMASK)))
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0;
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		if ((info->flash_id & FLASH_TYPEMASK) == 
+		    (AMD_ID_DL640 & FLASH_TYPEMASK)) 
+		{
+			base[0x555] = 0x00AA;
+			base[0x2AA] = 0x0055;
+			base[0x555] = 0x00A0; 
+		}
+		else {
+			base[0x5555] = 0x00AA;
+			base[0x2AAA] = 0x0055;
+			base[0x5555] = 0x00A0;
+		}
+		break;
+	}
+
+	/* load address/data */
+	*addr = data;
+
+	/* wait while polling the status register */
+	timeout = 0x3ffffff;
+	while ((*base & 0x40) != (*base & 0x40)) {
+		if ((timeout--) == 0) {
+			rc = ERR_TIMOUT;
+			goto outahere;
+		}
+	}
+
+  outahere:
+
+	/* allow flash to settle - wait 10 us */
+	udelay(10);
+
+	if (flag)
+		enable_interrupts ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	ushort data;
+	int l;
+	int i, rc;
+
+	wp = (addr & ~1);			/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_word (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_word (info, wp, data);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt_50/Makefile u-boot-1.1.6/board/slt_50/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/slt_50/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt_50/Makefile	2008-12-10 19:50:38.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o chip_count.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt_50/slt_50.c u-boot-1.1.6/board/slt_50/slt_50.c
--- /develop/source/01boot/u-boot-1.1.6/board/slt_50/slt_50.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt_50/slt_50.c	2008-12-10 19:50:38.000000000 +0800
@@ -0,0 +1,158 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4750.h>
+
+#if defined(CFG_CHIP_COUNT)
+extern int chip_count( void );
+
+static int hs = 6;
+inline int get_cpu_speed(void)
+{
+	unsigned int speed, cfg;
+
+	/* set gpio as input??? */
+	cfg = (REG_GPIO_PXPIN(2) >> 11) & 0x7; /* read GPC11,GPC12,GPC13 */
+	switch (cfg) {
+	case 0:
+		speed = 336000000;
+		break;
+	case 1:
+		speed = 392000000;
+		break;
+	case 2:
+		speed = 400000000;
+		break;
+	case 3:
+		speed = 180000000;
+		break;
+	case 4:
+		speed = 410000000;
+		break;
+	default:
+		speed = 420000000; /* default speed */
+		break;
+	}
+
+	return speed;
+}
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+static void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, hs, hs, hs, hs}; /* divisors of I:S:P:L:M */
+	int nf, pllout2;
+
+	cfcr = 	CPM_CPCCR_PCS |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	if (CFG_EXTAL > 16000000)
+		cfcr |= CPM_CPCCR_ECS;
+	else
+		cfcr &= ~CPM_CPCCR_ECS;
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? get_cpu_speed() : (get_cpu_speed() / 2);
+
+	/* Init USB Host clock, pllout2 must be n*48MHz */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+
+	nf = get_cpu_speed()  / 1000000;
+
+//	nf = get_cpu_speed() * 2 / CFG_EXTAL;
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(22 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+#endif
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+#if CONFIG_NR_DRAM_BANKS == 2   /*Use Two Banks SDRAM*/
+	__gpio_as_sdram_x2_32bit();
+#else
+	__gpio_as_sdram_32bit();
+#endif
+
+	/*
+	 * Initialize UART1 pins
+	 */
+	__gpio_as_uart1();
+	__gpio_as_i2c();
+	__cpm_start_i2c();
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+
+#if defined(CFG_CHIP_COUNT)
+	{
+		unsigned int cfg;
+		cfg = (REG_GPIO_PXPIN(2) >> 11) & 0x7; /* read GP110,GP109,GP108 */
+		if ( cfg != 0 ) 		/* if cfg == 7, skip chip count */
+			chip_count();		/* chip count increase */
+	}
+#endif
+	pll_init();
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	printf("Board: Ingenic SLT Board, System Level Test Board\n");
+	printf("For JZ4750 Chip-Sorting ");
+
+	printf("CPU Speed [%d] MHz\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt_50/u-boot.lds u-boot-1.1.6/board/slt_50/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/slt_50/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt_50/u-boot.lds	2008-12-10 19:50:38.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/slt_50/u-boot-nand.lds u-boot-1.1.6/board/slt_50/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/slt_50/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/slt_50/u-boot-nand.lds	2008-12-10 19:50:38.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/taurus/config.mk u-boot-1.1.6/board/taurus/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/taurus/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/taurus/config.mk	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's TAURUS board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/taurus/Makefile u-boot-1.1.6/board/taurus/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/taurus/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/taurus/Makefile	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/taurus/taurus.c u-boot-1.1.6/board/taurus/taurus.c
--- /develop/source/01boot/u-boot-1.1.6/board/taurus/taurus.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/taurus/taurus.c	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,67 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz5730.h>
+
+static void gpio_init(void)
+{
+	/* board led pins */
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_emc(0);
+	__gpio_as_dma();
+	__gpio_as_eth();
+	__gpio_as_pci();
+	__gpio_as_usbclk();
+
+	__gpio_as_output(67);
+	__gpio_as_output(68);
+	__gpio_as_output(69);
+	__gpio_as_output(70);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+void board_led(char ch)
+{
+	REG32(0xa8000000) = (ch << 24) | (ch << 16) | (ch << 8) | ch;
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic Taurus (CPU Speed %d MHz)\n", gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
+
diff -urN /develop/source/01boot/u-boot-1.1.6/board/taurus/u-boot.lds u-boot-1.1.6/board/taurus/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/taurus/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/taurus/u-boot.lds	2007-05-23 14:14:38.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/uranus/config.mk u-boot-1.1.6/board/uranus/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/uranus/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/uranus/config.mk	2007-05-23 12:06:32.000000000 +0800
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's uranus FPGA board, MIPS32 core
+#
+
+# ROM version
+TEXT_BASE = 0x9fc00000
+
+# RAM version
+#TEXT_BASE = 0x80100000
diff -urN /develop/source/01boot/u-boot-1.1.6/board/uranus/flash.c u-boot-1.1.6/board/uranus/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/uranus/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/uranus/flash.c	2007-05-23 12:06:32.000000000 +0800
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	return (0);
+}
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	printf ("flash_erase not implemented\n");
+	return 0;
+}
+
+void flash_print_info (flash_info_t * info)
+{
+	printf ("flash_print_info not implemented\n");
+}
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	printf ("write_buff not implemented\n");
+	return (-1);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/uranus/Makefile u-boot-1.1.6/board/uranus/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/uranus/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/uranus/Makefile	2007-05-23 12:06:32.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2005
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/uranus/u-boot.lds u-boot-1.1.6/board/uranus/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/uranus/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/uranus/u-boot.lds	2007-05-23 12:06:32.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/uranus/uranus.c u-boot-1.1.6/board/uranus/uranus.c
--- /develop/source/01boot/u-boot-1.1.6/board/uranus/uranus.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/uranus/uranus.c	2007-05-23 12:08:32.000000000 +0800
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4730.h>
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+}
+
+void board_led(char ch)
+{
+	volatile unsigned char *led = (unsigned char *)0xb6000058;
+
+	led[0] = 'U';
+	led[1] = '-';
+	led[2] = 'B';
+	led[3] = 'o';
+	led[4] = 'o';
+	led[5] = 't';
+	led[6] = ' ';
+
+	if (ch > 1)
+		led[7] = 'F';
+	else
+		led[7] = 'P';
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic URANUS (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/virgo/config.mk u-boot-1.1.6/board/virgo/config.mk
--- /develop/source/01boot/u-boot-1.1.6/board/virgo/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/virgo/config.mk	2007-11-02 09:55:21.000000000 +0800
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# Ingenic's virgo board, MIPS32 core
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# ROM version
+TEXT_BASE = 0x88000000
+
+# RAM version
+#TEXT_BASE = 0x80100000
+endif
diff -urN /develop/source/01boot/u-boot-1.1.6/board/virgo/flash.c u-boot-1.1.6/board/virgo/flash.c
--- /develop/source/01boot/u-boot-1.1.6/board/virgo/flash.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/virgo/flash.c	2007-11-02 09:55:21.000000000 +0800
@@ -0,0 +1,50 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips */
+
+/*-----------------------------------------------------------------------
+ * flash_init()
+ *
+ * sets up flash_info and returns size of FLASH (bytes)
+ */
+unsigned long flash_init (void)
+{
+	return (0);
+}
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	printf ("flash_erase not implemented\n");
+	return 0;
+}
+
+void flash_print_info (flash_info_t * info)
+{
+	printf ("flash_print_info not implemented\n");
+}
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	printf ("write_buff not implemented\n");
+	return (-1);
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/virgo/Makefile u-boot-1.1.6/board/virgo/Makefile
--- /develop/source/01boot/u-boot-1.1.6/board/virgo/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/virgo/Makefile	2007-11-02 09:55:21.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# (C) Copyright 2006
+# Ingenic Semiconductor, <jlwei@ingenic.cn>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	= $(BOARD).o flash.o
+SOBJS	= 
+
+$(LIB):	.depend $(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/board/virgo/u-boot.lds u-boot-1.1.6/board/virgo/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/board/virgo/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/virgo/u-boot.lds	2007-11-02 09:55:21.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/virgo/u-boot-nand.lds u-boot-1.1.6/board/virgo/u-boot-nand.lds
--- /develop/source/01boot/u-boot-1.1.6/board/virgo/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/virgo/u-boot-nand.lds	2007-11-02 09:55:21.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/board/virgo/virgo.c u-boot-1.1.6/board/virgo/virgo.c
--- /develop/source/01boot/u-boot-1.1.6/board/virgo/virgo.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/board/virgo/virgo.c	2008-05-30 14:03:26.000000000 +0800
@@ -0,0 +1,101 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/mipsregs.h>
+#include <asm/jz4740.h>
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize NAND Flash Pins
+	 */
+	__gpio_as_nand();
+
+	/*
+	 * Initialize SDRAM pins
+	 */
+	__gpio_as_sdram_16bit_4720();
+	/*
+	 * Initialize UART0 pins
+	 */
+	__gpio_as_uart0();
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize LCD pins
+	 */
+	__gpio_as_lcd_18bit();
+
+	/*
+	 * Initialize SSI pins
+	 */
+//	__gpio_as_ssi();
+
+	/*
+	 * Initialize I2C pins
+	 */
+//	__gpio_as_i2c();
+
+	/*
+	 * Initialize Other pins
+	 */
+	__gpio_as_output(GPIO_SD_VCC_EN_N);
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);
+
+	__gpio_as_input(GPIO_SD_CD_N);
+	__gpio_disable_pull(GPIO_SD_CD_N);
+
+//	__gpio_as_input(GPIO_SD_WP);
+//	__gpio_disable_pull(GPIO_SD_WP);
+
+	__gpio_as_input(GPIO_DC_DETE_N);
+//	__gpio_as_input(GPIO_CHARG_STAT_N);
+	__gpio_as_input(GPIO_USB_DETE);
+	__gpio_as_output(119);
+	__gpio_clear_pin(119);
+	__gpio_as_output(GPIO_DISP_OFF_N);
+}
+
+//----------------------------------------------------------------------
+// board early init routine
+
+void board_early_init(void)
+{
+	gpio_init();
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+int checkboard (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	printf("Board: Ingenic VIRGO (CPU Speed %d MHz)\n",
+	       gd->cpu_clk/1000000);
+
+	return 0; /* success */
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/Changelog u-boot-1.1.6/Changelog
--- /develop/source/01boot/u-boot-1.1.6/Changelog	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/Changelog	2008-11-25 16:50:00.000000000 +0800
@@ -0,0 +1,42 @@
+2008.11.24:
+* Support NAND of 4KB pagesize. <lhhuang@ingenic.cn>
+    Files updated:
+	include/linux/mtd/mtd-abi.h
+	nand_spl/nand_boot_jz4740.c
+	nand_spl/nand_boot_jz4750.c
+	drivers/nand/nand_base.c
+	drivers/nand/nand_ids.c
+	drivers/nand/nand_util.c
+	cpu/mips/jz4740_nand.c
+	cpu/mips/jz4750_nand.c
+	include/configs/pavo.h
+	include/configs/apus.h
+
+2008.05.30:
+
+* Add Jz4725 DIPPER Board Support
+	
+2008.05.05:
+
+* Added FOXCONN_PT035TN01 LCD panel support for PAVO board. <zyliu@ingenic.cn>
+
+2008.04.26:
+
+* Patch jz4740_nand.c to optimize the RS correction algorithm. <zengzhaoxiu>
+
+2008.04.11:
+
+* nand_spl/nand_boot_jz4740.c: fixed a fatal bug of nand_load(), which will
+  fail to load u-boot when meeting a bad block. <zyliu@ingenic.cn>
+
+2008.03.19:
+
+* Modified nand read/write/erase commands in common/cmd_nand.c
+  to support bad blocks checking. <zyliu@ingenic.cn>
+
+2008.02.26:
+
+* Release for JZ4740 and JZ4730.
+
+2008.10.31
+* Add boot from MMC/SD card for jz4750 like NAND. <cwjia@ingenic.cn>
\ No newline at end of file
diff -urN /develop/source/01boot/u-boot-1.1.6/common/cmd_bootm.c u-boot-1.1.6/common/cmd_bootm.c
--- /develop/source/01boot/u-boot-1.1.6/common/cmd_bootm.c	2007-10-31 00:43:21.000000000 +0800
+++ u-boot-1.1.6/common/cmd_bootm.c	2007-03-01 15:54:31.000000000 +0800
@@ -488,6 +488,10 @@
 		return;
 
 	debug ("before silent fix-up: %s\n", cmdline);
+#ifdef CONFIG_JzRISC
+	strcpy (buf, cmdline);
+	strcat (buf, " quiet");
+#else
 	if (cmdline) {
 		if ((start = strstr (cmdline, "console=")) != NULL) {
 			end = strchr (start, ' ');
@@ -503,6 +507,7 @@
 	} else {
 		strcpy (buf, "console=");
 	}
+#endif
 
 	setenv ("bootargs", buf);
 	debug ("after silent fix-up: %s\n", buf);
diff -urN /develop/source/01boot/u-boot-1.1.6/common/cmd_msc.c u-boot-1.1.6/common/cmd_msc.c
--- /develop/source/01boot/u-boot-1.1.6/common/cmd_msc.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/common/cmd_msc.c	2008-10-31 18:30:08.000000000 +0800
@@ -0,0 +1,390 @@
+/*
+ * Driver for NAND support, Rick Bronson
+ * borrowed heavily from:
+ * (c) 1999 Machine Vision Holdings, Inc.
+ * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
+ *
+ * Added 16-bit nand support
+ * (C) 2004 Texas Instruments
+ */
+
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/jz4750.h>
+#include <command.h>
+
+#define u32 unsigned int
+#define u16 unsigned short
+#define u8 unsigned char
+static int rca;
+static int sd2_0 = 0;
+
+/*
+ * GPIO definition
+ */
+#define MMC_IRQ_MASK()				\
+do {						\
+	REG_MSC_IMASK = 0xffff;			\
+	REG_MSC_IREG = 0xffff;			\
+} while (0)
+
+/* Stop the MMC clock and wait while it happens */
+static inline int jz_mmc_stop_clock(void)
+{
+	int timeout = 1000;
+
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;
+
+	while (timeout && (REG_MSC_STAT & MSC_STAT_CLK_EN)) {
+		timeout--;
+		if (timeout == 0) {
+			return -1;
+		}
+		udelay(1);
+	}
+	return 0;
+}
+
+/* Start the MMC clock and operation */
+static inline int jz_mmc_start_clock(void)
+{
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START | MSC_STRPCL_START_OP;
+	return 0;
+}
+
+static u8 * mmc_cmd(u16 cmd, unsigned int arg, unsigned int cmdat, u16 rtype)
+{
+	static u8 resp[20];
+	u32 timeout = 0x3fffff;
+	int words, i;
+
+	jz_mmc_stop_clock();
+	REG_MSC_CMD   = cmd;
+	REG_MSC_ARG   = arg;
+	REG_MSC_CMDAT = cmdat;
+
+	REG_MSC_IMASK = ~MSC_IMASK_END_CMD_RES;
+	jz_mmc_start_clock();
+
+	while (timeout-- && !(REG_MSC_STAT & MSC_STAT_END_CMD_RES))
+		;
+	REG_MSC_IREG = MSC_IREG_END_CMD_RES;
+
+	switch (rtype) {
+		case MSC_CMDAT_RESPONSE_R1:
+		case MSC_CMDAT_RESPONSE_R3:
+			words = 3;
+			break;
+
+		case MSC_CMDAT_RESPONSE_R2:
+			words = 8;
+			break;
+
+		default:
+			return 0;
+	}
+	
+	for (i = words-1; i >= 0; i--) {
+		u16 res_fifo = REG_MSC_RES;
+		int offset = i << 1;
+
+		resp[offset] = ((u8 *)&res_fifo)[0];
+		resp[offset+1] = ((u8 *)&res_fifo)[1];
+	}
+	return resp;
+}
+static int mmc_block_writem(u32 src, u32 num, u8 *dst)
+{
+	u8 *resp;
+	u32 stat, timeout, cnt, nob, sorm;
+	u32 *wbuf = (u32 *)dst;
+
+	resp = mmc_cmd(16, 0x200, 0x401, MSC_CMDAT_RESPONSE_R1);
+	REG_MSC_BLKLEN = 0x200;
+	REG_MSC_NOB = num / 512;
+	nob  = num / 512;
+
+	if (nob == 1) {
+		if (sd2_0)
+			resp = mmc_cmd(24, src, 0x419, MSC_CMDAT_RESPONSE_R1);
+		else
+			resp = mmc_cmd(24, src * 512, 0x419, MSC_CMDAT_RESPONSE_R1);
+
+		sorm = 0;
+	} else {
+		if (sd2_0)
+			resp = mmc_cmd(25, src, 0x419, MSC_CMDAT_RESPONSE_R1); // for sdhc card
+		else
+			resp = mmc_cmd(25, src * 512, 0x419, MSC_CMDAT_RESPONSE_R1);
+
+		sorm = 1;
+	}
+
+	for (nob; nob >= 1; nob--) {
+
+		timeout = 0x3FFFFFF;
+
+		while (timeout) {
+			timeout--;
+			stat = REG_MSC_STAT;
+			if (stat & (MSC_STAT_CRC_WRITE_ERROR | MSC_STAT_CRC_WRITE_ERROR_NOSTS)) {
+				serial_puts("\n MSC_STAT_CRC_WRITE_ERROR\n\n");
+				return -1;
+			}
+			else if (!(stat & MSC_STAT_DATA_FIFO_FULL)) {
+				/* Ready to write data */
+				break;
+			}
+
+			udelay(1);
+		}
+
+		if (!timeout)
+			return -1;
+
+		/* Write data to TXFIFO */
+		cnt = 128;
+		while (cnt) {
+			while (REG_MSC_STAT & MSC_STAT_DATA_FIFO_FULL)
+				;
+			REG_MSC_TXFIFO = *wbuf++;
+			cnt--;
+		}
+	}
+
+	if (sorm)
+		resp = mmc_cmd(12, 0, 0x41, MSC_CMDAT_RESPONSE_R1);
+
+	while (!(REG_MSC_STAT & MSC_STAT_DATA_TRAN_DONE))
+		;
+
+	while (!(REG_MSC_STAT & MSC_STAT_PRG_DONE))
+		;
+	jz_mmc_stop_clock();
+	return 0;
+}
+static int mmc_block_readm(u32 src, u32 num, u8 *dst)
+{
+	u8 *resp;
+	u32 stat, timeout, data, cnt, nob, sorm;
+
+	resp = mmc_cmd(16, 0x200, 0x401, MSC_CMDAT_RESPONSE_R1);
+	REG_MSC_BLKLEN = 0x200;
+	REG_MSC_NOB = num / 512;
+	nob  = num / 512;
+
+	if (nob == 1) {
+		if (sd2_0)
+			resp = mmc_cmd(17, src, 0x409, MSC_CMDAT_RESPONSE_R1);
+		else
+			resp = mmc_cmd(17, src * 512, 0x409, MSC_CMDAT_RESPONSE_R1);
+			
+		sorm = 0;
+	} else {
+		if (sd2_0)
+			resp = mmc_cmd(18, src, 0x409, MSC_CMDAT_RESPONSE_R1);
+		else
+			resp = mmc_cmd(18, src * 512, 0x409, MSC_CMDAT_RESPONSE_R1);
+
+		sorm = 1;
+	}
+
+	for (nob; nob >= 1; nob--) {
+
+		timeout = 0x3ffffff;
+
+		while (timeout) {
+			timeout--;
+			stat = REG_MSC_STAT;
+			if (stat & MSC_STAT_TIME_OUT_READ) {
+				serial_puts("\n MSC_STAT_TIME_OUT_READ\n\n");
+				return -1;
+			}
+			else if (stat & MSC_STAT_CRC_READ_ERROR) {
+				serial_puts("\n MSC_STAT_CRC_READ_ERROR\n\n");
+				return -1;
+			}
+			else if (!(stat & MSC_STAT_DATA_FIFO_EMPTY)) {
+				/* Ready to read data */
+				break;
+			}
+			udelay(1);
+		}
+		if (!timeout) {
+			serial_puts("\n mmc/sd read timeout\n");
+			return -1;
+		}
+
+		/* Read data from RXFIFO. It could be FULL or PARTIAL FULL */
+		cnt = 128;
+		while (cnt) {
+			while (cnt && (REG_MSC_STAT & MSC_STAT_DATA_FIFO_EMPTY))
+				;
+			cnt --;
+
+			data = REG_MSC_RXFIFO;
+			{
+				*dst++ = (u8)(data >> 0);
+				*dst++ = (u8)(data >> 8);
+				*dst++ = (u8)(data >> 16);
+				*dst++ = (u8)(data >> 24);
+			}
+		}
+	}
+
+	if (sorm)
+		resp = mmc_cmd(12, 0, 0x41, MSC_CMDAT_RESPONSE_R1);
+
+	jz_mmc_stop_clock();
+	return 0;
+}
+
+static void sd_init(void)
+{
+	int retries;
+	u8 *resp;
+	unsigned int cardaddr;
+
+	resp = mmc_cmd(41, 0x40ff8000, 0x3, MSC_CMDAT_RESPONSE_R3);
+	retries = 100;
+	while (retries-- && resp && !(resp[4] & 0x80)) {
+		resp = mmc_cmd(55, 0, 0x1, MSC_CMDAT_RESPONSE_R1);
+		resp = mmc_cmd(41, 0x40ff8000, 0x3, MSC_CMDAT_RESPONSE_R3);
+		udelay(100);
+	}
+
+	if (resp[4] & 0x80) 
+		serial_puts("SD init ok\n");
+	else 
+		serial_puts("SD init fail\n");
+
+	/* try to get card id */
+	resp = mmc_cmd(2, 0, 0x2, MSC_CMDAT_RESPONSE_R2);
+	resp = mmc_cmd(3, 0, 0x6, MSC_CMDAT_RESPONSE_R1);
+	cardaddr = (resp[4] << 8) | resp[3]; 
+	rca = cardaddr << 16;
+	resp = mmc_cmd(9, rca, 0x2, MSC_CMDAT_RESPONSE_R2);
+	sd2_0 = (resp[14] & 0xc0) >> 6;
+	REG_MSC_CLKRT = 2;    //2 is ok ,dont't grater
+	resp = mmc_cmd(7, rca, 0x41, MSC_CMDAT_RESPONSE_R1);
+	resp = mmc_cmd(55, rca, 0x1, MSC_CMDAT_RESPONSE_R1);
+	resp = mmc_cmd(6, 0x2, 0x401, MSC_CMDAT_RESPONSE_R1);
+}
+/* init mmc/sd card we assume that the card is in the slot */
+static int  mmc_init(void)
+{
+	int retries;
+	u8 *resp;
+
+	__gpio_as_msc0_8bit();
+	__msc_reset();
+	MMC_IRQ_MASK();	
+	__cpm_select_msc_clk(0,1);
+	REG_MSC_CLKRT = 6;    //250k
+
+	resp = mmc_cmd(12, 0, 0x41, MSC_CMDAT_RESPONSE_R1);
+	/* reset */
+	resp = mmc_cmd(0, 0, 0x80, 0);
+	resp = mmc_cmd(8, 0x1aa, 0x1, MSC_CMDAT_RESPONSE_R1);
+	resp = mmc_cmd(55, 0, 0x1, MSC_CMDAT_RESPONSE_R1);
+	if(!(resp[0] & 0x20) && (resp[5] != 0x37)) { 
+		resp = mmc_cmd(1, 0xff8000, 0x3, MSC_CMDAT_RESPONSE_R3);
+		retries = 100;
+		while (retries-- && resp && !(resp[4] & 0x80)) {
+			resp = mmc_cmd(1, 0x40300000, 0x3, MSC_CMDAT_RESPONSE_R3);
+			udelay(100);
+		}
+
+		if (resp[4]== 0x80) 
+			serial_puts("MMC init ok\n");
+		else 
+			serial_puts("MMC init fail\n");
+
+		/* try to get card id */
+		resp = mmc_cmd(2, 0, 0x2, MSC_CMDAT_RESPONSE_R2);
+		resp = mmc_cmd(3, 0x10, 0x1, MSC_CMDAT_RESPONSE_R1);
+
+		REG_MSC_CLKRT = 2;	/* 16/1 MHz */
+		resp = mmc_cmd(7, 0x10, 0x1, MSC_CMDAT_RESPONSE_R1);
+		resp = mmc_cmd(6, 0x3b70101, 0x401, MSC_CMDAT_RESPONSE_R1);
+	}
+	else
+		sd_init();
+	return 0;
+}
+
+/*
+ * Load kernel image from MMC/SD into RAM
+ */
+int msc_read(ulong start_byte, u8 *dst, size_t len)
+{
+	int start_sect;
+
+	start_sect = start_byte / 512;
+
+	mmc_init();
+	mmc_block_readm(start_sect, len, dst);
+	return 0;
+}
+
+int msc_write(ulong start_byte, u8 *dst, size_t len)
+{
+	int start_sect;
+
+	start_sect = start_byte / 512;
+
+	mmc_block_writem(start_sect, len, dst);
+	return 0;
+}
+
+static inline int str2long(char *p, ulong *num)
+{
+	char *endptr;
+
+	*num = simple_strtoul(p, &endptr, 16);
+	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
+}
+
+int do_msc(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	int ret=0;
+	ulong addr, off, size;
+	char *cmd;
+	int quiet = 1;
+	const char *quiet_str = getenv("quiet");
+
+	/* at least two arguments please */
+	if (argc < 2)
+		goto usage;
+
+	if (quiet_str)
+		quiet = simple_strtoul(quiet_str, NULL, 0) != 0;
+
+	cmd = argv[1];
+
+	if (strncmp(cmd, "read", 4) == 0) {
+		int read;
+
+		if (argc < 4)
+			goto usage;
+
+		addr = (ulong)simple_strtoul(argv[2], NULL, 16);
+		off = (ulong)simple_strtoul(argv[3], NULL, 16);
+		size = (ulong)simple_strtoul(argv[4], NULL, 16);
+
+		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
+		printf("\nMSC read");
+		ret = msc_read(off, (u_char *)addr, size);
+		printf(" %d bytes %s: %s\n", size, ret ? "ERROR" : "OK");
+		return ret == 0 ? 0 : 1;
+	}
+
+usage:
+	printf("Usage:\n%s\n", cmdtp->usage);
+	return 1;
+}
+
+U_BOOT_CMD(msc, 5, 1, do_msc,
+	"msc	- MMC/SD sub-system\n",
+	"msc read	- addr off|partition size\n");
diff -urN /develop/source/01boot/u-boot-1.1.6/common/cmd_nand.c u-boot-1.1.6/common/cmd_nand.c
--- /develop/source/01boot/u-boot-1.1.6/common/cmd_nand.c	2007-10-31 00:43:21.000000000 +0800
+++ u-boot-1.1.6/common/cmd_nand.c	2008-03-19 17:56:49.000000000 +0800
@@ -21,6 +21,8 @@
 
 #if (CONFIG_COMMANDS & CFG_CMD_NAND)
 
+#define CFG_NAND_WRITE_YAFFS
+
 #include <command.h>
 #include <watchdog.h>
 #include <malloc.h>
@@ -163,15 +165,144 @@
 	return 0;
 }
 
+#ifdef CFG_NAND_WRITE_YAFFS
+
+/*
+ * Write a yaffs filesystem image to NAND.
+ *
+ * If yaffs flag is 1, then the image is assumed to have been
+ * generated by yaffs2/utils/mkyaffsimage.c, and only
+ * 512B block + 16B OOB NAND is supported using the YAFFS1 OOB layout.
+ *
+ * Otherwise, the image is assumed to have been generated by
+ * yaffs2/utils/mkyaffs2image.c with Sergey Kubushyn's patch applied
+ * (see http://aleph1.co.uk/lurker/message/20060211.004601.77b55bf3.en.html)
+ * and supports larger 2KB block + 64B OOB NAND.
+ *
+ * Only MTD generated ECC is supported.
+ *
+ * Loosely based on mtd/util/nandwrite.c.
+ */
+
+static struct nand_oobinfo yaffs1_oobinfo = {
+        .useecc = MTD_NANDECC_PLACE,
+        .eccbytes = 6,
+        .eccpos = { 8, 9, 10, 13, 14, 15 }
+};
+
+static struct nand_oobinfo yaffs2_oobinfo = {
+        .useecc = MTD_NANDECC_AUTOPLACE,
+        .eccbytes = 24,
+        .eccpos = {
+                40, 41, 42, 43, 44, 45, 46, 47,
+                48, 49, 50, 51, 52, 53, 54, 55,
+                56, 57, 58, 59, 60, 61, 62, 63},
+        .oobfree = { {2, 38} }
+};
+
+static int nand_write_yaffs(nand_info_t *nand, ulong off, ulong *size, u_char *image, int yaffs)
+{
+        int imglen, pagelen;
+        u_char *imgptr, *oobptr;
+        int ret;
+        size_t retlen;
+        int i;
+        struct nand_oobinfo old_oobinfo;
+
+        imglen = *size;
+        imgptr = image;
+        *size = 0;
+
+        /* Make sure device page sizes are valid */
+        if ((yaffs == 1 && !(nand->oobsize == 16 && nand->oobblock == 512)) ||
+            (yaffs == 2 && !(nand->oobsize == 64 && nand->oobblock == 2048))) {
+                printf("Unsupported flash layout\n");
+                return 1;
+        }
+
+        /* update oobinfo for yaffs */
+        old_oobinfo = nand->oobinfo;
+        nand->oobinfo = yaffs == 1 ? yaffs1_oobinfo : yaffs2_oobinfo;
+
+        /* Check, if image is pagealigned */
+        pagelen = nand->oobblock + nand->oobsize;
+        if ((off % nand->erasesize) != 0 || (imglen % pagelen) != 0) {
+                printf ("Input image is not page aligned\n");
+                goto closeall;
+        }
+
+        /* Check, if length fits into device */
+        if ( ((imglen / pagelen) * nand->oobblock) > (nand->size - off)) {
+                printf ("Input image does not fit into device");
+                goto closeall;
+        }
+
+        /* Get data from input and write to the device */
+        while (imglen > 0 && (off < nand->size)) {
+
+                /* if start of eraseblock, check for bad block */
+                if (off % nand->erasesize == 0 && (nand->block_isbad)(nand, off)) {
+                        printf ("Bad block at 0x%08lx, will be skipped\n", off);
+
+                        off += nand->erasesize;
+                        continue;
+                }
+
+                oobptr = imgptr + nand->oobblock;
+
+                /* set the ECC bytes to 0xff so MTD will calculate it */
+                for (i = 0; i < nand->oobinfo.eccbytes; i++)
+                        oobptr[nand->oobinfo.eccpos[i]] = 0xff;
+
+                /* Write OOB data first, as ecc will be placed in there */
+                ret = (nand->write_oob)(nand, off, nand->oobsize, &retlen, oobptr);
+                if (ret != 0) {
+                        printf("\nNAND OOB write error %d at block 0x%08lx\n", ret, off);
+                        goto closeall;
+                }
+
+                /* Write out the Page data */
+                ret = (nand->write)(nand, off, nand->oobblock, &retlen, imgptr);
+                if (ret != 0) {
+                        printf("\nNAND write error %d at block 0x%08lx\n", ret, off);
+                        goto closeall;
+                }
+
+                imgptr += pagelen;
+                imglen -= pagelen;
+                off += nand->oobblock;
+        }
+
+ closeall:
+        nand->oobinfo = old_oobinfo;
+
+        *size = imgptr - image;
+
+        if (imglen > 0) {
+                printf("Data did not fit into device, due to bad blocks\n");
+                return 1;
+        }
+
+        return 0;
+}
+
+#endif /* CFG_NAND_WRITE_YAFFS */
+
+
 int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
-	int i, dev, ret;
+	int i, dev, ret=0;
 	ulong addr, off, size;
 	char *cmd, *s;
 	nand_info_t *nand;
-	int quiet = 0;
+//	int quiet = 0;
+	int quiet = 1;
 	const char *quiet_str = getenv("quiet");
 
+#ifdef CFG_NAND_WRITE_YAFFS
+        int yaffs = 0;          /* 1 = 512+64 NAND, 2 = 2048+64 NAND */
+#endif
+
 	/* at least two arguments please */
 	if (argc < 2)
 		goto usage;
@@ -327,8 +458,19 @@
 			return 1;
 
 		s = strchr(cmd, '.');
-		if (s != NULL &&
-		    (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i"))) {
+
+#ifdef CFG_NAND_WRITE_YAFFS
+                if (s != NULL && strncmp(s, ".yaffs", 6) == 0) {
+                        if (s[6] == '1')
+                                yaffs = 1;
+                        else if (s[6] == '2' || s[6] == '\0')
+                                yaffs = 2;
+                }
+#endif
+
+//		if (s != NULL &&
+		if (s == NULL ||
+		    (!strcmp(s, ".jffs2") || !strcmp(s, ".yaffs1")|| !strcmp(s, ".yaffs2")|| !strcmp(s, ".e") || !strcmp(s, ".i"))) {
 			if (read) {
 				/* read */
 				nand_read_options_t opts;
@@ -349,7 +491,15 @@
 				opts.pad	= 1;
 				opts.blockalign = 1;
 				opts.quiet      = quiet;
+#ifdef CFG_NAND_WRITE_YAFFS
+		                if(yaffs)
+	                        ret = nand_write_yaffs(nand, off, &size, (u_char *)addr, yaffs);
+				else
 				ret = nand_write_opts(nand, &opts);
+#endif
+#ifndef CFG_NAND_WRITE_YAFFS
+                                ret = nand_write_opts(nand, &opts);
+#endif
 			}
 		} else {
 			if (read)
@@ -462,6 +612,10 @@
 	"nand read[.jffs2]     - addr off|partition size\n"
 	"nand write[.jffs2]    - addr off|partiton size - read/write `size' bytes starting\n"
 	"    at offset `off' to/from memory address `addr'\n"
+#ifdef CFG_NAND_WRITE_YAFFS
+        "nand write[.yaffs[1]] addr off size - read/write `size' bytes starting\n"
+        "    at offset `off' to memory address `addr' [yaffs1 or yaffs2 format]\n"
+#endif
 	"nand erase [clean] [off size] - erase `size' bytes from\n"
 	"    offset `off' (entire device if not specified)\n"
 	"nand bad - show bad blocks\n"
diff -urN /develop/source/01boot/u-boot-1.1.6/common/cmd_nvedit.c u-boot-1.1.6/common/cmd_nvedit.c
--- /develop/source/01boot/u-boot-1.1.6/common/cmd_nvedit.c	2007-10-31 00:43:21.000000000 +0800
+++ u-boot-1.1.6/common/cmd_nvedit.c	2008-10-30 23:45:13.000000000 +0800
@@ -57,6 +57,7 @@
     !defined(CFG_ENV_IS_IN_FLASH)	&& \
     !defined(CFG_ENV_IS_IN_DATAFLASH)	&& \
     !defined(CFG_ENV_IS_IN_NAND)	&& \
+    !defined(CFG_ENV_IS_IN_MSC)		&& \
     !defined(CFG_ENV_IS_NOWHERE)
 # error Define one of CFG_ENV_IS_IN_{NVRAM|EEPROM|FLASH|DATAFLASH|NOWHERE}
 #endif
diff -urN /develop/source/01boot/u-boot-1.1.6/common/env_common.c u-boot-1.1.6/common/env_common.c
--- /develop/source/01boot/u-boot-1.1.6/common/env_common.c	2007-10-31 00:43:21.000000000 +0800
+++ u-boot-1.1.6/common/env_common.c	2008-10-31 17:51:35.000000000 +0800
@@ -145,6 +145,10 @@
 int default_environment_size = sizeof(default_environment);
 #endif
 
+#if defined(CFG_ENV_IS_IN_MSC)		/* Environment is in MMC/SD card */
+int default_environment_size = sizeof(default_environment);
+#endif
+
 void env_crc_update (void)
 {
 	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
diff -urN /develop/source/01boot/u-boot-1.1.6/common/env_msc.c u-boot-1.1.6/common/env_msc.c
--- /develop/source/01boot/u-boot-1.1.6/common/env_msc.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/common/env_msc.c	2008-12-17 19:06:13.000000000 +0800
@@ -0,0 +1,181 @@
+/*
+ * (C) Copyright 2004
+ * Jian Zhang, Texas Instruments, jzhang@ti.com.
+
+ * (C) Copyright 2000-2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Andreas Heppel <aheppel@sysgo.de>
+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* #define DEBUG */
+
+#include <common.h>
+
+#if defined(CFG_ENV_IS_IN_MSC) /* Environment is in Nand Flash */
+
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+#include <malloc.h>
+
+#if ((CONFIG_COMMANDS&(CFG_CMD_ENV|CFG_CMD_MSC)) == (CFG_CMD_ENV|CFG_CMD_MSC))
+#define CMD_SAVEENV
+#elif defined(CFG_ENV_OFFSET_REDUND)
+#error Cannot use CFG_ENV_OFFSET_REDUND without CFG_CMD_ENV & CFG_CMD_NAND
+#endif
+
+#if defined(CFG_ENV_SIZE_REDUND) && (CFG_ENV_SIZE_REDUND != CFG_ENV_SIZE)
+#error CFG_ENV_SIZE_REDUND should be the same as CFG_ENV_SIZE
+#endif
+
+#ifdef CONFIG_INFERNO
+#error CONFIG_INFERNO not supported yet
+#endif
+
+/* references to names in env_common.c */
+extern uchar default_environment[];
+extern int default_environment_size;
+
+char * env_name_spec = "MSC";
+
+#undef ENV_IS_EMBEDDED
+#ifdef ENV_IS_EMBEDDED
+extern uchar environment[];
+env_t *env_ptr = (env_t *)(&environment[0]);
+#else /* ! ENV_IS_EMBEDDED */
+env_t *env_ptr = 0;
+#endif /* ENV_IS_EMBEDDED */
+
+extern int msc_read(ulong start_byte, u8 *dst, size_t len);
+extern int msc_write(ulong start_byte, u8 *dst, size_t len);
+
+/* local functions */
+#if !defined(ENV_IS_EMBEDDED)
+static void use_default(void);
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+uchar env_get_char_spec (int index)
+{
+	return ( *((uchar *)(gd->env_addr + index)) );
+}
+
+/* this is called before u-boot starts
+ * so we can't read MMC/SD to validate env data.
+ * Mark it OK for now. env_relocate() in env_common.c
+ * will call our relocate function which will does
+ * the real validation.
+ *
+ * When using a MMC/SD boot image , the environment
+ * can be embedded or attached to the U-Boot image in MMC/SD card. This way
+ * the SPL loads not only the U-Boot image from MMC/SD card but also the
+ * environment.
+ */
+int env_init(void)
+{
+#if defined(ENV_IS_EMBEDDED)
+	ulong total;
+	int crc1_ok = 0;
+	env_t *tmp_env1;
+
+	total = CFG_ENV_SIZE;
+
+	tmp_env1 = env_ptr;
+	crc1_ok = (crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc);
+
+	if (!crc1_ok)
+		gd->env_valid = 0;
+	else 
+		gd->env_valid = 1;
+
+	if (gd->env_valid == 1)
+		env_ptr = tmp_env1;
+#else /* ENV_IS_EMBEDDED */
+	gd->env_addr  = (ulong)&default_environment[0];
+	gd->env_valid = 1;
+#endif /* ENV_IS_EMBEDDED */
+	return (0);
+}
+
+#ifdef CMD_SAVEENV
+/*
+ * The legacy NAND code saved the environment in the first NAND device i.e.,
+ * nand_dev_desc + 0. This is also the behaviour using the new NAND code.
+ */
+int saveenv(void)
+{
+	ulong total;
+	int ret = 0;
+
+	total = CFG_ENV_SIZE;
+
+	ret = msc_write(CFG_ENV_OFFSET, (u_char*)env_ptr, total);
+	return ret;
+}
+#endif /* CMD_SAVEENV */
+
+void env_relocate_spec (void)
+{
+#if !defined(ENV_IS_EMBEDDED)
+	ulong total;
+	int crc1_ok = 0;
+	env_t *tmp_env1;
+
+	total = CFG_ENV_SIZE;
+	tmp_env1 = (env_t *) malloc(CFG_ENV_SIZE);
+	msc_read(CFG_ENV_OFFSET, (u_char*) tmp_env1, total);
+
+	crc1_ok = (crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc);
+
+	if(!crc1_ok)
+		return use_default();
+
+	else if(crc1_ok)
+		gd->env_valid = 1;
+
+	if(gd->env_valid == 1) {
+		env_ptr = tmp_env1;
+	}
+#endif /* ! ENV_IS_EMBEDDED */
+}
+
+#if !defined(ENV_IS_EMBEDDED)
+static void use_default()
+{
+	puts ("*** Warning - MMC/SD first load, using default environment\n\n");
+
+	if (default_environment_size > CFG_ENV_SIZE){
+		puts ("*** Error - default environment is too large\n\n");
+		return;
+	}
+
+	memset (env_ptr, 0, sizeof(env_t));
+	memcpy (env_ptr->data,
+			default_environment,
+			default_environment_size);
+	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
+	gd->env_valid = 1;
+}
+#endif
+#endif /* CFG_ENV_IS_IN_MSC */
diff -urN /develop/source/01boot/u-boot-1.1.6/common/env_nand.c u-boot-1.1.6/common/env_nand.c
--- /develop/source/01boot/u-boot-1.1.6/common/env_nand.c	2007-10-31 00:43:21.000000000 +0800
+++ u-boot-1.1.6/common/env_nand.c	2007-05-28 15:02:18.000000000 +0800
@@ -66,7 +66,7 @@
 
 char * env_name_spec = "NAND";
 
-
+#undef ENV_IS_EMBEDDED
 #ifdef ENV_IS_EMBEDDED
 extern uchar environment[];
 env_t *env_ptr = (env_t *)(&environment[0]);
@@ -248,8 +248,9 @@
 			gd->env_valid = 1;
 
 	}
-
+#if 0
 	free(env_ptr);
+#endif
 	if(gd->env_valid == 1) {
 		env_ptr = tmp_env1;
 		free(tmp_env2);
diff -urN /develop/source/01boot/u-boot-1.1.6/common/lcd.c u-boot-1.1.6/common/lcd.c
--- /develop/source/01boot/u-boot-1.1.6/common/lcd.c	2007-10-31 00:43:22.000000000 +0800
+++ u-boot-1.1.6/common/lcd.c	2007-10-31 17:20:00.000000000 +0800
@@ -26,8 +26,7 @@
 /************************************************************************/
 /* ** HEADER FILES							*/
 /************************************************************************/
-
-/* #define DEBUG */
+/*#define DEBUG */
 
 #include <config.h>
 #include <common.h>
@@ -63,7 +62,7 @@
 #ifdef CONFIG_LCD_LOGO
 # include <bmp_logo.h>		/* Get logo data, width and height	*/
 # if (CONSOLE_COLOR_WHITE >= BMP_LOGO_OFFSET)
-#  error Default Color Map overlaps with Logo Color Map
+//#  error Default Color Map overlaps with Logo Color Map
 # endif
 #endif
 
@@ -82,6 +81,9 @@
 extern void lcd_enable (void);
 static void *lcd_logo (void);
 
+#ifdef CONFIG_JzRISC		  /* JzRISC core */ 
+extern int flush_cache_all(void);
+#endif
 
 #if LCD_BPP == LCD_COLOR8
 extern void lcd_setcolreg (ushort regno,
@@ -170,14 +172,18 @@
 }
 
 /*----------------------------------------------------------------------*/
-
+#ifndef CFG_LCD_LOGOONLY_NOINFO
 void lcd_putc (const char c)
 {
+	serial_putc(c); 
+
 	if (!lcd_is_enabled) {
-		serial_putc(c);
 		return;
 	}
 
+	if ( BMP_LOGO_HEIGHT > (panel_info.vl_row - 2*VIDEO_FONT_HEIGHT)) 
+		return ;
+
 	switch (c) {
 	case '\r':	console_col = 0;
 			return;
@@ -207,7 +213,12 @@
 	}
 	/* NOTREACHED */
 }
-
+#else         /* CFG_LCD_LOGOONLY_NOINFO, no info printed */
+void lcd_putc (const char c)
+{
+ 	serial_putc(c);
+}
+#endif /* CFG_LCD_LOGOONLY_NOINFO */
 /*----------------------------------------------------------------------*/
 
 void lcd_puts (const char *s)
@@ -228,6 +239,7 @@
 
 static void lcd_drawchars (ushort x, ushort y, uchar *str, int count)
 {
+
 	uchar *dest;
 	ushort off, row;
 
@@ -258,13 +270,23 @@
 #elif LCD_BPP == LCD_COLOR8
 			for (c=0; c<8; ++c) {
 				*d++ = (bits & 0x80) ?
-						lcd_color_fg : lcd_color_bg;
+					lcd_color_fg : lcd_color_bg;
 				bits <<= 1;
 			}
 #elif LCD_BPP == LCD_COLOR16
-			for (c=0; c<16; ++c) {
-				*d++ = (bits & 0x80) ?
-						lcd_color_fg : lcd_color_bg;
+			ushort *m = (ushort *)d;
+			for (c=0; c< 8; ++c) {
+				*m++ = (bits & 0x80) ?
+					lcd_color_fg : lcd_color_bg;
+				d+=2;
+				bits <<= 1;
+			}
+#elif LCD_BPP == LCD_COLOR18
+			uint *m = (uint *)d;
+			for (c=0; c< 8 ; ++c) {
+				*m++ = (bits & 0x80) ?
+					lcd_color_fg : lcd_color_bg;
+			 	d+=4;
 				bits <<= 1;
 			}
 #endif
@@ -273,6 +295,10 @@
 		*d  = rest | (*d & ((1 << (8-off)) - 1));
 #endif
 	}
+
+#ifdef CONFIG_JzRISC		  /* JzRISC core */ 
+	flush_cache_all();
+#endif
 }
 
 /*----------------------------------------------------------------------*/
@@ -395,10 +421,24 @@
 	test_pattern();
 #else
 	/* set framebuffer to background color */
+#if LCD_BPP == LCD_COLOR16
+	long long i;
+	short *lcdbase_p = (short *)lcd_base;
+	for(i=0;i<lcd_line_length*panel_info.vl_row/2;i++)
+		*lcdbase_p++ = COLOR_MASK(lcd_getbgcolor());
+
+#elif LCD_BPP == LCD_COLOR18
+	long long i;
+	int *lcdbase_p = (int *)lcd_base;
+	for(i=0;i<lcd_line_length*panel_info.vl_row/4;i++)
+		*lcdbase_p++ = COLOR_MASK(lcd_getbgcolor());
+#else
 	memset ((char *)lcd_base,
 		COLOR_MASK(lcd_getbgcolor()),
 		lcd_line_length*panel_info.vl_row);
 #endif
+#endif
+
 	/* Paint the logo and retrieve LCD base address */
 	debug ("[LCD] Drawing the logo...\n");
 	lcd_console_address = lcd_logo ();
@@ -474,14 +514,28 @@
 
 static void lcd_setfgcolor (int color)
 {
-	lcd_color_fg = color & 0x0F;
+#if LCD_BPP == LCD_COLOR16
+	lcd_color_fg = color & 0xFFFF;
+
+#elif LCD_BPP == LCD_COLOR18
+	lcd_color_fg = color & 0xFFFFFFFF;
+#else
+	lcd_color_fg = color & 0xF;
+#endif
 }
 
 /*----------------------------------------------------------------------*/
 
 static void lcd_setbgcolor (int color)
 {
-	lcd_color_bg = color & 0x0F;
+#if LCD_BPP == LCD_COLOR16
+	lcd_color_bg = color & 0xFFFF;
+
+#elif LCD_BPP == LCD_COLOR18
+	lcd_color_bg = color & 0xFFFFFFFF;
+#else
+	lcd_color_bg = color & 0xF;
+#endif
 }
 
 /*----------------------------------------------------------------------*/
@@ -490,6 +544,7 @@
 static int lcd_getfgcolor (void)
 {
 	return lcd_color_fg;
+
 }
 #endif	/* NOT_USED_SO_FAR */
 
@@ -513,13 +568,13 @@
 	uchar *bmap;
 	uchar *fb;
 	ushort *fb16;
+	uint *fb32;
 #if defined(CONFIG_PXA250)
 	struct pxafb_info *fbi = &panel_info.pxa;
 #elif defined(CONFIG_MPC823)
 	volatile immap_t *immr = (immap_t *) CFG_IMMR;
 	volatile cpm8xx_t *cp = &(immr->im_cpm);
 #endif
-
 	debug ("Logo: width %d  height %d  colors %d  cmap %d\n",
 		BMP_LOGO_WIDTH, BMP_LOGO_HEIGHT, BMP_LOGO_COLORS,
 		sizeof(bmp_logo_palette)/(sizeof(ushort)));
@@ -538,6 +593,7 @@
 		WATCHDOG_RESET();
 
 		/* Set color map */
+
 		for (i=0; i<(sizeof(bmp_logo_palette)/(sizeof(ushort))); ++i) {
 			ushort colreg = bmp_logo_palette[i];
 #ifdef  CFG_INVERT_COLORS
@@ -555,14 +611,27 @@
 			fb   += panel_info.vl_col;
 		}
 	}
-	else { /* true color mode */
-		fb16 = (ushort *)(lcd_base + y * lcd_line_length + x);
-		for (i=0; i<BMP_LOGO_HEIGHT; ++i) {
-			for (j=0; j<BMP_LOGO_WIDTH; j++) {
-				fb16[j] = bmp_logo_palette[(bmap[j])];
+	else{   /* true color mode */
+		if(NBITS(panel_info.vl_bpix) == 16){
+			fb16 = (ushort *)(lcd_base + y * lcd_line_length + x);
+			for (i=0; i<BMP_LOGO_HEIGHT; ++i) {
+				for (j=0; j<BMP_LOGO_WIDTH; j++) {
+					fb16[j] = bmp_logo_palette[(bmap[j])];
 				}
-			bmap += BMP_LOGO_WIDTH;
-			fb16 += panel_info.vl_col;
+				bmap += BMP_LOGO_WIDTH;
+				fb16 += panel_info.vl_col;
+			}
+		}
+		else{
+			fb32 = (uint *)(lcd_base + y * lcd_line_length + x);
+			for (i=0; i<BMP_LOGO_HEIGHT; ++i) {
+				for (j=0; j<BMP_LOGO_WIDTH; j++) {
+					fb32[j] = bmp_logo_palette[(bmap[j])];
+				}
+				bmap += BMP_LOGO_WIDTH;
+				fb32 += panel_info.vl_col;	
+			}
+		
 		}
 	}
 
@@ -727,6 +796,7 @@
 
 #ifdef CONFIG_LCD_LOGO
 	bitmap_plot (0, 0);
+	flush_cache_all();
 #endif /* CONFIG_LCD_LOGO */
 
 #ifdef CONFIG_MPC823
diff -urN /develop/source/01boot/u-boot-1.1.6/common/Makefile u-boot-1.1.6/common/Makefile
--- /develop/source/01boot/u-boot-1.1.6/common/Makefile	2007-10-31 00:43:20.000000000 +0800
+++ u-boot-1.1.6/common/Makefile	2008-10-31 02:02:41.000000000 +0800
@@ -36,7 +36,7 @@
 	  cmd_fat.o cmd_fdc.o cmd_fdos.o cmd_flash.o cmd_fpga.o \
 	  cmd_i2c.o cmd_ide.o cmd_immap.o cmd_itest.o cmd_jffs2.o \
 	  cmd_load.o cmd_log.o \
-	  cmd_mem.o cmd_mii.o cmd_misc.o cmd_mmc.o \
+	  cmd_mem.o cmd_mii.o cmd_misc.o cmd_mmc.o cmd_msc.o \
 	  cmd_nand.o cmd_net.o cmd_nvedit.o \
 	  cmd_pci.o cmd_pcmcia.o cmd_portio.o \
 	  cmd_reginfo.o cmd_reiser.o cmd_scsi.o cmd_spi.o cmd_universe.o \
@@ -44,7 +44,7 @@
 	  command.o console.o devices.o dlmalloc.o docecc.o \
 	  environment.o env_common.o \
 	  env_nand.o env_dataflash.o env_flash.o env_eeprom.o \
-	  env_nvram.o env_nowhere.o \
+	  env_nvram.o env_nowhere.o env_msc.o \
 	  exports.o \
 	  flash.o fpga.o ft_build.o \
 	  hush.o kgdb.o lcd.o lists.o lynxkdi.o \
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/cache.S u-boot-1.1.6/cpu/mips/cache.S
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/cache.S	2007-10-31 00:43:57.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/cache.S	2007-03-01 16:25:04.000000000 +0800
@@ -30,6 +30,7 @@
 #include <asm/addrspace.h>
 #include <asm/cacheops.h>
 
+#ifndef CONFIG_JzRISC
 
 	/* 16KB is the maximum size of instruction and data caches on
 	 * MIPS 4K.
@@ -267,3 +268,5 @@
 
 	j	ra
 	.end	mips_cache_lock
+
+#endif /* CONFIG_JzRISC */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/config.mk u-boot-1.1.6/cpu/mips/config.mk
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/config.mk	2007-10-31 00:43:57.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/config.mk	2007-03-01 16:25:04.000000000 +0800
@@ -20,20 +20,10 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 # MA 02111-1307 USA
 #
-v=$(shell \
-$(CROSS_COMPILE)as --version|grep "GNU assembler"|awk '{print $$3}'|awk -F . '{print $$2}')
-MIPSFLAGS=$(shell \
-if [ "$v" -lt "14" ]; then \
-	echo "-mcpu=4kc"; \
-else \
-	echo "-march=4kc -mtune=4kc"; \
-fi)
 
-ifneq (,$(findstring 4KCle,$(CROSS_COMPILE)))
-ENDIANNESS = -EL
-else
-ENDIANNESS = -EB
-endif
+MIPSFLAGS = -mtune=r4600 -mips32 -O2
+
+#ENDIANNESS = -EL
 
 MIPSFLAGS += $(ENDIANNESS) -mabicalls
 
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/cpu.c u-boot-1.1.6/cpu/mips/cpu.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/cpu.c	2007-10-31 00:43:57.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/cpu.c	2008-10-30 19:08:32.000000000 +0800
@@ -25,12 +25,46 @@
 #include <command.h>
 #include <asm/inca-ip.h>
 #include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+
+#ifdef CONFIG_JZ4730
+#include <asm/jz4730.h>
+#endif
+
+#ifdef CONFIG_JZ4740
+#include <asm/jz4740.h>
+#endif
+
+#ifdef CONFIG_JZ5730
+#include <asm/jz5730.h>
+#endif
+
+#ifdef CONFIG_JZ4750
+#include <asm/jz4750.h>
+#endif
+
+#if !defined (CONFIG_NAND_SPL) && !defined (CONFIG_MSC_SPL) 
 
 int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
+#ifdef CONFIG_JZ4730
+	__wdt_set_count(0xffffffff-32);
+	__wdt_start();
+	while(1);
+#endif
+#ifdef CONFIG_JZ4740
+	__wdt_select_extalclk();
+	__wdt_select_clk_div64();
+	__wdt_set_data(100);
+	__wdt_set_count(0);
+	__tcu_start_wdt_clock();
+	__wdt_start();
+	while(1);
+#endif
 #if defined(CONFIG_INCA_IP)
 	*INCA_IP_WDT_RST_REQ = 0x3f;
-#elif defined(CONFIG_PURPLE) || defined(CONFIG_TB0229)
+#elif defined(CONFIG_PURPLE) || defined(CONFIG_TB0229) || defined(CONFIG_JzRISC)
 	void (*f)(void) = (void *) 0xbfc00000;
 
 	f();
@@ -39,9 +73,43 @@
 	return 0;
 }
 
+#define cache16_unroll32(base,op)				\
+	__asm__ __volatile__("					\
+		.set noreorder;					\
+		.set mips3;					\
+		cache %1, 0x000(%0); cache %1, 0x010(%0);	\
+		cache %1, 0x020(%0); cache %1, 0x030(%0);	\
+		cache %1, 0x040(%0); cache %1, 0x050(%0);	\
+		cache %1, 0x060(%0); cache %1, 0x070(%0);	\
+		cache %1, 0x080(%0); cache %1, 0x090(%0);	\
+		cache %1, 0x0a0(%0); cache %1, 0x0b0(%0);	\
+		cache %1, 0x0c0(%0); cache %1, 0x0d0(%0);	\
+		cache %1, 0x0e0(%0); cache %1, 0x0f0(%0);	\
+		cache %1, 0x100(%0); cache %1, 0x110(%0);	\
+		cache %1, 0x120(%0); cache %1, 0x130(%0);	\
+		cache %1, 0x140(%0); cache %1, 0x150(%0);	\
+		cache %1, 0x160(%0); cache %1, 0x170(%0);	\
+		cache %1, 0x180(%0); cache %1, 0x190(%0);	\
+		cache %1, 0x1a0(%0); cache %1, 0x1b0(%0);	\
+		cache %1, 0x1c0(%0); cache %1, 0x1d0(%0);	\
+		cache %1, 0x1e0(%0); cache %1, 0x1f0(%0);	\
+		.set mips0;					\
+		.set reorder"					\
+		:						\
+		: "r" (base),					\
+		  "i" (op));
+
 void flush_cache (ulong start_addr, ulong size)
 {
+#ifdef CONFIG_JzRISC
+	unsigned long start = start_addr;
+	unsigned long end = start + size;
 
+	while (start < end) {
+		cache16_unroll32(start,Hit_Writeback_Inv_D);
+		start += 0x200;
+	}
+#endif
 }
 
 void write_one_tlb( int index, u32 pagemask, u32 hi, u32 low0, u32 low1 ){
@@ -52,3 +120,61 @@
 	write_32bit_cp0_register(CP0_INDEX, index);
 	tlb_write_indexed();
 }
+
+#endif /* !CONFIG_NAND_SPL */
+
+#ifdef CONFIG_JzRISC
+
+void flush_icache_all(void)
+{
+	u32 addr, t = 0;
+
+	asm volatile ("mtc0 $0, $28"); /* Clear Taglo */
+	asm volatile ("mtc0 $0, $29"); /* Clear TagHi */
+
+	for (addr = K0BASE; addr < K0BASE + CFG_ICACHE_SIZE;
+	     addr += CFG_CACHELINE_SIZE) {
+		asm volatile (
+			".set mips3\n\t"
+			" cache %0, 0(%1)\n\t"
+			".set mips2\n\t"
+			:
+			: "I" (Index_Store_Tag_I), "r"(addr));
+	}
+
+	/* invalicate btb */
+	asm volatile (
+		".set mips32\n\t"
+		"mfc0 %0, $16, 7\n\t"
+		"nop\n\t"
+		"ori %0,2\n\t"
+		"mtc0 %0, $16, 7\n\t"
+		".set mips2\n\t"
+		:
+		: "r" (t));
+}
+
+void flush_dcache_all(void)
+{
+	u32 addr;
+
+	for (addr = K0BASE; addr < K0BASE + CFG_DCACHE_SIZE; 
+	     addr += CFG_CACHELINE_SIZE) {
+		asm volatile (
+			".set mips3\n\t"
+			" cache %0, 0(%1)\n\t"
+			".set mips2\n\t"
+			:
+			: "I" (Index_Writeback_Inv_D), "r"(addr));
+	}
+
+	asm volatile ("sync");
+}
+
+void flush_cache_all(void)
+{
+	flush_dcache_all();
+	flush_icache_all();
+}
+
+#endif
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4730.c u-boot-1.1.6/cpu/mips/jz4730.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4730.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4730.c	2007-09-17 15:58:02.000000000 +0800
@@ -0,0 +1,397 @@
+/*
+ * Jz4730 common routines
+ *
+ *  Copyright (c) 2005
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_JZ4730
+
+#include <common.h>
+#include <command.h>
+
+#include <asm/jz4730.h>
+
+extern void board_early_init(void);
+extern void board_led(char ch);
+
+static void calc_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int od[4] = {1, 2, 2, 4};
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int nf, nr, nd;
+
+	nf = __cpm_plcr1_fd() + 2;
+	nr = __cpm_plcr1_rd() + 2;
+	nd = od[__cpm_plcr1_od()];
+
+	pllout = (CFG_EXTAL / (nr * nd)) * nf;
+
+	gd->cpu_clk = pllout / div[__cpm_cfcr_ifr()];
+	gd->sys_clk = pllout / div[__cpm_cfcr_sfr()];
+	gd->per_clk = pllout / div[__cpm_cfcr_pfr()];
+	gd->mem_clk = pllout / div[__cpm_cfcr_mfr()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+static void sdram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	register unsigned int dmcr0, dmcr, sdmode, tmp, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	REG_EMC_BCR = 0;	/* Disable bus release */
+	REG_EMC_RTCSR = 0;	/* Disable clock for counting */
+
+	/* Fault DMCR value for mode register setting*/
+#define SDRAM_ROW0    11
+#define SDRAM_COL0     8
+#define SDRAM_BANK40   0
+
+	dmcr0 = ((SDRAM_ROW0-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL0-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK40<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Basic DMCR value */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timing */
+	ns = 1000000000 / gd->mem_clk;
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4)
+		tmp = 4;
+	if (tmp > 11)
+		tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7)
+		tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14)
+		tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode value */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+	if (SDRAM_BW16)
+		sdmode <<= 1;
+	else
+		sdmode <<= 2;
+
+	/* Stage 1. Precharge all banks by writing SDMR with DMCR.MRSET=0 */
+	REG_EMC_DMCR = dmcr;
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+	/* Wait for precharge, > 200us */
+	tmp = (gd->cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 2. Enable auto-refresh */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH;
+
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff)	tmp = 0xff;
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCNT = 0;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* Wait for number of auto-refresh cycles */
+	tmp = (gd->cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 3. Mode Register Set */
+	REG_EMC_DMCR = dmcr0 | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+        /* Set back to the ture basic DMCR value */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* everything is ok now */
+}
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+static void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 3, 3, 3, 3}; /* divisors of I:S:P:L:M */
+	int nf;
+
+	cfcr = CPM_CFCR_CKOEN1;
+	cfcr |=  ((CFG_CPU_SPEED/48000000 - 1) << 25); /* USB clock divider */
+
+	cfcr |= (n2FR[div[0]] << CPM_CFCR_IFR_BIT) | 
+		(n2FR[div[1]] << CPM_CFCR_SFR_BIT) | 
+		(n2FR[div[2]] << CPM_CFCR_PFR_BIT) |
+		(n2FR[div[3]] << CPM_CFCR_LFR_BIT) |
+		(n2FR[div[4]] << CPM_CFCR_MFR_BIT);
+
+	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+
+	plcr1 = ((nf - 2) << CPM_PLCR1_PLL1FD_BIT) | /* FD=NF-2 */
+		(0 << CPM_PLCR1_PLL1RD_BIT) |	   /* RD=0, NR=2, 1.8432 = 3.6864/2 */
+		(0 << CPM_PLCR1_PLL1OD_BIT) |      /* OD=0, NO=1 */
+		(0x20 << CPM_PLCR1_PLL1ST_BIT) |   /* PLL stable time */
+		CPM_PLCR1_PLL1EN;                  /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CFCR = cfcr;
+	REG_CPM_PLCR1 = plcr1;
+}
+
+//----------------------------------------------------------------------
+// jz4730 board init routine
+
+int jz_board_init(void)
+{
+	/* use external RTC clock (32.768 KHz) */
+
+	board_early_init();  /* init gpio etc. */
+#ifndef CONFIG_NAND_U_BOOT
+	pll_init();          /* init PLL */
+#endif
+	calc_clocks();       /* calc the clocks */
+#ifndef CONFIG_NAND_U_BOOT
+	sdram_init();        /* init sdram memory */
+#endif
+	return 0;
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+long int initdram(int board_type)
+{
+	u32 dmcr;
+	u32 rows, cols, dw, banks;
+	ulong size;
+
+	dmcr = REG_EMC_DMCR;
+	rows = 11 + ((dmcr & EMC_DMCR_RA_MASK) >> EMC_DMCR_RA_BIT);
+	cols = 8 + ((dmcr & EMC_DMCR_CA_MASK) >> EMC_DMCR_CA_BIT);
+	dw = (dmcr & EMC_DMCR_BW) ? 2 : 4;
+	banks = (dmcr & EMC_DMCR_BA) ? 4 : 2;
+
+	size = (1 << (rows + cols)) * dw * banks;
+
+	return size;
+}
+
+//----------------------------------------------------------------------
+// Timer routines
+
+/* we always count down the max. */
+#define TIMER_LOAD_VAL 0xffffffff
+
+#define CHANNEL_ID  0
+/* macro to read the 32 bit timer */
+#define READ_TIMER __ost_get_count(CHANNEL_ID)
+
+static ulong timestamp;
+static ulong lastdec;
+
+void	reset_timer_masked	(void);
+ulong	get_timer_masked	(void);
+void	udelay_masked		(unsigned long usec);
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	__ost_set_clock(CHANNEL_ID, OST_TCSR_CKS_PCLK_256);
+	__ost_set_reload(CHANNEL_ID, TIMER_LOAD_VAL);
+	__ost_set_count(CHANNEL_ID, TIMER_LOAD_VAL);
+	__ost_enable_channel(CHANNEL_ID);
+
+	lastdec = TIMER_LOAD_VAL;
+	timestamp = 0;
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void udelay(unsigned long usec)
+{
+	ulong tmo,tmp;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= CFG_HZ;
+		tmo /= 1000;
+	}
+	else {
+		if (usec >= 1) {
+			tmo = usec * CFG_HZ;
+			tmo /= (1000*1000);
+		}
+		else
+			tmo = 1;
+	}
+
+	/* check for rollover during this delay */
+	tmp = get_timer (0);
+	if ((tmp + tmo) < tmp )
+		reset_timer_masked();  /* timer would roll over */
+	else
+		tmo += tmp;
+
+	while (get_timer_masked () < tmo);
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;
+	timestamp = 0;
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;
+
+	if (lastdec >= now) {
+		/* normal mode */
+		timestamp += (lastdec - now);
+	} else {
+		/* we have an overflow ... */
+		timestamp += ((lastdec + TIMER_LOAD_VAL) - now);
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= CFG_HZ;
+		tmo /= 1000;
+	} else {
+		if (usec > 1) {
+			tmo = usec * CFG_HZ;
+			tmo /= (1000*1000);
+		} else {
+			tmo = 1;
+		}
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	return CFG_HZ;
+}
+
+//---------------------------------------------------------------------
+// End of timer routine.
+//---------------------------------------------------------------------
+
+#endif /* CONFIG_JZ4730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4730_nand.c u-boot-1.1.6/cpu/mips/jz4730_nand.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4730_nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4730_nand.c	2007-08-30 10:51:31.000000000 +0800
@@ -0,0 +1,94 @@
+/*
+ * Platform independend driver for JZ4730.
+ *
+ * Copyright (c) 2007 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && defined(CONFIG_JZ4730)
+
+#include <nand.h>
+
+#include <asm/jz4730.h>
+
+static void jz_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *this = (struct nand_chip *)(mtd->priv);
+	switch (cmd) {
+		case NAND_CTL_SETNCE:
+			REG_EMC_NFCSR |= EMC_NFCSR_FCE;
+			break;
+
+		case NAND_CTL_CLRNCE:
+			REG_EMC_NFCSR &= ~EMC_NFCSR_FCE;
+			break;
+
+		case NAND_CTL_SETCLE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00040000);
+			break;
+
+		case NAND_CTL_CLRCLE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00040000);
+			break;
+
+		case NAND_CTL_SETALE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00080000);
+			break;
+
+		case NAND_CTL_CLRALE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00080000);
+			break;
+	}
+}
+
+static int jz_device_ready(struct mtd_info *mtd)
+{
+	int ready;
+	ready = (REG_EMC_NFCSR & EMC_NFCSR_RB) ? 1 : 0;
+	return ready;
+}
+
+/*
+ * EMC setup
+ */
+static void jz_device_setup(void)
+{
+	/* Set NFE bit */
+	REG_EMC_NFCSR |= EMC_NFCSR_NFE;
+	REG_EMC_SMCR3 = 0x04444400;
+}
+
+void board_nand_select_device(struct nand_chip *nand, int chip)
+{
+	/*
+	 * Don't use "chip" to address the NAND device,
+	 * generate the cs from the address where it is encoded.
+	 */
+}
+
+/*
+ * Main initialization routine
+ */
+void board_nand_init(struct nand_chip *nand)
+{
+	jz_device_setup();
+
+	nand->eccmode = NAND_ECC_NONE;	/* FIXME: should use NAND_ECC_SOFT */
+        nand->hwcontrol = jz_hwcontrol;
+        nand->dev_ready = jz_device_ready;
+
+        /* Set address of NAND IO lines */
+        nand->IO_ADDR_R = (void __iomem *) CFG_NAND_BASE;
+        nand->IO_ADDR_W = (void __iomem *) CFG_NAND_BASE;
+
+        /* 20 us command delay time */
+        nand->chip_delay = 20;
+}
+
+#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740.c u-boot-1.1.6/cpu/mips/jz4740.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4740.c	2008-12-16 01:19:17.000000000 +0800
@@ -0,0 +1,579 @@
+/*
+ * Jz4740 common routines
+ *
+ *  Copyright (c) 2006
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_JZ4740
+
+#include <common.h>
+#include <command.h>
+
+#include <asm/jz4740.h>
+
+extern void board_early_init(void);
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 3, 3, 3, 3}; /* divisors of I:S:P:L:M */
+	int nf, pllout2;
+
+	cfcr = CPM_CPCCR_CLKOEN |
+		CPM_CPCCR_PCS |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? CFG_CPU_SPEED : (CFG_CPU_SPEED / 2);
+
+	/* Init USB Host clock, pllout2 must be n*48MHz */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+
+	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(0 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void pll_add_test(int new_freq)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 4, 4, 4, 4}; /* divisors of I:S:P:M:L */
+	int nf, pllout2;
+
+	cfcr = CPM_CPCCR_CLKOEN |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? new_freq : (new_freq / 2);
+
+	/* Init UHC clock */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+	
+	//nf = new_freq * 2 / CFG_EXTAL;
+	nf = new_freq / 1000000; //step length is 1M
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(10 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void calc_clocks_add_test(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+void sdram_add_test(int new_freq)
+{
+	register unsigned int dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = new_freq;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_DISABLE;
+	REG_EMC_RTCOR = 0;
+	REG_EMC_RTCNT = 0;
+
+	/* Basic DMCR register value. */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg parameters */
+	ns = 1000000000 / mem_clk;
+
+#if 0
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+#else
+	dmcr |= 0xfffc;
+#endif
+
+	/* First, precharge phase */
+	REG_EMC_DMCR = dmcr;
+
+	/* Set refresh registers */
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* SDRAM mode values */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* precharge all chip-selects */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 200;
+	while (tmp--);
+
+	/* enable refresh and set SDRAM mode */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* write sdram mode register for each chip-select */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* everything is ok now */
+}
+
+void sdram_init(void)
+{
+	register unsigned int dmcr0, dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = CFG_CPU_SPEED;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	REG_EMC_BCR = 0;	/* Disable bus release */
+	REG_EMC_RTCSR = 0;	/* Disable clock for counting */
+
+	/* Fault DMCR value for mode register setting*/
+#define SDRAM_ROW0    11
+#define SDRAM_COL0     8
+#define SDRAM_BANK40   0
+
+	dmcr0 = ((SDRAM_ROW0-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL0-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK40<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Basic DMCR value */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg */
+	ns = 1000000000 / mem_clk;
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode value */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Stage 1. Precharge all banks by writing SDMR with DMCR.MRSET=0 */
+	REG_EMC_DMCR = dmcr;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* Wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 2. Enable auto-refresh */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH;
+
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCNT = 0;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* Wait for number of auto-refresh cycles */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+ 	/* Stage 3. Mode Register Set */
+	REG_EMC_DMCR = dmcr0 | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+        /* Set back to basic DMCR value */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* everything is ok now */
+}
+
+#ifndef CONFIG_NAND_SPL
+
+static void calc_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+static void rtc_init(void)
+{
+	unsigned long rtcsta;
+
+	while ( !__rtc_write_ready()) ;
+	__rtc_enable_alarm();	/* enable alarm */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_RGR   = 0x00007fff; /* type value */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HWFCR = 0x0000ffe0; /* Power on delay 2s */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HRCR  = 0x00000fe0; /* reset delay 125ms */
+#if 0
+	while ( !__rtc_write_ready()) 
+		;
+	rtcsta = REG_RTC_HWRSR;
+	while ( !__rtc_write_ready()) 
+		;
+	if (rtcsta & 0x33) {
+		if (rtcsta & 0x10) {
+			while ( !__rtc_write_ready()) 
+				;
+			REG_RTC_RSR = 0x0;
+		}
+		while ( !__rtc_write_ready()) 
+			;
+		REG_RTC_HWRSR = 0x0;
+	}
+#endif
+}
+
+
+//----------------------------------------------------------------------
+// jz4740 board init routine
+
+int jz_board_init(void)
+{
+	board_early_init();  /* init gpio, pll etc. */
+#ifndef CONFIG_NAND_U_BOOT
+#ifndef CONFIG_FPGA
+	pll_init();          /* init PLL */
+#endif
+	sdram_init();        /* init sdram memory */
+#endif
+	calc_clocks();       /* calc the clocks */
+#ifndef CONFIG_FPGA
+	rtc_init();		/* init rtc on any reset: */
+#endif
+	return 0;
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+long int initdram(int board_type)
+{
+	u32 dmcr;
+	u32 rows, cols, dw, banks;
+	ulong size;
+
+	dmcr = REG_EMC_DMCR;
+	rows = 11 + ((dmcr & EMC_DMCR_RA_MASK) >> EMC_DMCR_RA_BIT);
+	cols = 8 + ((dmcr & EMC_DMCR_CA_MASK) >> EMC_DMCR_CA_BIT);
+	dw = (dmcr & EMC_DMCR_BW) ? 2 : 4;
+	banks = (dmcr & EMC_DMCR_BA) ? 4 : 2;
+
+	size = (1 << (rows + cols)) * dw * banks;
+
+	return size;
+}
+
+//----------------------------------------------------------------------
+// Timer routines
+
+#define TIMER_CHAN  0
+#define TIMER_FDATA 0xffff  /* Timer full data value */
+#define TIMER_HZ    CFG_HZ
+
+#define READ_TIMER  REG_TCU_TCNT(TIMER_CHAN)  /* macro to read the 16 bit timer */
+
+static ulong timestamp;
+static ulong lastdec;
+
+void	reset_timer_masked	(void);
+ulong	get_timer_masked	(void);
+void	udelay_masked		(unsigned long usec);
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	REG_TCU_TCSR(TIMER_CHAN) = TCU_TCSR_PRESCALE256 | TCU_TCSR_EXT_EN;
+	REG_TCU_TCNT(TIMER_CHAN) = 0;
+	REG_TCU_TDHR(TIMER_CHAN) = 0;
+	REG_TCU_TDFR(TIMER_CHAN) = TIMER_FDATA;
+
+	REG_TCU_TMSR = (1 << TIMER_CHAN) | (1 << (TIMER_CHAN + 16)); /* mask irqs */
+	REG_TCU_TSCR = (1 << TIMER_CHAN); /* enable timer clock */
+	REG_TCU_TESR = (1 << TIMER_CHAN); /* start counting up */
+
+	lastdec = 0;
+	timestamp = 0;
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void udelay (unsigned long usec)
+{
+	ulong tmo,tmp;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	}
+	else {
+		if (usec >= 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		}
+		else
+			tmo = 1;
+	}
+
+	/* check for rollover during this delay */
+	tmp = get_timer (0);
+	if ((tmp + tmo) < tmp )
+		reset_timer_masked();  /* timer would roll over */
+	else
+		tmo += tmp;
+
+	while (get_timer_masked () < tmo);
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;
+	timestamp = 0;
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;
+
+	if (lastdec <= now) {
+		/* normal mode */
+		timestamp += (now - lastdec);
+	} else {
+		/* we have an overflow ... */
+		timestamp += TIMER_FDATA + now - lastdec;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	} else {
+		if (usec > 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		} else {
+			tmo = 1;
+		}
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	return TIMER_HZ;
+}
+
+#endif /* CONFIG_NAND_SPL */
+
+//---------------------------------------------------------------------
+// End of timer routine.
+//---------------------------------------------------------------------
+
+#endif /* CONFIG_JZ4740 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740_cpm_test.c u-boot-1.1.6/cpu/mips/jz4740_cpm_test.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740_cpm_test.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4740_cpm_test.c	2007-10-31 10:03:54.000000000 +0800
@@ -0,0 +1,98 @@
+#include <config.h>
+
+#ifdef CONFIG_JZ4740
+#include <common.h>
+#include <command.h>
+#include <asm/jz4740.h>
+#include <asm/io.h>               /* virt_to_phys() */
+#define JZ4740_CPM_TEST
+
+
+
+int cpm_value;
+void mdelay(int dly)
+{
+	udelay(dly * 1000);
+}
+
+int myatoi(char *string)
+{
+    int res = 0;
+    while (*string>='0' && *string <='9')
+    {
+	res *= 10;
+	res += *string-'0';
+	string++;
+    }
+
+    return res;
+}
+
+int myhatoi(char *string)
+{
+    int res = 0;
+    
+    if ( *string != '0' || *(string+1) != 'x' ) {
+	    return 0;
+    }
+
+    string += 2;
+
+    while ( *string )
+    {
+	res *= 16;
+	if (*string>='0' && *string <='9')
+		res += *string-'0';
+	else if (*string>='a' && *string <='f')
+		res += *string-'a' + 10;
+	else 
+		return res;
+
+	string++;
+    }
+
+    return res;
+}
+
+int atoi( char * string )
+{
+    if ( *string == '0' && *(string+1) == 'x' ) {
+	    return myhatoi(string);
+    }
+    else 
+	    return myatoi(string);
+}
+
+void cpm_add_test(void)
+{
+	pll_add_test(cpm_value);
+	//sdram_add_test(cpm_value);
+	calc_clocks_add_test();
+}
+
+int do_jz_cpmtest_function(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+
+	if ( !strncmp(argv[1], "add", 3 ) ) {
+		if ( argc == 3 ) {
+			cpm_value = atoi( argv[2] );
+			printf("cpm value:%d\n",cpm_value);
+			if((cpm_value >= 999) || (cpm_value <= 100)) {
+				printf("param is wrong!\n");
+			}
+			cpm_value *= 1000000;
+			cpm_add_test();
+		}
+	} else {
+		printf("command is wrong!\n");
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	cpm,	4,	1,	do_jz_cpmtest_function,
+	"cpm:\t - Usage: cpmtest [add][cpm_value]\n",
+	NULL
+	);
+
+#endif /* CONFIG_JZ4740 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740_nand.c u-boot-1.1.6/cpu/mips/jz4740_nand.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740_nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4740_nand.c	2008-11-25 02:02:05.000000000 +0800
@@ -0,0 +1,215 @@
+/*
+ * Platform independend driver for JZ4730.
+ *
+ * Copyright (c) 2007 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && defined(CONFIG_JZ4740)
+
+#include <nand.h>
+#include <asm/jz4740.h>
+
+static struct nand_oobinfo nand_oob_rs = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 36,
+	.eccpos = {
+		6,  7,  8,  9,  10, 11, 12, 13,
+		14, 15, 16, 17, 18, 19, 20, 21,
+		22, 23, 24, 25, 26, 27, 28, 29,
+		30, 31, 32, 33, 34, 35, 36, 37,
+		38, 39, 40, 41},
+	.oobfree = { {2, 4}, {42, 22} }
+};
+
+#define PAR_SIZE 9
+#define __nand_ecc_enable()    (REG_EMC_NFECR = EMC_NFECR_ECCE | EMC_NFECR_ERST )
+#define __nand_ecc_disable()   (REG_EMC_NFECR &= ~EMC_NFECR_ECCE)
+
+#define __nand_select_rs_ecc() (REG_EMC_NFECR |= EMC_NFECR_RS)
+
+#define __nand_rs_ecc_encoding()	(REG_EMC_NFECR |= EMC_NFECR_RS_ENCODING)
+#define __nand_rs_ecc_decoding()	(REG_EMC_NFECR |= EMC_NFECR_RS_DECODING)
+#define __nand_ecc_encode_sync() while (!(REG_EMC_NFINTS & EMC_NFINTS_ENCF))
+#define __nand_ecc_decode_sync() while (!(REG_EMC_NFINTS & EMC_NFINTS_DECF))
+
+static void jz_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *this = (struct nand_chip *)(mtd->priv);
+	switch (cmd) {
+		case NAND_CTL_SETNCE:
+			REG_EMC_NFCSR |= EMC_NFCSR_NFCE1;
+			break;
+
+		case NAND_CTL_CLRNCE:
+			REG_EMC_NFCSR &= ~EMC_NFCSR_NFCE1;
+			break;
+
+		case NAND_CTL_SETCLE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00008000);
+			break;
+
+		case NAND_CTL_CLRCLE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00008000);
+			break;
+
+		case NAND_CTL_SETALE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00010000);
+			break;
+
+		case NAND_CTL_CLRALE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00010000);
+			break;
+	}
+}
+
+static int jz_device_ready(struct mtd_info *mtd)
+{
+	int ready;
+	udelay(20);	/* FIXME: add 20us delay */
+	ready = (REG_GPIO_PXPIN(2) & 0x40000000) ? 1 : 0;
+	return ready;
+}
+
+/*
+ * EMC setup
+ */
+static void jz_device_setup(void)
+{
+	/* Set NFE bit */
+	REG_EMC_NFCSR |= EMC_NFCSR_NFE1;
+	REG_EMC_SMCR1 = 0x094c4400;
+}
+
+void board_nand_select_device(struct nand_chip *nand, int chip)
+{
+	/*
+	 * Don't use "chip" to address the NAND device,
+	 * generate the cs from the address where it is encoded.
+	 */
+}
+
+static int jzsoc_nand_calculate_rs_ecc(struct mtd_info* mtd, const u_char* dat,
+				u_char* ecc_code)
+{
+	volatile u8 *paraddr = (volatile u8 *)EMC_NFPAR0;
+	short i;
+
+	__nand_ecc_encode_sync() 
+	__nand_ecc_disable();
+	
+	for(i = 0; i < PAR_SIZE; i++) 
+		ecc_code[i] = *paraddr++;			
+	
+	return 0;
+}
+
+static void jzsoc_nand_enable_rs_hwecc(struct mtd_info* mtd, int mode)
+{
+ 	__nand_ecc_enable();
+	__nand_select_rs_ecc();
+
+	REG_EMC_NFINTS = 0x0;
+	if (NAND_ECC_READ == mode){
+		__nand_rs_ecc_decoding();
+	}
+	if (NAND_ECC_WRITE == mode){
+		__nand_rs_ecc_encoding();
+	}
+}	
+
+/* Correct 1~9-bit errors in 512-bytes data */
+static void jzsoc_rs_correct(unsigned char *dat, int idx, int mask)
+{
+	int i;
+
+	idx--;
+
+	i = idx + (idx >> 3);
+	if (i >= 512)
+		return;
+
+	mask <<= (idx & 0x7);
+
+	dat[i] ^= mask & 0xff;
+	if (i < 511)
+		dat[i+1] ^= (mask >> 8) & 0xff;
+}
+
+static int jzsoc_nand_rs_correct_data(struct mtd_info *mtd, u_char *dat,
+				 u_char *read_ecc, u_char *calc_ecc)					
+{
+	volatile u8 *paraddr = (volatile u8 *)EMC_NFPAR0;
+	short k;
+	u32 stat;
+	/* Set PAR values */
+	
+	for (k = 0; k < PAR_SIZE; k++) {
+		*paraddr++ = read_ecc[k];
+	}
+
+	/* Set PRDY */
+	REG_EMC_NFECR |= EMC_NFECR_PRDY;
+
+	/* Wait for completion */
+	__nand_ecc_decode_sync();
+	__nand_ecc_disable();
+
+	/* Check decoding */
+	stat = REG_EMC_NFINTS;
+	if (stat & EMC_NFINTS_ERR) {
+		if (stat & EMC_NFINTS_UNCOR) {
+			printk("Uncorrectable error occurred\n");
+			return -1;
+		}
+		else {
+			u32 errcnt = (stat & EMC_NFINTS_ERRCNT_MASK) >> EMC_NFINTS_ERRCNT_BIT;
+			switch (errcnt) {
+			case 4:
+				jzsoc_rs_correct(dat, (REG_EMC_NFERR3 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT, (REG_EMC_NFERR3 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT);
+			case 3:
+				jzsoc_rs_correct(dat, (REG_EMC_NFERR2 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT, (REG_EMC_NFERR2 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT);
+			case 2:
+				jzsoc_rs_correct(dat, (REG_EMC_NFERR1 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT, (REG_EMC_NFERR1 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT);
+			case 1:
+				jzsoc_rs_correct(dat, (REG_EMC_NFERR0 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT, (REG_EMC_NFERR0 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT);
+				return 0;
+			default:
+				break;
+	   		}
+		}
+	}
+	//no error need to be correct 
+	return 0;
+}
+
+/*
+ * Main initialization routine
+ */
+void board_nand_init(struct nand_chip *nand)
+{
+	jz_device_setup();
+
+	nand->eccmode = NAND_ECC_HW9_512;	/* FIXME: should use NAND_ECC_SOFT */
+        nand->hwcontrol = jz_hwcontrol;
+        nand->dev_ready = jz_device_ready;
+	
+	nand->correct_data  = jzsoc_nand_rs_correct_data;
+	nand->enable_hwecc  = jzsoc_nand_enable_rs_hwecc;
+	nand->calculate_ecc = jzsoc_nand_calculate_rs_ecc;
+
+        /* Set address of NAND IO lines */
+        nand->IO_ADDR_R = (void __iomem *) CFG_NAND_BASE;
+        nand->IO_ADDR_W = (void __iomem *) CFG_NAND_BASE;
+
+        /* 20 us command delay time */
+        nand->chip_delay = 20;
+//	nand->autooob    = &nand_oob_rs; // init in nand_base.c
+}
+#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740_slcd.c u-boot-1.1.6/cpu/mips/jz4740_slcd.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740_slcd.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4740_slcd.c	2009-02-03 21:03:09.000000000 +0800
@@ -0,0 +1,636 @@
+/*
+ * JzRISC Smart lcd controller
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/************************************************************************/
+/* ** HEADER FILES							*/
+/************************************************************************/
+
+/* 
+ * Fallowing macro may be used:
+ *  CONFIG_LCD                        : LCD support 
+ *  LCD_BPP                           : Bits per pixel, 0 = 1, 1 = 2, 2 = 4, 3 = 8,
+ *							4 = 16, 5 = 32
+ *  CFG_WHITE_ON_BLACK
+ *  CONFIG_LCD_LOGO                   : show logo
+ *  CFG_LCD_LOGOONLY_NOINFO           : not display info on lcd screen, only logo
+ * -----------------------------------------------------------------------
+ * bugs:
+ * if BMP_LOGO_HEIGHT > (lcd screen height - 2*VIDEO_FONT_HEIGHT),
+ * must not print info onto screen,
+ * it means should define CFG_LCD_LOGOONLY_NOINFO.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <devices.h>
+#include <lcd.h>
+
+#include <asm/io.h>               /* virt_to_phys() */
+
+#if defined(CONFIG_LCD) && defined(CONFIG_SLCD)
+
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+
+
+#include "jz4740_slcd.h"
+
+
+/************************************************************************/
+
+
+struct jzfb_info {
+	unsigned int cfg;	/* panel mode and pin usage etc. */
+	unsigned int w;
+	unsigned int h;
+	unsigned int bpp;	/* bit per pixel */
+	unsigned int bus;
+	unsigned int fclk;	/* frame clock */
+};
+
+static struct jzfb_info jzfb = {
+#ifdef CONFIG_JZ_SLCD_LGDP4551
+	SLCD_CFG_CS_ACTIVE_LOW | SLCD_CFG_RS_CMD_LOW | SLCD_CFG_TYPE_PARALLEL,
+	400, 240, 16, 8, 60 	/*16 bpp, 8 bus*/
+#endif
+
+#ifdef CONFIG_JZ_SLCD_SPFD5420A
+	SLCD_CFG_CS_ACTIVE_LOW | SLCD_CFG_RS_CMD_LOW | SLCD_CFG_TYPE_PARALLEL,
+	400, 240, 18, 18, 60 	/*18 bpp, 18 bus*/
+#endif
+
+#ifdef CONFIG_JZ_SLCD_SPFD5408A
+	SLCD_CFG_CS_ACTIVE_LOW | SLCD_CFG_RS_CMD_LOW | SLCD_CFG_TYPE_PARALLEL,
+	320, 240, 16, 16, 60 	/*16 bpp, 16 bus*/
+#endif
+};
+
+/************************************************************************/
+
+vidinfo_t panel_info = {
+#ifdef CONFIG_JZ_SLCD_LGDP4551
+	400, 240, LCD_BPP,
+#endif
+
+#ifdef CONFIG_JZ_SLCD_SPFD5420A
+	400, 240, LCD_BPP,
+#endif
+
+#ifdef CONFIG_JZ_SLCD_SPFD5408A
+	320, 240, LCD_BPP,
+#endif
+
+};
+
+
+/*----------------------------------------------------------------------*/
+
+int lcd_line_length;
+
+int lcd_color_fg;
+int lcd_color_bg;
+
+/*
+ * Frame buffer memory information
+ */
+void *lcd_base;			/* Start of framebuffer memory	*/
+void *lcd_console_address;	/* Start of console buffer	*/
+
+short console_col;
+short console_row;
+
+/************************************************************************/
+void lcd_ctrl_init (void *lcdbase);
+void lcd_enable (void);
+void lcd_disable (void);
+void flush_screen(void *lcdbase);
+
+/************************************************************************/
+static void Mcupanel_RegSet(UINT32 cmd, UINT32 data);
+static void Mcupanel_Command(UINT32 cmd);
+static void Mcupanel_Data(UINT32 data);
+
+/************************************************************************/
+static int  jz_lcd_init_mem(void *lcdbase, vidinfo_t *vid);
+static void jz_lcd_desc_init(vidinfo_t *vid);
+static int  jz_lcd_hw_init( vidinfo_t *vid );
+static int slcd_dma_init(vidinfo_t *vid);
+
+extern int flush_cache_all(void);
+
+#if LCD_BPP == LCD_COLOR8
+void lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue);
+#endif
+#if LCD_BPP == LCD_MONOCHROME
+void lcd_initcolregs (void);
+#endif
+
+/************************************************************************/
+
+void lcd_ctrl_init (void *lcdbase)
+{
+	jz_lcd_init_mem(lcdbase, &panel_info);
+	jz_lcd_hw_init(&panel_info);
+	jz_lcd_desc_init(&panel_info);
+	__slcd_display_on();
+	slcd_dma_init(&panel_info);
+//	flush_screen(lcdbase); 	/* If use cpu mode, call this function to flush screen */
+}
+
+/*----------------------------------------------------------------------*/
+#if LCD_BPP == LCD_COLOR8
+void
+lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue)
+{
+}
+#endif
+/*----------------------------------------------------------------------*/
+
+#if LCD_BPP == LCD_MONOCHROME
+static
+void lcd_initcolregs (void)
+{
+}
+#endif
+
+/*----------------------------------------------------------------------*/
+
+/* Sent a command and data */
+static void Mcupanel_RegSet(UINT32 cmd, UINT32 data)
+{
+	switch (jzfb.bus) {
+	case 8:
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | ((cmd&0xff00) >> 8);
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | ((cmd&0xff) >> 0);
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_DATA | (data&0xffff);
+		break;
+	case 9:
+		data = ((data & 0xff) << 1) | ((data & 0xff00) << 2);
+		data = ((data << 6) & 0xfc0000) | ((data << 4) & 0xfc00) | ((data << 2) & 0xfc);
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | ((cmd&0xff00) >> 8);
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | ((cmd&0xff) >> 0);
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_DATA | data;
+		break;
+	case 16:
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | (cmd&0xffff);
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_DATA | (data&0xffff);
+		break;
+	case 18:
+		cmd = ((cmd & 0xff) << 1) | ((cmd & 0xff00) << 2); 	
+ 		data = ((data & 0xff) << 1) | ((data & 0xff00) << 2);
+ 		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | cmd;
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_DATA | ((data<<6)&0xfc0000)|((data<<4)&0xfc00) | ((data<<2)&0xfc);
+		break;
+	default:
+		printf("Don't support %d bit Bus\n", jzfb.bus );
+		break;
+	}
+}
+
+/* Sent a command only */
+static void Mcupanel_Command(UINT32 cmd) {
+	switch (jzfb.bus) {
+	case 8:
+	case 9:
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | ((cmd&0xff00) >> 8);
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | ((cmd&0xff) >> 0);
+		break;
+	case 16:
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | (cmd&0xffff);
+		break;
+	case 18:
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_COMMAND | ((cmd&0xff00) << 2) | ((cmd&0xff) << 1);
+		break;
+	default:
+		printf("Don't support %d bit Bus\n", jzfb.bus );
+		break;
+	}
+}
+
+/* Sent data only */
+static void Mcupanel_Data(UINT32 data) {
+
+	switch (jzfb.bpp) {
+	case 8:
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_DATA | (((unsigned int)data >> 8)& 0xff);
+		break;
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_DATA | (((unsigned int)data >> 0) & 0xff);
+		break;
+	case 15:
+	case 16:
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_DATA | ((unsigned int)data & 0xffff);
+		break;
+	case 32:
+	default:
+		while (REG_SLCD_STATE & SLCD_STATE_BUSY);
+		REG_SLCD_DATA = SLCD_DATA_RS_DATA | ((unsigned int)data & 0xffffff);
+		break;
+	}
+}
+
+/*
+ * Before enabled lcd controller, lcd registers should be configured correctly.
+ */
+
+void lcd_enable (void)
+{
+}
+
+/*----------------------------------------------------------------------*/
+
+
+void lcd_disable (void)
+{
+}
+
+/************************************************************************/
+
+
+static int jz_lcd_init_mem(void *lcdbase, vidinfo_t *vid)
+{
+	u_long palette_mem_size;
+	struct jz_fb_info *fbi = &vid->jz_fb;
+	int fb_size = vid->vl_row * (vid->vl_col * NBITS (vid->vl_bpix)) / 8;
+
+	fbi->screen = (u_long)lcdbase;
+	fbi->palette_size = 256;
+	palette_mem_size = fbi->palette_size * sizeof(u16);
+
+	debug("palette_mem_size = 0x%08lx\n", (u_long) palette_mem_size);
+	/* locate palette and descs at end of page following fb */
+	fbi->palette = (u_long)lcdbase + fb_size + PAGE_SIZE - palette_mem_size;
+
+	return 0;
+}
+static void jz_lcd_desc_init(vidinfo_t *vid)
+{
+	struct jz_fb_info * fbi;
+	unsigned int next, pal_size, frm_size;
+
+	fbi = &vid->jz_fb;
+	fbi->dmadesc_fblow = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 3*16);
+	fbi->dmadesc_fbhigh = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 2*16);
+	fbi->dmadesc_palette = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 1*16);
+
+
+	#define BYTES_PER_PANEL	 (vid->vl_col * vid->vl_row * NBITS(vid->vl_bpix) / 8)
+
+	/*Prepare Frame Descriptor in memory*/
+	switch (jzfb.bpp) {
+	case 8 ... 16:
+		fbi->dmadesc_fblow->dcmd  = DMAC_DCMD_SAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32
+			| DMAC_DCMD_DWDH_16 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_TM | DMAC_DCMD_DES_V
+			| DMAC_DCMD_DES_VIE | DMAC_DCMD_LINK;
+	break;
+
+	case 17 ... 32:
+		fbi->dmadesc_fblow->dcmd  = DMAC_DCMD_SAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32
+			| DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_TM | DMAC_DCMD_DES_V
+			| DMAC_DCMD_DES_VIE | DMAC_DCMD_LINK;
+		break;
+	}
+	fbi->dmadesc_fblow->dsadr = virt_to_phys((void *)(fbi->screen + BYTES_PER_PANEL));
+	fbi->dmadesc_fblow->dtadr  = virt_to_phys((void *)SLCD_FIFO);
+
+	switch (jzfb.bpp) {
+	case 8 ... 16:
+		fbi->dmadesc_fbhigh->dcmd  = DMAC_DCMD_SAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32
+			| DMAC_DCMD_DWDH_16 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_TM | DMAC_DCMD_DES_V
+			| DMAC_DCMD_DES_VIE | DMAC_DCMD_LINK;
+	break;
+
+	case 17 ... 32:
+		fbi->dmadesc_fbhigh->dcmd  = DMAC_DCMD_SAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32
+			| DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_TM | DMAC_DCMD_DES_V
+			| DMAC_DCMD_DES_VIE | DMAC_DCMD_LINK;
+		break;
+	}
+
+	fbi->dmadesc_fbhigh->dsadr = virt_to_phys((void *)(fbi->screen));
+	fbi->dmadesc_fbhigh->dtadr  = virt_to_phys((void *)SLCD_FIFO);
+
+	/* palette descriptor */
+	fbi->dmadesc_palette->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32
+		| DMAC_DCMD_DWDH_16 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_TM | DMAC_DCMD_DES_V 
+		| DMAC_DCMD_DES_VIE | DMAC_DCMD_LINK;
+	fbi->dmadesc_palette->dsadr = virt_to_phys((void *)fbi->palette);
+	fbi->dmadesc_palette->dtadr  = virt_to_phys((void *)SLCD_FIFO);
+
+	pal_size = fbi->palette_size;
+	frm_size = BYTES_PER_PANEL;
+
+	switch (fbi->dmadesc_palette->dcmd & DMAC_DCMD_DS_MASK) {
+	case DMAC_DCMD_DS_32BYTE:
+		pal_size /= 32;
+		break;
+	case DMAC_DCMD_DS_16BYTE:
+		pal_size /= 16;
+		break;
+	case DMAC_DCMD_DS_32BIT:
+		pal_size /= 4;
+		break;
+	case DMAC_DCMD_DS_16BIT:
+		pal_size /= 2;
+		break;
+	case DMAC_DCMD_DS_8BIT:
+	default:
+		break;
+	}
+	switch (fbi->dmadesc_fbhigh->dcmd & DMAC_DCMD_DS_MASK) {
+	case DMAC_DCMD_DS_32BYTE:
+		frm_size /= 32;
+		break;
+	case DMAC_DCMD_DS_16BYTE:
+		frm_size /= 16;
+		break;
+	case DMAC_DCMD_DS_32BIT:
+		frm_size /= 4;
+		break;
+	case DMAC_DCMD_DS_16BIT:
+		frm_size /= 2;
+		break;
+	case DMAC_DCMD_DS_8BIT:
+	default:
+		break;
+	}
+	if( NBITS(vid->vl_bpix) < 12)
+	{
+		/* assume any mode with <12 bpp is palette driven */
+
+		next = (unsigned long)virt_to_phys(fbi->dmadesc_fbhigh) >> 4;
+		fbi->dmadesc_palette->ddadr = /* offset and size*/
+			(volatile unsigned int)((next << 24) | (pal_size & 0xffffff)); 
+
+		/* flips back and forth between pal and fbhigh */
+		next = (unsigned long)fbi->dmadesc_palette >> 4;
+		fbi->dmadesc_fbhigh->ddadr = /* offset and size*/
+			(volatile unsigned int)((next << 24) | (frm_size & 0xffffff));
+
+	}
+	else
+	{
+		next = (unsigned int)virt_to_phys(fbi->dmadesc_fbhigh) >> 4;
+		/* palette shouldn't be loaded in true-color mode */
+		fbi->dmadesc_fbhigh->ddadr = /* offset and size*/
+			(volatile unsigned int)((next << 24) | (frm_size & 0xffffff));
+	}
+
+	flush_cache_all();
+}
+static int  jz_lcd_hw_init(vidinfo_t *vid)
+{
+	struct jz_fb_info *fbi = &vid->jz_fb;
+	unsigned int val = 0;
+	unsigned int pclk;
+	unsigned int stnH;
+	int pll_div;
+
+	if ((jzfb.bpp == 18) | (jzfb.bpp == 24))
+		jzfb.bpp = 32;
+	
+	/* Setting Control register */
+	REG_LCD_CFG &= ~LCD_CFG_LCDPIN_MASK;
+	REG_LCD_CFG |= LCD_CFG_LCDPIN_SLCD;
+	/* Configure SLCD module for initialize smart lcd registers*/
+	switch (jzfb.bus) {
+	case 8:
+		REG_SLCD_CFG = SLCD_CFG_BURST_8_WORD | SLCD_CFG_DWIDTH_8_x2 
+			| SLCD_CFG_CWIDTH_8BIT | SLCD_CFG_CS_ACTIVE_LOW 
+			| SLCD_CFG_RS_CMD_LOW | SLCD_CFG_CLK_ACTIVE_FALLING 
+			| SLCD_CFG_TYPE_PARALLEL;
+		__gpio_as_slcd_8bit();
+		break;
+	case 9:
+		REG_SLCD_CFG = SLCD_CFG_BURST_8_WORD | SLCD_CFG_DWIDTH_8_x2
+			| SLCD_CFG_CWIDTH_8BIT | SLCD_CFG_CS_ACTIVE_LOW 
+			| SLCD_CFG_RS_CMD_LOW | SLCD_CFG_CLK_ACTIVE_FALLING 
+			| SLCD_CFG_TYPE_PARALLEL;
+		__gpio_as_slcd_9bit();
+		break;
+	case 16:
+		REG_SLCD_CFG = SLCD_CFG_BURST_8_WORD | SLCD_CFG_DWIDTH_16
+			| SLCD_CFG_CWIDTH_16BIT | SLCD_CFG_CS_ACTIVE_LOW
+			| SLCD_CFG_RS_CMD_LOW | SLCD_CFG_CLK_ACTIVE_FALLING
+			| SLCD_CFG_TYPE_PARALLEL;
+		__gpio_as_slcd_16bit();
+		break;
+	case 18:
+		REG_SLCD_CFG = SLCD_CFG_BURST_8_WORD | SLCD_CFG_DWIDTH_18
+			| SLCD_CFG_CWIDTH_18BIT | SLCD_CFG_CS_ACTIVE_LOW 
+			| SLCD_CFG_RS_CMD_LOW | SLCD_CFG_CLK_ACTIVE_FALLING 
+			| SLCD_CFG_TYPE_PARALLEL;
+		__gpio_as_slcd_18bit();
+		break;
+	default:
+		printf("Error: Don't support BUS %d!\n", jzfb.bus);
+		break;
+	}
+
+	REG_SLCD_CTRL = SLCD_CTRL_DMA_EN;
+
+	/* Timing setting */
+	__cpm_stop_lcd();
+
+	val = jzfb.fclk; /* frame clk */
+	pclk = val * jzfb.w * jzfb.h; /* Pixclk */
+
+	pll_div = ( REG_CPM_CPCCR & CPM_CPCCR_PCS ); /* clock source,0:pllout/2 1: pllout */
+	pll_div = pll_div ? 1 : 2 ;
+	val = ( __cpm_get_pllout()/pll_div ) / pclk;
+	val--;
+	if ( val > 0x1ff ) {
+		printf("CPM_LPCDR too large, set it to 0x1ff\n");
+		val = 0x1ff;
+	}
+	__cpm_set_pixdiv(val);
+
+	REG_CPM_CPCCR |= CPM_CPCCR_CE ; /* update divide */
+
+	__cpm_start_lcd();
+	udelay(1000);
+	__slcd_display_pin_init();
+ 	__slcd_special_on();
+
+	/* Configure SLCD module for transfer data to smart lcd GRAM*/
+	switch (jzfb.bus) {
+	case 8:
+		switch (jzfb.bpp) {
+		case 8:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_8_x1;
+			break;
+		case 15:
+		case 16:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_8_x2;
+			break;
+		case 17 ... 32:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_8_x3;
+			break;
+		default:
+			printf("The BPP %d is not supported\n", jzfb.bpp);
+			break;
+		}
+		break;
+	case 9:
+		switch (jzfb.bpp) {
+		case 8:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_8_x1;
+			break;
+		case 15 ... 16:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_8_x2;
+			break;
+		case 17 ... 32:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_9_x2;
+			break;
+		default:
+			printf("The BPP %d is not supported\n", jzfb.bpp);
+			break;
+		}
+		break;
+	case 16:
+		switch (jzfb.bpp) {
+		case 8:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_8_x1;
+			break;
+		case 15 ... 16:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_16;
+			break;
+		case 17 ... 32:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_8_x3;
+			break;
+		default:
+			printf("The BPP %d is not supported\n", jzfb.bpp);
+			break;
+		}
+		break;
+	case 18:
+		switch (jzfb.bpp) {
+		case 8:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_8_x1;
+			break;
+		case 15:
+		case 16:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_16;
+			break;
+		case 17 ... 32:
+			REG_SLCD_CFG &= ~SLCD_CFG_DWIDTH_MASK;
+			REG_SLCD_CFG |= SLCD_CFG_DWIDTH_18;
+			break;
+		default:
+			printf("The BPP %d is not supported\n", jzfb.bpp);
+			break;
+		}
+		break;
+	default:
+		printf("Error: The BUS %d is not supported\n", jzfb.bus);
+		break;
+	}
+	return 0;
+}
+static int slcd_dma_init(vidinfo_t *vid)
+{
+	/* Request DMA channel and setup irq handler */
+	int dma_chan;
+	struct jz_fb_info *fbi = &vid->jz_fb;;
+
+	dma_chan = SLCD_DMA_CHAN_ID;
+	printf("DMA channel %d is requested by SLCD!\n", dma_chan);
+
+	/*Init the SLCD DMA and Enable*/
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_SLCD;
+	REG_DMAC_DMACR = DMAC_DMACR_DMAE;
+	REG_DMAC_DCCSR(dma_chan) =  DMAC_DCCSR_EN; /*Descriptor Transfer*/
+
+	if (jzfb.bpp <= 8)
+		REG_DMAC_DDA(dma_chan) = virt_to_phys(fbi->dmadesc_palette);
+	else
+		REG_DMAC_DDA(dma_chan) = virt_to_phys(fbi->dmadesc_fbhigh);
+
+	/* DMA doorbell set -- start DMA now ... */
+	__dmac_channel_set_doorbell(dma_chan);
+	return 0;
+}
+
+/* cpu mode flush screen */
+void flush_screen(void *lcdbase)
+{
+#if LCD_BPP < 5
+	unsigned short *fb_end, *ptr_data = (unsigned short *)lcdbase;
+	fb_end = (unsigned short *)lcdbase + (jzfb.w * jzfb.h * jzfb.bpp / 16);
+#else 
+	unsigned int *fb_end, *ptr_data = (unsigned int *)lcdbase;
+	fb_end = (unsigned int *)lcdbase + (jzfb.w * jzfb.h * jzfb.bpp / 32);
+#endif
+
+	while (ptr_data < fb_end) {
+		Mcupanel_Data(*ptr_data);
+		ptr_data++;
+	}
+}
+
+void dump_jz_dma_channel(unsigned int dmanr)
+{
+	struct dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return;
+	printf("DMA%d Registers:\n", dmanr);
+	printf("  DMACR  = 0x%08x\n", REG_DMAC_DMACR);
+	printf("  DSAR   = 0x%08x\n", REG_DMAC_DSAR(dmanr));
+	printf("  DTAR   = 0x%08x\n", REG_DMAC_DTAR(dmanr));
+	printf("  DTCR   = 0x%08x\n", REG_DMAC_DTCR(dmanr));
+	printf("  DRSR   = 0x%08x\n", REG_DMAC_DRSR(dmanr));
+	printf("  DCCSR  = 0x%08x\n", REG_DMAC_DCCSR(dmanr));
+	printf("  DCMD  = 0x%08x\n", REG_DMAC_DCMD(dmanr));
+	printf("  DDA  = 0x%08x\n", REG_DMAC_DDA(dmanr));
+	printf("  DMADBR = 0x%08x\n", REG_DMAC_DMADBR);
+}
+
+#endif /* CONFIG_LCD  && CONFIG_SLCD */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740_slcd.h u-boot-1.1.6/cpu/mips/jz4740_slcd.h
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4740_slcd.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4740_slcd.h	2009-02-03 21:03:09.000000000 +0800
@@ -0,0 +1,474 @@
+/*
+ * linux/drivers/video/jzslcd.h -- Ingenic On-Chip SLCD frame buffer device
+ *
+ * Copyright (C) 2005-2007, Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __JZSLCD_H__
+#define __JZSLCD_H__
+
+#define UINT16 unsigned short
+#define UINT32 unsigned int
+
+#define NR_PALETTE	256
+/* Jz LCDFB supported I/O controls. */
+#define FBIOSETBACKLIGHT	0x4688
+#define FBIODISPON		0x4689
+#define FBIODISPOFF		0x468a
+#define FBIORESET		0x468b
+#define FBIOPRINT_REG		0x468c
+#define FBIO_REFRESH_ALWAYS	0x468d
+#define FBIO_REFRESH_EVENTS	0x468e
+#define FBIO_DO_REFRESH		0x468f
+#define FBIO_SET_REG		0x4690
+
+#ifdef CONFIG_JZ_SLCD_SPFD5408A
+
+#define PIN_CS_N 	(32*1+17)	/* Chip select      :SLCD_WR: GPB17 */ 
+#define PIN_RESET_N 	(32*1+18)	/* LCD reset        :SLCD_RST: GPB18*/ 
+#define __slcd_special_on()	\
+do {      \
+	__gpio_set_pin(PIN_RESET_N);	\
+	mdelay(10);	\
+	__gpio_clear_pin(PIN_RESET_N);	\
+	mdelay(10);	\
+	__gpio_set_pin(PIN_RESET_N);	\
+	mdelay(100);	\
+	/************* Start Initial Sequence **********/\
+	Mcupanel_RegSet(0x00, 0x0000); /*0001);	// Start internal OSC.*/\
+	Mcupanel_RegSet(0x01, 0x0000); /*0x0100);	// set SS and SM bit*/\
+	Mcupanel_RegSet(0x02, 0x0700); /*0400);	// set 1 line inversion*/\
+	Mcupanel_RegSet(0x03, 0x10b8); /*0x1038); //0x1028); //0x1038);		// set GRAM write direction and BGR=1.*/\
+	Mcupanel_RegSet(0x04, 0x0000);		/* Resize register*/\
+	Mcupanel_RegSet(0x08, 0x0207); /*0202);	// set the back porch and front porch*/\
+	Mcupanel_RegSet(0x09, 0x0000);		/* set non-display area refresh cycle ISC[3:0]*/\
+	Mcupanel_RegSet(0x0A, 0x0000);		/* FMARK function*/\
+	Mcupanel_RegSet(0x0C, 0x0000);		/* RGB interface setting*/\
+	Mcupanel_RegSet(0x0D, 0x0000);		/* Frame marker Position*/\
+	Mcupanel_RegSet(0x0F, 0x0000);		/* RGB interface polarity*/\
+	/*************Power On sequence ****************/\
+	/*WCOM(0x51, 0x00, 0xEF);*/\
+	Mcupanel_RegSet(0x07, 0x0101);\
+	Mcupanel_RegSet(0x10, 0x10B0); /*0000);     // SAP, BT[3:0], AP, DSTB, SLP, STB*/\
+	Mcupanel_RegSet(0x11, 0x0007);              /*/ DC1[2:0], DC0[2:0], VC[2:0]*/\
+	mdelay(50);\
+	Mcupanel_RegSet(0x07, 0x0001);\
+	Mcupanel_RegSet(0x12, 0x013b); /*0000);     // VREG1OUT voltage*/\
+	mdelay(50);\
+	Mcupanel_RegSet(0x13, 0x0500); /*0000);     // VDV[4:0] for VCOM amplitude*/\
+	Mcupanel_RegSet(0x29, 0x0009); /*B);*/\
+	mdelay(50);\
+	/* ---------- Gamma Control  ---------- //*/	\
+	Mcupanel_RegSet(0x30, 0x0102);\
+	Mcupanel_RegSet(0x31, 0x0C1B);\
+	Mcupanel_RegSet(0x32, 0x121F);\
+	Mcupanel_RegSet(0x33, 0x391A);\
+	Mcupanel_RegSet(0x34, 0x380B);\
+	Mcupanel_RegSet(0x35, 0x1004);\
+	Mcupanel_RegSet(0x36, 0x1701);\
+	Mcupanel_RegSet(0x37, 0x0A1E);\
+	Mcupanel_RegSet(0x38, 0x0007);\
+	Mcupanel_RegSet(0x39, 0x0101);\
+	Mcupanel_RegSet(0x3A, 0x0C06);\
+	Mcupanel_RegSet(0x3B, 0x0F03);\
+	Mcupanel_RegSet(0x3C, 0x000C);\
+	Mcupanel_RegSet(0x3D, 0x0D0C);\
+	Mcupanel_RegSet(0x3E, 0x0504);\
+	Mcupanel_RegSet(0x3F, 0x0601);	\
+	/*/ ---------- Window Address Area  ---------- /*/\
+	Mcupanel_RegSet(0x50, 0x0000);		/*/ Horizontal GRAM Start Address-----HSA[7:0]*/\
+	Mcupanel_RegSet(0x51, 0x00EF);		/*/ Horizontal GRAM End Address-----HEA[7:0]*/\
+	Mcupanel_RegSet(0x52, 0x0000);		/*/ Vertical GRAM Start Address-----VSA[8:0]*/\
+	Mcupanel_RegSet(0x53, 0x013F);		/*/ Vertical GRAM Start Address-----VEA[8:0]*/\
+	Mcupanel_RegSet(0x60, 0x2700);	/*/ GS, NL[5:0], SCN[5:0]*/\
+	Mcupanel_RegSet(0x61, 0x0001);		/*/ NDL,VLE, REV*/\
+	Mcupanel_RegSet(0x6A, 0x0000);		/*/ VL[8:0]*/\
+	/*/ ---------- Partial Display Control  ---------- /*/\
+	Mcupanel_RegSet(0x80, 0x0000);		/*/ Partial Image 1 Display Position-----PTDP0[8:0]*/\
+	Mcupanel_RegSet(0x81, 0x0000);		/*/ Partial Image 1 Start Address-----PTSA0[8:0]*/\
+	Mcupanel_RegSet(0x82, 0x0000);		/*/ Partial Image 1 End Address-----PTEA0[8:0]*/\
+	Mcupanel_RegSet(0x83, 0x0000);		/*/ Partial Image 2 Display Position-----PTDP1[8:0]*/\
+	Mcupanel_RegSet(0x84, 0x0000);		/*/ Partial Image 2 Start Address-----PTSA1[8:0]*/\
+	Mcupanel_RegSet(0x85, 0x0000);		/*/ Partial Image 2 Start Address-----PTEA1[8:0]*/\
+	/*/ ---------- Panel Interface Control  ---------- //*/\
+	Mcupanel_RegSet(0x90, 0x0013);	/*/ Panel Interface Control 1-----DIVI[1:0], RTNI[4:0]*/\
+	Mcupanel_RegSet(0x92, 0x0000);		/*/ Panel Interface Control 2-----NOWI[2:0]*/\
+	Mcupanel_RegSet(0x93, 0x0103);	/*/ Panel Interface Control 3-----MCPI[2:0]*/\
+	Mcupanel_RegSet(0x95, 0x0110);		/*/ Panel Interface Control 4-----DIVE[1:0], RTNE[5:0]*/\
+	Mcupanel_RegSet(0x97, 0x0000);		/*/ Panel Interface Control 5-----NOWE[3:0]*/\
+	Mcupanel_RegSet(0x98, 0x0000);		/*/ Panel Interface Control 6-----MCPE[2:0]*/\
+	Mcupanel_RegSet(0xF0, 0x5408);\
+	Mcupanel_RegSet(0xF3, 0x0010);\
+	Mcupanel_RegSet(0xF4, 0x001F);\
+	Mcupanel_RegSet(0xF0, 0x0000);\
+	Mcupanel_RegSet(0x07, 0x0001);	/*/ Display Control 1*/\
+	mdelay(50);\
+	Mcupanel_RegSet(0x07, 0x0021);	/*/ Display Control 1*/\
+	Mcupanel_RegSet(0x07, 0x0023);	/*/ Display Control 1*/\
+	mdelay(50);\
+	Mcupanel_RegSet(0x07, 0x0173);		/*/ Display Control 1-----262K color and display ON*/\
+	mdelay(50);\
+	Mcupanel_Command(0x22);\
+} while(0)
+
+#define __slcd_special_pin_init() \
+do {\
+	__gpio_as_output(PIN_CS_N);	\
+	__gpio_as_output(PIN_RESET_N);	\
+	__gpio_clear_pin(PIN_CS_N); /* Clear CS */	\
+	mdelay(100);	\
+} while(0)
+#endif  //end CONFIG_JZ_SLCD_SPFD5408A
+
+#ifdef CONFIG_JZ_SLCD_LGDP4551
+#define PIN_CS_N 	(32*2+18)	/* Chip select      :SLCD_WR: GPC18 */ 
+#define PIN_RESET_N 	(32*2+21)	/* LCD reset        :SLCD_RST: GPC21*/ 
+#define PIN_RS_N 	(32*2+19)
+
+#define	__slcd_special_pin_init() \
+do { \
+	__gpio_as_output(PIN_CS_N); 	\
+	__gpio_as_output(PIN_RESET_N); 	\
+	__gpio_clear_pin(PIN_CS_N); /* Clear CS */\
+	mdelay(100);			\
+} while(0)
+
+#define __slcd_special_on() 		\
+do {	/* RESET# */			\
+	__gpio_set_pin(PIN_RESET_N);	\
+	mdelay(10);			\
+	__gpio_clear_pin(PIN_RESET_N);	\
+	mdelay(10);			\
+	__gpio_set_pin(PIN_RESET_N);	\
+	mdelay(100);			\
+	Mcupanel_RegSet(0x0015,0x0050);	\
+	Mcupanel_RegSet(0x0011,0x0000);	\
+	Mcupanel_RegSet(0x0010,0x3628);	\
+	Mcupanel_RegSet(0x0012,0x0002);	\
+	Mcupanel_RegSet(0x0013,0x0E47);	\
+	udelay(100);			\
+	Mcupanel_RegSet(0x0012,0x0012);	\
+	udelay(100);			\
+	Mcupanel_RegSet(0x0010,0x3620);	\
+	Mcupanel_RegSet(0x0013,0x2E47);	\
+	udelay(50);			\
+	Mcupanel_RegSet(0x0030,0x0000);	\
+	Mcupanel_RegSet(0x0031,0x0502);	\
+	Mcupanel_RegSet(0x0032,0x0307);	\
+	Mcupanel_RegSet(0x0033,0x0304);	\
+	Mcupanel_RegSet(0x0034,0x0004);	\
+	Mcupanel_RegSet(0x0035,0x0401);	\
+	Mcupanel_RegSet(0x0036,0x0707);	\
+	Mcupanel_RegSet(0x0037,0x0303);	\
+	Mcupanel_RegSet(0x0038,0x1E02);	\
+	Mcupanel_RegSet(0x0039,0x1E02);	\
+	Mcupanel_RegSet(0x0001,0x0000);	\
+	Mcupanel_RegSet(0x0002,0x0300);	\
+	if (jzfb.bpp == 16)		\
+		Mcupanel_RegSet(0x0003,0x10B8); /*8-bit system interface two transfers
+						  up:0x10B8 down:0x1088 left:0x1090 right:0x10a0*/ \
+	else	\
+		if (jzfb.bpp == 32)\
+			Mcupanel_RegSet(0x0003,0xD0B8);/*8-bit system interface three transfers,666
+							 up:0xD0B8 down:0xD088 left:0xD090 right:0xD0A0*/ \
+	Mcupanel_RegSet(0x0008,0x0204);\
+	Mcupanel_RegSet(0x000A,0x0008);\
+	Mcupanel_RegSet(0x0060,0x3100);\
+	Mcupanel_RegSet(0x0061,0x0001);\
+	Mcupanel_RegSet(0x0090,0x0052);\
+	Mcupanel_RegSet(0x0092,0x000F);\
+	Mcupanel_RegSet(0x0093,0x0001);\
+	Mcupanel_RegSet(0x009A,0x0008);\
+	Mcupanel_RegSet(0x00A3,0x0010);\
+	Mcupanel_RegSet(0x0050,0x0000);\
+	Mcupanel_RegSet(0x0051,0x00EF);\
+	Mcupanel_RegSet(0x0052,0x0000);\
+	Mcupanel_RegSet(0x0053,0x018F);\
+	/*===Display_On_Function=== */ \
+	Mcupanel_RegSet(0x0007,0x0001);\
+	Mcupanel_RegSet(0x0007,0x0021);\
+	Mcupanel_RegSet(0x0007,0x0023);\
+	Mcupanel_RegSet(0x0007,0x0033);\
+	Mcupanel_RegSet(0x0007,0x0133);\
+	Mcupanel_Command(0x0022);/*Write Data to GRAM	*/  \
+	udelay(1);		\
+	Mcupanel_SetAddr(0,0);	\
+	mdelay(100);		\
+} while (0)
+
+#define __slcd_special_off() 		\
+do { \
+} while(0)
+#endif /*CONFIG_JZ_SLCD_LGDP4551_xxBUS*/
+
+#ifdef CONFIG_JZ_SLCD_SPFD5420A
+
+  //#define PIN_CS_N 	(32*2+18)	// Chip select 	//GPC18;
+#define PIN_CS_N 	(32*2+22)	// Chip select 	//GPC18;
+#define PIN_RESET_N 	(32*1+18)	// LCD reset   	//GPB18;
+#define PIN_RS_N 	(32*2+19)	// LCD RS		//GPC19;
+#define PIN_POWER_N	(32*3+0)	//Power off 	//GPD0;
+#define PIN_FMARK_N	(32*3+1)	//fmark			//GPD1;
+
+#define GAMMA()	\
+do {	\
+	Mcupanel_RegSet(0x0300,0x0101);	\
+	Mcupanel_RegSet(0x0301,0x0b27);	\
+	Mcupanel_RegSet(0x0302,0x132a);	\
+	Mcupanel_RegSet(0x0303,0x2a13);	\
+	Mcupanel_RegSet(0x0304,0x270b);	\
+	Mcupanel_RegSet(0x0305,0x0101);	\
+	Mcupanel_RegSet(0x0306,0x1205);	\
+	Mcupanel_RegSet(0x0307,0x0512);	\
+	Mcupanel_RegSet(0x0308,0x0005);	\
+	Mcupanel_RegSet(0x0309,0x0003);	\
+	Mcupanel_RegSet(0x030a,0x0f04);	\
+	Mcupanel_RegSet(0x030b,0x0f00);	\
+	Mcupanel_RegSet(0x030c,0x000f);	\
+	Mcupanel_RegSet(0x030d,0x040f);	\
+	Mcupanel_RegSet(0x030e,0x0300);	\
+	Mcupanel_RegSet(0x030f,0x0500);	\
+	/*** secorrect gamma2 ***/	\
+	Mcupanel_RegSet(0x0400,0x3500);	\
+	Mcupanel_RegSet(0x0401,0x0001);	\
+	Mcupanel_RegSet(0x0404,0x0000);	\
+	Mcupanel_RegSet(0x0500,0x0000);	\
+	Mcupanel_RegSet(0x0501,0x0000);	\
+	Mcupanel_RegSet(0x0502,0x0000);	\
+	Mcupanel_RegSet(0x0503,0x0000);	\
+	Mcupanel_RegSet(0x0504,0x0000);	\
+	Mcupanel_RegSet(0x0505,0x0000);	\
+	Mcupanel_RegSet(0x0600,0x0000);	\
+	Mcupanel_RegSet(0x0606,0x0000);	\
+	Mcupanel_RegSet(0x06f0,0x0000);	\
+	Mcupanel_RegSet(0x07f0,0x5420);	\
+	Mcupanel_RegSet(0x07f3,0x288a);	\
+	Mcupanel_RegSet(0x07f4,0x0022);	\
+	Mcupanel_RegSet(0x07f5,0x0001);	\
+	Mcupanel_RegSet(0x07f0,0x0000);	\
+} while(0)
+
+#define __slcd_special_on()	\
+do {      \
+	__gpio_set_pin(PIN_RESET_N);	\
+	mdelay(10);	\
+	__gpio_clear_pin(PIN_RESET_N);	\
+	mdelay(10);	\
+	__gpio_set_pin(PIN_RESET_N);	\
+	mdelay(100);	\
+	if (jzfb.bus == 18) {\
+	Mcupanel_RegSet(0x0606,0x0000);	\
+	udelay(10);	\
+	Mcupanel_RegSet(0x0007,0x0001);	\
+	udelay(10);	\
+	Mcupanel_RegSet(0x0110,0x0001);	\
+	udelay(10);	\
+	Mcupanel_RegSet(0x0100,0x17b0);	\
+	Mcupanel_RegSet(0x0101,0x0147);	\
+	Mcupanel_RegSet(0x0102,0x019d);	\
+	Mcupanel_RegSet(0x0103,0x8600);	\
+	Mcupanel_RegSet(0x0281,0x0010);	\
+	udelay(10);	\
+	Mcupanel_RegSet(0x0102,0x01bd);	\
+	udelay(10);	\
+	/************initial************/\
+	Mcupanel_RegSet(0x0000,0x0000);	\
+	Mcupanel_RegSet(0x0001,0x0000);	\
+	Mcupanel_RegSet(0x0002,0x0400);	\
+	Mcupanel_RegSet(0x0003,0x1288); /*up:0x1288 down:0x12B8 left:0x1290 right:0x12A0*/ \
+	Mcupanel_RegSet(0x0006,0x0000);	\
+	Mcupanel_RegSet(0x0008,0x0503);	\
+	Mcupanel_RegSet(0x0009,0x0001);	\
+	Mcupanel_RegSet(0x000b,0x0010);	\
+	Mcupanel_RegSet(0x000c,0x0000);	\
+	Mcupanel_RegSet(0x000f,0x0000);	\
+	Mcupanel_RegSet(0x0007,0x0001);	\
+	Mcupanel_RegSet(0x0010,0x0010);	\
+	Mcupanel_RegSet(0x0011,0x0202);	\
+	Mcupanel_RegSet(0x0012,0x0300);	\
+	Mcupanel_RegSet(0x0020,0x021e);	\
+	Mcupanel_RegSet(0x0021,0x0202);	\
+	Mcupanel_RegSet(0x0022,0x0100);	\
+	Mcupanel_RegSet(0x0090,0x0000);	\
+	Mcupanel_RegSet(0x0092,0x0000);	\
+	Mcupanel_RegSet(0x0100,0x16b0);	\
+	Mcupanel_RegSet(0x0101,0x0147);	\
+	Mcupanel_RegSet(0x0102,0x01bd);	\
+	Mcupanel_RegSet(0x0103,0x2c00);	\
+    	Mcupanel_RegSet(0x0107,0x0000);	\
+	Mcupanel_RegSet(0x0110,0x0001);	\
+	Mcupanel_RegSet(0x0210,0x0000);	\
+	Mcupanel_RegSet(0x0211,0x00ef);	\
+	Mcupanel_RegSet(0x0212,0x0000);	\
+	Mcupanel_RegSet(0x0213,0x018f);	\
+	Mcupanel_RegSet(0x0280,0x0000);	\
+	Mcupanel_RegSet(0x0281,0x0001);	\
+	Mcupanel_RegSet(0x0282,0x0000);	\
+	GAMMA();	\
+ 	Mcupanel_RegSet(0x0007,0x0173);	\
+	} else {		\
+		Mcupanel_RegSet(0x0600, 0x0001);   /*soft reset*/	\
+		mdelay(10); 		\
+		Mcupanel_RegSet(0x0600, 0x0000);   /*soft reset*/	\
+		mdelay(10);						\
+		Mcupanel_RegSet(0x0606, 0x0000);   /*i80-i/F Endian Control*/ \
+		/*===User setting===    */				\
+		Mcupanel_RegSet(0x0001, 0x0000);/* Driver Output Control-----0x0100 SM(bit10) | 0x400*/ \
+		Mcupanel_RegSet(0x0002, 0x0100);   /*LCD Driving Wave Control      0x0100 */ \
+		if (jzfb.bpp == 16)					\
+			Mcupanel_RegSet(0x0003, 0x50A8);/*Entry Mode 0x1030*/ \
+		else /*bpp = 18*/					\
+			Mcupanel_RegSet(0x0003, 0x1010 | 0xC8);   /*Entry Mode 0x1030*/	\
+		/*#endif								*/ \
+		Mcupanel_RegSet(0x0006, 0x0000);   /*Outline Sharpening Control*/\     
+		Mcupanel_RegSet(0x0008, 0x0808);   /*Sets the number of lines for front/back porch period*/\
+		Mcupanel_RegSet(0x0009, 0x0001);   /*Display Control 3   */\ 
+		Mcupanel_RegSet(0x000B, 0x0010);   /*Low Power Control*/\
+		Mcupanel_RegSet(0x000C, 0x0000);   /*External Display Interface Control 1 */\
+		Mcupanel_RegSet(0x000F, 0x0000);   /*External Display Interface Control 2         */\
+		Mcupanel_RegSet(0x0400, 0xB104);/*Base Image Number of Line---GS(bit15) | */ \
+		Mcupanel_RegSet(0x0401, 0x0001);   /*Base Image Display        0x0001*/\
+		Mcupanel_RegSet(0x0404, 0x0000);   /*Base Image Vertical Scroll Control    */\
+		Mcupanel_RegSet(0x0500, 0x0000);   /*Partial Image 1: Display Position*/\
+		Mcupanel_RegSet(0x0501, 0x0000);   /*RAM Address (Start Line Address) */\
+		Mcupanel_RegSet(0x0502, 0x018f);   /*RAM Address (End Line Address)  */	\
+		Mcupanel_RegSet(0x0503, 0x0000);   /*Partial Image 2: Display Position  RAM Address*/\
+		Mcupanel_RegSet(0x0504, 0x0000);   /*RAM Address (Start Line Address) */\
+		Mcupanel_RegSet(0x0505, 0x0000);   /*RAM Address (End Line Address)*/\
+		/*Panel interface control===*/\
+		Mcupanel_RegSet(0x0010, 0x0011);   /*Division Ratio,Clocks per Line  14  */\
+		mdelay(10); \
+		Mcupanel_RegSet(0x0011, 0x0202);   /*Division Ratio,Clocks per Line*/\
+		Mcupanel_RegSet(0x0012, 0x0300);   /*Sets low power VCOM drive period.   */\
+		mdelay(10); \
+		Mcupanel_RegSet(0x0020, 0x021e);   /*Panel Interface Control 4  */\
+		Mcupanel_RegSet(0x0021, 0x0202);   /*Panel Interface Control 5 */\
+		Mcupanel_RegSet(0x0022, 0x0100);   /*Panel Interface Control 6*/\ 
+		Mcupanel_RegSet(0x0090, 0x0000);   /*Frame Marker Control  */\
+		Mcupanel_RegSet(0x0092, 0x0000);   /*MDDI Sub-display Control  */\
+		/*===Gamma setting===    */\
+		Mcupanel_RegSet(0x0300, 0x0101);   /* Control*/\
+		Mcupanel_RegSet(0x0301, 0x0000);   /* Control*/\
+		Mcupanel_RegSet(0x0302, 0x0016);   /* Control*/\
+		Mcupanel_RegSet(0x0303, 0x2913);   /* Control*/\
+		Mcupanel_RegSet(0x0304, 0x260B);   /* Control*/\
+		Mcupanel_RegSet(0x0305, 0x0101);   /* Control*/\
+		Mcupanel_RegSet(0x0306, 0x1204);   /* Control*/\
+		Mcupanel_RegSet(0x0307, 0x0415);   /* Control*/\
+		Mcupanel_RegSet(0x0308, 0x0205);   /* Control*/\
+		Mcupanel_RegSet(0x0309, 0x0303);   /* Control*/\
+		Mcupanel_RegSet(0x030a, 0x0E05);   /* Control*/\
+		Mcupanel_RegSet(0x030b, 0x0D01);   /* Control*/\
+		Mcupanel_RegSet(0x030c, 0x010D);   /* Control*/\
+		Mcupanel_RegSet(0x030d, 0x050E);   /* Control*/\
+		Mcupanel_RegSet(0x030e, 0x0303);   /* Control*/\
+		Mcupanel_RegSet(0x030f, 0x0502);   /* Control*/\
+		/*===Power on sequence===*/\
+		Mcupanel_RegSet(0x0007, 0x0001);   /*Display Control 1*/\
+		Mcupanel_RegSet(0x0110, 0x0001);   /*Power supply startup enable bit*/\
+		Mcupanel_RegSet(0x0112, 0x0060);   /*Power Control 7*/\
+		Mcupanel_RegSet(0x0100, 0x16B0);   /*Power Control 1 */\
+		Mcupanel_RegSet(0x0101, 0x0115);   /*Power Control 2*/\
+		Mcupanel_RegSet(0x0102, 0x0119);   /*Starts VLOUT3,Sets the VREG1OUT.*/\
+		mdelay(50); \
+		Mcupanel_RegSet(0x0103, 0x2E00);   /*set the amplitude of VCOM*/\
+		mdelay(50);\
+		Mcupanel_RegSet(0x0282, 0x0093);/*VCOMH voltage*/\
+		Mcupanel_RegSet(0x0281, 0x000A);   /*Selects the factor of VREG1OUT to generate VCOMH. */\
+		Mcupanel_RegSet(0x0102, 0x01BE);   /*Starts VLOUT3,Sets the VREG1OUT.*/\
+		mdelay(10);\
+		/*Address */\
+		Mcupanel_RegSet(0x0210, 0x0000);   /*Window Horizontal RAM Address Start*/\
+		Mcupanel_RegSet(0x0211, 0x00ef);   /*Window Horizontal RAM Address End*/\
+		Mcupanel_RegSet(0x0212, 0x0000);   /*Window Vertical RAM Address Start*/\
+		Mcupanel_RegSet(0x0213, 0x018f);   /*Window Vertical RAM Address End */\
+		Mcupanel_RegSet(0x0200, 0x0000);   /*RAM Address Set (Horizontal Address)*/\
+		Mcupanel_RegSet(0x0201, 0x018f);   /*RAM Address Set (Vertical Address)*/ \
+		/*===Display_On_Function===*/\
+		Mcupanel_RegSet(0x0007, 0x0021);   /*Display Control 1 */\
+		mdelay(50);   /*40*/\
+		Mcupanel_RegSet(0x0007, 0x0061);   /*Display Control 1 */\
+		mdelay(50);   /*100*/\
+		Mcupanel_RegSet(0x0007, 0x0173);   /*Display Control 1 */\
+		mdelay(50);   /*300*/\
+	}\
+	  Mcupanel_Command(0x0202);                  /*Write Data to GRAM	*/  \
+	udelay(10);\
+	Mcupanel_SetAddr(0,0);\
+	udelay(100);\
+} while(0)
+
+#define __slcd_special_pin_init() \
+do {	\
+	__gpio_as_output(PIN_CS_N);	\
+	__gpio_as_output(PIN_RESET_N);	\
+	__gpio_clear_pin(PIN_CS_N); /* Clear CS */	\
+	__gpio_as_output(PIN_POWER_N);	\
+	mdelay(100);	\
+} while(0)
+
+#endif /*CONFIG_JZ_SLCD_SPFD5420A*/
+
+#ifndef __slcd_special_pin_init
+#define __slcd_special_pin_init()
+#endif
+#ifndef __slcd_special_on
+#define __slcd_special_on()
+#endif
+#ifndef __slcd_special_off
+#define __slcd_special_off()
+#endif
+
+/*
+ * Platform specific definition
+ */
+#if defined(CONFIG_JZ4740)
+#if defined(CONFIG_PAVO)
+#define GPIO_PWM    123		/* GP_D27 */
+#define PWM_CHN 4    /* pwm channel */
+#define PWM_FULL 101
+/* 100 level: 0,1,...,100 */
+#define __slcd_set_backlight_level(n)\
+do { \
+	__gpio_as_output(32*3+27);	\
+	__gpio_set_pin(32*3+27);	\
+} while (0)
+
+#define __slcd_close_backlight() \
+do { \
+	__gpio_as_output(GPIO_PWM);	\
+	__gpio_clear_pin(GPIO_PWM);	\
+} while (0)
+
+#else
+
+#define __slcd_set_backlight_level(n)
+#define __slcd_close_backlight()
+
+#endif /* #if defined(CONFIG_MIPS_JZ4740_PAVO) */
+
+#define __slcd_display_pin_init() \
+do { \
+	__slcd_special_pin_init(); \
+} while (0)
+
+#define __slcd_display_on() \
+do { \
+	__slcd_special_on(); \
+	__slcd_set_backlight_level(80); \
+} while (0)
+
+#define __slcd_display_off() \
+do { \
+	__slcd_special_off(); \
+	__slcd_close_backlight(); \
+} while (0)
+
+#endif /* CONFIG_SOC_JZ4740 */
+#endif  /*__JZSLCD_H__*/
+
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4750.c u-boot-1.1.6/cpu/mips/jz4750.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4750.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4750.c	2009-01-14 01:15:38.000000000 +0800
@@ -0,0 +1,612 @@
+/*
+ * Jz4750 common routines
+ *
+ *  Copyright (c) 2006
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#if defined(CONFIG_JZ4750) || defined(CONFIG_JZ4750D)
+
+#include <common.h>
+#include <command.h>
+#ifdef CONFIG_JZ4750
+#include <asm/jz4750.h>
+#else
+#include <asm/jz4750d.h>
+#endif
+
+extern void board_early_init(void);
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 3, 3, 3, 3}; /* divisors of I:S:P:L:M */
+	int nf, pllout2;
+
+	cfcr = 	CPM_CPCCR_PCS |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	if (CFG_EXTAL > 16000000)
+		cfcr |= CPM_CPCCR_ECS;
+	else
+		cfcr &= ~CPM_CPCCR_ECS;
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? CFG_CPU_SPEED : (CFG_CPU_SPEED / 2);
+
+	/* Init USB Host clock, pllout2 must be n*48MHz */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+
+	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(0 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void pll_add_test(int new_freq)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 6, 6, 6, 6}; /* divisors of I:S:P:M:L */
+	int nf, pllout2;
+
+	cfcr = 	(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	if (CFG_EXTAL > 16000000)
+		cfcr |= CPM_CPCCR_ECS;
+	else
+		cfcr &= ~CPM_CPCCR_ECS;
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? new_freq : (new_freq / 2);
+
+	/* Init UHC clock */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+	
+	//nf = new_freq * 2 / CFG_EXTAL;
+	nf = new_freq / 1000000; //step length is 1M
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(22 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void calc_clocks_add_test(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+void sdram_add_test(int new_freq)
+{
+	register unsigned int dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = new_freq;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_DISABLE;
+	REG_EMC_RTCOR = 0;
+	REG_EMC_RTCNT = 0;
+
+	/* Basic DMCR register value. */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg parameters */
+	ns = 1000000000 / mem_clk;
+
+#if 0
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+#else
+	dmcr |= 0xfffc;
+#endif
+
+	/* First, precharge phase */
+	REG_EMC_DMCR = dmcr;
+
+	/* Set refresh registers */
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* SDRAM mode values */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* precharge all chip-selects */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 200;
+	while (tmp--);
+
+	/* enable refresh and set SDRAM mode */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* write sdram mode register for each chip-select */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* everything is ok now */
+}
+
+void sdram_init(void)
+{
+	register unsigned int dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+#ifdef CONFIG_MOBILE_SDRAM
+	register unsigned int sdemode; /*SDRAM Extended Mode*/
+#endif
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = CFG_CPU_SPEED;
+#if defined(CONFIG_FPGA)
+	mem_clk = CFG_EXTAL / CFG_DIV;
+#else
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+#endif
+
+#if CONFIG_NR_DRAM_BANKS == 2   /* Use both DCS0 and DCS1 */
+	/* set REG_EMC_DMAR0 for supporting 64MB sdram on DCS0 */
+	REG_EMC_DMAR0 = EMC_DMAR0_BASE | EMC_DMAR_MASK_64_64;
+
+	/* set REG_EMC_DMAR1 for supporting 64MB sdram on DCS1 */
+	REG_EMC_DMAR1 = EMC_DMAR1_BASE_64M | EMC_DMAR_MASK_64_64;
+#else
+	/* set REG_EMC_DMAR0 for supporting 128MB sdram on DCS0 */
+	REG_EMC_DMAR0 = EMC_DMAR0_BASE | EMC_DMAR_MASK_128_128;
+#endif
+
+	REG_EMC_BCR = 0;	/* Disable bus release */
+	REG_EMC_RTCSR = 0;	/* Disable clock for counting */
+
+	/* Basic DMCR value */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg */
+	ns = 1000000000 / mem_clk;
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode value */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Stage 1. Precharge all banks by writing SDMR with DMCR.MRSET=0 */
+	REG_EMC_DMCR = dmcr;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* Precharge Bank1 SDRAM */
+#if CONFIG_NR_DRAM_BANKS == 2   
+	REG_EMC_DMCR = dmcr | EMC_DMCR_MBSEL_B1;
+	REG8(EMC_SDMR0|sdmode) = 0;
+#endif
+
+#ifdef CONFIG_MOBILE_SDRAM
+	/* Mobile SDRAM Extended Mode Register */
+	sdemode = EMC_SDMR_SET_BA1 | EMC_SDMR_DS_FULL | EMC_SDMR_PRSR_ALL;
+#endif
+
+	/* Wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 2. Enable auto-refresh */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH;
+
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCNT = 0;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* Wait for number of auto-refresh cycles */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+ 	/* Stage 3. Mode Register Set */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET | EMC_DMCR_MBSEL_B0;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+
+#ifdef CONFIG_MOBILE_SDRAM
+	REG8(EMC_SDMR0|sdemode) = 0;   	/* Set Mobile SDRAM Extended Mode Register */
+#endif
+
+#if CONFIG_NR_DRAM_BANKS == 2
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET | EMC_DMCR_MBSEL_B1;
+	REG8(EMC_SDMR0|sdmode) = 0;	/* Set Bank1 SDRAM Register */
+
+
+#ifdef CONFIG_MOBILE_SDRAM
+	REG8(EMC_SDMR0|sdemode) = 0;	/* Set Mobile SDRAM Extended Mode Register */
+#endif
+
+#endif   /*CONFIG_NR_DRAM_BANKS == 2*/
+
+	/* Set back to basic DMCR value */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* everything is ok now */
+}
+
+#ifndef CONFIG_NAND_SPL
+
+static void calc_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = CFG_CPU_SPEED;
+	gd->sys_clk = gd->per_clk = gd->mem_clk = gd->dev_clk 
+		= CFG_EXTAL / CFG_DIV;
+#endif
+}
+
+static void rtc_init(void)
+{
+
+	while ( !__rtc_write_ready()) ;
+	__rtc_enable_alarm();	/* enable alarm */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_RGR   = 0x00007fff; /* type value */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HWFCR = 0x0000ffe0; /* Power on delay 2s */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HRCR  = 0x00000fe0; /* reset delay 125ms */
+
+}
+
+
+//----------------------------------------------------------------------
+// jz4750 board init routine
+
+int jz_board_init(void)
+{
+	board_early_init();  /* init gpio, pll etc. */
+#ifndef CONFIG_NAND_U_BOOT
+#ifndef CONFIG_FPGA
+	pll_init();          /* init PLL */
+#endif
+	serial_init();
+	sdram_init();        /* init sdram memory */
+#endif
+#if defined CONFIG_MSC_U_BOOT
+	pll_init();          /* init PLL */
+#endif
+	calc_clocks();       /* calc the clocks */
+#ifndef CONFIG_FPGA
+	rtc_init();		/* init rtc on any reset: */
+#endif
+	return 0;
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+long int initdram(int board_type)
+{
+	u32 dmcr;
+	u32 rows, cols, dw, banks;
+	ulong size;
+
+	dmcr = REG_EMC_DMCR;
+	rows = 11 + ((dmcr & EMC_DMCR_RA_MASK) >> EMC_DMCR_RA_BIT);
+	cols = 8 + ((dmcr & EMC_DMCR_CA_MASK) >> EMC_DMCR_CA_BIT);
+	dw = (dmcr & EMC_DMCR_BW) ? 2 : 4;
+	banks = (dmcr & EMC_DMCR_BA) ? 4 : 2;
+
+	size = (1 << (rows + cols)) * dw * banks;
+	size *= CONFIG_NR_DRAM_BANKS;
+
+	return size;
+}
+
+//----------------------------------------------------------------------
+// Timer routines
+
+#define TIMER_CHAN  0
+#define TIMER_FDATA 0xffff  /* Timer full data value */
+#define TIMER_HZ    CFG_HZ
+
+#define READ_TIMER  REG_TCU_TCNT(TIMER_CHAN)  /* macro to read the 16 bit timer */
+
+static ulong timestamp;
+static ulong lastdec;
+
+void	reset_timer_masked	(void);
+ulong	get_timer_masked	(void);
+void	udelay_masked		(unsigned long usec);
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	REG_TCU_TCSR(TIMER_CHAN) = TCU_TCSR_PRESCALE256 | TCU_TCSR_EXT_EN;
+	REG_TCU_TCNT(TIMER_CHAN) = 0;
+	REG_TCU_TDHR(TIMER_CHAN) = 0;
+	REG_TCU_TDFR(TIMER_CHAN) = TIMER_FDATA;
+
+	REG_TCU_TMSR = (1 << TIMER_CHAN) | (1 << (TIMER_CHAN + 16)); /* mask irqs */
+	REG_TCU_TSCR = (1 << TIMER_CHAN); /* enable timer clock */
+	REG_TCU_TESR = (1 << TIMER_CHAN); /* start counting up */
+
+	lastdec = 0;
+	timestamp = 0;
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void udelay (unsigned long usec)
+{
+	ulong tmo,tmp;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	}
+	else {
+		if (usec >= 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		}
+		else
+			tmo = 1;
+	}
+
+	/* check for rollover during this delay */
+	tmp = get_timer (0);
+	if ((tmp + tmo) < tmp )
+		reset_timer_masked();  /* timer would roll over */
+	else
+		tmo += tmp;
+
+	while (get_timer_masked () < tmo);
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;
+	timestamp = 0;
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;
+
+	if (lastdec <= now) {
+		/* normal mode */
+		timestamp += (now - lastdec);
+	} else {
+		/* we have an overflow ... */
+		timestamp += TIMER_FDATA + now - lastdec;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	} else {
+		if (usec > 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		} else {
+			tmo = 1;
+		}
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	return TIMER_HZ;
+}
+
+#endif /* CONFIG_NAND_SPL */
+
+//---------------------------------------------------------------------
+// End of timer routine.
+//---------------------------------------------------------------------
+
+#endif /* CONFIG_JZ4750 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4750_mmc.c u-boot-1.1.6/cpu/mips/jz4750_mmc.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4750_mmc.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4750_mmc.c	2008-12-12 22:35:17.000000000 +0800
@@ -0,0 +1,1420 @@
+/*
+ * (C) Copyright 2003
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h> 
+#include <common.h>
+#include <part.h>
+
+#ifdef CONFIG_JZ4750
+
+#include <asm-mips/jz4750.h>
+#include "jz_mmc.h"
+
+#define CFG_MMC_BASE		0x80600000
+static int sd2_0 = 0;
+/*
+ * GPIO definition
+ */
+
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD0_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD0_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD0_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD0_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected()			\
+({						\
+	int detected = 1;			\
+	__gpio_as_input(GPIO_SD0_CD_N);		\
+	if (__gpio_get_pin(GPIO_SD0_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+/*
+ * Local functions
+ */
+#ifdef CONFIG_MMC
+extern int
+fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+
+static block_dev_desc_t mmc_dev;
+
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/*
+ * FIXME needs to read cid and csd info to determine block size
+ * and other parameters
+ */
+static uchar mmc_buf[MMC_BLOCK_SIZE];
+static int mmc_ready = 0;
+static mmc_csd_t mmc_csd;
+static int use_4bit;                    /* Use 4-bit data bus */
+/***********************************************************************
+ *  MMC Events
+ */
+#define MMC_EVENT_NONE	        0x00	/* No events */
+#define MMC_EVENT_RX_DATA_DONE	0x01	/* Rx data done */
+#define MMC_EVENT_TX_DATA_DONE	0x02	/* Tx data done */
+#define MMC_EVENT_PROG_DONE	0x04	/* Programming is done */
+
+
+#define MMC_IRQ_MASK()				\
+do {						\
+      	REG_MSC_IMASK = 0xffff;			\
+      	REG_MSC_IREG = 0xffff;			\
+} while (0)
+
+/* Stop the MMC clock and wait while it happens */
+static inline int jz_mmc_stop_clock(void)
+{
+	int timeout = 1000;
+	
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;
+
+	while (timeout && (REG_MSC_STAT & MSC_STAT_CLK_EN)) {
+		timeout--;
+		if (timeout == 0) {
+			return MMC_ERROR_TIMEOUT;
+		}
+		udelay(1);
+	}
+        return MMC_NO_ERROR;
+}
+
+/* Start the MMC clock and operation */
+static inline int jz_mmc_start_clock(void)
+{
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START | MSC_STRPCL_START_OP;
+	return MMC_NO_ERROR;
+}
+
+static inline u32 jz_mmc_calc_clkrt(int is_sd, u32 rate)
+{
+	u32 clkrt;
+	u32 clk_src = is_sd ? 24000000: 16000000;
+
+	clkrt = 0;
+  	while (rate < clk_src)
+    	{
+      		clkrt ++;
+      		clk_src >>= 1;
+    	}
+	return clkrt;
+}
+/* Set the MMC clock frequency */
+void jz_mmc_set_clock(int sd, u32 rate)
+{
+	jz_mmc_stop_clock();
+
+	/* Select clock source of MSC */
+	__cpm_select_msc_clk(0, 1);
+
+	/* Set clock dividor of MSC */
+	REG_MSC_CLKRT = jz_mmc_calc_clkrt(sd, rate);
+}
+
+static int jz_mmc_check_status(struct mmc_request *request)
+{
+	u32 status = REG_MSC_STAT;
+
+	/* Checking for response or data timeout */
+	if (status & (MSC_STAT_TIME_OUT_RES | MSC_STAT_TIME_OUT_READ)) {
+		printf("MMC/SD timeout, MMC_STAT 0x%x CMD %d\n", status, request->cmd);
+		return MMC_ERROR_TIMEOUT;
+	}
+
+	/* Checking for CRC error */
+	if (status & (MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR | MSC_STAT_CRC_RES_ERR)) {
+		printf("MMC/CD CRC error, MMC_STAT 0x%x\n", status);
+		return MMC_ERROR_CRC;
+	}
+
+	return MMC_NO_ERROR;
+}
+
+/* Obtain response to the command and store it to response buffer */
+static void jz_mmc_get_response(struct mmc_request *request)
+{
+	int i;
+	u8 *buf;
+	u32 data;
+
+	DEBUG(3, "fetch response for request %d, cmd %d\n", request->rtype, request->cmd);
+
+	buf = request->response;
+	request->result = MMC_NO_ERROR;
+
+	switch (request->rtype) {
+	case RESPONSE_R1: case RESPONSE_R1B: case RESPONSE_R6:
+	case RESPONSE_R3: case RESPONSE_R4: case RESPONSE_R5:
+	{
+		data = REG_MSC_RES;
+		buf[0] = (data >> 8) & 0xff;
+		buf[1] = data & 0xff;
+		data = REG_MSC_RES;
+		buf[2] = (data >> 8) & 0xff;
+		buf[3] = data & 0xff;
+		data = REG_MSC_RES;
+		buf[4] = data & 0xff;
+
+		DEBUG(3, "request %d, response [%02x %02x %02x %02x %02x]\n",
+		      request->rtype, buf[0], buf[1], buf[2], buf[3], buf[4]);
+		break;
+	}
+	case RESPONSE_R2_CID: case RESPONSE_R2_CSD:
+	{
+		for (i = 0; i < 16; i += 2) {
+			data = REG_MSC_RES;
+			buf[i] = (data >> 8) & 0xff;
+			buf[i+1] = data & 0xff;
+		}
+		DEBUG(3, "request %d, response [", request->rtype);
+#if CONFIG_MMC_DEBUG_VERBOSE > 2
+		if (g_mmc_debug >= 3) {
+			int n;
+			for (n = 0; n < 17; n++)
+				printk("%02x ", buf[n]);
+			printk("]\n");
+		}
+#endif
+		break;
+	}
+	case RESPONSE_NONE:
+		DEBUG(3, "No response\n");
+		break;
+		
+	default:
+		DEBUG(3, "unhandled response type for request %d\n", request->rtype);
+		break;
+	}
+}
+
+static int jz_mmc_receive_data(struct mmc_request *req)
+{
+	u32  stat, timeout, data, cnt;
+	u8 *buf = req->buffer;
+	u32 wblocklen = (u32)(req->block_len + 3) >> 2; /* length in word */
+	
+	timeout = 0x3ffffff;
+	
+	while (timeout) {
+		timeout--;
+		stat = REG_MSC_STAT;
+		
+		if (stat & MSC_STAT_TIME_OUT_READ)
+			return MMC_ERROR_TIMEOUT;
+		else if (stat & MSC_STAT_CRC_READ_ERROR)
+			return MMC_ERROR_CRC;
+		else if (!(stat & MSC_STAT_DATA_FIFO_EMPTY) 
+			 || (stat & MSC_STAT_DATA_FIFO_AFULL)) {
+			/* Ready to read data */
+			break;
+		}
+		udelay(1);
+	}
+	if (!timeout)
+		return MMC_ERROR_TIMEOUT;
+	
+	/* Read data from RXFIFO. It could be FULL or PARTIAL FULL */
+	cnt = wblocklen;
+	while (cnt) {
+		data = REG_MSC_RXFIFO;
+		{
+			*buf++ = (u8)(data >> 0);
+			*buf++ = (u8)(data >> 8);
+			*buf++ = (u8)(data >> 16);
+			*buf++ = (u8)(data >> 24);
+		}
+		cnt --;
+		while (cnt && (REG_MSC_STAT & MSC_STAT_DATA_FIFO_EMPTY))
+			;
+	}
+	return MMC_NO_ERROR;
+}
+
+static int jz_mmc_transmit_data(struct mmc_request *req)
+{
+#if 0
+	u32 nob = req->nob;
+	u32 wblocklen = (u32)(req->block_len + 3) >> 2; /* length in word */
+	u8 *buf = req->buffer;
+	u32 *wbuf = (u32 *)buf;
+	u32 waligned = (((u32)buf & 0x3) == 0); /* word aligned ? */
+	u32 stat, timeout, data, cnt;
+
+	for (nob; nob >= 1; nob--) {
+		timeout = 0x3FFFFFF;
+
+		while (timeout) {
+			timeout--;
+			stat = REG_MSC_STAT;
+
+			if (stat & (MSC_STAT_CRC_WRITE_ERROR | MSC_STAT_CRC_WRITE_ERROR_NOSTS))
+				return MMC_ERROR_CRC;
+			else if (!(stat & MSC_STAT_DATA_FIFO_FULL)) {
+				/* Ready to write data */
+				break;
+			}
+
+			udelay(1);
+		}
+
+		if (!timeout)
+			return MMC_ERROR_TIMEOUT;
+
+		/* Write data to TXFIFO */
+		cnt = wblocklen;
+		while (cnt) {
+			while (REG_MSC_STAT & MSC_STAT_DATA_FIFO_FULL)
+				;
+
+			if (waligned) {
+				REG_MSC_TXFIFO = *wbuf++;
+			}
+			else {
+				data = *buf++ | (*buf++ << 8) | (*buf++ << 16) | (*buf++ << 24);
+				REG_MSC_TXFIFO = data;
+			}
+
+			cnt--;
+		}
+	}
+#endif
+	return MMC_NO_ERROR;
+}
+
+
+/********************************************************************************************************************
+** Name:	  int jz_mmc_exec_cmd()
+** Function:      send command to the card, and get a response
+** Input:	  struct mmc_request *req	: MMC/SD request
+** Output:	  0:  right		>0:  error code
+********************************************************************************************************************/
+int jz_mmc_exec_cmd(struct mmc_request *request)
+{
+	u32 cmdat = 0, events = 0;
+	int retval, timeout = 0x3fffff;
+
+	/* Indicate we have no result yet */
+	request->result = MMC_NO_RESPONSE;
+	if (request->cmd == MMC_CIM_RESET) {
+		/* On reset, 1-bit bus width */
+		use_4bit = 0;
+
+		/* Reset MMC/SD controller */
+		__msc_reset();
+
+		/* On reset, drop MMC clock down */
+		jz_mmc_set_clock(0, MMC_CLOCK_SLOW);
+
+		/* On reset, stop MMC clock */
+		jz_mmc_stop_clock();
+	}
+	if (request->cmd == MMC_SEND_OP_COND) {
+		DEBUG(3, "Have an MMC card\n");
+		/* always use 1bit for MMC */
+		use_4bit = 0;
+	}
+	if (request->cmd == SET_BUS_WIDTH) {
+		if (request->arg == 0x2) {
+			DEBUG(2, "Use 4-bit bus width\n");
+			use_4bit = 1;
+		}
+		else {
+			DEBUG(2, "Use 1-bit bus width\n");
+			use_4bit = 0;
+		}
+	}
+
+	/* stop clock */
+	jz_mmc_stop_clock();
+
+	/* mask all interrupts */
+	REG_MSC_IMASK = 0xffff;
+
+	/* clear status */
+	REG_MSC_IREG = 0xffff;
+
+	/* use 4-bit bus width when possible */
+	if (use_4bit)
+		cmdat |= MSC_CMDAT_BUS_WIDTH_4BIT;
+
+        /* Set command type and events */ 
+	switch (request->cmd) {
+	/* MMC core extra command */
+	case MMC_CIM_RESET:
+		cmdat |= MSC_CMDAT_INIT; /* Initialization sequence sent prior to command */
+		break;
+
+	/* bc - broadcast - no response */
+	case MMC_GO_IDLE_STATE:
+	case MMC_SET_DSR:
+		break;
+
+	/* bcr - broadcast with response */
+	case MMC_SEND_OP_COND:
+	case MMC_ALL_SEND_CID:
+	case MMC_GO_IRQ_STATE:
+		break;
+
+	/* adtc - addressed with data transfer */
+	case MMC_READ_DAT_UNTIL_STOP:
+	case MMC_READ_SINGLE_BLOCK:
+	case MMC_READ_MULTIPLE_BLOCK:
+	case SEND_SCR:
+		cmdat |= MSC_CMDAT_DATA_EN | MSC_CMDAT_READ;
+		events = MMC_EVENT_RX_DATA_DONE;
+		break;
+
+	case MMC_WRITE_DAT_UNTIL_STOP:
+	case MMC_WRITE_BLOCK:
+	case MMC_WRITE_MULTIPLE_BLOCK:
+	case MMC_PROGRAM_CID:
+	case MMC_PROGRAM_CSD:
+	case MMC_SEND_WRITE_PROT:
+	case MMC_GEN_CMD:
+	case MMC_LOCK_UNLOCK:
+		cmdat |= MSC_CMDAT_DATA_EN | MSC_CMDAT_WRITE;
+		events = MMC_EVENT_TX_DATA_DONE | MMC_EVENT_PROG_DONE;
+
+		break;
+
+	case MMC_STOP_TRANSMISSION:
+		events = MMC_EVENT_PROG_DONE;
+		break;
+
+	/* ac - no data transfer */
+	default: 
+		break;
+	}
+
+	/* Set response type */
+	switch (request->rtype) {
+	case RESPONSE_NONE:
+		break;
+
+	case RESPONSE_R1B:
+		cmdat |= MSC_CMDAT_BUSY;
+		/*FALLTHRU*/
+	case RESPONSE_R1:
+		cmdat |= MSC_CMDAT_RESPONSE_R1;
+		break;
+	case RESPONSE_R2_CID:
+	case RESPONSE_R2_CSD:
+		cmdat |= MSC_CMDAT_RESPONSE_R2;
+		break;
+	case RESPONSE_R3:
+		cmdat |= MSC_CMDAT_RESPONSE_R3;
+		break;
+	case RESPONSE_R4:
+		cmdat |= MSC_CMDAT_RESPONSE_R4;
+		break;
+	case RESPONSE_R5:
+		cmdat |= MSC_CMDAT_RESPONSE_R5;
+		break;
+	case RESPONSE_R6:
+		cmdat |= MSC_CMDAT_RESPONSE_R6;
+		break;
+	default:
+		break;
+	}
+
+	/* Set command index */
+	if (request->cmd == MMC_CIM_RESET) {
+		REG_MSC_CMD = MMC_GO_IDLE_STATE;
+	} else {
+		REG_MSC_CMD = request->cmd;
+	}
+
+        /* Set argument */
+	REG_MSC_ARG = request->arg;
+
+	/* Set block length and nob */
+	if (request->cmd == SEND_SCR) { /* get SCR from DataFIFO */
+		REG_MSC_BLKLEN = 8;
+		REG_MSC_NOB = 1;
+	} else {
+		REG_MSC_BLKLEN = request->block_len;
+		REG_MSC_NOB = request->nob;
+	}
+
+	/* Set command */
+	REG_MSC_CMDAT = cmdat;
+
+	DEBUG(1, "Send cmd %d cmdat: %x arg: %x resp %d\n", request->cmd,
+	      cmdat, request->arg, request->rtype);
+
+        /* Start MMC/SD clock and send command to card */
+	jz_mmc_start_clock();
+
+	/* Wait for command completion */
+	while (timeout-- && !(REG_MSC_STAT & MSC_STAT_END_CMD_RES))
+		;
+
+	if (timeout == 0)
+		return MMC_ERROR_TIMEOUT;
+
+	REG_MSC_IREG = MSC_IREG_END_CMD_RES; /* clear flag */
+
+	/* Check for status */
+	retval = jz_mmc_check_status(request);
+	if (retval) {
+		return retval;
+	}
+
+	/* Complete command with no response */
+	if (request->rtype == RESPONSE_NONE) {
+		return MMC_NO_ERROR;
+	}
+
+	/* Get response */
+	jz_mmc_get_response(request);
+
+	/* Start data operation */
+	if (events & (MMC_EVENT_RX_DATA_DONE | MMC_EVENT_TX_DATA_DONE)) {
+		if (events & MMC_EVENT_RX_DATA_DONE) {
+			if (request->cmd == SEND_SCR) {
+				/* SD card returns SCR register as data. 
+				   MMC core expect it in the response buffer, 
+				   after normal response. */
+				request->buffer = (u8 *)((u32)request->response + 5);
+			}
+			jz_mmc_receive_data(request);
+		}
+		
+		if (events & MMC_EVENT_TX_DATA_DONE) {
+			jz_mmc_transmit_data(request);
+		}
+		
+		/* Wait for Data Done */
+		while (!(REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE))
+			;
+		REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE; /* clear status */
+	}
+
+	/* Wait for Prog Done event */
+	if (events & MMC_EVENT_PROG_DONE) {
+		while (!(REG_MSC_IREG & MSC_IREG_PRG_DONE))
+			;
+		REG_MSC_IREG = MSC_IREG_PRG_DONE; /* clear status */
+	}
+
+	/* Command completed */
+
+	return MMC_NO_ERROR;			 /* return successfully */
+}
+
+/****************************************************/
+int mmc_block_read(u8 *dst, ulong src, ulong len)
+/****************************************************/
+{
+
+	struct mmc_request request;
+	struct mmc_response_r1 r1;
+	int retval; 
+
+	if (len == 0) {
+		return 0;
+	}
+	mmc_simple_cmd(&request, MMC_SEND_STATUS, mmcinfo.rca, RESPONSE_R1);
+	retval = mmc_unpack_r1(&request, &r1, 0);
+	if (retval && (retval != MMC_ERROR_STATE_MISMATCH)) {
+		return retval;
+	}
+
+	mmc_simple_cmd(&request, MMC_SET_BLOCKLEN, len, RESPONSE_R1);
+	if ((retval = mmc_unpack_r1(&request, &r1, 0))) {
+		return retval;
+	}
+
+	if (sd2_0)
+		src /= len;
+	
+	mmc_send_cmd(&request, MMC_READ_SINGLE_BLOCK, src, 1,len, RESPONSE_R1, dst);
+	if ((retval = mmc_unpack_r1(&request, &r1, 0))) {
+		return retval;
+	}
+	return retval;
+}
+
+/****************************************************/
+int mmc_block_write(ulong dst, uchar *src, int len)
+/****************************************************/
+{
+	return 0;
+}
+
+/****************************************************/
+int mmc_read(ulong src, uchar *dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("MMC card is not ready\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	src -= CFG_MMC_BASE;
+	end = src + size;
+	part_start = ~mmc_block_address & src;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & src;
+	aligned_end = mmc_block_address & end;
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf+part_start, part_len);
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+
+		if ((mmc_block_read((uchar *)(dst), src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+
+	if (part_end && src < end) {
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf, part_end);
+	}
+	return 0;
+
+}
+
+/****************************************************/
+int mmc_write(uchar *src, ulong dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+	
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("MMC card is not ready\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	dst -= CFG_MMC_BASE;
+	end = dst + size;
+	part_start = ~mmc_block_address & dst;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & dst;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		(ulong)src, dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf+part_start, src, part_len);
+		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_write(dst, (uchar *)src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && dst < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf, src, part_end);
+		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/****************************************************/
+ulong mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
+/****************************************************/
+{
+	ulong src;
+	int mmc_block_size = MMC_BLOCK_SIZE;
+
+	src = blknr * mmc_block_size + CFG_MMC_BASE;
+	mmc_read(src, (uchar *)dst, blkcnt*mmc_block_size);
+	return blkcnt;
+}
+
+int mmc_select_card(void)
+{
+	struct mmc_request request;
+	struct mmc_response_r1 r1;
+	int retval;
+
+	mmc_simple_cmd(&request, MMC_SELECT_CARD, mmcinfo.rca, RESPONSE_R1B);
+	retval = mmc_unpack_r1(&request, &r1, 0);
+	if (retval) {
+		return retval;
+	}
+
+	if (mmcinfo.sd) {
+		mmc_simple_cmd(&request, MMC_APP_CMD,  mmcinfo.rca, RESPONSE_R1);
+		retval = mmc_unpack_r1(&request,&r1,0);
+		if (retval) {
+			return retval;
+		}
+		mmc_simple_cmd(&request, SET_BUS_WIDTH, 2, RESPONSE_R1);
+                retval = mmc_unpack_r1(&request,&r1,0);
+                if (retval) {
+			return retval;
+		}
+	}
+	return 0;
+}
+
+/******************************************************************
+ *
+ * Configure card
+ *
+ ******************************************************************/
+
+static void mmc_configure_card(void)
+{
+	u32 rate;
+
+	/* Get card info */
+	if (sd2_0)
+		mmcinfo.block_num = (mmcinfo.csd.c_size + 1) << 10;
+	else
+		mmcinfo.block_num = (mmcinfo.csd.c_size + 1) * (1 << (mmcinfo.csd.c_size_mult + 2));
+
+	mmcinfo.block_len = 1 << mmcinfo.csd.read_bl_len;
+
+	/* Fix the clock rate */
+	rate = mmc_tran_speed(mmcinfo.csd.tran_speed);
+	if (rate < MMC_CLOCK_SLOW)
+		rate = MMC_CLOCK_SLOW;
+	if ((mmcinfo.sd == 0) && (rate > MMC_CLOCK_FAST))
+		rate = MMC_CLOCK_FAST;
+        if ((mmcinfo.sd) && (rate > SD_CLOCK_FAST))
+		rate = SD_CLOCK_FAST;
+
+	DEBUG(2,"mmc_configure_card: block_len=%d block_num=%d rate=%d\n", mmcinfo.block_len, mmcinfo.block_num, rate);
+
+	jz_mmc_set_clock(mmcinfo.sd, rate);
+}
+
+/******************************************************************
+ *
+ * State machine routines to initialize card(s)
+ *
+ ******************************************************************/
+
+/*
+  CIM_SINGLE_CARD_ACQ  (frequency at 400 kHz)
+  --- Must enter from GO_IDLE_STATE ---
+  1. SD_SEND_OP_COND (SD Card) [CMD55] + [CMD41]
+  2. SEND_OP_COND (Full Range) [CMD1]   {optional}
+  3. SEND_OP_COND (Set Range ) [CMD1]
+     If busy, delay and repeat step 2
+  4. ALL_SEND_CID              [CMD2]
+     If timeout, set an error (no cards found)
+  5. SET_RELATIVE_ADDR         [CMD3]
+  6. SEND_CSD                  [CMD9]
+  7. SET_DSR                   [CMD4]    Only call this if (csd.dsr_imp).
+  8. Set clock frequency (check available in csd.tran_speed)
+ */
+
+#define MMC_INIT_DOING   0
+#define MMC_INIT_PASSED  1
+#define MMC_INIT_FAILED  2
+
+static int mmc_init_card_state(struct mmc_request *request)
+{
+	struct mmc_response_r1 r1;
+	struct mmc_response_r3 r3;
+	int retval;
+	int ocr = 0x40300000;
+	int limit_41 = 0;
+
+	DEBUG(2,"mmc_init_card_state\n");
+
+	switch (request->cmd) {
+	case MMC_GO_IDLE_STATE: /* No response to parse */
+		if (mmcinfo.sd)
+			mmc_simple_cmd(request, 8, 0x1aa, RESPONSE_R1);
+		else
+			mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+		break;
+
+	case 8:
+        	retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+		mmc_simple_cmd(request, MMC_APP_CMD,  0, RESPONSE_R1);
+		break;
+
+        case MMC_APP_CMD:
+        	retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+		if (retval & (limit_41 < 100)) {
+			DEBUG(0, "mmc_init_card_state: unable to MMC_APP_CMD error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			limit_41++;
+			mmc_simple_cmd(request, SD_SEND_OP_COND, ocr, RESPONSE_R3);
+		} else if (limit_41 < 100) {
+			limit_41++;		
+			mmc_simple_cmd(request, SD_SEND_OP_COND, ocr, RESPONSE_R3);
+		} else{
+			/* reset the card to idle*/
+			mmc_simple_cmd(request, MMC_GO_IDLE_STATE, 0, RESPONSE_NONE);
+			mmcinfo.sd = 0;
+		}
+		break;
+
+        case SD_SEND_OP_COND:
+                retval = mmc_unpack_r3(request, &r3);
+                if (retval) {
+                  /* Try MMC card */
+                    mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+                    break;
+		}
+
+                DEBUG(2,"mmc_init_card_state: read ocr value = 0x%08x\n", r3.ocr);
+		
+		if(!(r3.ocr & MMC_CARD_BUSY || ocr == 0)){
+			udelay(10000);
+			mmc_simple_cmd(request, MMC_APP_CMD, 0, RESPONSE_R1);
+		}
+		else {
+		  /* Set the data bus width to 4 bits */
+                  mmcinfo.sd = 1; /* SD Card ready */
+                  mmcinfo.state = CARD_STATE_READY;
+		  mmc_simple_cmd(request, MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID);
+		}
+		break;
+
+	case MMC_SEND_OP_COND:
+		retval = mmc_unpack_r3(request, &r3);
+		if (retval) {
+			DEBUG(0,"mmc_init_card_state: failed SEND_OP_COND error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+
+		DEBUG(2,"mmc_init_card_state: read ocr value = 0x%08x\n", r3.ocr);
+		if (!(r3.ocr & MMC_CARD_BUSY)) {
+	                mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+		}
+		else {
+		        mmcinfo.sd = 0; /* MMC Card ready */
+			mmcinfo.state = CARD_STATE_READY;
+			mmc_simple_cmd(request, MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID);
+		}
+		break;
+		
+	case MMC_ALL_SEND_CID: 
+		retval = mmc_unpack_cid( request, &mmcinfo.cid );
+		mmc_dev.if_type = IF_TYPE_MMC;
+		mmc_dev.part_type = PART_TYPE_DOS;
+		mmc_dev.dev = 0;
+		mmc_dev.lun = 0;
+		mmc_dev.type = 0;
+		/* FIXME fill in the correct size (is set to 32MByte) */
+		mmc_dev.blksz = 512;
+		mmc_dev.lba = 0x10000;
+		mmc_dev.removable = 0;
+		
+		/*FIXME:ignore CRC error for CMD2/CMD9/CMD10 */
+		if ( retval && (retval != MMC_ERROR_CRC)) {
+			DEBUG(0,"mmc_init_card_state: unable to ALL_SEND_CID error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		mmcinfo.state = CARD_STATE_IDENT;
+		if(mmcinfo.sd)
+			mmc_simple_cmd(request, MMC_SET_RELATIVE_ADDR, 0, RESPONSE_R6);
+                else
+			mmc_simple_cmd(request, MMC_SET_RELATIVE_ADDR, ID_TO_RCA(mmcinfo.id) << 16, RESPONSE_R1);
+		break;
+
+        case MMC_SET_RELATIVE_ADDR:
+	        if (mmcinfo.sd)	{
+			retval = mmc_unpack_r6(request, &r1, mmcinfo.state, &mmcinfo.rca);
+			mmcinfo.rca = mmcinfo.rca << 16; 
+			DEBUG(2, "mmc_init_card_state: Get RCA from SD: 0x%04x Status: %x\n", mmcinfo.rca, r1.status);
+                } else {
+			retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+			mmcinfo.rca = ID_TO_RCA(mmcinfo.id) << 16;
+	        }
+		if (retval) {
+			DEBUG(0, "mmc_init_card_state: unable to SET_RELATIVE_ADDR error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		
+		mmcinfo.state = CARD_STATE_STBY;
+                mmc_simple_cmd(request, MMC_SEND_CSD, mmcinfo.rca, RESPONSE_R2_CSD);
+		
+		break;
+        
+	case MMC_SEND_CSD:
+		retval = mmc_unpack_csd(request, &mmcinfo.csd);
+			mmc_csd_t *csd = (mmc_csd_t *)retval;
+			memcpy(&mmc_csd, csd, sizeof(csd));
+			mmc_ready = 1;
+
+			printf("MMC card is ready\n");
+			/* FIXME add verbose printout for csd */
+                
+		/*FIXME:ignore CRC error for CMD2/CMD9/CMD10 */
+	        if (retval && (retval != MMC_ERROR_CRC)) {
+			DEBUG(0, "mmc_init_card_state: unable to SEND_CSD error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		if (mmcinfo.csd.dsr_imp) {
+			DEBUG(0, "mmc_init_card_state: driver doesn't support setting DSR\n");
+		}
+		mmc_configure_card();
+		return MMC_INIT_PASSED;
+		
+	default:
+		DEBUG(0, "mmc_init_card_state: error!  Illegal last cmd %d\n", request->cmd);
+		return MMC_INIT_FAILED;
+	}
+
+	return MMC_INIT_DOING;
+}
+
+int mmc_init_card(void)
+{
+	struct mmc_request request;
+	int retval;
+
+	mmc_simple_cmd(&request, MMC_CIM_RESET, 0, RESPONSE_NONE); /* reset card */
+	mmc_simple_cmd(&request, MMC_GO_IDLE_STATE, 0, RESPONSE_NONE);
+	mmcinfo.sd = 1;  /* assuming a SD card */
+
+	while ((retval = mmc_init_card_state(&request)) == MMC_INIT_DOING)
+		;
+
+	if (retval == MMC_INIT_PASSED)
+		return MMC_NO_ERROR;
+	else
+		return MMC_NO_RESPONSE;
+}
+
+/****************************************************/
+/****************************************************/
+
+int mmc_init(int verbose)
+{
+	if (!__msc_card_detected())
+		return 1;
+	
+	printf("MMC/SD card found\n");
+ 
+	// Step-1: init GPIO
+	__gpio_as_msc0_8bit();
+
+	__msc_init_io();
+
+	// Step-2: turn on power of card
+	__msc_enable_power();
+
+	// Step-3: Reset MSC Controller.
+	__msc_reset();
+
+	// Step-3: mask all IRQs.
+	MMC_IRQ_MASK();	
+
+	// Step-4: stop MMC/SD clock
+	jz_mmc_stop_clock();
+	mmc_init_card();
+	mmc_select_card();
+
+	mmc_dev.block_read = mmc_bread; 
+	fat_register_device(&mmc_dev,1); /* partitions start counting with 1 */
+
+	return 0;
+}
+
+int mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+
+int mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000) {
+	return 1; 
+	} 
+	return 0;
+}
+/**************************************************************************
+ * Debugging functions
+ **************************************************************************/
+
+static char * mmc_result_strings[] = {
+	"NO_RESPONSE",
+	"NO_ERROR",
+	"ERROR_OUT_OF_RANGE",
+	"ERROR_ADDRESS",
+	"ERROR_BLOCK_LEN",
+	"ERROR_ERASE_SEQ",
+	"ERROR_ERASE_PARAM",
+	"ERROR_WP_VIOLATION",
+	"ERROR_CARD_IS_LOCKED",
+	"ERROR_LOCK_UNLOCK_FAILED",
+	"ERROR_COM_CRC",
+	"ERROR_ILLEGAL_COMMAND",
+	"ERROR_CARD_ECC_FAILED",
+	"ERROR_CC",
+	"ERROR_GENERAL",
+	"ERROR_UNDERRUN",
+	"ERROR_OVERRUN",
+	"ERROR_CID_CSD_OVERWRITE",
+	"ERROR_STATE_MISMATCH",
+	"ERROR_HEADER_MISMATCH",
+	"ERROR_TIMEOUT",
+	"ERROR_CRC",
+	"ERROR_DRIVER_FAILURE",
+};
+
+char * mmc_result_to_string(int i)
+{
+	return mmc_result_strings[i+1];
+}
+
+static char * card_state_strings[] = {
+	"empty",
+	"idle",
+	"ready",
+	"ident",
+	"stby",
+	"tran",
+	"data",
+	"rcv",
+	"prg",
+	"dis",
+};
+
+static inline char * card_state_to_string(int i)
+{
+	return card_state_strings[i+1];
+}
+
+/**************************************************************************
+ * Utility functions
+ **************************************************************************/
+
+#define PARSE_U32(_buf,_index) \
+	(((u32)_buf[_index]) << 24) | (((u32)_buf[_index+1]) << 16) | \
+        (((u32)_buf[_index+2]) << 8) | ((u32)_buf[_index+3]);
+
+#define PARSE_U16(_buf,_index) \
+	(((u16)_buf[_index]) << 8) | ((u16)_buf[_index+1]);
+
+int mmc_unpack_csd(struct mmc_request *request, struct mmc_csd *csd)
+{
+	u8 *buf = request->response;
+	int num = 0;
+	
+	if (request->result)
+		return request->result;
+
+	csd->csd_structure      = (buf[1] & 0xc0) >> 6;
+	if (csd->csd_structure)
+		sd2_0 = 1;
+	else
+		sd2_0 = 0;
+	
+	switch (csd->csd_structure) {
+	case 0 :
+		csd->taac               = buf[2];
+		csd->nsac               = buf[3];
+		csd->tran_speed         = buf[4];
+		csd->ccc                = (((u16)buf[5]) << 4) | ((buf[6] & 0xf0) >> 4);
+		csd->read_bl_len        = buf[6] & 0x0f;
+		/* for support 2GB card*/
+		if (csd->read_bl_len >= 10) 
+		{
+			num = csd->read_bl_len - 9;
+			csd->read_bl_len = 9;
+		}
+		
+		csd->read_bl_partial    = (buf[7] & 0x80) ? 1 : 0;
+		csd->write_blk_misalign = (buf[7] & 0x40) ? 1 : 0;
+		csd->read_blk_misalign  = (buf[7] & 0x20) ? 1 : 0;
+		csd->dsr_imp            = (buf[7] & 0x10) ? 1 : 0;
+		csd->c_size             = ((((u16)buf[7]) & 0x03) << 10) | (((u16)buf[8]) << 2) | (((u16)buf[9]) & 0xc0) >> 6;
+
+		if (num)
+			csd->c_size = csd->c_size << num;
+		
+		
+		csd->vdd_r_curr_min     = (buf[9] & 0x38) >> 3;
+		csd->vdd_r_curr_max     = buf[9] & 0x07;
+		csd->vdd_w_curr_min     = (buf[10] & 0xe0) >> 5;
+		csd->vdd_w_curr_max     = (buf[10] & 0x1c) >> 2;
+		csd->c_size_mult        = ((buf[10] & 0x03) << 1) | ((buf[11] & 0x80) >> 7);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			csd->erase.v22.sector_size    = (buf[11] & 0x7c) >> 2;
+			csd->erase.v22.erase_grp_size = ((buf[11] & 0x03) << 3) | ((buf[12] & 0xe0) >> 5);
+
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			csd->erase.v31.erase_grp_size = (buf[11] & 0x7c) >> 2;
+			csd->erase.v31.erase_grp_mult = ((buf[11] & 0x03) << 3) | ((buf[12] & 0xe0) >> 5);
+			break;
+		}
+		csd->wp_grp_size        = buf[12] & 0x1f;
+		csd->wp_grp_enable      = (buf[13] & 0x80) ? 1 : 0;
+		csd->default_ecc        = (buf[13] & 0x60) >> 5;
+		csd->r2w_factor         = (buf[13] & 0x1c) >> 2;
+		csd->write_bl_len       = ((buf[13] & 0x03) << 2) | ((buf[14] & 0xc0) >> 6);
+		if (csd->write_bl_len >= 10)
+			csd->write_bl_len = 9;
+		
+		csd->write_bl_partial   = (buf[14] & 0x20) ? 1 : 0;
+		csd->file_format_grp    = (buf[15] & 0x80) ? 1 : 0;
+		csd->copy               = (buf[15] & 0x40) ? 1 : 0;
+		csd->perm_write_protect = (buf[15] & 0x20) ? 1 : 0;
+		csd->tmp_write_protect  = (buf[15] & 0x10) ? 1 : 0;
+		csd->file_format        = (buf[15] & 0x0c) >> 2;
+		csd->ecc                = buf[15] & 0x03;
+		
+		DEBUG(2,"  csd_structure=%d  spec_vers=%d  taac=%02x  nsac=%02x  tran_speed=%02x\n"
+		      "  ccc=%04x  read_bl_len=%d  read_bl_partial=%d  write_blk_misalign=%d\n"
+		      "  read_blk_misalign=%d  dsr_imp=%d  c_size=%d  vdd_r_curr_min=%d\n"
+		      "  vdd_r_curr_max=%d  vdd_w_curr_min=%d  vdd_w_curr_max=%d  c_size_mult=%d\n"
+		      "  wp_grp_size=%d  wp_grp_enable=%d  default_ecc=%d  r2w_factor=%d\n"
+		      "  write_bl_len=%d  write_bl_partial=%d  file_format_grp=%d  copy=%d\n"
+		      "  perm_write_protect=%d  tmp_write_protect=%d  file_format=%d  ecc=%d\n",
+		      csd->csd_structure, csd->spec_vers, 
+		      csd->taac, csd->nsac, csd->tran_speed,
+		      csd->ccc, csd->read_bl_len, 
+		      csd->read_bl_partial, csd->write_blk_misalign,
+		      csd->read_blk_misalign, csd->dsr_imp, 
+		      csd->c_size, csd->vdd_r_curr_min,
+		      csd->vdd_r_curr_max, csd->vdd_w_curr_min, 
+		      csd->vdd_w_curr_max, csd->c_size_mult,
+		      csd->wp_grp_size, csd->wp_grp_enable,
+		      csd->default_ecc, csd->r2w_factor, 
+		      csd->write_bl_len, csd->write_bl_partial,
+		      csd->file_format_grp, csd->copy, 
+		      csd->perm_write_protect, csd->tmp_write_protect,
+		      csd->file_format, csd->ecc);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			DEBUG(2," V22 sector_size=%d erase_grp_size=%d\n", 
+			      csd->erase.v22.sector_size, 
+			      csd->erase.v22.erase_grp_size);
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			DEBUG(2," V31 erase_grp_size=%d erase_grp_mult=%d\n", 
+			      csd->erase.v31.erase_grp_size,
+			      csd->erase.v31.erase_grp_mult);
+			break;
+			
+		}
+		break;	
+		
+	case 1 :
+		csd->taac               = 0;
+		csd->nsac               = 0;
+		csd->tran_speed         = buf[4];
+		csd->ccc                = (((u16)buf[5]) << 4) | ((buf[6] & 0xf0) >> 4);
+
+		csd->read_bl_len        = 9;
+		csd->read_bl_partial    = 0;
+		csd->write_blk_misalign = 0;
+		csd->read_blk_misalign  = 0;
+		csd->dsr_imp            = (buf[7] & 0x10) ? 1 : 0;
+		csd->c_size             = ((((u16)buf[8]) & 0x3f) << 16) | (((u16)buf[9]) << 8) | ((u16)buf[10]) ;
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			csd->erase.v22.sector_size    = 0x7f;
+			csd->erase.v22.erase_grp_size = 0;
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			csd->erase.v31.erase_grp_size = 0x7f;
+			csd->erase.v31.erase_grp_mult = 0;
+			break;
+		}
+		csd->wp_grp_size        = 0;
+		csd->wp_grp_enable      = 0;
+		csd->default_ecc        = (buf[13] & 0x60) >> 5;
+		csd->r2w_factor         = 4;/* Unused */
+		csd->write_bl_len       = 9;
+		
+		csd->write_bl_partial   = 0;
+		csd->file_format_grp    = 0;
+		csd->copy               = (buf[15] & 0x40) ? 1 : 0;
+		csd->perm_write_protect = (buf[15] & 0x20) ? 1 : 0;
+		csd->tmp_write_protect  = (buf[15] & 0x10) ? 1 : 0;
+		csd->file_format        = 0;
+		csd->ecc                = buf[15] & 0x03;
+		
+		DEBUG(2,"  csd_structure=%d  spec_vers=%d  taac=%02x  nsac=%02x  tran_speed=%02x\n"
+		      "  ccc=%04x  read_bl_len=%d  read_bl_partial=%d  write_blk_misalign=%d\n"
+		      "  read_blk_misalign=%d  dsr_imp=%d  c_size=%d  vdd_r_curr_min=%d\n"
+		      "  vdd_r_curr_max=%d  vdd_w_curr_min=%d  vdd_w_curr_max=%d  c_size_mult=%d\n"
+		      "  wp_grp_size=%d  wp_grp_enable=%d  default_ecc=%d  r2w_factor=%d\n"
+		      "  write_bl_len=%d  write_bl_partial=%d  file_format_grp=%d  copy=%d\n"
+		      "  perm_write_protect=%d  tmp_write_protect=%d  file_format=%d  ecc=%d\n",
+		      csd->csd_structure, csd->spec_vers, 
+		      csd->taac, csd->nsac, csd->tran_speed,
+		      csd->ccc, csd->read_bl_len, 
+		      csd->read_bl_partial, csd->write_blk_misalign,
+		      csd->read_blk_misalign, csd->dsr_imp, 
+		      csd->c_size, csd->vdd_r_curr_min,
+		      csd->vdd_r_curr_max, csd->vdd_w_curr_min, 
+		      csd->vdd_w_curr_max, csd->c_size_mult,
+		      csd->wp_grp_size, csd->wp_grp_enable,
+		      csd->default_ecc, csd->r2w_factor, 
+		      csd->write_bl_len, csd->write_bl_partial,
+		      csd->file_format_grp, csd->copy, 
+		      csd->perm_write_protect, csd->tmp_write_protect,
+		      csd->file_format, csd->ecc);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			DEBUG(2," V22 sector_size=%d erase_grp_size=%d\n", 
+			      csd->erase.v22.sector_size, 
+			      csd->erase.v22.erase_grp_size);
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			DEBUG(2," V31 erase_grp_size=%d erase_grp_mult=%d\n", 
+			      csd->erase.v31.erase_grp_size,
+			      csd->erase.v31.erase_grp_mult);
+			break;
+		}
+	}
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+
+	return 0;
+}
+
+int mmc_unpack_r1(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state)
+{
+	u8 *buf = request->response;
+
+	if (request->result)        return request->result;
+
+	r1->cmd    = buf[0];
+	r1->status = PARSE_U32(buf,1);
+
+	DEBUG(2, "mmc_unpack_r1: cmd=%d status=%08x\n", r1->cmd, r1->status);
+
+	if (R1_STATUS(r1->status)) {
+		if (r1->status & R1_OUT_OF_RANGE)       return MMC_ERROR_OUT_OF_RANGE;
+		if (r1->status & R1_ADDRESS_ERROR)      return MMC_ERROR_ADDRESS;
+		if (r1->status & R1_BLOCK_LEN_ERROR)    return MMC_ERROR_BLOCK_LEN;
+		if (r1->status & R1_ERASE_SEQ_ERROR)    return MMC_ERROR_ERASE_SEQ;
+		if (r1->status & R1_ERASE_PARAM)        return MMC_ERROR_ERASE_PARAM;
+		if (r1->status & R1_WP_VIOLATION)       return MMC_ERROR_WP_VIOLATION;
+		//if (r1->status & R1_CARD_IS_LOCKED)     return MMC_ERROR_CARD_IS_LOCKED;
+		if (r1->status & R1_LOCK_UNLOCK_FAILED) return MMC_ERROR_LOCK_UNLOCK_FAILED;
+		if (r1->status & R1_COM_CRC_ERROR)      return MMC_ERROR_COM_CRC;
+		if (r1->status & R1_ILLEGAL_COMMAND)    return MMC_ERROR_ILLEGAL_COMMAND;
+		if (r1->status & R1_CARD_ECC_FAILED)    return MMC_ERROR_CARD_ECC_FAILED;
+		if (r1->status & R1_CC_ERROR)           return MMC_ERROR_CC;
+		if (r1->status & R1_ERROR)              return MMC_ERROR_GENERAL;
+		if (r1->status & R1_UNDERRUN)           return MMC_ERROR_UNDERRUN;
+		if (r1->status & R1_OVERRUN)            return MMC_ERROR_OVERRUN;
+		if (r1->status & R1_CID_CSD_OVERWRITE)  return MMC_ERROR_CID_CSD_OVERWRITE;
+	}
+
+	if (buf[0] != request->cmd) return MMC_ERROR_HEADER_MISMATCH;
+
+	/* This should be last - it's the least dangerous error */
+
+	return 0;
+}
+
+int mmc_unpack_scr(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, u32 *scr)
+{
+        u8 *buf = request->response;
+	if (request->result)        return request->result;
+        
+        *scr = PARSE_U32(buf, 5); /* Save SCR returned by the SD Card */
+        return mmc_unpack_r1(request, r1, state);
+        
+}
+
+int mmc_unpack_r6(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, int *rca)
+{
+	u8 *buf = request->response;
+
+	if (request->result)        return request->result;
+        
+        *rca = PARSE_U16(buf,1);  /* Save RCA returned by the SD Card */
+        
+        *(buf+1) = 0;
+        *(buf+2) = 0;
+        
+        return mmc_unpack_r1(request, r1, state);
+}   
+
+int mmc_unpack_cid(struct mmc_request *request, struct mmc_cid *cid)
+{
+	u8 *buf = request->response;
+	int i;
+
+	if (request->result) return request->result;
+
+	cid->mid = buf[1];
+	cid->oid = PARSE_U16(buf,2);
+	for (i = 0 ; i < 6 ; i++)
+		cid->pnm[i] = buf[4+i];
+	cid->pnm[6] = 0;
+	cid->prv = buf[10];
+	cid->psn = PARSE_U32(buf,11);
+	cid->mdt = buf[15];
+	
+	DEBUG(2,"mmc_unpack_cid: mid=%d oid=%d pnm=%s prv=%d.%d psn=%08x mdt=%d/%d\n",
+	      cid->mid, cid->oid, cid->pnm, 
+	      (cid->prv>>4), (cid->prv&0xf), 
+	      cid->psn, (cid->mdt>>4), (cid->mdt&0xf)+1997);
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+      	return 0;
+}
+
+int mmc_unpack_r3(struct mmc_request *request, struct mmc_response_r3 *r3)
+{
+	u8 *buf = request->response;
+
+	if (request->result) return request->result;
+
+	r3->ocr = PARSE_U32(buf,1);
+	DEBUG(2,"mmc_unpack_r3: ocr=%08x\n", r3->ocr);
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+	return 0;
+}
+
+/**************************************************************************/
+
+#define KBPS 1
+#define MBPS 1000
+
+static u32 ts_exp[] = { 100*KBPS, 1*MBPS, 10*MBPS, 100*MBPS, 0, 0, 0, 0 };
+static u32 ts_mul[] = { 0,    1000, 1200, 1300, 1500, 2000, 2500, 3000, 
+			3500, 4000, 4500, 5000, 5500, 6000, 7000, 8000 };
+
+u32 mmc_tran_speed(u8 ts)
+{
+	u32 rate = ts_exp[(ts & 0x7)] * ts_mul[(ts & 0x78) >> 3];
+
+	if (rate <= 0) {
+		DEBUG(0, "mmc_tran_speed: error - unrecognized speed 0x%02x\n", ts);
+		return 1;
+	}
+
+	return rate;
+}
+
+/**************************************************************************/
+
+void mmc_send_cmd(struct mmc_request *request, int cmd, u32 arg, 
+		   u16 nob, u16 block_len, enum mmc_rsp_t rtype, u8 *buffer)
+{
+	request->cmd       = cmd;
+	request->arg       = arg;
+	request->rtype     = rtype;
+	request->nob       = nob;
+	request->block_len = block_len;
+	request->buffer    = buffer;
+	request->cnt       = nob * block_len;
+
+	jz_mmc_exec_cmd(request);
+}
+
+#endif	/* CONFIG_MMC */
+#endif /* CONFIG_JZ4750 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4750_nand.c u-boot-1.1.6/cpu/mips/jz4750_nand.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz4750_nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz4750_nand.c	2008-12-23 01:54:24.000000000 +0800
@@ -0,0 +1,274 @@
+/*
+ * Platform independend driver for JZ4750.
+ *
+ * Copyright (c) 2007 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && (defined(CONFIG_JZ4750) || defined(CONFIG_JZ4750D))
+
+#include <nand.h>
+#ifdef CONFIG_JZ4750
+#include <asm/jz4750.h>
+#else
+#include <asm/jz4750d.h>
+#endif
+/* Size of ecc parities per 512 bytes, 7 or 13 bytes */
+static int par_size;
+
+/* It indicates share mode between nand and SDRAM Bus */
+static int share_mode = 1;
+
+static struct nand_oobinfo nand_oob_bch = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 52,
+	.eccpos = {
+		3,  4,  5,  6,  7,  8,  9,  10,
+		11, 12, 13, 14, 15, 16, 17, 18,
+		19, 20, 21, 22, 23, 24, 25, 26,
+		27, 28, 29, 30, 31, 32, 33, 34,
+		35, 36, 37, 38, 39, 40, 41, 42,
+		43, 44, 45, 46, 47, 48, 49, 50,
+		51, 52, 53, 54},
+	.oobfree = {{2, 1}, {55, 9}}
+};
+
+static void jz_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *this = (struct nand_chip *)(mtd->priv);
+	switch (cmd) {
+		case NAND_CTL_SETNCE:
+			REG_EMC_NFCSR |= EMC_NFCSR_NFCE1;
+			break;
+
+		case NAND_CTL_CLRNCE:
+			REG_EMC_NFCSR &= ~EMC_NFCSR_NFCE1;
+			break;
+
+		case NAND_CTL_SETCLE:
+			if (share_mode)
+				this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00008000);
+			else
+				this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00000008);
+			break;
+
+		case NAND_CTL_CLRCLE:
+			if (share_mode)
+				this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00008000);
+			else
+				this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00000008);
+			break;
+
+		case NAND_CTL_SETALE:
+			if (share_mode)
+				this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00010000);
+			else
+				this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00000010);
+			break;
+
+		case NAND_CTL_CLRALE:
+			if (share_mode)
+				this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00010000);
+			else
+				this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00000010);
+			break;
+	}
+}
+
+static int jz_device_ready(struct mtd_info *mtd)
+{
+	int ready;
+	udelay(20);	/* FIXME: add 20us delay */
+	ready = (REG_GPIO_PXPIN(2) & 0x08000000) ? 1 : 0;
+	return ready;
+}
+
+/*
+ * EMC setup
+ */
+static void jz_device_setup(void)
+{
+	/* Set NFE bit */
+	REG_EMC_NFCSR |= EMC_NFCSR_NFE1;
+	REG_EMC_SMCR1 = 0x0d444400;
+}
+
+void board_nand_select_device(struct nand_chip *nand, int chip)
+{
+	/*
+	 * Don't use "chip" to address the NAND device,
+	 * generate the cs from the address where it is encoded.
+	 */
+}
+
+static int jzsoc_nand_calculate_bch_ecc(struct mtd_info *mtd, const u_char * dat, u_char * ecc_code)
+{
+	struct nand_chip *this = (struct nand_chip *)(mtd->priv);
+	volatile u8 *paraddr = (volatile u8 *)BCH_PAR0;
+	short i;
+
+	/* Write data to REG_BCH_DR */
+	for (i = 0; i < this->eccsize; i++) {
+		REG_BCH_DR = dat[i];
+	}
+
+	__ecc_encode_sync();
+	__ecc_disable();
+
+	for (i = 0; i < par_size; i++) {
+		ecc_code[i] = *paraddr++;
+	}
+
+	return 0;
+}
+
+static void jzsoc_nand_enable_bch_hwecc(struct mtd_info* mtd, int mode)
+{
+	struct nand_chip *this = (struct nand_chip *)(mtd->priv);
+
+	REG_BCH_INTS = 0xffffffff;
+
+	if (mode == NAND_ECC_READ) {
+		if (CFG_NAND_BCH_BIT == 8)
+			__ecc_decoding_8bit();
+		else
+			__ecc_decoding_4bit();
+		__ecc_cnt_dec(this->eccsize + par_size);
+	}
+
+	if (mode == NAND_ECC_WRITE) {
+		if (CFG_NAND_BCH_BIT == 8)
+			__ecc_encoding_8bit();
+		else
+			__ecc_encoding_4bit();
+		__ecc_cnt_enc(this->eccsize);
+	}
+
+}
+
+/**
+ * bch_correct
+ * @dat:        data to be corrected
+ * @idx:        the index of error bit in an eccsize
+ */
+static void bch_correct(u8 * dat, int idx)
+{
+	int i, bit;		/* the 'bit' of i byte is error */
+	i = (idx - 1) >> 3;
+	bit = (idx - 1) & 0x7;
+	dat[i] ^= (1 << bit);
+}
+
+/**
+ * jzsoc_nand_bch_correct_data:  calc_ecc points to oob_buf for us
+ * @mtd:	mtd info structure
+ * @dat:        data to be corrected
+ * @read_ecc:   pointer to ecc buffer calculated when nand writing
+ * @calc_ecc:   no used
+ */
+static int jzsoc_nand_bch_correct_data(struct mtd_info *mtd, u_char * dat, u_char * read_ecc, u_char * calc_ecc)
+{
+	struct nand_chip *this = (struct nand_chip *)(mtd->priv);
+	short k;
+	u32 stat;
+
+	/* Write data to REG_BCH_DR */
+	for (k = 0; k < this->eccsize; k++) {
+		REG_BCH_DR = dat[k];
+	}
+
+	/* Write parities to REG_BCH_DR */
+	for (k = 0; k < par_size; k++) {
+		REG_BCH_DR = read_ecc[k];
+	}
+
+	/* Wait for completion */
+	__ecc_decode_sync();
+	__ecc_disable();
+
+	/* Check decoding */
+	stat = REG_BCH_INTS;
+
+	if (stat & BCH_INTS_ERR) {
+		/* Error occurred */
+		if (stat & BCH_INTS_UNCOR) {
+			printk("NAND: Uncorrectable ECC error--\n");
+			return -1;
+		} else {
+			u32 errcnt = (stat & BCH_INTS_ERRC_MASK) >> BCH_INTS_ERRC_BIT;
+			switch (errcnt) {
+			case 8:
+				bch_correct(dat, (REG_BCH_ERR3 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				/* FALL-THROUGH */
+			case 7:
+				bch_correct(dat, (REG_BCH_ERR3 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				/* FALL-THROUGH */
+			case 6:
+				bch_correct(dat, (REG_BCH_ERR2 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				/* FALL-THROUGH */
+			case 5:
+				bch_correct(dat, (REG_BCH_ERR2 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				/* FALL-THROUGH */
+			case 4:
+				bch_correct(dat, (REG_BCH_ERR1 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				/* FALL-THROUGH */
+			case 3:
+				bch_correct(dat, (REG_BCH_ERR1 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				/* FALL-THROUGH */
+			case 2:
+				bch_correct(dat, (REG_BCH_ERR0 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				/* FALL-THROUGH */
+			case 1:
+				bch_correct(dat, (REG_BCH_ERR0 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				return 0;
+			default:
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Main initialization routine
+ */
+void board_nand_init(struct nand_chip *nand)
+{
+	if ((REG_EMC_BCR & EMC_BCR_BSR_MASK) == EMC_BCR_BSR_SHARE)
+		share_mode = 1;
+	else
+		share_mode = 0;
+
+	jz_device_setup();
+
+	if (CFG_NAND_BCH_BIT == 8) {
+		par_size = 13;
+		nand->eccmode = NAND_ECC_HW13_512;
+	} else {
+		par_size = 7;
+		nand->eccmode = NAND_ECC_HW7_512;
+	}
+
+        nand->hwcontrol = jz_hwcontrol;
+        nand->dev_ready = jz_device_ready;
+	
+	nand->correct_data  = jzsoc_nand_bch_correct_data;
+	nand->enable_hwecc  = jzsoc_nand_enable_bch_hwecc;
+	nand->calculate_ecc = jzsoc_nand_calculate_bch_ecc;
+
+        /* Set address of NAND IO lines */
+        nand->IO_ADDR_R = (void __iomem *) CFG_NAND_BASE;
+        nand->IO_ADDR_W = (void __iomem *) CFG_NAND_BASE;
+
+        /* 20 us command delay time */
+        nand->chip_delay = 20;
+//	nand->autooob    = &nand_oob_bch; // init in nand_base.c
+}
+#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz5730.c u-boot-1.1.6/cpu/mips/jz5730.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz5730.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz5730.c	2007-05-23 17:47:29.000000000 +0800
@@ -0,0 +1,410 @@
+/*
+ * Jz5730 common routines
+ *
+ *  Copyright (c) 2005
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_JZ5730
+
+#include <common.h>
+#include <command.h>
+
+#include <asm/jz5730.h>
+
+extern void board_early_init(void);
+extern void board_led(char ch);
+
+static void sdram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	register unsigned int dmcr, sdmode, tmp, ns;
+	volatile unsigned int *p;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	REG_EMC_BCR = EMC_BCR_BRE;	/* Enable SPLIT */
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_DISABLE;
+	REG_EMC_RTCOR = 0;
+	REG_EMC_RTCNT = 0;
+
+	/* Basic DMCR register value. */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg parameters */
+	ns = 1000000000 / gd->mem_clk;
+
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4)
+		tmp = 4;
+	if (tmp > 11)
+		tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7)
+		tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14)
+		tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode values */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	if (SDRAM_BW16)
+		sdmode <<= 1;
+	else
+		sdmode <<= 2;
+
+	/* First, precharge phase */
+	REG_EMC_DMCR = dmcr;
+
+	/* Set refresh registers */
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff)
+		tmp = 0xff;
+
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* precharge all chip-selects */
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+	/* wait for precharge, > 200us */
+	tmp = (gd->cpu_clk / 1000000) * 200;
+	while (tmp--);
+
+	/* enable refresh and set SDRAM mode */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* write sdram mode register for each chip-select */
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+	/* do simple memory check */
+	p = (volatile unsigned int *)(0xa0100000);
+	*p = 0x12345678;
+	p += 1;
+	*p = 0x87654321;    
+	p -= 1;
+
+	if (*p != 0x12345678) {
+		/* memory initialization failed */
+		board_led(0xe);
+		while (1);
+	}
+
+	/* everything is ok now */
+	board_led(0x1);
+}
+
+static void calc_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+  
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int od[4] = {1, 2, 2, 4};
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int nf, nr, nd;
+
+	nf = __cpm_plcr1_fd() + 2;
+	nr = __cpm_plcr1_rd() + 2;
+	nd = od[__cpm_plcr1_od()];
+
+	pllout = (CFG_EXTAL / (nr * nd)) * nf;
+
+	gd->cpu_clk = pllout / div[__cpm_cfcr_ifr()];
+	gd->sys_clk = pllout / div[__cpm_cfcr_sfr()];
+	gd->per_clk = pllout / div[__cpm_cfcr_pfr()];
+	gd->mem_clk = pllout / div[__cpm_cfcr_mfr()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+static void check_reset(void)
+{
+	if (REG_CPM_RSTR & 0x4) {
+		/* CPU was reset by hibernate wakeup */
+		void (*resume) (void);
+
+		/* Clear HGP */
+		REG_CPM_SCR &= ~CPM_SCR_HGP;
+
+		/* Jump to sleep address directly */
+		resume = (void (*)(void))(REG_CPM_SPR | 0x80000000);
+		resume();
+	}
+}
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+static void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 3, 3, 3, 10}; /* divisors of I:S:P:M:SSI */
+	int nf;
+
+	cfcr = CPM_CFCR_CKOEN;
+	cfcr |=  ((CFG_CPU_SPEED/48000000 - 1) << 25); /* USB clock divider */
+
+	cfcr |= (n2FR[div[0]] << CPM_CFCR_IFR_BIT) | 
+		(n2FR[div[1]] << CPM_CFCR_SFR_BIT) | 
+		(n2FR[div[2]] << CPM_CFCR_PFR_BIT) |
+		(n2FR[div[3]] << CPM_CFCR_MFR_BIT) |
+		((div[4]-1) << CPM_CFCR_SSIFR_BIT);
+
+	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+
+	plcr1 = ((nf - 2) << CPM_PLCR1_PLL1FD_BIT) | /* FD=NF-2 */
+		(0 << CPM_PLCR1_PLL1RD_BIT) |	   /* RD=0, NR=2, 1.8432 = 3.6864/2 */
+		(0 << CPM_PLCR1_PLL1OD_BIT) |      /* OD=0, NO=1 */
+		(0x20 << CPM_PLCR1_PLL1ST_BIT) |   /* PLL stable time */
+		CPM_PLCR1_PLL1EN;                  /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CFCR = cfcr;
+	REG_CPM_PLCR1 = plcr1;
+}
+
+//----------------------------------------------------------------------
+// jz5730 board init routine
+
+int jz_board_init(void)
+{
+	board_early_init();  /* init gpio etc. */
+	pll_init();          /* init PLL */
+	calc_clocks();       /* calc the clocks */
+	sdram_init();        /* init sdram memory */
+	check_reset();       /* check the reset status */
+	return 0;
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+long int initdram(int board_type)
+{
+	u32 dmcr;
+	u32 rows, cols, dw, banks;
+	ulong size;
+
+	dmcr = REG_EMC_DMCR;
+	rows = 11 + ((dmcr & EMC_DMCR_RA_MASK) >> EMC_DMCR_RA_BIT);
+	cols = 8 + ((dmcr & EMC_DMCR_CA_MASK) >> EMC_DMCR_CA_BIT);
+	dw = (dmcr & EMC_DMCR_BW) ? 2 : 4;
+	banks = (dmcr & EMC_DMCR_BA) ? 4 : 2;
+
+	size = (1 << (rows + cols)) * dw * banks;
+
+	return size;
+}
+
+//----------------------------------------------------------------------
+// Timer routines
+
+/* we always count down the max. */
+#define TIMER_LOAD_VAL 0xffffffff
+
+#define CHANNEL_ID  0
+/* macro to read the 32 bit timer */
+#define READ_TIMER __ost_get_count(CHANNEL_ID)
+
+static ulong timestamp;
+static ulong lastdec;
+
+void	reset_timer_masked	(void);
+ulong	get_timer_masked	(void);
+void	udelay_masked		(unsigned long usec);
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	__ost_set_clock(CHANNEL_ID, OST_TCSR_CKS_PCLK_256);
+	__ost_set_reload(CHANNEL_ID, TIMER_LOAD_VAL);
+	__ost_set_count(CHANNEL_ID, TIMER_LOAD_VAL);
+	__ost_enable_channel(CHANNEL_ID);
+
+	lastdec = TIMER_LOAD_VAL;
+	timestamp = 0;
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void udelay (unsigned long usec)
+{
+	ulong tmo,tmp;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= CFG_HZ;
+		tmo /= 1000;
+	}
+	else {
+		if (usec >= 1) {
+			tmo = usec * CFG_HZ;
+			tmo /= (1000*1000);
+		}
+		else
+			tmo = 1;
+	}
+
+	/* check for rollover during this delay */
+	tmp = get_timer (0);
+	if ((tmp + tmo) < tmp )
+		reset_timer_masked();  /* timer would roll over */
+	else
+		tmo += tmp;
+
+	while (get_timer_masked () < tmo);
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;
+	timestamp = 0;
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;
+
+	if (lastdec >= now) {
+		/* normal mode */
+		timestamp += (lastdec - now);
+	} else {
+		/* we have an overflow ... */
+		timestamp += ((lastdec + TIMER_LOAD_VAL) - now);
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= CFG_HZ;
+		tmo /= 1000;
+	} else {
+		if (usec > 1) {
+			tmo = usec * CFG_HZ;
+			tmo /= (1000*1000);
+		} else {
+			tmo = 1;
+		}
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	return CFG_HZ;
+}
+
+//---------------------------------------------------------------------
+// End of timer routine.
+//---------------------------------------------------------------------
+
+#endif /* CONFIG_JZ5730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz5730_nand.c u-boot-1.1.6/cpu/mips/jz5730_nand.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz5730_nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz5730_nand.c	2007-06-12 17:16:20.000000000 +0800
@@ -0,0 +1,93 @@
+/*
+ * Platform independend driver for JZ5730.
+ *
+ * Copyright (c) 2007 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && defined(CONFIG_JZ5730)
+
+#include <nand.h>
+
+#include <asm/jz5730.h>
+
+static void jz_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *this = (struct nand_chip *)(mtd->priv);
+	switch (cmd) {
+		case NAND_CTL_SETNCE:
+			REG_EMC_NFCSR |= EMC_NFCSR_FCE;
+			break;
+
+		case NAND_CTL_CLRNCE:
+			REG_EMC_NFCSR &= ~EMC_NFCSR_FCE;
+			break;
+
+		case NAND_CTL_SETCLE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00040000);
+			break;
+
+		case NAND_CTL_CLRCLE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00040000);
+			break;
+
+		case NAND_CTL_SETALE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) | 0x00080000);
+			break;
+
+		case NAND_CTL_CLRALE:
+			this->IO_ADDR_W = (void __iomem *)((unsigned long)(this->IO_ADDR_W) & ~0x00080000);
+			break;
+	}
+}
+
+static int jz_device_ready(struct mtd_info *mtd)
+{
+	int ready;
+	ready = (REG_EMC_NFCSR & EMC_NFCSR_RB) ? 1 : 0;
+	return ready;
+}
+
+/*
+ * EMC setup
+ */
+static void jz_device_setup(void)
+{
+	/* Set NFE bit */
+	REG_EMC_NFCSR |= EMC_NFCSR_NFE;
+}
+
+void board_nand_select_device(struct nand_chip *nand, int chip)
+{
+	/*
+	 * Don't use "chip" to address the NAND device,
+	 * generate the cs from the address where it is encoded.
+	 */
+}
+
+/*
+ * Main initialization routine
+ */
+void board_nand_init(struct nand_chip *nand)
+{
+	jz_device_setup();
+
+	nand->eccmode = NAND_ECC_SOFT;
+        nand->hwcontrol = jz_hwcontrol;
+        nand->dev_ready = jz_device_ready;
+
+        /* Set address of NAND IO lines */
+        nand->IO_ADDR_R = (void __iomem *) CFG_NAND_BASE;
+        nand->IO_ADDR_W = (void __iomem *) CFG_NAND_BASE;
+
+        /* 20 us command delay time */
+        nand->chip_delay = 20;
+}
+
+#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_cs8900.c u-boot-1.1.6/cpu/mips/jz_cs8900.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_cs8900.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_cs8900.c	2008-09-08 23:12:21.000000000 +0800
@@ -0,0 +1,397 @@
+/*
+ * Cirrus Logic CS8900A Ethernet
+ *
+ * (C) 2003 Wolfgang Denk, wd@denx.de
+ *     Extension to synchronize ethaddr environment variable
+ *     against value in EEPROM
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * Copyright (C) 1999 Ben Williamson <benw@pobox.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is loaded into SRAM in bootstrap mode, where it waits
+ * for commands on UART1 to read and write memory, jump to code etc.
+ * A design goal for this program is to be entirely independent of the
+ * target board.  Anything with a CL-PS7111 or EP7211 should be able to run
+ * this code in bootstrap mode.  All the board specifics can be handled on
+ * the host.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <config.h>
+#ifndef CONFIG_FPGA
+#if defined(CONFIG_JZ4740) || defined(CONFIG_JZ4750)
+#include <common.h>
+#include <malloc.h>
+#if defined(CONFIG_JZ4740) 
+#include <asm/jz4740.h>
+#elif defined(CONFIG_JZ4750) 
+#include <asm/jz4750.h>
+#endif
+#include <net.h>
+struct eth_device *dev;
+#define CS8900_BASE ((u32)(dev->iobase))
+#define CONFIG_DRIVER_CS8900
+#define CS8900_BUS16
+#include <command.h>
+#include <asm/io.h>
+
+#include "jz_cs8900.h"
+
+#ifdef CONFIG_DRIVER_CS8900
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+
+#undef DEBUG
+
+/* packet page register access functions */
+
+#ifdef CS8900_BUS32
+/* we don't need 16 bit initialisation on 32 bit bus */
+#define get_reg_init_bus(x) get_reg((x))
+#else
+static unsigned short get_reg_init_bus (int regno)
+{
+	/* force 16 bit busmode */
+	volatile unsigned char c;
+    //c = CS8900_BUS16_0;
+	//c = CS8900_BUS16_1;
+	//c = CS8900_BUS16_0;
+	//c = CS8900_BUS16_1;
+	//c = CS8900_BUS16_0;
+
+	CS8900_PPTR = regno;
+    //udelay(100);
+	
+	return (unsigned short) CS8900_PDATA;
+}
+#endif
+
+static unsigned short get_reg (int regno)
+{
+	CS8900_PPTR = regno;
+	return (unsigned short) CS8900_PDATA;
+}
+
+
+static void put_reg (int regno, unsigned short val)
+{
+	CS8900_PPTR = regno;
+	CS8900_PDATA = val;
+}
+
+static void eth_reset (void)
+{
+	int tmo;
+	unsigned short us;
+
+	/* reset NIC */
+	put_reg (PP_SelfCTL, get_reg (PP_SelfCTL) | PP_SelfCTL_Reset);
+
+	/* wait for 200ms */
+	udelay (200000);
+	/* Wait until the chip is reset */
+
+	tmo = get_timer (0) + 1 * CFG_HZ;
+	while ((((us = get_reg_init_bus (PP_SelfSTAT)) & PP_SelfSTAT_InitD) == 0)
+		   && tmo < get_timer (0))
+		/*NOP*/;
+}
+
+static void eth_reginit (void)
+{
+	/* receive only error free packets addressed to this card */
+	put_reg (PP_RxCTL, PP_RxCTL_IA | PP_RxCTL_Broadcast | PP_RxCTL_RxOK);
+	/* do not generate any interrupts on receive operations */
+	put_reg (PP_RxCFG, 0);
+	/* do not generate any interrupts on transmit operations */
+	put_reg (PP_TxCFG, 0);
+	/* do not generate any interrupts on buffer operations */
+	put_reg (PP_BufCFG, 0);
+	/* enable transmitter/receiver mode */
+	put_reg (PP_LineCTL, PP_LineCTL_Rx | PP_LineCTL_Tx);
+}
+
+static void cs8900_get_enetaddr (uchar * addr)
+{
+	int i;
+	unsigned char env_enetaddr[6];
+	char *tmp = getenv ("ethaddr");
+	char *end;
+
+	for (i=0; i<6; i++) {
+		env_enetaddr[i] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
+		if (tmp)
+			tmp = (*end) ? end+1 : end;
+	}
+
+	/* verify chip id */
+	if (get_reg_init_bus (PP_ChipID) != 0x630e)
+		return;
+	eth_reset ();
+	if ((get_reg (PP_SelfST) & (PP_SelfSTAT_EEPROM | PP_SelfSTAT_EEPROM_OK)) ==
+			(PP_SelfSTAT_EEPROM | PP_SelfSTAT_EEPROM_OK)) {
+
+		/* Load the MAC from EEPROM */
+		for (i = 0; i < 6 / 2; i++) {
+			unsigned int Addr;
+
+			Addr = get_reg (PP_IA + i * 2);
+			addr[i * 2] = Addr & 0xFF;
+			addr[i * 2 + 1] = Addr >> 8;
+		}
+
+		if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6) != 0 &&
+		    memcmp(env_enetaddr, addr, 6) != 0) {
+			printf ("\nWarning: MAC addresses don't match:\n");
+			printf ("\tHW MAC address:  "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				addr[0], addr[1],
+				addr[2], addr[3],
+				addr[4], addr[5] );
+			printf ("\t\"ethaddr\" value: "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				env_enetaddr[0], env_enetaddr[1],
+				env_enetaddr[2], env_enetaddr[3],
+				env_enetaddr[4], env_enetaddr[5]) ;
+			debug ("### Set MAC addr from environment\n");
+			memcpy (addr, env_enetaddr, 6);
+		}
+		if (!tmp) {
+			char ethaddr[20];
+			sprintf (ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
+				 addr[0], addr[1],
+				 addr[2], addr[3],
+				 addr[4], addr[5]) ;
+			debug ("### Set environment from HW MAC addr = \"%s\"\n",				ethaddr);
+			setenv ("ethaddr", ethaddr);
+		}
+
+	}
+}
+
+static void jz_eth_halt (struct eth_device *dev)
+{
+	/* disable transmitter/receiver mode */
+	put_reg (PP_LineCTL, 0);
+
+	/* "shutdown" to show ChipID or kernel wouldn't find he cs8900 ... */
+	get_reg_init_bus (PP_ChipID);
+}
+
+static int jz_eth_init (struct eth_device* dev, bd_t * bd)
+{
+    u16 id;
+	
+    dev = dev;
+   
+	
+    /* verify chip id */
+	id = get_reg_init_bus (PP_ChipID);
+	if (id != 0x630e) {
+		printf ("CS8900 jz_eth_init error!\n");
+		return 0;
+	}
+
+	eth_reset ();
+	/* set the ethernet address */
+	//printf("MAC = %02x:%02x:%02x:%02x:%02x:%02x\r\n",
+	//	   bd->bi_enetaddr[5],bd->bi_enetaddr[4],
+	//	   bd->bi_enetaddr[3],bd->bi_enetaddr[2],
+	//	   bd->bi_enetaddr[1],bd->bi_enetaddr[0]);
+	
+	put_reg (PP_IA + 0, bd->bi_enetaddr[0] | (bd->bi_enetaddr[1] << 8));
+	put_reg (PP_IA + 2, bd->bi_enetaddr[2] | (bd->bi_enetaddr[3] << 8));
+	put_reg (PP_IA + 4, bd->bi_enetaddr[4] | (bd->bi_enetaddr[5] << 8));
+
+	eth_reginit ();
+	return 0;
+}
+
+/* Get a data block via Ethernet */
+static int jz_eth_rx (struct eth_device* dev)
+{
+	int i;
+	unsigned short rxlen;
+	unsigned short *addr;
+	unsigned short status;
+    dev = dev;
+	status = get_reg (PP_RER);
+
+	if ((status & PP_RER_RxOK) == 0)
+		return 0;
+
+	status = CS8900_RTDATA;		/* stat */
+	rxlen = CS8900_RTDATA;		/* len */
+
+#ifdef DEBUG
+	if (rxlen > PKTSIZE_ALIGN + PKTALIGN)
+		printf ("packet too big!\n");
+#endif
+	for (addr = (unsigned short *) NetRxPackets[0], i = rxlen >> 1; i > 0;
+		 i--)
+		*addr++ = CS8900_RTDATA;
+	if (rxlen & 1)
+		*addr++ = CS8900_RTDATA;
+
+	/* Pass the packet up to the protocol layers. */
+	NetReceive (NetRxPackets[0], rxlen);
+
+	return rxlen;
+}
+
+/* Send a data block via Ethernet. */
+static int jz_eth_send (struct eth_device* dev,volatile void *packet, int length)
+{
+	volatile unsigned short *addr;
+	int tmo;
+	unsigned short s;
+    dev = dev;
+	
+retry:
+	/* initiate a transmit sequence */
+	CS8900_TxCMD = PP_TxCmd_TxStart_Full;
+	CS8900_TxLEN = length;
+
+	/* Test to see if the chip has allocated memory for the packet */
+	if ((get_reg (PP_BusSTAT) & PP_BusSTAT_TxRDY) == 0) {
+		/* Oops... this should not happen! */
+#ifdef DEBUG
+		printf ("cs: unable to send packet; retrying...\n");
+#endif
+		for (tmo = get_timer (0) + 5 * CFG_HZ; get_timer (0) < tmo;)
+			/*NOP*/;
+		eth_reset ();
+		eth_reginit ();
+		goto retry;
+	}
+
+	/* Write the contents of the packet */
+	/* assume even number of bytes */
+	for (addr = packet; length > 0; length -= 2)
+		CS8900_RTDATA = *addr++;
+
+	/* wait for transfer to succeed */
+	tmo = get_timer (0) + 5 * CFG_HZ;
+	while ((s = get_reg (PP_TER) & ~0x1F) == 0) {
+		if (get_timer (0) >= tmo)
+			break;
+	}
+
+	/* nothing */ ;
+	if ((s & (PP_TER_CRS | PP_TER_TxOK)) != PP_TER_TxOK) {
+#ifdef DEBUG
+		printf ("\ntransmission error %#x\n", s);
+#endif
+	}
+
+	return 0;
+}
+
+static void cs8900_e2prom_ready(void)
+{
+	while(get_reg(PP_SelfST) & SI_BUSY);
+}
+
+/***********************************************************/
+/* read a 16-bit word out of the EEPROM                    */
+/***********************************************************/
+
+static int cs8900_e2prom_read(unsigned char addr, unsigned short *value)
+{
+	cs8900_e2prom_ready();
+	put_reg(PP_EECMD, EEPROM_READ_CMD | addr);
+	cs8900_e2prom_ready();
+	*value = get_reg(PP_EEData);
+
+	return 0;
+}
+
+
+/***********************************************************/
+/* write a 16-bit word into the EEPROM                     */
+/***********************************************************/
+
+static int cs8900_e2prom_write(unsigned char addr, unsigned short value)
+{
+	cs8900_e2prom_ready();
+	put_reg(PP_EECMD, EEPROM_WRITE_EN);
+	cs8900_e2prom_ready();
+	put_reg(PP_EEData, value);
+	put_reg(PP_EECMD, EEPROM_WRITE_CMD | addr);
+	cs8900_e2prom_ready();
+	put_reg(PP_EECMD, EEPROM_WRITE_DIS);
+	cs8900_e2prom_ready();
+
+	return 0;
+}
+int jz_enet_initialize(bd_t *bis)
+{
+	
+    u32 reg;
+	
+	dev = (struct eth_device *) malloc(sizeof *dev);
+	memset(dev, 0, sizeof *dev);
+
+#if defined(CONFIG_JZ4740)
+#define RD_N_PIN (32 + 29)
+#define WE_N_PIN (32 + 30)
+#define CS4_PIN (32 + 28)
+	__gpio_as_func0(CS4_PIN);
+	__gpio_as_func0(RD_N_PIN);
+	__gpio_as_func0(WE_N_PIN);
+
+	reg = REG_EMC_SMCR4;
+	reg = (reg & (~EMC_SMCR_BW_MASK)) | EMC_SMCR_BW_16BIT;
+	REG_EMC_SMCR4 = reg;
+	dev->iobase = 0xa8000000;
+
+#elif defined(CONFIG_JZ4750)
+#define RD_N_PIN (32*2 +25)
+#define WE_N_PIN (32*2 +26)
+#define CS3_PIN (32*2 +23)
+	__gpio_as_func0(CS3_PIN);
+	__gpio_as_func0(RD_N_PIN);
+	__gpio_as_func0(WE_N_PIN);
+
+	reg = REG_EMC_SMCR3;
+	reg = (reg & (~EMC_SMCR_BW_MASK)) | EMC_SMCR_BW_16BIT;
+	REG_EMC_SMCR3 = reg;
+	dev->iobase = 0xac000000;
+#endif
+
+	sprintf(dev->name, "JZ ETHERNET");
+	dev->priv   = 0;
+	dev->init   = jz_eth_init;
+	dev->halt   = jz_eth_halt;
+	dev->send   = jz_eth_send;
+	dev->recv   = jz_eth_rx;
+
+	eth_register(dev);
+	
+	return 1;
+}
+
+
+#endif	/* COMMANDS & CFG_NET */
+
+#endif	/* CONFIG_DRIVER_CS8900 */
+#endif  /* defined(CONFIG_JZ4740) || defined(CONFIG_JZ4750) */
+#endif  /* !CONFIG_FPGA */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_cs8900.h u-boot-1.1.6/cpu/mips/jz_cs8900.h
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_cs8900.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_cs8900.h	2007-08-28 11:57:51.000000000 +0800
@@ -0,0 +1,258 @@
+/*
+ * Cirrus Logic CS8900A Ethernet
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * Copyright (C) 1999 Ben Williamson <benw@pobox.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is loaded into SRAM in bootstrap mode, where it waits
+ * for commands on UART1 to read and write memory, jump to code etc.
+ * A design goal for this program is to be entirely independent of the
+ * target board.  Anything with a CL-PS7111 or EP7211 should be able to run
+ * this code in bootstrap mode.  All the board specifics can be handled on
+ * the host.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <asm/types.h>
+#include <config.h>
+
+#ifdef CONFIG_DRIVER_CS8900
+
+/* although the registers are 16 bit, they are 32-bit aligned on the
+   EDB7111. so we have to read them as 32-bit registers and ignore the
+   upper 16-bits. i'm not sure if this holds for the EDB7211. */
+
+#ifdef CS8900_BUS16
+  /* 16 bit aligned registers, 16 bit wide */
+  #define CS8900_REG u16
+  #define CS8900_OFF 0x02
+  #define CS8900_BUS16_0  *(volatile u8 *)(CS8900_BASE+0x00)
+  #define CS8900_BUS16_1  *(volatile u8 *)(CS8900_BASE+0x01)
+#elif  defined(CS8900_BUS32)
+  /* 32 bit aligned registers, 16 bit wide (we ignore upper 16 bits) */
+  #define CS8900_REG u32
+  #define CS8900_OFF 0x04
+#else
+  #error unknown bussize ...
+#endif
+
+#define CS8900_RTDATA *(volatile CS8900_REG *)(CS8900_BASE+0x00*CS8900_OFF)
+#define CS8900_TxCMD  *(volatile CS8900_REG *)(CS8900_BASE+0x02*CS8900_OFF)
+#define CS8900_TxLEN  *(volatile CS8900_REG *)(CS8900_BASE+0x03*CS8900_OFF)
+#define CS8900_ISQ    *(volatile CS8900_REG *)(CS8900_BASE+0x04*CS8900_OFF)
+#define CS8900_PPTR   *(volatile CS8900_REG *)(CS8900_BASE+0x05*CS8900_OFF)
+#define CS8900_PDATA  *(volatile CS8900_REG *)(CS8900_BASE+0x06*CS8900_OFF)
+
+
+#define ISQ_RxEvent     0x04
+#define ISQ_TxEvent     0x08
+#define ISQ_BufEvent    0x0C
+#define ISQ_RxMissEvent 0x10
+#define ISQ_TxColEvent  0x12
+#define ISQ_EventMask   0x3F
+
+/* packet page register offsets */
+
+/* bus interface registers */
+#define PP_ChipID    0x0000  /* Chip identifier - must be 0x630E */
+#define PP_ChipRev   0x0002  /* Chip revision, model codes */
+
+#define PP_IntReg    0x0022  /* Interrupt configuration */
+#define PP_IntReg_IRQ0         0x0000  /* Use INTR0 pin */
+#define PP_IntReg_IRQ1         0x0001  /* Use INTR1 pin */
+#define PP_IntReg_IRQ2         0x0002  /* Use INTR2 pin */
+#define PP_IntReg_IRQ3         0x0003  /* Use INTR3 pin */
+
+/* status and control registers */
+
+#define PP_RxCFG     0x0102  /* Receiver configuration */
+#define PP_RxCFG_Skip1         0x0040  /* Skip (i.e. discard) current frame */
+#define PP_RxCFG_Stream        0x0080  /* Enable streaming mode */
+#define PP_RxCFG_RxOK          0x0100  /* RxOK interrupt enable */
+#define PP_RxCFG_RxDMAonly     0x0200  /* Use RxDMA for all frames */
+#define PP_RxCFG_AutoRxDMA     0x0400  /* Select RxDMA automatically */
+#define PP_RxCFG_BufferCRC     0x0800  /* Include CRC characters in frame */
+#define PP_RxCFG_CRC           0x1000  /* Enable interrupt on CRC error */
+#define PP_RxCFG_RUNT          0x2000  /* Enable interrupt on RUNT frames */
+#define PP_RxCFG_EXTRA         0x4000  /* Enable interrupt on frames with extra data */
+
+#define PP_RxCTL     0x0104  /* Receiver control */
+#define PP_RxCTL_IAHash        0x0040  /* Accept frames that match hash */
+#define PP_RxCTL_Promiscuous   0x0080  /* Accept any frame */
+#define PP_RxCTL_RxOK          0x0100  /* Accept well formed frames */
+#define PP_RxCTL_Multicast     0x0200  /* Accept multicast frames */
+#define PP_RxCTL_IA            0x0400  /* Accept frame that matches IA */
+#define PP_RxCTL_Broadcast     0x0800  /* Accept broadcast frames */
+#define PP_RxCTL_CRC           0x1000  /* Accept frames with bad CRC */
+#define PP_RxCTL_RUNT          0x2000  /* Accept runt frames */
+#define PP_RxCTL_EXTRA         0x4000  /* Accept frames that are too long */
+
+#define PP_TxCFG     0x0106  /* Transmit configuration */
+#define PP_TxCFG_CRS           0x0040  /* Enable interrupt on loss of carrier */
+#define PP_TxCFG_SQE           0x0080  /* Enable interrupt on Signal Quality Error */
+#define PP_TxCFG_TxOK          0x0100  /* Enable interrupt on successful xmits */
+#define PP_TxCFG_Late          0x0200  /* Enable interrupt on "out of window" */
+#define PP_TxCFG_Jabber        0x0400  /* Enable interrupt on jabber detect */
+#define PP_TxCFG_Collision     0x0800  /* Enable interrupt if collision */
+#define PP_TxCFG_16Collisions  0x8000  /* Enable interrupt if > 16 collisions */
+
+#define PP_TxCmd     0x0108  /* Transmit command status */
+#define PP_TxCmd_TxStart_5     0x0000  /* Start after 5 bytes in buffer */
+#define PP_TxCmd_TxStart_381   0x0040  /* Start after 381 bytes in buffer */
+#define PP_TxCmd_TxStart_1021  0x0080  /* Start after 1021 bytes in buffer */
+#define PP_TxCmd_TxStart_Full  0x00C0  /* Start after all bytes loaded */
+#define PP_TxCmd_Force         0x0100  /* Discard any pending packets */
+#define PP_TxCmd_OneCollision  0x0200  /* Abort after a single collision */
+#define PP_TxCmd_NoCRC         0x1000  /* Do not add CRC */
+#define PP_TxCmd_NoPad         0x2000  /* Do not pad short packets */
+
+#define PP_BufCFG    0x010A  /* Buffer configuration */
+#define PP_BufCFG_SWI          0x0040  /* Force interrupt via software */
+#define PP_BufCFG_RxDMA        0x0080  /* Enable interrupt on Rx DMA */
+#define PP_BufCFG_TxRDY        0x0100  /* Enable interrupt when ready for Tx */
+#define PP_BufCFG_TxUE         0x0200  /* Enable interrupt in Tx underrun */
+#define PP_BufCFG_RxMiss       0x0400  /* Enable interrupt on missed Rx packets */
+#define PP_BufCFG_Rx128        0x0800  /* Enable Rx interrupt after 128 bytes */
+#define PP_BufCFG_TxCol        0x1000  /* Enable int on Tx collision ctr overflow */
+#define PP_BufCFG_Miss         0x2000  /* Enable int on Rx miss ctr overflow */
+#define PP_BufCFG_RxDest       0x8000  /* Enable int on Rx dest addr match */
+
+#define PP_LineCTL   0x0112  /* Line control */
+#define PP_LineCTL_Rx          0x0040  /* Enable receiver */
+#define PP_LineCTL_Tx          0x0080  /* Enable transmitter */
+#define PP_LineCTL_AUIonly     0x0100  /* AUI interface only */
+#define PP_LineCTL_AutoAUI10BT 0x0200  /* Autodetect AUI or 10BaseT interface */
+#define PP_LineCTL_ModBackoffE 0x0800  /* Enable modified backoff algorithm */
+#define PP_LineCTL_PolarityDis 0x1000  /* Disable Rx polarity autodetect */
+#define PP_LineCTL_2partDefDis 0x2000  /* Disable two-part defferal */
+#define PP_LineCTL_LoRxSquelch 0x4000  /* Reduce receiver squelch threshold */
+
+#define PP_SelfCTL   0x0114  /* Chip self control */
+#define PP_SelfCTL_Reset       0x0040  /* Self-clearing reset */
+#define PP_SelfCTL_SWSuspend   0x0100  /* Initiate suspend mode */
+#define PP_SelfCTL_HWSleepE    0x0200  /* Enable SLEEP input */
+#define PP_SelfCTL_HWStandbyE  0x0400  /* Enable standby mode */
+#define PP_SelfCTL_HC0E        0x1000  /* use HCB0 for LINK LED */
+#define PP_SelfCTL_HC1E        0x2000  /* use HCB1 for BSTATUS LED */
+#define PP_SelfCTL_HCB0        0x4000  /* control LINK LED if HC0E set */
+#define PP_SelfCTL_HCB1        0x8000  /* control BSTATUS LED if HC1E set */
+
+#define PP_BusCTL    0x0116  /* Bus control */
+#define PP_BusCTL_ResetRxDMA   0x0040  /* Reset RxDMA pointer */
+#define PP_BusCTL_DMAextend    0x0100  /* Extend DMA cycle */
+#define PP_BusCTL_UseSA        0x0200  /* Assert MEMCS16 on address decode */
+#define PP_BusCTL_MemoryE      0x0400  /* Enable memory mode */
+#define PP_BusCTL_DMAburst     0x0800  /* Limit DMA access burst */
+#define PP_BusCTL_IOCHRDYE     0x1000  /* Set IOCHRDY high impedence */
+#define PP_BusCTL_RxDMAsize    0x2000  /* Set DMA buffer size 64KB */
+#define PP_BusCTL_EnableIRQ    0x8000  /* Generate interrupt on interrupt event */
+
+#define PP_TestCTL   0x0118  /* Test control */
+#define PP_TestCTL_DisableLT   0x0080  /* Disable link status */
+#define PP_TestCTL_ENDECloop   0x0200  /* Internal loopback */
+#define PP_TestCTL_AUIloop     0x0400  /* AUI loopback */
+#define PP_TestCTL_DisBackoff  0x0800  /* Disable backoff algorithm */
+#define PP_TestCTL_FDX         0x4000  /* Enable full duplex mode */
+
+#define PP_ISQ       0x0120  /* Interrupt Status Queue */
+
+#define PP_RER       0x0124  /* Receive event */
+#define PP_RER_IAHash          0x0040  /* Frame hash match */
+#define PP_RER_Dribble         0x0080  /* Frame had 1-7 extra bits after last byte */
+#define PP_RER_RxOK            0x0100  /* Frame received with no errors */
+#define PP_RER_Hashed          0x0200  /* Frame address hashed OK */
+#define PP_RER_IA              0x0400  /* Frame address matched IA */
+#define PP_RER_Broadcast       0x0800  /* Broadcast frame */
+#define PP_RER_CRC             0x1000  /* Frame had CRC error */
+#define PP_RER_RUNT            0x2000  /* Runt frame */
+#define PP_RER_EXTRA           0x4000  /* Frame was too long */
+
+#define PP_TER       0x0128 /* Transmit event */
+#define PP_TER_CRS             0x0040  /* Carrier lost */
+#define PP_TER_SQE             0x0080  /* Signal Quality Error */
+#define PP_TER_TxOK            0x0100  /* Packet sent without error */
+#define PP_TER_Late            0x0200  /* Out of window */
+#define PP_TER_Jabber          0x0400  /* Stuck transmit? */
+#define PP_TER_NumCollisions   0x7800  /* Number of collisions */
+#define PP_TER_16Collisions    0x8000  /* > 16 collisions */
+
+#define PP_BER       0x012C /* Buffer event */
+#define PP_BER_SWint           0x0040 /* Software interrupt */
+#define PP_BER_RxDMAFrame      0x0080 /* Received framed DMAed */
+#define PP_BER_Rdy4Tx          0x0100 /* Ready for transmission */
+#define PP_BER_TxUnderrun      0x0200 /* Transmit underrun */
+#define PP_BER_RxMiss          0x0400 /* Received frame missed */
+#define PP_BER_Rx128           0x0800 /* 128 bytes received */
+#define PP_BER_RxDest          0x8000 /* Received framed passed address filter */
+
+#define PP_RxMiss    0x0130  /*  Receiver miss counter */
+
+#define PP_TxCol     0x0132  /*  Transmit collision counter */
+
+#define PP_LineSTAT  0x0134  /* Line status */
+#define PP_LineSTAT_LinkOK     0x0080  /* Line is connected and working */
+#define PP_LineSTAT_AUI        0x0100  /* Connected via AUI */
+#define PP_LineSTAT_10BT       0x0200  /* Connected via twisted pair */
+#define PP_LineSTAT_Polarity   0x1000  /* Line polarity OK (10BT only) */
+#define PP_LineSTAT_CRS        0x4000  /* Frame being received */
+
+#define PP_SelfSTAT  0x0136  /* Chip self status */
+#define PP_SelfSTAT_33VActive  0x0040  /* supply voltage is 3.3V */
+#define PP_SelfSTAT_InitD      0x0080  /* Chip initialization complete */
+#define PP_SelfSTAT_SIBSY      0x0100  /* EEPROM is busy */
+#define PP_SelfSTAT_EEPROM     0x0200  /* EEPROM present */
+#define PP_SelfSTAT_EEPROM_OK  0x0400  /* EEPROM checks out */
+#define PP_SelfSTAT_ELPresent  0x0800  /* External address latch logic available */
+#define PP_SelfSTAT_EEsize     0x1000  /* Size of EEPROM */
+
+#define PP_BusSTAT   0x0138  /* Bus status */
+#define PP_BusSTAT_TxBid       0x0080  /* Tx error */
+#define PP_BusSTAT_TxRDY       0x0100  /* Ready for Tx data */
+
+#define PP_TDR       0x013C  /* AUI Time Domain Reflectometer */
+
+/* initiate transmit registers */
+
+#define PP_TxCommand 0x0144  /* Tx Command */
+#define PP_TxLength  0x0146  /* Tx Length */
+
+
+/* address filter registers */
+
+#define PP_LAF       0x0150  /* Logical address filter (6 bytes) */
+#define PP_IA        0x0158  /* Individual address (MAC) */
+
+/* EEPROM Kram */
+#define SI_BUSY 0x0100
+#define PP_SelfST 0x0136	/*  Self State register */
+#define PP_EECMD 0x0040		/*  NVR Interface Command register */
+#define PP_EEData 0x0042	/*  NVR Interface Data Register */
+#define EEPROM_WRITE_EN		0x00F0
+#define EEPROM_WRITE_DIS	0x0000
+#define EEPROM_WRITE_CMD	0x0100
+#define EEPROM_READ_CMD		0x0200
+#define EEPROM_ERASE_CMD	0x0300
+
+static int cs8900_e2prom_read(uchar, ushort *);
+static int cs8900_e2prom_write(uchar, ushort);
+
+#endif /* CONFIG_DRIVER_CS8900 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_eth.c u-boot-1.1.6/cpu/mips/jz_eth.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_eth.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_eth.c	2008-12-23 01:54:24.000000000 +0800
@@ -0,0 +1,376 @@
+/* Jz ethernet support
+ *
+ *  Copyright (c) 2005
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <config.h>
+
+#if defined(CONFIG_JZ4730) || defined(CONFIG_JZ5730) || defined(CONFIG_FPGA)
+
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ4750)
+#include <asm/jz4750.h>
+#endif
+#if defined(CONFIG_JZ4750D)
+#include <asm/jz4750d.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+
+#include "jz_eth.h"
+
+#define MAX_WAIT 1000
+
+/* Tx and Rx Descriptor */
+typedef struct {
+	u32 status;
+	u32 ctrl;
+	u32 addr;
+	u32 next;
+} eth_desc_t;
+
+#define NUM_RX_DESCS 16
+#define NUM_TX_DESCS 4
+
+static eth_desc_t rx_desc[NUM_RX_DESCS];
+static eth_desc_t tx_desc[NUM_TX_DESCS];
+
+static int next_rx;
+static int next_tx;
+
+static u32 full_duplex, phy_mode;
+
+static inline void reset_eth(void)
+{
+    int i;
+
+    jz_writel(ETH_BMR, jz_readl(ETH_BMR) | BMR_SWR);
+
+    for (i = 0; i < MAX_WAIT; i++) {
+         if(!(jz_readl(ETH_BMR) & BMR_SWR))
+	     break;
+         udelay(1);
+    }
+
+    if (i == MAX_WAIT)
+	printf("Reset eth timeout\n");
+}
+
+static inline void enable_eth(void)
+{
+	jz_writel(ETH_OMR, jz_readl(ETH_OMR) | OMR_ST | OMR_SR);
+}
+	
+static inline void disable_eth(void)
+{
+	jz_writel(ETH_OMR, jz_readl(ETH_OMR) & ~(OMR_ST | OMR_SR));
+}
+
+#define MII_CMD_ADDR(id, offset) (((id) << 11) | ((offset) << 6))
+#define MII_CMD_READ(id, offset) (MII_CMD_ADDR(id, offset))
+#define MII_CMD_WRITE(id, offset) (MII_CMD_ADDR(id, offset) | 0x2)
+
+static u32 mii_read(int phy_id, int offset)
+{
+	int i;
+	u32 mii_cmd = MII_CMD_READ(phy_id, offset);
+
+	jz_writel(ETH_MIAR, mii_cmd);
+
+	/* wait for completion */
+	for (i = 0; i < MAX_WAIT; i++) {
+		if (!(jz_readl(ETH_MIAR) & 0x1))
+			break;
+		udelay(1);
+	}
+
+	if (i == MAX_WAIT) {
+		printf("MII wait timeout\n");
+		return 0;
+	}
+
+	return jz_readl(ETH_MIDR) & 0x0000ffff;
+}
+
+static int autonet_complete(int phy_id)
+{
+	int i;
+
+	for (i = 0; i < MAX_WAIT; i++) {
+		if (mii_read(phy_id, MII_SR) & 0x0020) 
+			break;  //auto negotiation completed
+		udelay(500);
+	}
+
+	if (i == MAX_WAIT)
+		return -1;     //auto negotiation  error
+	else
+		return 0;
+}
+
+static int search_phy(int phy_id)
+{
+	unsigned int r;
+	r = mii_read(phy_id, 1);
+	if (r!=0 && r!=0xffff)
+		return 1;
+	return 0;
+}
+
+static void config_phy(int phy_id)
+{
+	u32 mii_reg5;
+
+	full_duplex = 0;
+
+	mii_reg5 = mii_read(phy_id, MII_ANLPA);
+
+	if (mii_reg5 != 0xffff) {
+		mii_reg5 = mii_read(phy_id, MII_ANLPA);
+		if ((mii_reg5 & 0x0100) || (mii_reg5 & 0x01C0) == 0x0040)
+			full_duplex = 1;
+
+		phy_mode = mii_reg5 >> 5;
+
+		printf("ETH: setting %s %s-duplex based on MII tranceiver #%d\n",
+		       (phy_mode & MII_ANLPA_100M) ? "100Mbps" : "10Mbps",
+		       full_duplex ? "full" : "half", phy_id);
+	}
+}
+
+static void config_mac(void)
+{
+	u32 omr, mcr;
+
+	/* Set MAC address */
+#define ea eth_get_dev()->enetaddr
+	jz_writel(ETH_MALR, (ea[3] << 24) | (ea[2] << 16) | (ea[1] <<  8) | ea[0]);
+	jz_writel(ETH_MAHR, (ea[5] <<  8) | ea[4]);
+
+	jz_writel(ETH_HTLR, 0);
+	jz_writel(ETH_HTHR, 0);
+
+	/* Assert the MCR_PS bit in CSR */
+	if (phy_mode & MII_ANLPA_100M)
+		omr = OMR_SF;
+	else
+		omr = OMR_TTM | OMR_SF;
+
+	mcr = MCR_TE | MCR_RE | MCR_DBF | MCR_LCC; 
+    
+	if (full_duplex)
+		mcr |= MCR_FDX;
+
+	/* Set the Operation Mode (OMR) and Mac Control (MCR) registers */
+	jz_writel(ETH_OMR, omr);
+	jz_writel(ETH_MCR, mcr);
+
+	/* Set the Programmable Burst Length (BMR.PBL, value 1 or 4 is validate) */
+	jz_writel(ETH_BMR, DMA_BURST << 8);
+
+	/* Reset csr8 */
+	jz_readl(ETH_MFCR); // missed frams counter
+}
+
+/*---------------------------------------------------------------------------
+ * ETH interface routines
+ *--------------------------------------------------------------------------*/
+
+static int jz_send(struct eth_device* dev, volatile void *packet, int length)
+{
+	volatile eth_desc_t *desc = 
+		(volatile eth_desc_t *)((unsigned int)(tx_desc + next_tx) | 0xa0000000);
+	int i;
+
+	/* tx fifo should always be idle */
+	desc->addr = virt_to_phys(packet);
+	desc->ctrl |= TD_LS | TD_FS | length;
+	desc->status = T_OWN;
+
+	jz_flush_dcache();
+	jz_sync();
+
+	/* Start the tx */
+	jz_writel(ETH_TPDR, 1);
+
+	i = 0;
+	while (desc->status & T_OWN) {
+		if(i > MAX_WAIT) {
+			printf("ETH TX timeout\n");
+			break;
+		}
+		udelay(1);
+		i++;
+	}
+
+	/* Clear done bits */
+	jz_writel(ETH_SR,  DMA_TX_DEFAULT);
+
+	desc->status = 0;
+	desc->addr = 0;
+	desc->ctrl &= ~(TD_LS | TD_FS);
+
+	next_tx++;
+	if (next_tx >= NUM_TX_DESCS){
+		next_tx=0;
+	}
+
+	return (desc->status);
+}
+
+static int jz_recv(struct eth_device* dev)
+{
+	volatile eth_desc_t *desc;
+	int length;
+	u32 status;
+
+	for(;;) {
+		desc = (volatile eth_desc_t *)((unsigned int)(rx_desc + next_rx) | 0xa0000000);
+
+		status = desc->status;
+
+		if (status & R_OWN) {
+			/* Nothing has been received */
+			return(-1);
+		}
+
+		length = ((status & RD_FL) >> 16); /* with 4-byte CRC value */
+
+		if (status & RD_ES) {
+			printf("ETH RX error 0x%x\n", status);
+		}
+		else {
+			/* Pass the packet up to the protocol layers. */
+			NetReceive(NetRxPackets[next_rx], length - 4);
+		}
+
+		/* Clear done bits */
+		jz_writel(ETH_SR,  DMA_RX_DEFAULT);
+
+		desc->status = R_OWN;
+
+		jz_flush_dcache();
+		jz_sync();
+
+		next_rx++;
+		if (next_rx >= NUM_RX_DESCS) {
+			next_rx = 0;
+		}
+	} /* for */
+
+	return(0); /* Does anyone use this? */
+}
+
+static int jz_init(struct eth_device* dev, bd_t * bd)
+{
+	int i, phyid = -1;
+
+	/* Reset ethernet unit */
+	reset_eth();
+
+	/* Disable interrupts: we don't use ethernet interrupts */
+	jz_writel(ETH_IER, 0);
+
+	for (i=0;i<32;i++)
+		if (search_phy(i)) {
+			phyid = i;
+			break;
+		}
+
+	if (phyid == -1)
+		printf("Can't locate any PHY\n");
+
+	/* Start Auto Negotiation of PHY 0 and check it */
+	if (autonet_complete(phyid))
+		printf("ETH Auto-Negotiation failed\n");
+
+	/* Configure PHY */
+	config_phy(phyid);
+
+	/* Configure MAC */
+	config_mac();
+
+	/* Setup the Rx&Tx descriptors */
+	for (i = 0; i < NUM_RX_DESCS; i++) {
+		rx_desc[i].status  = R_OWN;
+		rx_desc[i].ctrl    = PKTSIZE_ALIGN | RD_RCH;
+		rx_desc[i].addr    = virt_to_phys(NetRxPackets[i]);
+		rx_desc[i].next    = virt_to_phys(rx_desc + i + 1);
+	}
+	rx_desc[NUM_RX_DESCS - 1].next = virt_to_phys(rx_desc); // The last links to the first	
+	rx_desc[NUM_RX_DESCS - 1].ctrl |= RD_RER;  // Set the Receive End Of Ring flag
+
+	for (i = 0; i < NUM_TX_DESCS; i++) {
+		tx_desc[i].status  = 0;
+		tx_desc[i].ctrl    = TD_TCH;
+		tx_desc[i].addr    = 0;
+		tx_desc[i].next    = virt_to_phys(tx_desc + i + 1);
+	}
+	tx_desc[NUM_TX_DESCS - 1].next = virt_to_phys(tx_desc); // The last links to the first
+	tx_desc[NUM_TX_DESCS - 1].ctrl |= TD_TER;  // Set the Transmit End Of Ring flag
+
+	jz_flush_dcache();
+
+	jz_writel(ETH_RAR, virt_to_phys(rx_desc));
+	jz_writel(ETH_TAR, virt_to_phys(tx_desc));
+
+	next_rx = next_tx = 0;
+
+	/* Enable ETH */
+	enable_eth();
+
+	return (1);
+}
+
+static void jz_halt(struct eth_device *dev)
+{
+	disable_eth();
+}
+
+int jz_enet_initialize(bd_t *bis)
+{
+	struct eth_device *dev;
+
+	dev = (struct eth_device *) malloc(sizeof *dev);
+	memset(dev, 0, sizeof *dev);
+
+	sprintf(dev->name, "JZ ETHERNET");
+	dev->iobase = 0;
+	dev->priv   = 0;
+	dev->init   = jz_init;
+	dev->halt   = jz_halt;
+	dev->send   = jz_send;
+	dev->recv   = jz_recv;
+
+	eth_register(dev);
+
+	return 1;
+}
+
+#endif /* CONFIG_JZ4730 || CONFIG_JZ5730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_eth.h u-boot-1.1.6/cpu/mips/jz_eth.h
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_eth.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_eth.h	2007-03-01 16:21:30.000000000 +0800
@@ -0,0 +1,267 @@
+#ifndef __JZ_ETH_H__
+#define __JZ_ETH_H__
+
+#define ETH_BASE	0xB3100000
+
+#define ETH_BMR		(ETH_BASE + 0x1000)
+#define ETH_TPDR	(ETH_BASE + 0x1004)
+#define ETH_RPDR	(ETH_BASE + 0x1008)
+#define ETH_RAR		(ETH_BASE + 0x100C)
+#define ETH_TAR		(ETH_BASE + 0x1010)
+#define ETH_SR		(ETH_BASE + 0x1014)
+#define ETH_OMR		(ETH_BASE + 0x1018)
+#define ETH_IER		(ETH_BASE + 0x101C)
+#define ETH_MFCR	(ETH_BASE + 0x1020)
+#define ETH_CTAR	(ETH_BASE + 0x1050)
+#define ETH_CRAR	(ETH_BASE + 0x1054)
+#define ETH_MCR		(ETH_BASE + 0x0000)
+#define ETH_MAHR	(ETH_BASE + 0x0004)
+#define ETH_MALR	(ETH_BASE + 0x0008)
+#define ETH_HTHR	(ETH_BASE + 0x000C)
+#define ETH_HTLR	(ETH_BASE + 0x0010)
+#define ETH_MIAR	(ETH_BASE + 0x0014)
+#define ETH_MIDR	(ETH_BASE + 0x0018)
+#define ETH_FCR		(ETH_BASE + 0x001C)
+#define ETH_VTR1	(ETH_BASE + 0x0020)
+#define ETH_VTR2	(ETH_BASE + 0x0024)
+#define ETH_WKFR	(ETH_BASE + 0x0028)
+#define ETH_PMTR	(ETH_BASE + 0x002C)
+
+// Bus Mode Register (DMA_BMR)
+#define BMR_PBL		0x00003f00	// Programmable Burst Length
+#define BMR_DSL		0x0000007c	// Descriptor Skip Length
+#define BMR_BAR		0x00000002	// Bus ARbitration
+#define BMR_SWR		0x00000001	// Software Reset
+
+#define DMA_BURST       4
+
+// Status Register (DMA_STS)
+#define STS_BE		0x03800000	// Bus Error Bits
+#define STS_TS		0x00700000	// Transmit Process State
+#define STS_RS		0x000e0000	// Receive Process State
+
+#define TS_STOP		0x00000000	// Stopped
+#define TS_FTD		0x00100000	// Running Fetch Transmit Descriptor
+#define TS_WEOT		0x00200000	// Running Wait for End Of Transmission
+#define TS_QDAT		0x00300000	// Running Queue skb data into TX FIFO
+#define TS_RES		0x00400000	// Reserved
+#define TS_SPKT		0x00500000	// Reserved
+#define TS_SUSP		0x00600000	// Suspended
+#define TS_CLTD		0x00700000	// Running Close Transmit Descriptor
+
+#define RS_STOP		0x00000000	// Stopped
+#define RS_FRD		0x00020000	// Running Fetch Rx Descriptor
+#define RS_CEOR		0x00040000	// Running Check for End of Rx Packet
+#define RS_WFRP		0x00060000	// Running Wait for Rx Packet
+#define RS_SUSP		0x00080000	// Suspended
+#define RS_CLRD		0x000a0000	// Running Close Rx Descriptor
+#define RS_FLUSH	0x000c0000	// Running Flush RX FIFO
+#define RS_QRFS		0x000e0000	// Running Queue RX FIFO into RX Skb
+
+// Operation Mode Register (DMA_OMR)
+#define OMR_TTM		0x00400000	// Transmit Threshold Mode
+#define OMR_SF		0x00200000	// Store and Forward
+#define OMR_TR		0x0000c000	// Threshold Control Bits
+#define OMR_ST		0x00002000	// Start/Stop Transmission Command
+#define OMR_SR		0x00000002	// Start/Stop Receive
+
+#define TR_18		0x00000000	// Threshold set to 18 (32) bytes
+#define TR_24		0x00004000	// Threshold set to 24 (64) bytes
+#define TR_32		0x00008000	// Threshold set to 32 (128) bytes
+#define TR_40		0x0000c000	// Threshold set to 40 (256) bytes
+
+// Missed Frames Counters (DMA_MFC)
+#define MFC_CNT1	0xffff0000	// Missed Frames Counter Bits by
+					// application
+#define MFC_CNT2	0x0000ffff	// Missed Frames Counter Bits by
+					// controller
+
+// Mac control  Register (MAC_MCR)
+#define MCR_RA		0x80000000	// Receive All
+#define MCR_HBD		0x10000000	// HeartBeat Disable
+#define MCR_PS		0x08000000	// Port Select
+#define MCR_DRO		0x00800000	// Receive own Disable
+#define MCR_OM		0x00600000	// Operating(loopback) Mode
+#define MCR_FDX		0x00100000	// Full Duplex Mode
+#define MCR_PM		0x00080000	// Pass All Multicast
+#define MCR_PR		0x00040000	// Promiscuous Mode
+#define MCR_IF		0x00020000	// Inverse Filtering
+#define MCR_PB		0x00010000	// Pass Bad Frames
+#define MCR_HO		0x00008000	// Hash Only Filtering Mode
+#define MCR_HP		0x00002000	// Hash/Perfect Receive Filtering Mode
+#define MCR_LCC		0x00001000	// Late Collision control
+#define MCR_DBF		0x00000800	// Boardcast frame Disable
+#define MCR_DTRY	0x00000400	// Retry Disable
+#define MCR_ASTP	0x00000100	// Automatic pad stripping
+#define MCR_BOLMT	0x000000c0	// Back off Limit
+#define MCR_DC		0x00000020	// Deferral check
+#define MCR_TE		0x00000008	// Transmitter enable
+#define MCR_RE		0x00000004	// Receiver enable
+
+#define MCR_MII_10	( OMR_TTM | MCR_PS)
+#define MCR_MII_100	( MCR_HBD | MCR_PS)
+
+// Constants for the intr mask and intr status registers. (DMA_SIS and DMA_IER)
+#define DMA_INT_NI	0x00010000	// Normal interrupt summary
+#define DMA_INT_AI	0x00008000	// Abnormal interrupt summary
+#define DMA_INT_ER	0x00004000	// Early receive interrupt
+#define DMA_INT_FB	0x00002000	// Fatal bus error
+#define DMA_INT_ET	0x00000400	// Early transmit interrupt
+#define DMA_INT_RW	0x00000200	// Receive watchdog timeout
+#define DMA_INT_RS	0x00000100	// Receive stop
+#define DMA_INT_RU	0x00000080	// Receive buffer unavailble
+#define DMA_INT_RI	0x00000040	// Receive interrupt
+#define DMA_INT_UN	0x00000020	// Underflow 
+#define DMA_INT_TJ	0x00000008	// Transmit jabber timeout
+#define DMA_INT_TU	0x00000004	// Transmit buffer unavailble 
+#define DMA_INT_TS	0x00000002	// Transmit stop
+#define DMA_INT_TI	0x00000001	// Transmit interrupt
+
+#define DMA_TX_DEFAULT 	( DMA_INT_TI | DMA_INT_TS | DMA_INT_TU | DMA_INT_TJ | DMA_INT_FB )
+
+#define DMA_RX_DEFAULT 	( DMA_INT_RI | DMA_INT_RS | DMA_INT_RU | DMA_INT_RW | DMA_INT_FB )
+
+#define DMA_ENABLE	(DMA_INT_NI | DMA_INT_AI)
+
+
+// Receive Descriptor Bit Summary
+#define R_OWN		0x80000000	// Own Bit
+#define RD_FF		0x40000000	// Filtering Fail
+#define RD_FL		0x3fff0000	// Frame Length
+#define RD_ES		0x00008000	// Error Summary
+#define RD_DE		0x00004000	// Descriptor Error
+#define RD_LE		0x00001000	// Length Error
+#define RD_RF		0x00000800	// Runt Frame
+#define RD_MF		0x00000400	// Multicast Frame
+#define RD_FS		0x00000200	// First Descriptor
+#define RD_LS		0x00000100	// Last Descriptor
+#define RD_TL		0x00000080	// Frame Too Long
+#define RD_CS		0x00000040	// Collision Seen
+#define RD_FT		0x00000020	// Frame Type
+#define RD_RJ		0x00000010	// Receive Watchdog timeout
+#define RD_RE		0x00000008	// Report on MII Error
+#define RD_DB		0x00000004	// Dribbling Bit
+#define RD_CE		0x00000002	// CRC Error
+
+#define RD_RER		0x02000000	// Receive End Of Ring
+#define RD_RCH		0x01000000	// Second Address Chained
+#define RD_RBS2		0x003ff800	// Buffer 2 Size
+#define RD_RBS1		0x000007ff	// Buffer 1 Size
+
+// Transmit Descriptor Bit Summary
+#define T_OWN		0x80000000	// Own Bit
+#define TD_ES		0x00008000	// Frame Aborted (error summary)
+#define TD_LO		0x00000800	// Loss Of Carrier
+#define TD_NC		0x00000400	// No Carrier
+#define TD_LC		0x00000200	// Late Collision
+#define TD_EC		0x00000100	// Excessive Collisions
+#define TD_HF		0x00000080	// Heartbeat Fail
+#define TD_CC		0x0000003c	// Collision Counter
+#define TD_UF		0x00000002	// Underflow Error
+#define TD_DE		0x00000001	// Deferred
+
+#define TD_IC		0x80000000	// Interrupt On Completion
+#define TD_LS		0x40000000	// Last Segment
+#define TD_FS		0x20000000	// First Segment
+#define TD_FT1		0x10000000	// Filtering Type
+#define TD_SET		0x08000000	// Setup Packet
+#define TD_AC		0x04000000	// Add CRC Disable
+#define TD_TER		0x02000000	// Transmit End Of Ring
+#define TD_TCH		0x01000000	// Second Address Chained
+#define TD_DPD		0x00800000	// Disabled Padding
+#define TD_FT0		0x00400000	// Filtering Type
+#define TD_TBS2		0x003ff800	// Buffer 2 Size
+#define TD_TBS1		0x000007ff	// Buffer 1 Size
+
+#define PERFECT_F  	0x00000000
+#define HASH_F     	TD_FT0
+#define INVERSE_F  	TD_FT1
+#define HASH_O_F   	(TD_FT1 | TD_F0)
+
+// ------------------------------------------------------------------------
+// MII Registers and Definitions
+// ------------------------------------------------------------------------
+#define MII_CR       0x00          /* MII Management Control Register */
+#define MII_SR       0x01          /* MII Management Status Register */
+#define MII_ID0      0x02          /* PHY Identifier Register 0 */
+#define MII_ID1      0x03          /* PHY Identifier Register 1 */
+#define MII_ANA      0x04          /* Auto Negotiation Advertisement */
+#define MII_ANLPA    0x05          /* Auto Negotiation Link Partner Ability */
+#define MII_ANE      0x06          /* Auto Negotiation Expansion */
+#define MII_ANP      0x07          /* Auto Negotiation Next Page TX */
+
+// MII Management Control Register
+#define MII_CR_RST  0x8000         /* RESET the PHY chip */
+#define MII_CR_LPBK 0x4000         /* Loopback enable */
+#define MII_CR_SPD  0x2000         /* 0: 10Mb/s; 1: 100Mb/s */
+#define MII_CR_10   0x0000         /* Set 10Mb/s */
+#define MII_CR_100  0x2000         /* Set 100Mb/s */
+#define MII_CR_ASSE 0x1000         /* Auto Speed Select Enable */
+#define MII_CR_PD   0x0800         /* Power Down */
+#define MII_CR_ISOL 0x0400         /* Isolate Mode */
+#define MII_CR_RAN  0x0200         /* Restart Auto Negotiation */
+#define MII_CR_FDM  0x0100         /* Full Duplex Mode */
+#define MII_CR_CTE  0x0080         /* Collision Test Enable */
+
+// MII Management Status Register
+#define MII_SR_T4C  0x8000         /* 100BASE-T4 capable */
+#define MII_SR_TXFD 0x4000         /* 100BASE-TX Full Duplex capable */
+#define MII_SR_TXHD 0x2000         /* 100BASE-TX Half Duplex capable */
+#define MII_SR_TFD  0x1000         /* 10BASE-T Full Duplex capable */
+#define MII_SR_THD  0x0800         /* 10BASE-T Half Duplex capable */
+#define MII_SR_ASSC 0x0020         /* Auto Speed Selection Complete*/
+#define MII_SR_RFD  0x0010         /* Remote Fault Detected */
+#define MII_SR_ANC  0x0008         /* Auto Negotiation capable */
+#define MII_SR_LKS  0x0004         /* Link Status */
+#define MII_SR_JABD 0x0002         /* Jabber Detect */
+#define MII_SR_XC   0x0001         /* Extended Capabilities */
+
+// MII Management Auto Negotiation Advertisement Register
+#define MII_ANA_TAF  0x03e0        /* Technology Ability Field */
+#define MII_ANA_T4AM 0x0200        /* T4 Technology Ability Mask */
+#define MII_ANA_TXAM 0x0180        /* TX Technology Ability Mask */
+#define MII_ANA_FDAM 0x0140        /* Full Duplex Technology Ability Mask */
+#define MII_ANA_HDAM 0x02a0        /* Half Duplex Technology Ability Mask */
+#define MII_ANA_100M 0x0380        /* 100Mb Technology Ability Mask */
+#define MII_ANA_10M  0x0060        /* 10Mb Technology Ability Mask */
+#define MII_ANA_CSMA 0x0001        /* CSMA-CD Capable */
+
+// MII Management Auto Negotiation Remote End Register
+#define MII_ANLPA_NP   0x8000      /* Next Page (Enable) */
+#define MII_ANLPA_ACK  0x4000      /* Remote Acknowledge */
+#define MII_ANLPA_RF   0x2000      /* Remote Fault */
+#define MII_ANLPA_TAF  0x03e0      /* Technology Ability Field */
+#define MII_ANLPA_T4AM 0x0200      /* T4 Technology Ability Mask */
+#define MII_ANLPA_TXAM 0x0180      /* TX Technology Ability Mask */
+#define MII_ANLPA_FDAM 0x0140      /* Full Duplex Technology Ability Mask */
+#define MII_ANLPA_HDAM 0x02a0      /* Half Duplex Technology Ability Mask */
+#define MII_ANLPA_100M 0x0380      /* 100Mb Technology Ability Mask */
+#define MII_ANLPA_10M  0x0060      /* 10Mb Technology Ability Mask */
+#define MII_ANLPA_CSMA 0x0001      /* CSMA-CD Capable */
+
+// Media / mode state machine definitions
+// User selectable:
+#define TP              0x0040     /* 10Base-T (now equiv to _10Mb)        */
+#define TP_NW           0x0002     /* 10Base-T with Nway                   */
+#define BNC             0x0004     /* Thinwire                             */
+#define AUI             0x0008     /* Thickwire                            */
+#define BNC_AUI         0x0010     /* BNC/AUI on DC21040 indistinguishable */
+#define _10Mb           0x0040     /* 10Mb/s Ethernet                      */
+#define _100Mb          0x0080     /* 100Mb/s Ethernet                     */
+#define AUTO            0x4000     /* Auto sense the media or speed        */
+
+// Internal states
+#define NC              0x0000     /* No Connection                        */
+#define ANS             0x0020     /* Intermediate AutoNegotiation State   */
+#define SPD_DET         0x0100     /* Parallel speed detection             */
+#define INIT            0x0200     /* Initial state                        */
+#define EXT_SIA         0x0400     /* External SIA for motherboard chip    */
+#define ANS_SUSPECT     0x0802     /* Suspect the ANS (TP) port is down    */
+#define TP_SUSPECT      0x0803     /* Suspect the TP port is down          */
+#define BNC_AUI_SUSPECT 0x0804     /* Suspect the BNC or AUI port is down  */
+#define EXT_SIA_SUSPECT 0x0805     /* Suspect the EXT SIA port is down     */
+#define BNC_SUSPECT     0x0806     /* Suspect the BNC port is down         */
+#define AUI_SUSPECT     0x0807     /* Suspect the AUI port is down         */
+#define MII             0x1000     /* MII on the 21143                     */
+
+#endif /* __JZ_ETH_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_i2c.c u-boot-1.1.6/cpu/mips/jz_i2c.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_i2c.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_i2c.c	2008-12-10 19:46:50.000000000 +0800
@@ -0,0 +1,234 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#include <config.h>
+
+#if defined(CONFIG_JZ4730) || defined(CONFIG_JZ4740) || defined(CONFIG_JZ5730) || defined(CONFIG_JZ4750)
+
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <command.h>
+#include <asm/io.h>
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+#if defined(CONFIG_JZ4750)
+#include <asm/jz4750.h>
+#endif
+
+
+/* I2C protocol */
+#define I2C_READ	1
+#define I2C_WRITE	0
+
+#define TIMEOUT         1000
+
+#define ETIMEDOUT 1
+
+
+static inline void my_udelay(int n )
+{
+	int i;
+	i=n*100;
+	while ( i-- )
+		;
+}
+
+
+/*
+ * I2C bus protocol basic routines
+ */
+static int i2c_put_data(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT*10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (!__i2c_received_ack() && timeout)
+		timeout--;
+
+	if (timeout)
+		return 0;
+	else
+		return -ETIMEDOUT;
+}
+
+static int i2c_get_data(unsigned char *data, int ack)
+{
+	int timeout = TIMEOUT*10;
+
+	if (!ack)
+		__i2c_send_nack();
+	else
+		__i2c_send_ack();
+
+	while (__i2c_check_drf() == 0 && timeout)
+		timeout--;
+
+	if (timeout) {
+		if (!ack)
+			__i2c_send_stop();
+		*data = __i2c_read();
+		__i2c_clear_drf();
+		return 0;
+	} else
+		return -ETIMEDOUT;
+}
+
+/*
+ * I2C interface
+ */
+void i2c_open(void)
+{
+	__i2c_set_clk(CFG_EXTAL, 10000); /* default 10 KHz */
+	__i2c_enable();
+}
+
+void i2c_close(void)
+{
+	my_udelay(300); /* wait for STOP goes over. */
+	__i2c_disable();
+}
+
+void i2c_setclk(unsigned int i2cclk)
+{
+	__i2c_set_clk(CFG_EXTAL, i2cclk);
+}
+
+int i2c_lseek(unsigned char device, unsigned char offset)
+{
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(offset) < 0)
+		goto address_err;
+	return 0;
+ device_err:
+	printf("No I2C device (0x%02x) installed.\n", device);
+	__i2c_send_stop();
+	return -1;
+ address_err:
+	printf("No I2C device (0x%02x) response.\n", device);
+	__i2c_send_stop();
+	return -1;
+}
+
+int i2c_read(unsigned char device, unsigned char *buf,
+	       unsigned char address, int count)
+{
+	int cnt = count;
+	int timeout = 5;
+
+L_try_again:
+
+	if (timeout < 0)
+		goto L_timeout;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_werr;
+	if (i2c_put_data(address) < 0)
+		goto address_err;
+
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_READ ) < 0)
+		goto device_rerr;
+	__i2c_send_ack();	/* Master sends ACK for continue reading */
+	while (cnt) {
+		if (cnt == 1) {
+			if (i2c_get_data(buf, 0) < 0)
+				break;
+		} else {
+			if (i2c_get_data(buf, 1) < 0)
+				break;
+		}
+		cnt--;
+		buf++;
+	}
+
+	__i2c_send_stop();
+	return count - cnt;
+ device_rerr:
+ device_werr:
+ address_err:
+	timeout --;
+	__i2c_send_stop();
+	goto L_try_again;
+
+L_timeout:
+	__i2c_send_stop();
+	printf("Read I2C device 0x%2x failed.\n", device);
+	return -1;
+}
+
+int i2c_write(unsigned char device, unsigned char *buf,
+		unsigned char address, int count)
+{
+	int cnt = count;
+	int cnt_in_pg;
+	int timeout = 5;
+	unsigned char *tmpbuf;
+	unsigned char tmpaddr;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+
+ W_try_again:
+	if (timeout < 0)
+		goto W_timeout;
+
+	cnt = count;
+	tmpbuf = (unsigned char *)buf;
+	tmpaddr = address;
+
+ start_write_page:
+	cnt_in_pg = 0;
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(tmpaddr) < 0)
+		goto address_err;
+	while (cnt) {
+		if (++cnt_in_pg > 8) {
+			__i2c_send_stop();
+			my_udelay(1000);
+			tmpaddr += 8;
+			goto start_write_page;
+		}
+		if (i2c_put_data(*tmpbuf) < 0)
+			break;
+		cnt--;
+		tmpbuf++;
+	}
+	__i2c_send_stop();
+	return count - cnt;
+ device_err:
+ address_err:
+	timeout--;
+	__i2c_send_stop();
+	goto W_try_again;
+
+ W_timeout:
+	printf("Write I2C device 0x%2x failed.\n", device);
+	__i2c_send_stop();
+	return -1;
+}
+
+#endif /* CONFIG_JZ4730 || CONFIG_JZ4740 || CONFIG_JZ5730 */
+
+
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_lcd.c u-boot-1.1.6/cpu/mips/jz_lcd.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_lcd.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_lcd.c	2009-02-03 21:04:08.000000000 +0800
@@ -0,0 +1,669 @@
+/*
+ * JzRISC lcd controller
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/************************************************************************/
+/* ** HEADER FILES							*/
+/************************************************************************/
+
+/* 
+ * Fallowing macro may be used:
+ *  CONFIG_LCD                        : LCD support 
+ *  LCD_BPP                           : Bits per pixel, 0 = 1, 1 = 2, 2 = 4, 3 = 8
+ *  CFG_WHITE_ON_BLACK
+ *  CONFIG_LCD_LOGO                   : show logo
+ *  CFG_LCD_LOGOONLY_NOINFO           : not display info on lcd screen, only logo
+ * -----------------------------------------------------------------------
+ * bugs:
+ * if BMP_LOGO_HEIGHT > (lcd screen height - 2*VIDEO_FONT_HEIGHT),
+ * must not print info onto screen,
+ * it means should define CFG_LCD_LOGOONLY_NOINFO.
+ */
+
+
+
+#include <config.h>
+#include <common.h>
+#include <devices.h>
+#include <lcd.h>
+
+#include <asm/io.h>               /* virt_to_phys() */
+
+#if defined(CONFIG_LCD) && !defined(CONFIG_SLCD)
+
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+
+#include "jz_lcd.h"
+
+
+
+/************************************************************************/
+
+struct jzfb_info {
+	unsigned int cfg;	/* panel mode and pin usage etc. */
+	unsigned int w;
+	unsigned int h;
+	unsigned int bpp;	/* bit per pixel */
+	unsigned int fclk;	/* frame clk */
+	unsigned int hsw;	/* hsync width, in pclk */
+	unsigned int vsw;	/* vsync width, in line count */
+	unsigned int elw;	/* end of line, in pclk */
+	unsigned int blw;	/* begin of line, in pclk */
+	unsigned int efw;	/* end of frame, in line count */
+	unsigned int bfw;	/* begin of frame, in line count */
+};
+
+
+static struct jzfb_info jzfb = {
+#if defined(CONFIG_JZLCD_SHARP_LQ035Q7)
+	MODE_TFT_SHARP | PCLK_N | VSYNC_N,
+	240, 320, 16, 60, 1, 2, 1, 2, 0, 6
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTS350Q1)
+	MODE_TFT_SAMSUNG | PCLK_N,
+	240, 320, 16, 60, 1, 2, (254-240), 0, 7, 0
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTV350QVF04)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N,
+	320, 240, 16, 70, 19, 4, 20, 14, 18, 6
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTP400WQF01)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N,
+	480, 272, 16, 60, 41, 10, 2, 2, 2, 2
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTP400WQF02_18BIT)
+	MODE_TFT_GEN | MODE_TFT_18BIT | HSYNC_N | VSYNC_N, /* MODE_TFT_18BIT: JZ4740@ version */
+	480, 272, 32, 60, 41, 10, 2, 2, 2, 2
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N | PCLK_N,
+	320, 240, 16, 85, 30, 3, 38, 20, 11, 8
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL)
+	MODE_8BIT_SERIAL_TFT | HSYNC_N | VSYNC_N | PCLK_N,
+	/* serial mode 280 lines, parallel mode 240 lines */
+	320, 280, 32, 60, (30*3), 3, (20*3), (38*3), 46, 23 
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N | PCLK_N | DE_N,
+	//240, 320, 16, 60, 3, 3, 3, 3, 3, 3 /* 240x320 */
+	320, 240, 16, 60, 3, 3, 3, 3, 3, 85 /* 320x240 */
+#endif
+#if defined(CONFIG_JZLCD_HYNIX_HT10X21)
+	MODE_TFT_GEN | PCLK_N,
+	1024, 768, 16, 45, 1, 1, 75, 0, 3, 0
+#endif
+#if defined(CONFIG_JZLCD_TOSHIBA_LTM084P363)
+	MODE_TFT_GEN | PCLK_N,
+	800, 600, 16, 50, 1, 2, 199, 0, 2, 0
+#endif
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01) && (!defined(CONFIG_PAVO))
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N | PCLK_N,
+	320, 240, 16, 110, 1, 1, 10, 50, 10, 13
+#endif
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01) && defined(CONFIG_PAVO)
+	MODE_TFT_GEN | HSYNC_N | VSYNC_N | MODE_TFT_18BIT | PCLK_N,
+	320, 240, 18, 110, 1, 1, 10, 50, 10, 13
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL)
+	MODE_8BIT_SERIAL_TFT | PCLK_N | HSYNC_N | VSYNC_N,
+	320, 240, 32, 60, 1, 1, 10, 50, 10, 13
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)
+	MODE_TFT_SHARP | PCLK_N,
+	800, 600, 16, 50, 1, 1, 255, 0, 34, 0 
+#endif
+#if defined(CONFIG_JZLCD_CSTN_800x600)
+	MODE_STN_COLOR_DUAL | STN_DAT_PIN8,
+	800, 600, 16, 30, 8, 1, 0, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_CSTN_320x240)
+	MODE_STN_COLOR_SINGLE | STN_DAT_PIN8,
+	320, 240, 16, 120, 8, 1, 8, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_MSTN_640x480)
+	MODE_STN_MONO_DUAL | STN_DAT_PIN4,
+	640, 480, 8, 110, 4, 1, 4, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_MSTN_320x240)
+	MODE_STN_MONO_SINGLE | STN_DAT_PIN4,
+	320, 240, 8, 110, 4, 1, 4, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_MSTN_480x320)
+	MODE_STN_MONO_SINGLE | STN_DAT_PIN8
+#if defined(CONFIG_JZLCD_MSTN_INVERSE)
+	| DATA_INVERSE
+#endif
+	, 480, 320, 8, 65, 8, 1, 8, 0, 0, 0
+#endif
+#if defined(CONFIG_JZLCD_MSTN_240x128)
+	MODE_STN_MONO_SINGLE | STN_DAT_PIN1
+#if defined(CONFIG_JZLCD_MSTN_INVERSE)
+	| DATA_INVERSE
+#endif
+	, 240, 128, 8, 100, 1, 1, 1, 0, 0, 0 
+#endif
+};
+
+/************************************************************************/
+
+vidinfo_t panel_info = {
+#if defined(CONFIG_JZLCD_SHARP_LQ035Q7)
+	240, 320, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTS350Q1)
+	240, 320, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTV350QVF04)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTP400WQF01)
+	480, 272, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_SAMSUNG_LTP400WQF02_18BIT)
+	480, 272, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL)
+	320, 280, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL)
+	320, 240, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_HYNIX_HT10X21)
+	1024, 768, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_TOSHIBA_LTM084P363)
+	800, 600, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)
+	800, 600, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_CSTN_800x600)
+	800, 600, LCD_BPP,
+#endif
+#if defined(CONFIG_JZLCD_CSTN_320x240)
+	320, 240, LCD_BPP,
+#endif
+};
+
+
+/*----------------------------------------------------------------------*/
+
+int lcd_line_length;
+
+int lcd_color_fg;
+int lcd_color_bg;
+
+/*
+ * Frame buffer memory information
+ */
+void *lcd_base;			/* Start of framebuffer memory	*/
+void *lcd_console_address;	/* Start of console buffer	*/
+
+short console_col;
+short console_row;
+
+/************************************************************************/
+
+void lcd_ctrl_init (void *lcdbase);
+
+void lcd_enable (void);
+void lcd_disable (void);
+
+
+/************************************************************************/
+
+static int  jz_lcd_init_mem(void *lcdbase, vidinfo_t *vid);
+static void jz_lcd_desc_init(vidinfo_t *vid);
+static int  jz_lcd_hw_init( vidinfo_t *vid );
+extern int flush_cache_all(void);
+
+#if LCD_BPP == LCD_COLOR8
+void lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue);
+#endif
+#if LCD_BPP == LCD_MONOCHROME
+void lcd_initcolregs (void);
+#endif
+
+/************************************************************************/
+
+void lcd_ctrl_init (void *lcdbase)
+{
+	__lcd_display_pin_init();
+
+	jz_lcd_init_mem(lcdbase, &panel_info);
+	jz_lcd_desc_init(&panel_info);
+	jz_lcd_hw_init(&panel_info);
+
+	__lcd_display_on() ;
+}
+
+/*----------------------------------------------------------------------*/
+#if LCD_BPP == LCD_COLOR8
+void
+lcd_setcolreg (ushort regno, ushort red, ushort green, ushort blue)
+{
+}
+#endif
+/*----------------------------------------------------------------------*/
+
+#if LCD_BPP == LCD_MONOCHROME
+static
+void lcd_initcolregs (void)
+{
+}
+#endif
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Before enabled lcd controller, lcd registers should be configured correctly.
+ */
+
+void lcd_enable (void)
+{
+	REG_LCD_CTRL &= ~(1<<4); /* LCDCTRL.DIS */
+	REG_LCD_CTRL |= 1<<3;    /* LCDCTRL.ENA*/
+}
+
+/*----------------------------------------------------------------------*/
+
+
+void lcd_disable (void)
+{
+	REG_LCD_CTRL |= (1<<4); /* LCDCTRL.DIS, regular disable */
+	/* REG_LCD_CTRL |= (1<<3); */  /* LCDCTRL.DIS, quikly disable */
+}
+
+/************************************************************************/
+
+
+static int jz_lcd_init_mem(void *lcdbase, vidinfo_t *vid)
+{
+	u_long palette_mem_size;
+	struct jz_fb_info *fbi = &vid->jz_fb;
+	int fb_size = vid->vl_row * (vid->vl_col * NBITS (vid->vl_bpix)) / 8;
+
+	fbi->screen = (u_long)lcdbase;
+	fbi->palette_size = 256;
+	palette_mem_size = fbi->palette_size * sizeof(u16);
+
+	debug("palette_mem_size = 0x%08lx\n", (u_long) palette_mem_size);
+	/* locate palette and descs at end of page following fb */
+	fbi->palette = (u_long)lcdbase + fb_size + PAGE_SIZE - palette_mem_size;
+
+	return 0;
+}
+
+static void jz_lcd_desc_init(vidinfo_t *vid)
+{
+	struct jz_fb_info * fbi;
+	fbi = &vid->jz_fb;
+	fbi->dmadesc_fblow = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 3*16);
+	fbi->dmadesc_fbhigh = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 2*16);
+	fbi->dmadesc_palette = (struct jz_fb_dma_descriptor *)((unsigned int)fbi->palette - 1*16);
+
+
+	#define BYTES_PER_PANEL	 (vid->vl_col * vid->vl_row * NBITS(vid->vl_bpix) / 8)
+
+	/* populate descriptors */
+	fbi->dmadesc_fblow->fdadr = virt_to_phys(fbi->dmadesc_fblow);
+	fbi->dmadesc_fblow->fsadr = virt_to_phys((void *)(fbi->screen + BYTES_PER_PANEL));
+	fbi->dmadesc_fblow->fidr  = 0;
+	fbi->dmadesc_fblow->ldcmd = BYTES_PER_PANEL / 4 ;
+
+	fbi->fdadr1 = virt_to_phys(fbi->dmadesc_fblow); /* only used in dual-panel mode */
+
+	fbi->dmadesc_fbhigh->fsadr = virt_to_phys((void *)fbi->screen); 
+	fbi->dmadesc_fbhigh->fidr = 0;
+	fbi->dmadesc_fbhigh->ldcmd =  BYTES_PER_PANEL / 4; /* length in word */
+
+	fbi->dmadesc_palette->fsadr = virt_to_phys((void *)fbi->palette);
+	fbi->dmadesc_palette->fidr  = 0;
+	fbi->dmadesc_palette->ldcmd = (fbi->palette_size * 2)/4 | (1<<28);
+
+	if( NBITS(vid->vl_bpix) < 12)
+	{
+		/* assume any mode with <12 bpp is palette driven */
+		fbi->dmadesc_palette->fdadr = virt_to_phys(fbi->dmadesc_fbhigh);
+		fbi->dmadesc_fbhigh->fdadr = virt_to_phys(fbi->dmadesc_palette);
+		/* flips back and forth between pal and fbhigh */
+		fbi->fdadr0 = virt_to_phys(fbi->dmadesc_palette);
+	}
+	else
+	{
+		/* palette shouldn't be loaded in true-color mode */
+		fbi->dmadesc_fbhigh->fdadr = virt_to_phys((void *)fbi->dmadesc_fbhigh);
+		fbi->fdadr0 = virt_to_phys(fbi->dmadesc_fbhigh); /* no pal just fbhigh */
+	}
+
+	flush_cache_all();
+}
+
+static int  jz_lcd_hw_init(vidinfo_t *vid)
+{
+	struct jz_fb_info *fbi = &vid->jz_fb;
+	unsigned int val = 0;
+	unsigned int pclk;
+	unsigned int stnH;
+#if defined(CONFIG_MIPS_JZ4740)
+	int pll_div;
+#endif
+
+	/* Setting Control register */
+	switch (jzfb.bpp) {
+	case 1:
+		val |= LCD_CTRL_BPP_1;
+		break;
+	case 2:
+		val |= LCD_CTRL_BPP_2;
+		break;
+	case 4:
+		val |= LCD_CTRL_BPP_4;
+		break;
+	case 8:
+		val |= LCD_CTRL_BPP_8;
+		break;
+	case 15:
+		val |= LCD_CTRL_RGB555;
+	case 16:
+		val |= LCD_CTRL_BPP_16;
+		break;
+#if defined(CONFIG_MIPS_JZ4740)
+	case 17 ... 32:
+		val |= LCD_CTRL_BPP_18_24;	/* target is 4bytes/pixel */
+		break;
+#endif
+	default:
+		printf("The BPP %d is not supported\n", jzfb.bpp);
+		val |= LCD_CTRL_BPP_16;
+		break;
+	}
+
+	switch (jzfb.cfg & MODE_MASK) {
+	case MODE_STN_MONO_DUAL:
+	case MODE_STN_COLOR_DUAL:
+	case MODE_STN_MONO_SINGLE:
+	case MODE_STN_COLOR_SINGLE:
+		switch (jzfb.bpp) {
+		case 1:
+			//val |= LCD_CTRL_PEDN;
+		case 2:
+			val |= LCD_CTRL_FRC_2;
+			break;
+		case 4:
+			val |= LCD_CTRL_FRC_4;
+			break;
+		case 8:
+		default:
+			val |= LCD_CTRL_FRC_16;
+			break;
+		}
+		break;
+	}
+
+	val |= LCD_CTRL_BST_16;		/* Burst Length is 16WORD=64Byte */
+	val |= LCD_CTRL_OFUP;		/* OutFIFO underrun protect */
+
+	switch (jzfb.cfg & MODE_MASK) {
+	case MODE_STN_MONO_DUAL:
+	case MODE_STN_COLOR_DUAL:
+	case MODE_STN_MONO_SINGLE:
+	case MODE_STN_COLOR_SINGLE:
+		switch (jzfb.cfg & STN_DAT_PINMASK) {
+#define align2(n) (n)=((((n)+1)>>1)<<1)
+#define align4(n) (n)=((((n)+3)>>2)<<2)
+#define align8(n) (n)=((((n)+7)>>3)<<3)
+		case STN_DAT_PIN1:
+			/* Do not adjust the hori-param value. */
+			break;
+		case STN_DAT_PIN2:
+			align2(jzfb.hsw);
+			align2(jzfb.elw);
+			align2(jzfb.blw);
+			break;
+		case STN_DAT_PIN4:
+			align4(jzfb.hsw);
+			align4(jzfb.elw);
+			align4(jzfb.blw);
+			break;
+		case STN_DAT_PIN8:
+			align8(jzfb.hsw);
+			align8(jzfb.elw);
+			align8(jzfb.blw);
+			break;
+		}
+		break;
+	}
+
+	REG_LCD_CTRL = val;
+
+	switch (jzfb.cfg & MODE_MASK) {
+	case MODE_STN_MONO_DUAL:
+	case MODE_STN_COLOR_DUAL:
+	case MODE_STN_MONO_SINGLE:
+	case MODE_STN_COLOR_SINGLE:
+		if (((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_DUAL) ||
+		    ((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL))
+			stnH = jzfb.h >> 1;
+		else
+			stnH = jzfb.h;
+
+		REG_LCD_VSYNC = (0 << 16) | jzfb.vsw;
+		REG_LCD_HSYNC = ((jzfb.blw+jzfb.w) << 16) | (jzfb.blw+jzfb.w+jzfb.hsw);
+
+		/* Screen setting */
+		REG_LCD_VAT = ((jzfb.blw + jzfb.w + jzfb.hsw + jzfb.elw) << 16) | (stnH + jzfb.vsw + jzfb.bfw + jzfb.efw);
+		REG_LCD_DAH = (jzfb.blw << 16) | (jzfb.blw + jzfb.w);
+		REG_LCD_DAV = (0 << 16) | (stnH);
+
+		/* AC BIAs signal */
+		REG_LCD_PS = (0 << 16) | (stnH+jzfb.vsw+jzfb.efw+jzfb.bfw);
+
+		break;
+
+	case MODE_TFT_GEN:
+	case MODE_TFT_SHARP:
+	case MODE_TFT_CASIO:
+	case MODE_TFT_SAMSUNG:
+	case MODE_8BIT_SERIAL_TFT:
+	case MODE_TFT_18BIT:
+		REG_LCD_VSYNC = (0 << 16) | jzfb.vsw;
+		REG_LCD_HSYNC = (0 << 16) | jzfb.hsw;
+#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)
+		REG_LCD_DAV = (0 << 16) | ( jzfb.h );
+#else
+		REG_LCD_DAV =((jzfb.vsw+jzfb.bfw) << 16) | (jzfb.vsw +jzfb.bfw+jzfb.h);
+#endif /*#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)*/
+		REG_LCD_DAH = ((jzfb.hsw + jzfb.blw) << 16) | (jzfb.hsw + jzfb.blw + jzfb.w );
+		REG_LCD_VAT = (((jzfb.blw + jzfb.w + jzfb.elw + jzfb.hsw)) << 16) \
+			| (jzfb.vsw + jzfb.bfw + jzfb.h + jzfb.efw);
+		break;
+	}
+
+	switch (jzfb.cfg & MODE_MASK) {
+	case MODE_TFT_SAMSUNG:
+	{
+		unsigned int total, tp_s, tp_e, ckv_s, ckv_e;
+		unsigned int rev_s, rev_e, inv_s, inv_e;
+
+		pclk = val * (jzfb.w + jzfb.hsw + jzfb.elw + jzfb.blw) *
+			(jzfb.h + jzfb.vsw + jzfb.efw + jzfb.bfw); /* Pixclk */
+
+		total = jzfb.blw + jzfb.w + jzfb.elw + jzfb.hsw;
+		tp_s = jzfb.blw + jzfb.w + 1;
+		tp_e = tp_s + 1;
+		//ckv_s = tp_s - jz_clocks.pixclk/(1000000000/4100);
+		ckv_s = tp_s - pclk/(1000000000/4100);
+		ckv_e = tp_s + total;
+		rev_s = tp_s - 11;	/* -11.5 clk */
+		rev_e = rev_s + total;
+		inv_s = tp_s;
+		inv_e = inv_s + total;
+		REG_LCD_CLS = (tp_s << 16) | tp_e;
+		REG_LCD_PS = (ckv_s << 16) | ckv_e;
+		REG_LCD_SPL = (rev_s << 16) | rev_e;
+		REG_LCD_REV = (inv_s << 16) | inv_e;
+		jzfb.cfg |= STFT_REVHI | STFT_SPLHI;
+		break;
+	}
+	case MODE_TFT_SHARP:
+	{
+		unsigned int total, cls_s, cls_e, ps_s, ps_e;
+		unsigned int spl_s, spl_e, rev_s, rev_e;
+		total = jzfb.blw + jzfb.w + jzfb.elw + jzfb.hsw;
+#if !defined(CONFIG_JZLCD_INNOLUX_AT080TN42)
+		spl_s = 1;
+		spl_e = spl_s + 1;
+		cls_s = 0;
+		cls_e = total - 60;	/* > 4us (pclk = 80ns) */
+		ps_s = cls_s;
+		ps_e = cls_e;
+		rev_s = total - 40;	/* > 3us (pclk = 80ns) */
+		rev_e = rev_s + total;
+		jzfb.cfg |= STFT_PSHI; 
+#else           /*#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)*/
+		spl_s = total - 5; /* LD */
+		spl_e = total -3;
+		cls_s = 32;	/* CKV */
+		cls_e = 145;
+		ps_s  = 0;      /* OEV */
+		ps_e  = 45;
+		rev_s = 0;	/* POL */
+		rev_e = 0;
+#endif          /*#if defined(CONFIG_JZLCD_INNOLUX_AT080TN42)*/
+		REG_LCD_SPL = (spl_s << 16) | spl_e;
+		REG_LCD_CLS = (cls_s << 16) | cls_e;
+		REG_LCD_PS = (ps_s << 16) | ps_e;
+		REG_LCD_REV = (rev_s << 16) | rev_e;
+		break;
+	}
+	case MODE_TFT_CASIO:
+		break;
+	}
+
+	/* Configure the LCD panel */
+	REG_LCD_CFG = jzfb.cfg;
+
+	/* Timing setting */
+	__cpm_stop_lcd();
+
+	val = jzfb.fclk; /* frame clk */
+	if ( (jzfb.cfg & MODE_MASK) != MODE_8BIT_SERIAL_TFT) {
+		pclk = val * (jzfb.w + jzfb.hsw + jzfb.elw + jzfb.blw) *
+			(jzfb.h + jzfb.vsw + jzfb.efw + jzfb.bfw); /* Pixclk */
+	}
+	else {
+		/* serial mode: Hsync period = 3*Width_Pixel */
+		pclk = val * (jzfb.w*3 + jzfb.hsw + jzfb.elw + jzfb.blw) *
+			(jzfb.h + jzfb.vsw + jzfb.efw + jzfb.bfw); /* Pixclk */
+	}
+
+	if (((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_SINGLE) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL))
+		pclk = (pclk * 3);
+
+	if (((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_SINGLE) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_SINGLE) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_DUAL))
+		pclk = pclk >> ((jzfb.cfg & STN_DAT_PINMASK) >> 4);
+
+	if (((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_DUAL))
+		pclk >>= 1;
+
+#if defined(CONFIG_MIPS_JZ4730)
+	val = __cpm_get_pllout() / pclk;
+	REG_CPM_CFCR2 = val - 1;
+	val = pclk * 4 ;
+	if ( val > 150000000 ) {
+		printf("Warning: LCDClock=%d\n, LCDClock must less or equal to 150MHz.\n", val);
+		printf("Change LCDClock to 150MHz\n");
+		val = 150000000;
+	}
+	val = __cpm_get_pllout() / val;
+	val--;
+	if ( val > 0xF ) 
+		val = 0xF;
+	__cpm_set_lcdclk_div(val);
+	REG_CPM_CFCR |= CPM_CFCR_UPE;
+
+#elif defined(CONFIG_MIPS_JZ4740)
+	pll_div = ( REG_CPM_CPCCR & CPM_CPCCR_PCS ); /* clock source,0:pllout/2 1: pllout */
+	pll_div = pll_div ? 1 : 2 ;
+	val = ( __cpm_get_pllout()/pll_div ) / pclk;
+	val--;
+	if ( val > 0x1ff ) {
+		printf("CPM_LPCDR too large, set it to 0x1ff\n");
+		val = 0x1ff;
+	}
+	__cpm_set_pixdiv(val);
+
+	val = pclk * 3 ;	/* LCDClock > 2.5*Pixclock */
+	if ( val > 150000000 ) {
+		printf("Warning: LCDClock=%d\n, LCDClock must less or equal to 150MHz.\n", val);
+		printf("Change LCDClock to 150MHz\n");
+		val = 150000000;
+	}
+	val = ( __cpm_get_pllout()/pll_div ) / val;
+	val--;
+	if ( val > 0x1f ) {
+		printf("CPM_CPCCR.LDIV too large, set it to 0x1f\n");
+		val = 0x1f;
+	}
+	__cpm_set_ldiv( val );
+	REG_CPM_CPCCR |= CPM_CPCCR_CE ; /* update divide */
+
+#else
+#error "drivers/video/Jzlcd.c, CONFIG_MIPS_JZ4730, please set chip type."
+#endif /*#ifdef CONFIG_MIPS_JZ4730 */
+
+	__cpm_start_lcd();
+	udelay(1000);
+
+	REG_LCD_DA0 = fbi->fdadr0; /* frame descripter*/
+
+	if (((jzfb.cfg & MODE_MASK) == MODE_STN_COLOR_DUAL) ||
+	    ((jzfb.cfg & MODE_MASK) == MODE_STN_MONO_DUAL))
+		REG_LCD_DA1 = fbi->fdadr1; /* frame descripter*/
+
+	return 0;
+}
+
+#endif /* CONFIG_LCD */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_lcd.h u-boot-1.1.6/cpu/mips/jz_lcd.h
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_lcd.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_lcd.h	2008-05-05 14:56:17.000000000 +0800
@@ -0,0 +1,938 @@
+#ifndef __JZLCD_H__
+#define __JZLCD_H__
+
+#include <asm/io.h>
+
+/* =============================================== */
+/*
+ * change u-boot macro to celinux macro 
+ */
+
+/* Chip type */
+#if defined(CONFIG_JZ4730)
+#define CONFIG_MIPS_JZ4730 		1
+#endif
+#if defined(CONFIG_JZ4740)
+#define CONFIG_MIPS_JZ4740 		1
+#endif
+#if defined(CONFIG_JZ5730)
+#define CONFIG_MIPS_JZ5730 		1
+#endif
+
+/* board */
+#if defined(CONFIG_LIBRA)
+#define CONFIG_MIPS_JZ4730_LIBRA 		1
+#endif
+#if defined(CONFIG_PMPV1)
+#define CONFIG_MIPS_JZ4730_PMPV1 		1
+#endif
+#if defined(CONFIG_PMPV2)
+#define CONFIG_MIPS_JZ4730_PMPV2 		1
+#endif
+#if defined(CONFIG_GPS)
+#define CONFIG_MIPS_JZ4730_GPS 			1
+#endif
+#if defined(CONFIG_FPRINT)
+#define CONFIG_MIPS_JZ4730_FPRINT 		1
+#endif
+#if defined(CONFIG_LEO)
+#define CONFIG_MIPS_JZ4740_LEO 			1
+#endif
+#if defined(CONFIG_PAVO)
+#define CONFIG_MIPS_JZ4740_PAVO 		1
+#endif
+#if defined(CONFIG_VIRGO)
+#define CONFIG_MIPS_JZ4740_VIRGO 		1
+#endif
+
+#define mdelay(n) 		udelay((n)*1000)
+
+/*
+ * change u-boot macro to celinux macro 
+ */
+/* =============================================== */
+
+#define NR_PALETTE	256
+
+struct lcd_desc{
+	unsigned int next_desc; /* LCDDAx */
+	unsigned int databuf;   /* LCDSAx */
+	unsigned int frame_id;  /* LCDFIDx */ 
+	unsigned int cmd;       /* LCDCMDx */
+};
+
+#define MODE_MASK		0x0f
+#define MODE_TFT_GEN		0x00
+#define MODE_TFT_SHARP		0x01
+#define MODE_TFT_CASIO		0x02
+#define MODE_TFT_SAMSUNG	0x03
+#define MODE_CCIR656_NONINT	0x04
+#define MODE_CCIR656_INT	0x05
+#define MODE_STN_COLOR_SINGLE	0x08
+#define MODE_STN_MONO_SINGLE	0x09
+#define MODE_STN_COLOR_DUAL	0x0a
+#define MODE_STN_MONO_DUAL	0x0b
+#define MODE_8BIT_SERIAL_TFT    0x0c
+
+#define MODE_TFT_18BIT          (1<<7)
+
+#define STN_DAT_PIN1	(0x00 << 4)
+#define STN_DAT_PIN2	(0x01 << 4)
+#define STN_DAT_PIN4	(0x02 << 4)
+#define STN_DAT_PIN8	(0x03 << 4)
+#define STN_DAT_PINMASK	STN_DAT_PIN8
+
+#define STFT_PSHI	(1 << 15)
+#define STFT_CLSHI	(1 << 14)
+#define STFT_SPLHI	(1 << 13)
+#define STFT_REVHI	(1 << 12)
+
+#define SYNC_MASTER	(0 << 16)
+#define SYNC_SLAVE	(1 << 16)
+
+#define DE_P		(0 << 9)
+#define DE_N		(1 << 9)
+
+#define PCLK_P		(0 << 10)
+#define PCLK_N		(1 << 10)
+
+#define HSYNC_P		(0 << 11)
+#define HSYNC_N		(1 << 11)
+
+#define VSYNC_P		(0 << 8)
+#define VSYNC_N		(1 << 8)
+
+#define DATA_NORMAL	(0 << 17)
+#define DATA_INVERSE	(1 << 17)
+
+
+/* Jz LCDFB supported I/O controls. */
+#define FBIOSETBACKLIGHT	0x4688
+#define FBIODISPON		0x4689
+#define FBIODISPOFF		0x468a
+#define FBIORESET		0x468b
+#define FBIOPRINT_REG		0x468c
+
+/*
+ * LCD panel specific definition
+ */
+
+#if defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW) || defined(CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL)
+
+#if defined(CONFIG_MIPS_JZ4730_PMPV1)
+#define LCD_RESET_PIN	63
+#elif defined(CONFIG_MIPS_JZ4730_PMPV2)
+#define LCD_RESET_PIN	60
+#elif defined(CONFIG_MIPS_JZ4740_LEO)
+#define LCD_RESET_PIN	50
+#endif
+
+#define __lcd_special_on() \
+do { \
+	__gpio_set_pin(LCD_RESET_PIN); \
+	__gpio_as_output(LCD_RESET_PIN); \
+	__gpio_clear_pin(LCD_RESET_PIN); \
+	udelay(100); \
+	__gpio_set_pin(LCD_RESET_PIN); \
+} while (0)
+
+#endif /* CONFIG_JZLCD_TRULY_TFTG320240DTSW, parellel or serial RGB mode */
+
+#if defined(CONFIG_JZLCD_SAMSUNG_LTV350QVF04)
+
+#if defined(CONFIG_MIPS_JZ4730_FPRINT)
+#define PortSDI	60
+#define PortSCL	61
+#define PortCS	62
+#define PortRST	63
+#define PortSht 64
+#endif
+
+#if defined(CONFIG_MIPS_JZ4730_GPS)
+#define PortSDI	74
+#define PortSCL	72
+#define PortCS	73
+#define PortRST	60
+#define PortSht 59
+#endif
+
+#ifndef PortSDI
+#define PortSDI	0
+#endif
+#ifndef PortSCL
+#define PortSCL	0
+#endif
+#ifndef PortCS
+#define PortCS	0
+#endif
+#ifndef PortRST
+#define PortRST	0
+#endif
+#ifndef PortSht
+#define PortSht	0
+#endif
+
+#define __lcd_special_pin_init() \
+do { \
+	__gpio_as_output(PortSDI); /* SDI */\
+	__gpio_as_output(PortSCL); /* SCL */ \
+	__gpio_as_output(PortCS); /* CS */ \
+	__gpio_as_output(PortRST); /* Reset */ \
+	__gpio_as_output(PortSht); /* Shut Down # */ \
+	__gpio_set_pin(PortCS); \
+	__gpio_set_pin(PortSCL); \
+	__gpio_set_pin(PortSDI); \
+} while (0)
+
+#define __spi_out(val) \
+do { \
+	int __i__; \
+	unsigned int _t_ = (val); \
+	__gpio_clear_pin(PortCS); \
+	udelay(25); \
+	for (__i__ = 0; __i__ < 24; __i__++ ) { \
+		__gpio_clear_pin(PortSCL); \
+		if (_t_ & 0x800000) \
+			__gpio_set_pin(PortSDI); \
+		else \
+			__gpio_clear_pin(PortSDI); \
+		_t_ <<= 1; \
+		udelay(25); \
+		__gpio_set_pin(PortSCL); \
+		udelay(25); \
+	} \
+	__gpio_set_pin(PortCS); \
+	udelay(25); \
+	__gpio_set_pin(PortSDI); \
+	udelay(25); \
+	__gpio_set_pin(PortSCL); \
+} while (0)
+
+#define __spi_id_op_data(rs, rw, val) \
+	__spi_out((0x1d<<18)|((rs)<<17)|((rw)<<16)|(val))
+
+#define __spi_write_reg(reg, val) \
+do { \
+	__spi_id_op_data(0, 0, (reg)); \
+	__spi_id_op_data(1, 0, (val)); \
+} while (0)
+
+#define __lcd_special_on() \
+do { \
+	__gpio_set_pin(PortSht); \
+	__gpio_clear_pin(PortRST); \
+	mdelay(10); \
+	__gpio_set_pin(PortRST); \
+	mdelay(1); \
+	__spi_write_reg(0x09, 0); \
+	mdelay(10); \
+	__spi_write_reg(0x09, 0x4000); \
+	__spi_write_reg(0x0a, 0x2000); \
+	mdelay(40); \
+	__spi_write_reg(0x09, 0x4055); \
+	mdelay(50); \
+	__spi_write_reg(0x01, 0x409d); \
+	__spi_write_reg(0x02, 0x0204); \
+	__spi_write_reg(0x03, 0x0100); \
+	__spi_write_reg(0x04, 0x3000); \
+	__spi_write_reg(0x05, 0x4003); \
+	__spi_write_reg(0x06, 0x000a); \
+	__spi_write_reg(0x07, 0x0021); \
+	__spi_write_reg(0x08, 0x0c00); \
+	__spi_write_reg(0x10, 0x0103); \
+	__spi_write_reg(0x11, 0x0301); \
+	__spi_write_reg(0x12, 0x1f0f); \
+	__spi_write_reg(0x13, 0x1f0f); \
+	__spi_write_reg(0x14, 0x0707); \
+	__spi_write_reg(0x15, 0x0307); \
+	__spi_write_reg(0x16, 0x0707); \
+	__spi_write_reg(0x17, 0x0000); \
+	__spi_write_reg(0x18, 0x0004); \
+	__spi_write_reg(0x19, 0x0000); \
+	mdelay(60); \
+	__spi_write_reg(0x09, 0x4a55); \
+	__spi_write_reg(0x05, 0x5003); \
+} while (0)
+
+#define __lcd_special_off() \
+do { \
+	__spi_write_reg(0x09, 0x4055); \
+	__spi_write_reg(0x05, 0x4003); \
+	__spi_write_reg(0x0a, 0x0000); \
+	mdelay(10); \
+	__spi_write_reg(0x09, 0x4000); \
+	__gpio_clear_pin(PortSht); \
+} while (0)
+
+#endif  /* CONFIG_JZLCD_SAMSUNG_LTV350QVF04 */
+
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01) || defined(CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL)
+
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01) /* board pmp */
+#define MODE 0xcd 		/* 24bit parellel RGB */
+#endif
+#if defined(CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL)
+#define MODE 0xc9		/* 8bit serial RGB */
+#endif
+
+#if defined(CONFIG_MIPS_JZ4730_PMPV1) || defined(CONFIG_MIPS_JZ4730_PMPV2)
+	#define SPEN	60       //LCD_SPL
+	#define SPCK	61       //LCD_CLS
+	#define SPDA	62       //LCD_PS
+	#define LCD_RET 63       //LCD_REV  //use for lcd reset
+#elif defined(CONFIG_MIPS_JZ4740_LEO) /* board leo */
+	#define SPEN	(32*1+18)       //LCD_SPL
+	#define SPCK	(32*1+17)       //LCD_CLS
+	#define SPDA	(32*2+22)       //LCD_PS
+	#define LCD_RET (32*2+23)       //LCD_REV  //use for lcd reset
+#elif defined(CONFIG_MIPS_JZ4740_PAVO) /* board pavo */
+	#define SPEN	(32*1+18)       //LCD_SPL
+	#define SPCK	(32*1+17)       //LCD_CLS
+	#define SPDA	(32*2+12)       //LCD_D12
+	#define LCD_RET (32*2+23)       //LCD_REV, GPC23
+#else
+#error "driver/video/Jzlcd.h, please define SPI pins on your board."
+#endif
+
+	#define __spi_write_reg1(reg, val) \
+	do { \
+		unsigned char no;\
+		unsigned short value;\
+		unsigned char a=0;\
+		unsigned char b=0;\
+		a=reg;\
+		b=val;\
+		__gpio_set_pin(SPEN);\
+		__gpio_set_pin(SPCK);\
+		__gpio_clear_pin(SPDA);\
+		__gpio_clear_pin(SPEN);\
+		udelay(25);\
+		value=((a<<8)|(b&0xFF));\
+		for(no=0;no<16;no++)\
+		{\
+			__gpio_clear_pin(SPCK);\
+			if((value&0x8000)==0x8000)\
+			__gpio_set_pin(SPDA);\
+			else\
+			__gpio_clear_pin(SPDA);\
+			udelay(25);\
+			__gpio_set_pin(SPCK);\
+			value=(value<<1); \
+			udelay(25);\
+		 }\
+		__gpio_set_pin(SPEN);\
+		udelay(100);\
+	} while (0)
+
+	#define __spi_write_reg(reg, val) \
+	do {\
+		__spi_write_reg1((reg<<2|2), val);\
+		udelay(100); \
+	}while(0)
+
+	
+	#define __lcd_special_pin_init() \
+	do { \
+		__gpio_as_output(SPEN); /* use SPDA */\
+		__gpio_as_output(SPCK); /* use SPCK */\
+		__gpio_as_output(SPDA); /* use SPDA */\
+		__gpio_as_output(LCD_RET);\
+	} while (0)
+
+	#define __lcd_special_on() \
+	do { \
+		udelay(50);\
+		__gpio_clear_pin(LCD_RET);\
+		mdelay(150);\
+		__gpio_set_pin(LCD_RET);\
+		mdelay(10);\
+		__spi_write_reg(0x00, 0x03); \
+		__spi_write_reg(0x01, 0x40); \
+		__spi_write_reg(0x02, 0x11); \
+		__spi_write_reg(0x03, MODE); /* mode */ \
+		__spi_write_reg(0x04, 0x32); \
+		__spi_write_reg(0x05, 0x0e); \
+		__spi_write_reg(0x07, 0x03); \
+		__spi_write_reg(0x08, 0x08); \
+		__spi_write_reg(0x09, 0x40); \
+		__spi_write_reg(0x0A, 0x88); \
+		__spi_write_reg(0x0B, 0x88); \
+		__spi_write_reg(0x0C, 0x20); \
+		__spi_write_reg(0x0D, 0x20); \
+	} while (0)	//reg 0x0a is control the display direction:DB0->horizontal level DB1->vertical level
+	
+	#define __lcd_special_off() \
+	do { \
+		__spi_write_reg(0x00, 0x03); \
+	} while (0)
+
+#endif	/* CONFIG_JZLCD_FOXCONN_PT035TN01 or CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL */
+
+#if defined(CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E)
+		
+#if defined(CONFIG_MIPS_JZ4730_FPRINT)
+ #define PortSDI	60
+ #define PortSCL	65		/* GPIO65 as WR/SCL */
+ #define PortCS	62
+ #define PortRST	63
+ #define PortSDO 64
+ #define PortSCL1  61
+#else
+ #error "driver/video/Jzlcd.h, please define pins on your board."
+#endif
+
+#define __spi_out(val) \
+do { \
+	int __i__; \
+	unsigned int _t_ = (val); \
+	__gpio_clear_pin(PortCS); \
+	udelay(2); \
+	for (__i__ = 0; __i__ < 24; __i__++ ) { \
+		__gpio_clear_pin(PortSCL); \
+		if (_t_ & 0x800000) \
+			__gpio_set_pin(PortSDI); \
+		else \
+			__gpio_clear_pin(PortSDI); \
+		_t_ <<= 1; \
+		udelay(1); \
+		__gpio_set_pin(PortSCL); \
+		udelay(1); \
+	} \
+	udelay(2); \
+	__gpio_set_pin(PortCS); \
+	__gpio_set_pin(PortSDI); \
+	__gpio_set_pin(PortSCL); \
+} while (0)
+
+#define __spi_id_op_data(rs, rw, val) \
+	__spi_out((0x0e<<19)|(0<<18)|((rs)<<17)|((rw)<<16)|(val)) /* 0e: 01110. ID:? */
+
+#define __spi_write_reg(reg, val) \
+do { \
+	__spi_id_op_data(0, 0, (reg)); \
+	__spi_id_op_data(1, 0, (val)); \
+} while (0)
+
+#define get_data(n)	(__gpio_get_pin((n)) ? 1:0) /* 1: high level, 0: low level */
+
+static inline unsigned int __spi_in(void)
+{
+	int __i__; 
+	unsigned int read_val = 0;
+	unsigned int _t_ = (0x0e<<19)|(0<<18)|((1)<<17)|((1)<<16);/* 0e: 01110. ID:? */
+
+	__gpio_clear_pin(PortCS); 
+	udelay(2); 
+	//for (__i__ = 0; __i__ < 24; __i__++ ) { 
+	for (__i__ = 0; __i__ < 32; __i__++ ) { 
+		__gpio_clear_pin(PortSCL); 
+		if (_t_ & 0x800000) /* send data */
+			__gpio_set_pin(PortSDI); 
+		else 
+			__gpio_clear_pin(PortSDI); 
+		_t_ <<= 1; 
+		udelay(1); 
+		__gpio_set_pin(PortSCL); 
+		read_val <<= 1;
+		read_val |= get_data(PortSDO); /* receive data */
+		udelay(1); 
+	} 
+	udelay(2); 
+	__gpio_set_pin(PortCS); 
+	__gpio_set_pin(PortSDI); 
+	__gpio_set_pin(PortSCL); 
+
+	return read_val;
+ }
+static inline unsigned int __spi_read_reg(int reg)
+{
+	unsigned int read_val;
+	__spi_id_op_data(0, 0, (reg));
+	udelay(40);
+	read_val = __spi_in();
+	return read_val;
+}
+
+
+#define WMLCDCOM(val)	__spi_id_op_data(0,0,val)
+#define WMLCDDATA(val)	__spi_id_op_data(1,0,val)
+#define Delayms(n) 	mdelay(n)
+
+static inline void mlcd_mode_setting(void)
+{
+	/* RGB Interface */ 
+	WMLCDCOM(0x0001);WMLCDDATA(0x0000); /* Horizontal reverse  */
+	WMLCDCOM(0x0002);WMLCDDATA(0x0700);
+	/* Entry Mode */
+	//WMLCDCOM(0x0003);WMLCDDATA(0x1230); /* default 240x320, HWM=1 write data in high speed */
+	WMLCDCOM(0x0003);WMLCDDATA(0x1038); /* Rotate to 320x240, HWM=0, low speed */
+	WMLCDCOM(0x000C);WMLCDDATA(0x0111); /* External interface, as 16bit RGB interface */
+	WMLCDCOM(0x0020);WMLCDDATA(0x0000); /* Horizontal base */
+	WMLCDCOM(0x0021);WMLCDDATA(0x0000); /* Vertical base */
+	WMLCDCOM(0x0030);WMLCDDATA(0x0707);
+	WMLCDCOM(0x0031);WMLCDDATA(0x0407);
+	WMLCDCOM(0x0032);WMLCDDATA(0x0203);
+	WMLCDCOM(0x0033);WMLCDDATA(0x0303);
+	WMLCDCOM(0x0034);WMLCDDATA(0x0303);
+	WMLCDCOM(0x0035);WMLCDDATA(0x0202);
+	WMLCDCOM(0x0036);WMLCDDATA(0x001F);
+	WMLCDCOM(0x0037);WMLCDDATA(0x0707);
+	WMLCDCOM(0x0038);WMLCDDATA(0x0407);
+	WMLCDCOM(0x0039);WMLCDDATA(0x0203);
+	WMLCDCOM(0x003A);WMLCDDATA(0x0303);
+	WMLCDCOM(0x003B);WMLCDDATA(0x0303);
+	WMLCDCOM(0x003C);WMLCDDATA(0x0202);
+	WMLCDCOM(0x003D);WMLCDDATA(0x001F);
+	WMLCDCOM(0x0050);WMLCDDATA(0x0000); /* X start:  0 */
+	WMLCDCOM(0x0051);WMLCDDATA(0x00EF); /* X end:  239 */
+	WMLCDCOM(0x0052);WMLCDDATA(0x0000); /* Y start:  0 */
+	WMLCDCOM(0x0053);WMLCDDATA(0x013F); /* Y end:  319 */
+	WMLCDCOM(0x0060);WMLCDDATA(0x2700);
+	WMLCDCOM(0x0061);WMLCDDATA(0x0001);
+	WMLCDCOM(0x006A);WMLCDDATA(0x0000); /* VL: Vertical Scroll */
+	WMLCDCOM(0x0090);WMLCDDATA(0x0016);
+	WMLCDCOM(0x0092);WMLCDDATA(0x0000);
+	WMLCDCOM(0x0093);WMLCDDATA(0x0000);
+}
+
+static inline void mlcd_power_on(void)
+{ 
+	/* Power supply on */
+	WMLCDCOM(0x0007);WMLCDDATA(0x0001);
+	WMLCDCOM(0x0017);WMLCDDATA(0x0001);
+	Delayms(50);
+	WMLCDCOM(0x0010);WMLCDDATA(0x17B0);
+	WMLCDCOM(0x0011);WMLCDDATA(0x0007);
+	WMLCDCOM(0x0012);WMLCDDATA(0x011A);
+	WMLCDCOM(0x0013);WMLCDDATA(0x0F00);
+	WMLCDCOM(0x0029);WMLCDDATA(0x0010);
+	WMLCDCOM(0x0012);WMLCDDATA(0x013A);
+	Delayms(50);
+}
+static inline void mlcd_power_off(void)
+{ 
+	WMLCDCOM(0x0010);WMLCDDATA(0x0780);
+	WMLCDCOM(0x0011);WMLCDDATA(0x0067);
+	WMLCDCOM(0x0012);WMLCDDATA(0x010A);
+	Delayms(20);
+	WMLCDCOM(0x0010);WMLCDDATA(0x0700);
+}
+
+static inline void mlcd_display_on(void)
+{
+	/* Display on sequence */
+	WMLCDCOM(0x0007);WMLCDDATA(0x0021);
+	Delayms(1);
+	WMLCDCOM(0x0007);WMLCDDATA(0x0061);
+	Delayms(20);
+	WMLCDCOM(0x0007);WMLCDDATA(0x0173);
+	WMLCDCOM(0x0022);	/* set Index register R22 */
+}
+static inline void mlcd_display_off(void)
+{
+	/* Display off sequence */
+	WMLCDCOM(0x0007);WMLCDDATA(0x0072);
+	Delayms(20);
+	WMLCDCOM(0x0007);WMLCDDATA(0x0001);
+	Delayms(1);
+	WMLCDCOM(0x0007);WMLCDDATA(0x0000);
+}
+	
+#define __lcd_special_pin_init() \
+do { \
+	__gpio_as_input(PortSDO);  /* SDO */\
+	__gpio_as_output(PortSDI); /* SDI */\
+	__gpio_as_output(PortSCL); /* SCL */ \
+	__gpio_as_output(PortCS);  /* CS */ \
+	__gpio_as_output(PortRST); /* Reset */ \
+	__gpio_as_output(PortSCL1); /* SCL1 */ \
+	__gpio_set_pin(PortCS); \
+	__gpio_set_pin(PortSCL); \
+	__gpio_set_pin(PortSDI); \
+	__gpio_set_pin(PortRST); \
+	__gpio_set_pin(PortSCL1); \
+	__gpio_set_pin(PortRST); \
+} while (0)
+
+#define __lcd_special_on() \
+do { \
+	mdelay(10); \
+	__gpio_clear_pin(PortRST); /* Reset period > 1ms */ \
+	mdelay(10); \
+	__gpio_set_pin(PortRST); \
+	mdelay(1); \
+	mlcd_power_on(); \
+	mlcd_mode_setting();\
+	mlcd_display_on(); \
+} while (0)
+
+#if 0				/* Customer need Power Off? --No need, right now */
+#define __lcd_special_off() \
+do { \
+	mlcd_display_off(); \
+	mlcd_power_off(); \
+} while (0)
+#endif /* if 0 */
+
+#endif	/* CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E */
+
+#ifndef __lcd_special_pin_init
+#define __lcd_special_pin_init()
+#endif
+#ifndef __lcd_special_on
+#define __lcd_special_on()
+#endif
+#ifndef __lcd_special_off
+#define __lcd_special_off()
+#endif
+
+
+/*
+ * Platform specific definition
+ */
+
+#if defined(CONFIG_MIPS_JZ4730_GPS)
+
+#define __lcd_set_backlight_level(n) \
+do { \
+	; \
+} while (0)
+
+#define __lcd_display_pin_init() \
+do { \
+	__lcd_special_pin_init(); \
+	__gpio_as_output(94); /* PWM0 pin */ \
+	__gpio_as_output(95); /* PWM1 pin */ \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_special_on(); \
+	__gpio_set_pin(94); /* PWM0 pin */ \
+	__gpio_set_pin(95); /* PWM1 pin */ \
+	__lcd_set_backlight_level(8); \
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_special_off(); \
+} while (0)
+
+#endif /* CONFIG_MIPS_JZ4730_GPS */
+
+#if defined(CONFIG_MIPS_JZ4730_FPRINT)
+
+#define __lcd_set_backlight_level(n) \
+do { \
+	REG_PWM_DUT(0) = n; \
+	REG_PWM_PER(0) = 7; \
+	REG_PWM_CTR(0) = 0xc1; \
+} while (0)
+
+#if defined(CONFIG_JZLCD_FOXCONN_PT035TN01)
+
+#define __lcd_display_pin_init() \
+do { \
+	__lcd_special_pin_init();\
+	__gpio_as_pwm();\
+	__lcd_set_backlight_level(8);\
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_set_backlight_level(8); \
+	__lcd_special_on();\
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_set_backlight_level(0); \
+	__lcd_special_off();\
+} while (0)
+
+#elif	defined(CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E)
+/* pwm circle frequece = 1KHz */
+/* back light level: 0~100 */
+#undef  __lcd_set_backlight_level
+#define __lcd_set_backlight_level(n) \
+do { \
+	REG_PWM_DUT(0) = n; \
+	REG_PWM_PER(0) = 99; \
+	REG_PWM_CTR(0) = 0xe4; \
+} while (0)
+
+#define __lcd_display_pin_init() \
+do { \
+	__lcd_special_pin_init();\
+	__gpio_as_pwm();\
+	__lcd_set_backlight_level(88);\
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_set_backlight_level(88); \
+	__lcd_special_on();\
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_set_backlight_level(0); \
+	__lcd_special_off();\
+} while (0)
+
+#else
+
+#define __lcd_display_pin_init() \
+do { \
+	__gpio_as_output(GPIO_DISP_OFF_N); \
+	__gpio_as_pwm(); \
+	__lcd_set_backlight_level(8); \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_set_backlight_level(8); \
+	__gpio_set_pin(GPIO_DISP_OFF_N); \
+} while (0)
+	
+#define __lcd_display_off() \
+do { \
+	__lcd_set_backlight_level(0); \
+	__gpio_clear_pin(GPIO_DISP_OFF_N); \
+} while (0)
+#endif
+
+#endif /* CONFIG_MIPS_JZ4730_FPRINT */
+
+#if defined(CONFIG_MIPS_JZ4730_LIBRA)
+
+#define __lcd_set_backlight_level(n) \
+do { \
+} while (0)
+
+#define __lcd_display_pin_init() \
+do { \
+	__lcd_special_pin_init(); \
+	__gpio_clear_pin(100); \
+	__gpio_as_output(100); \
+	__gpio_as_output(94); \
+	__gpio_as_output(95); \
+	__lcd_set_backlight_level(8); \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_special_on(); \
+	__gpio_set_pin(100); \
+	__gpio_set_pin(94); \
+	__gpio_set_pin(95); \
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_special_off(); \
+	__gpio_clear_pin(100); \
+	__gpio_clear_pin(94); \
+	__gpio_clear_pin(95); \
+} while (0)
+
+#endif /* CONFIG_MIPS_JZ4730_LIBRA */
+
+#if defined(CONFIG_MIPS_JZ4730_PMPV1) || defined(CONFIG_MIPS_JZ4730_PMPV2)
+
+#define GPIO_PWM0 94
+
+#define __lcd_set_backlight_level(n) \
+do { \
+	__gpio_as_pwm(); \
+	REG_PWM_DUT(0) = n; \
+	REG_PWM_PER(0) = 7; \
+	REG_PWM_CTR(0) = 0xc1; \
+} while (0)
+
+#define __lcd_close_backlight() \
+do { \
+__gpio_as_output(GPIO_PWM0);\
+__gpio_clear_pin(GPIO_PWM0);\
+} while (0)
+
+#define __lcd_display_pin_init() \
+do { \
+	__gpio_as_output(GPIO_DISP_OFF_N); \
+	__lcd_set_backlight_level(8); \
+	__lcd_special_pin_init(); \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__gpio_set_pin(GPIO_DISP_OFF_N); \
+	__lcd_special_on(); \
+	__lcd_set_backlight_level(8); \
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_special_off(); \
+	__lcd_close_backlight(); \
+	__gpio_clear_pin(GPIO_DISP_OFF_N); \
+} while (0)
+
+#endif /* CONFIG_MIPS_JZ4730_PMPV1 | CONFIG_MIPS_JZ4730_PMPV1 */
+
+
+#if defined(CONFIG_MIPS_JZ4740_LEO) || defined(CONFIG_MIPS_JZ4740_PAVO)|| defined(CONFIG_MIPS_JZ4740_VIRGO)
+
+#if defined(CONFIG_MIPS_JZ4740_PAVO)
+#define GPIO_PWM    123		/* GP_D27 */
+#define PWM_CHN 4    /* pwm channel */
+#define PWM_FULL 101
+/* 100 level: 0,1,...,100 */
+/*#define __lcd_set_backlight_level(n)                     \
+do {                                                     \
+	__gpio_as_pwm(4); \
+        __tcu_disable_pwm_output(PWM_CHN);               \
+        __tcu_stop_counter(PWM_CHN);                     \
+        __tcu_init_pwm_output_high(PWM_CHN);             \
+        __tcu_set_pwm_output_shutdown_abrupt(PWM_CHN);   \
+        __tcu_select_clk_div1(PWM_CHN);                  \
+        __tcu_mask_full_match_irq(PWM_CHN);              \
+        __tcu_mask_half_match_irq(PWM_CHN);              \
+        __tcu_set_count(PWM_CHN,0);                      \
+        __tcu_set_full_data(PWM_CHN,__cpm_get_extalclk()/1000);           \
+        __tcu_set_half_data(PWM_CHN,__cpm_get_extalclk()/1000*n/100);     \
+        __tcu_enable_pwm_output(PWM_CHN);                \
+        __tcu_select_extalclk(PWM_CHN);                  \
+        __tcu_start_counter(PWM_CHN);                    \
+} while (0)
+*/
+#define __lcd_set_backlight_level(n)                     \
+do { \
+__gpio_as_output(GPIO_PWM); \
+__gpio_set_pin(GPIO_PWM); \
+} while (0)
+
+#define __lcd_close_backlight() \
+do { \
+__gpio_as_output(GPIO_PWM); \
+__gpio_clear_pin(GPIO_PWM); \
+} while (0)
+
+#elif defined(CONFIG_MIPS_JZ4740_VIRGO)
+#define GPIO_PWM    119		/* GP_D23 */
+#define PWM_CHN 0    /* pwm channel */
+#define PWM_FULL 101
+/* 100 level: 0,1,...,100 */
+/*#define __lcd_set_backlight_level(n)                     \
+do {                                                     \
+	__gpio_as_pwm(0); \
+        __tcu_disable_pwm_output(PWM_CHN);               \
+        __tcu_stop_counter(PWM_CHN);                     \
+        __tcu_init_pwm_output_high(PWM_CHN);             \
+        __tcu_set_pwm_output_shutdown_abrupt(PWM_CHN);   \
+        __tcu_select_clk_div1(PWM_CHN);                  \
+        __tcu_mask_full_match_irq(PWM_CHN);              \
+        __tcu_mask_half_match_irq(PWM_CHN);              \
+        __tcu_set_count(PWM_CHN,0);                      \
+        __tcu_set_full_data(PWM_CHN,__cpm_get_extalclk()/1000);           \
+        __tcu_set_half_data(PWM_CHN,__cpm_get_extalclk()/1000*n/100);     \
+        __tcu_enable_pwm_output(PWM_CHN);                \
+        __tcu_select_extalclk(PWM_CHN);                  \
+        __tcu_start_counter(PWM_CHN);                    \
+	} while (0)
+*/
+
+#define __lcd_set_backlight_level(n)                     \
+do { \
+__gpio_as_output(GPIO_PWM); \
+__gpio_set_pin(GPIO_PWM); \
+} while (0)
+
+#define __lcd_close_backlight() \
+do { \
+__gpio_as_output(GPIO_PWM); \
+__gpio_clear_pin(GPIO_PWM); \
+} while (0)
+
+#elif defined CONFIG_MIPS_JZ4740_LEO
+
+#define __lcd_set_backlight_level(n)
+#define __lcd_close_backlight()
+
+#endif /* #if defined(CONFIG_MIPS_JZ4740_PAVO) */
+
+#define __lcd_display_pin_init() \
+do { \
+	__gpio_as_output(GPIO_DISP_OFF_N); \
+	__cpm_start_tcu(); \
+	__lcd_special_pin_init(); \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__lcd_special_on(); \
+	__gpio_set_pin(GPIO_DISP_OFF_N); \
+        udelay(500000); \
+	__lcd_set_backlight_level(80); \
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_close_backlight(); \
+	__lcd_special_off(); \
+	__gpio_clear_pin(GPIO_DISP_OFF_N); \
+} while (0)
+
+#endif /* CONFIG_MIPS_JZ4740_LEO */
+
+#if defined(CONFIG_JZLCD_MSTN_240x128)
+#if 0	/* The final version does not use software emulation of VCOM. */
+
+#define GPIO_VSYNC	59
+#define GPIO_VCOM	90
+
+#define REG_VCOM	REG_GPIO_GPDR((GPIO_VCOM>>5))
+#define VCOM_BIT	(1 << (GPIO_VCOM & 0x1f))
+static unsigned int vcom_static;
+static void vsync_irq(int irq, void *dev_id, struct pt_regs *reg)
+{
+	vcom_static = REG_VCOM;
+	vcom_static ^= VCOM_BIT;
+	REG_VCOM = vcom_static;
+}
+
+#define __lcd_display_pin_init()					  \
+	__gpio_as_irq_rise_edge(GPIO_VSYNC);				  \
+	__gpio_as_output(GPIO_VCOM);					  \
+	{								  \
+	static int inited = 0;						  \
+	if (!inited) {							  \
+	inited = 1;							  \
+	if (request_irq(IRQ_GPIO_0 + GPIO_VSYNC, vsync_irq, SA_INTERRUPT, \
+			"vsync", 0)) {					  \
+		err = -EBUSY;						  \
+		goto failed;						  \
+	}}}
+
+#endif
+
+/* We uses AC BIAs pin to generate VCOM signal, so above code should be removed.
+ */
+
+#endif
+/*****************************************************************************
+ * LCD display pin dummy macros
+ *****************************************************************************/
+#ifndef __lcd_display_pin_init
+#define __lcd_display_pin_init()
+#endif
+#ifndef __lcd_display_on
+#define __lcd_display_on()
+#endif
+#ifndef __lcd_display_off
+#define __lcd_display_off()
+#endif
+#ifndef __lcd_set_backlight_level
+#define __lcd_set_backlight_level(n)
+#endif
+
+#endif /* __JZLCD_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_mmc.c u-boot-1.1.6/cpu/mips/jz_mmc.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_mmc.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_mmc.c	2008-12-12 22:43:06.000000000 +0800
@@ -0,0 +1,1426 @@
+/*
+ * (C) Copyright 2003
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h> 
+#include <common.h>
+#include <part.h>
+
+#if defined CONFIG_JZ4740 || defined CONFIG_JZ4730
+#ifdef CONFIG_JZ4730
+#include <asm-mips/jz4730.h>
+#endif
+#ifdef CONFIG_JZ4740
+#include <asm-mips/jz4740.h>
+#endif
+
+#include "jz_mmc.h"
+
+#define CFG_MMC_BASE		0x80600000
+static int sd2_0 = 0;
+/*
+ * GPIO definition
+ */
+
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected()			\
+({						\
+	int detected = 1;			\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+	if (__gpio_get_pin(GPIO_SD_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+/*
+ * Local functions
+ */
+
+#ifdef CONFIG_MMC
+extern int
+fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+
+static block_dev_desc_t mmc_dev;
+
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/*
+ * FIXME needs to read cid and csd info to determine block size
+ * and other parameters
+ */
+static uchar mmc_buf[MMC_BLOCK_SIZE];
+static int mmc_ready = 0;
+static mmc_csd_t mmc_csd;
+static int use_4bit;                    /* Use 4-bit data bus */
+/***********************************************************************
+ *  MMC Events
+ */
+#define MMC_EVENT_NONE	        0x00	/* No events */
+#define MMC_EVENT_RX_DATA_DONE	0x01	/* Rx data done */
+#define MMC_EVENT_TX_DATA_DONE	0x02	/* Tx data done */
+#define MMC_EVENT_PROG_DONE	0x04	/* Programming is done */
+
+
+#define MMC_IRQ_MASK()				\
+do {						\
+      	REG_MSC_IMASK = 0xffff;			\
+      	REG_MSC_IREG = 0xffff;			\
+} while (0)
+
+/* Stop the MMC clock and wait while it happens */
+static inline int jz_mmc_stop_clock(void)
+{
+	int timeout = 1000;
+	
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;
+
+	while (timeout && (REG_MSC_STAT & MSC_STAT_CLK_EN)) {
+		timeout--;
+		if (timeout == 0) {
+			return MMC_ERROR_TIMEOUT;
+		}
+		udelay(1);
+	}
+        return MMC_NO_ERROR;
+}
+
+/* Start the MMC clock and operation */
+static inline int jz_mmc_start_clock(void)
+{
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START | MSC_STRPCL_START_OP;
+	return MMC_NO_ERROR;
+}
+
+static inline u32 jz_mmc_calc_clkrt(int is_sd, u32 rate)
+{
+	u32 clkrt;
+	u32 clk_src = is_sd ? 24000000: 16000000;
+
+	clkrt = 0;
+  	while (rate < clk_src)
+    	{
+      		clkrt ++;
+      		clk_src >>= 1;
+    	}
+	return clkrt;
+}
+/* Set the MMC clock frequency */
+void jz_mmc_set_clock(int sd, u32 rate)
+{
+	jz_mmc_stop_clock();
+
+	/* Select clock source of MSC */
+	__cpm_select_msc_clk(sd);
+
+	/* Set clock dividor of MSC */
+	REG_MSC_CLKRT = jz_mmc_calc_clkrt(sd, rate);
+}
+
+static int jz_mmc_check_status(struct mmc_request *request)
+{
+	u32 status = REG_MSC_STAT;
+
+	/* Checking for response or data timeout */
+	if (status & (MSC_STAT_TIME_OUT_RES | MSC_STAT_TIME_OUT_READ)) {
+		printf("MMC/SD timeout, MMC_STAT 0x%x CMD %d\n", status, request->cmd);
+		return MMC_ERROR_TIMEOUT;
+	}
+
+	/* Checking for CRC error */
+	if (status & (MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR | MSC_STAT_CRC_RES_ERR)) {
+		printf("MMC/CD CRC error, MMC_STAT 0x%x\n", status);
+		return MMC_ERROR_CRC;
+	}
+
+	return MMC_NO_ERROR;
+}
+
+/* Obtain response to the command and store it to response buffer */
+static void jz_mmc_get_response(struct mmc_request *request)
+{
+	int i;
+	u8 *buf;
+	u32 data;
+
+	DEBUG(3, "fetch response for request %d, cmd %d\n", request->rtype, request->cmd);
+
+	buf = request->response;
+	request->result = MMC_NO_ERROR;
+
+	switch (request->rtype) {
+	case RESPONSE_R1: case RESPONSE_R1B: case RESPONSE_R6:
+	case RESPONSE_R3: case RESPONSE_R4: case RESPONSE_R5:
+	{
+		data = REG_MSC_RES;
+		buf[0] = (data >> 8) & 0xff;
+		buf[1] = data & 0xff;
+		data = REG_MSC_RES;
+		buf[2] = (data >> 8) & 0xff;
+		buf[3] = data & 0xff;
+		data = REG_MSC_RES;
+		buf[4] = data & 0xff;
+
+		DEBUG(3, "request %d, response [%02x %02x %02x %02x %02x]\n",
+		      request->rtype, buf[0], buf[1], buf[2], buf[3], buf[4]);
+		break;
+	}
+	case RESPONSE_R2_CID: case RESPONSE_R2_CSD:
+	{
+		for (i = 0; i < 16; i += 2) {
+			data = REG_MSC_RES;
+			buf[i] = (data >> 8) & 0xff;
+			buf[i+1] = data & 0xff;
+		}
+		DEBUG(3, "request %d, response [", request->rtype);
+#if CONFIG_MMC_DEBUG_VERBOSE > 2
+		if (g_mmc_debug >= 3) {
+			int n;
+			for (n = 0; n < 17; n++)
+				printk("%02x ", buf[n]);
+			printk("]\n");
+		}
+#endif
+		break;
+	}
+	case RESPONSE_NONE:
+		DEBUG(3, "No response\n");
+		break;
+		
+	default:
+		DEBUG(3, "unhandled response type for request %d\n", request->rtype);
+		break;
+	}
+}
+
+static int jz_mmc_receive_data(struct mmc_request *req)
+{
+	u32  stat, timeout, data, cnt;
+	u8 *buf = req->buffer;
+	u32 wblocklen = (u32)(req->block_len + 3) >> 2; /* length in word */
+	
+	timeout = 0x3ffffff;
+	
+	while (timeout) {
+		timeout--;
+		stat = REG_MSC_STAT;
+		
+		if (stat & MSC_STAT_TIME_OUT_READ)
+			return MMC_ERROR_TIMEOUT;
+		else if (stat & MSC_STAT_CRC_READ_ERROR)
+			return MMC_ERROR_CRC;
+		else if (!(stat & MSC_STAT_DATA_FIFO_EMPTY) 
+			 || (stat & MSC_STAT_DATA_FIFO_AFULL)) {
+			/* Ready to read data */
+			break;
+		}
+		udelay(1);
+	}
+	if (!timeout)
+		return MMC_ERROR_TIMEOUT;
+	
+	/* Read data from RXFIFO. It could be FULL or PARTIAL FULL */
+	cnt = wblocklen;
+	while (cnt) {
+		data = REG_MSC_RXFIFO;
+		{
+			*buf++ = (u8)(data >> 0);
+			*buf++ = (u8)(data >> 8);
+			*buf++ = (u8)(data >> 16);
+			*buf++ = (u8)(data >> 24);
+		}
+		cnt --;
+		while (cnt && (REG_MSC_STAT & MSC_STAT_DATA_FIFO_EMPTY))
+			;
+	}
+	return MMC_NO_ERROR;
+}
+
+static int jz_mmc_transmit_data(struct mmc_request *req)
+{
+#if 0
+	u32 nob = req->nob;
+	u32 wblocklen = (u32)(req->block_len + 3) >> 2; /* length in word */
+	u8 *buf = req->buffer;
+	u32 *wbuf = (u32 *)buf;
+	u32 waligned = (((u32)buf & 0x3) == 0); /* word aligned ? */
+	u32 stat, timeout, data, cnt;
+
+	for (nob; nob >= 1; nob--) {
+		timeout = 0x3FFFFFF;
+
+		while (timeout) {
+			timeout--;
+			stat = REG_MSC_STAT;
+
+			if (stat & (MSC_STAT_CRC_WRITE_ERROR | MSC_STAT_CRC_WRITE_ERROR_NOSTS))
+				return MMC_ERROR_CRC;
+			else if (!(stat & MSC_STAT_DATA_FIFO_FULL)) {
+				/* Ready to write data */
+				break;
+			}
+
+			udelay(1);
+		}
+
+		if (!timeout)
+			return MMC_ERROR_TIMEOUT;
+
+		/* Write data to TXFIFO */
+		cnt = wblocklen;
+		while (cnt) {
+			while (REG_MSC_STAT & MSC_STAT_DATA_FIFO_FULL)
+				;
+
+			if (waligned) {
+				REG_MSC_TXFIFO = *wbuf++;
+			}
+			else {
+				data = *buf++ | (*buf++ << 8) | (*buf++ << 16) | (*buf++ << 24);
+				REG_MSC_TXFIFO = data;
+			}
+
+			cnt--;
+		}
+	}
+#endif
+	return MMC_NO_ERROR;
+}
+
+
+/********************************************************************************************************************
+** Name:	  int jz_mmc_exec_cmd()
+** Function:      send command to the card, and get a response
+** Input:	  struct mmc_request *req	: MMC/SD request
+** Output:	  0:  right		>0:  error code
+********************************************************************************************************************/
+int jz_mmc_exec_cmd(struct mmc_request *request)
+{
+	u32 cmdat = 0, events = 0;
+	int retval, timeout = 0x3fffff;
+
+	/* Indicate we have no result yet */
+	request->result = MMC_NO_RESPONSE;
+	if (request->cmd == MMC_CIM_RESET) {
+		/* On reset, 1-bit bus width */
+		use_4bit = 0;
+
+		/* Reset MMC/SD controller */
+		__msc_reset();
+
+		/* On reset, drop MMC clock down */
+		jz_mmc_set_clock(0, MMC_CLOCK_SLOW);
+
+		/* On reset, stop MMC clock */
+		jz_mmc_stop_clock();
+	}
+	if (request->cmd == MMC_SEND_OP_COND) {
+		DEBUG(3, "Have an MMC card\n");
+		/* always use 1bit for MMC */
+		use_4bit = 0;
+	}
+	if (request->cmd == SET_BUS_WIDTH) {
+		if (request->arg == 0x2) {
+			DEBUG(2, "Use 4-bit bus width\n");
+			use_4bit = 1;
+		}
+		else {
+			DEBUG(2, "Use 1-bit bus width\n");
+			use_4bit = 0;
+		}
+	}
+
+	/* stop clock */
+	jz_mmc_stop_clock();
+
+	/* mask all interrupts */
+	REG_MSC_IMASK = 0xffff;
+
+	/* clear status */
+	REG_MSC_IREG = 0xffff;
+
+	/* use 4-bit bus width when possible */
+	if (use_4bit)
+		cmdat |= MSC_CMDAT_BUS_WIDTH_4BIT;
+
+        /* Set command type and events */ 
+	switch (request->cmd) {
+	/* MMC core extra command */
+	case MMC_CIM_RESET:
+		cmdat |= MSC_CMDAT_INIT; /* Initialization sequence sent prior to command */
+		break;
+
+	/* bc - broadcast - no response */
+	case MMC_GO_IDLE_STATE:
+	case MMC_SET_DSR:
+		break;
+
+	/* bcr - broadcast with response */
+	case MMC_SEND_OP_COND:
+	case MMC_ALL_SEND_CID:
+	case MMC_GO_IRQ_STATE:
+		break;
+
+	/* adtc - addressed with data transfer */
+	case MMC_READ_DAT_UNTIL_STOP:
+	case MMC_READ_SINGLE_BLOCK:
+	case MMC_READ_MULTIPLE_BLOCK:
+	case SEND_SCR:
+		cmdat |= MSC_CMDAT_DATA_EN | MSC_CMDAT_READ;
+		events = MMC_EVENT_RX_DATA_DONE;
+		break;
+
+	case MMC_WRITE_DAT_UNTIL_STOP:
+	case MMC_WRITE_BLOCK:
+	case MMC_WRITE_MULTIPLE_BLOCK:
+	case MMC_PROGRAM_CID:
+	case MMC_PROGRAM_CSD:
+	case MMC_SEND_WRITE_PROT:
+	case MMC_GEN_CMD:
+	case MMC_LOCK_UNLOCK:
+		cmdat |= MSC_CMDAT_DATA_EN | MSC_CMDAT_WRITE;
+		events = MMC_EVENT_TX_DATA_DONE | MMC_EVENT_PROG_DONE;
+
+		break;
+
+	case MMC_STOP_TRANSMISSION:
+		events = MMC_EVENT_PROG_DONE;
+		break;
+
+	/* ac - no data transfer */
+	default: 
+		break;
+	}
+
+	/* Set response type */
+	switch (request->rtype) {
+	case RESPONSE_NONE:
+		break;
+
+	case RESPONSE_R1B:
+		cmdat |= MSC_CMDAT_BUSY;
+		/*FALLTHRU*/
+	case RESPONSE_R1:
+		cmdat |= MSC_CMDAT_RESPONSE_R1;
+		break;
+	case RESPONSE_R2_CID:
+	case RESPONSE_R2_CSD:
+		cmdat |= MSC_CMDAT_RESPONSE_R2;
+		break;
+	case RESPONSE_R3:
+		cmdat |= MSC_CMDAT_RESPONSE_R3;
+		break;
+	case RESPONSE_R4:
+		cmdat |= MSC_CMDAT_RESPONSE_R4;
+		break;
+	case RESPONSE_R5:
+		cmdat |= MSC_CMDAT_RESPONSE_R5;
+		break;
+	case RESPONSE_R6:
+		cmdat |= MSC_CMDAT_RESPONSE_R6;
+		break;
+	default:
+		break;
+	}
+
+	/* Set command index */
+	if (request->cmd == MMC_CIM_RESET) {
+		REG_MSC_CMD = MMC_GO_IDLE_STATE;
+	} else {
+		REG_MSC_CMD = request->cmd;
+	}
+
+        /* Set argument */
+	REG_MSC_ARG = request->arg;
+
+	/* Set block length and nob */
+	if (request->cmd == SEND_SCR) { /* get SCR from DataFIFO */
+		REG_MSC_BLKLEN = 8;
+		REG_MSC_NOB = 1;
+	} else {
+		REG_MSC_BLKLEN = request->block_len;
+		REG_MSC_NOB = request->nob;
+	}
+
+	/* Set command */
+	REG_MSC_CMDAT = cmdat;
+
+	DEBUG(1, "Send cmd %d cmdat: %x arg: %x resp %d\n", request->cmd,
+	      cmdat, request->arg, request->rtype);
+
+        /* Start MMC/SD clock and send command to card */
+	jz_mmc_start_clock();
+
+	/* Wait for command completion */
+	while (timeout-- && !(REG_MSC_STAT & MSC_STAT_END_CMD_RES))
+		;
+
+	if (timeout == 0)
+		return MMC_ERROR_TIMEOUT;
+
+	REG_MSC_IREG = MSC_IREG_END_CMD_RES; /* clear flag */
+
+	/* Check for status */
+	retval = jz_mmc_check_status(request);
+	if (retval) {
+		return retval;
+	}
+
+	/* Complete command with no response */
+	if (request->rtype == RESPONSE_NONE) {
+		return MMC_NO_ERROR;
+	}
+
+	/* Get response */
+	jz_mmc_get_response(request);
+
+	/* Start data operation */
+	if (events & (MMC_EVENT_RX_DATA_DONE | MMC_EVENT_TX_DATA_DONE)) {
+		if (events & MMC_EVENT_RX_DATA_DONE) {
+			if (request->cmd == SEND_SCR) {
+				/* SD card returns SCR register as data. 
+				   MMC core expect it in the response buffer, 
+				   after normal response. */
+				request->buffer = (u8 *)((u32)request->response + 5);
+			}
+			jz_mmc_receive_data(request);
+		}
+		
+		if (events & MMC_EVENT_TX_DATA_DONE) {
+			jz_mmc_transmit_data(request);
+		}
+		
+		/* Wait for Data Done */
+		while (!(REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE))
+			;
+		REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE; /* clear status */
+	}
+
+	/* Wait for Prog Done event */
+	if (events & MMC_EVENT_PROG_DONE) {
+		while (!(REG_MSC_IREG & MSC_IREG_PRG_DONE))
+			;
+		REG_MSC_IREG = MSC_IREG_PRG_DONE; /* clear status */
+	}
+
+	/* Command completed */
+
+	return MMC_NO_ERROR;			 /* return successfully */
+}
+
+/****************************************************/
+int mmc_block_read(u8 *dst, ulong src, ulong len)
+/****************************************************/
+{
+
+	struct mmc_request request;
+	struct mmc_response_r1 r1;
+	int retval; 
+
+	if (len == 0) {
+		return 0;
+	}
+	mmc_simple_cmd(&request, MMC_SEND_STATUS, mmcinfo.rca, RESPONSE_R1);
+	retval = mmc_unpack_r1(&request, &r1, 0);
+	if (retval && (retval != MMC_ERROR_STATE_MISMATCH)) {
+		return retval;
+	}
+
+	mmc_simple_cmd(&request, MMC_SET_BLOCKLEN, len, RESPONSE_R1);
+	if ((retval = mmc_unpack_r1(&request, &r1, 0))) {
+		return retval;
+	}
+
+	if (sd2_0)
+		src /= len;
+	
+	mmc_send_cmd(&request, MMC_READ_SINGLE_BLOCK, src, 1,len, RESPONSE_R1, dst);
+	if ((retval = mmc_unpack_r1(&request, &r1, 0))) {
+		return retval;
+	}
+	return retval;
+}
+
+/****************************************************/
+int mmc_block_write(ulong dst, uchar *src, int len)
+/****************************************************/
+{
+	return 0;
+}
+
+/****************************************************/
+int mmc_read(ulong src, uchar *dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("MMC card is not ready\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	src -= CFG_MMC_BASE;
+	end = src + size;
+	part_start = ~mmc_block_address & src;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & src;
+	aligned_end = mmc_block_address & end;
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf+part_start, part_len);
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+
+		if ((mmc_block_read((uchar *)(dst), src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+
+	if (part_end && src < end) {
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf, part_end);
+	}
+	return 0;
+
+}
+
+/****************************************************/
+int mmc_write(uchar *src, ulong dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+	
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("MMC card is not ready\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	dst -= CFG_MMC_BASE;
+	end = dst + size;
+	part_start = ~mmc_block_address & dst;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & dst;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		(ulong)src, dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf+part_start, src, part_len);
+		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_write(dst, (uchar *)src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && dst < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf, src, part_end);
+		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/****************************************************/
+ulong mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
+/****************************************************/
+{
+	ulong src;
+	int mmc_block_size = MMC_BLOCK_SIZE;
+
+	src = blknr * mmc_block_size + CFG_MMC_BASE;
+	mmc_read(src, (uchar *)dst, blkcnt*mmc_block_size);
+	return blkcnt;
+}
+
+int mmc_select_card(void)
+{
+	struct mmc_request request;
+	struct mmc_response_r1 r1;
+	int retval;
+
+	mmc_simple_cmd(&request, MMC_SELECT_CARD, mmcinfo.rca, RESPONSE_R1B);
+	retval = mmc_unpack_r1(&request, &r1, 0);
+	if (retval) {
+		return retval;
+	}
+
+	if (mmcinfo.sd) {
+		mmc_simple_cmd(&request, MMC_APP_CMD,  mmcinfo.rca, RESPONSE_R1);
+		retval = mmc_unpack_r1(&request,&r1,0);
+		if (retval) {
+			return retval;
+		}
+		mmc_simple_cmd(&request, SET_BUS_WIDTH, 2, RESPONSE_R1);
+                retval = mmc_unpack_r1(&request,&r1,0);
+                if (retval) {
+			return retval;
+		}
+	}
+	return 0;
+}
+
+/******************************************************************
+ *
+ * Configure card
+ *
+ ******************************************************************/
+
+static void mmc_configure_card(void)
+{
+	u32 rate;
+
+	/* Get card info */
+	if (sd2_0)
+		mmcinfo.block_num = (mmcinfo.csd.c_size + 1) << 10;
+	else
+		mmcinfo.block_num = (mmcinfo.csd.c_size + 1) * (1 << (mmcinfo.csd.c_size_mult + 2));
+
+	mmcinfo.block_len = 1 << mmcinfo.csd.read_bl_len;
+
+	/* Fix the clock rate */
+	rate = mmc_tran_speed(mmcinfo.csd.tran_speed);
+	if (rate < MMC_CLOCK_SLOW)
+		rate = MMC_CLOCK_SLOW;
+	if ((mmcinfo.sd == 0) && (rate > MMC_CLOCK_FAST))
+		rate = MMC_CLOCK_FAST;
+        if ((mmcinfo.sd) && (rate > SD_CLOCK_FAST))
+		rate = SD_CLOCK_FAST;
+
+	DEBUG(2,"mmc_configure_card: block_len=%d block_num=%d rate=%d\n", mmcinfo.block_len, mmcinfo.block_num, rate);
+
+	jz_mmc_set_clock(mmcinfo.sd, rate);
+}
+
+/******************************************************************
+ *
+ * State machine routines to initialize card(s)
+ *
+ ******************************************************************/
+
+/*
+  CIM_SINGLE_CARD_ACQ  (frequency at 400 kHz)
+  --- Must enter from GO_IDLE_STATE ---
+  1. SD_SEND_OP_COND (SD Card) [CMD55] + [CMD41]
+  2. SEND_OP_COND (Full Range) [CMD1]   {optional}
+  3. SEND_OP_COND (Set Range ) [CMD1]
+     If busy, delay and repeat step 2
+  4. ALL_SEND_CID              [CMD2]
+     If timeout, set an error (no cards found)
+  5. SET_RELATIVE_ADDR         [CMD3]
+  6. SEND_CSD                  [CMD9]
+  7. SET_DSR                   [CMD4]    Only call this if (csd.dsr_imp).
+  8. Set clock frequency (check available in csd.tran_speed)
+ */
+
+#define MMC_INIT_DOING   0
+#define MMC_INIT_PASSED  1
+#define MMC_INIT_FAILED  2
+
+static int mmc_init_card_state(struct mmc_request *request)
+{
+	struct mmc_response_r1 r1;
+	struct mmc_response_r3 r3;
+	int retval;
+	int ocr = 0x40300000;
+	int limit_41 = 0;
+
+	DEBUG(2,"mmc_init_card_state\n");
+
+	switch (request->cmd) {
+	case MMC_GO_IDLE_STATE: /* No response to parse */
+		if (mmcinfo.sd)
+			mmc_simple_cmd(request, 8, 0x1aa, RESPONSE_R1);
+		else
+			mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+		break;
+
+	case 8:
+        	retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+		mmc_simple_cmd(request, MMC_APP_CMD,  0, RESPONSE_R1);
+		break;
+
+        case MMC_APP_CMD:
+        	retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+		if (retval & (limit_41 < 100)) {
+			DEBUG(0, "mmc_init_card_state: unable to MMC_APP_CMD error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			limit_41++;
+			mmc_simple_cmd(request, SD_SEND_OP_COND, ocr, RESPONSE_R3);
+		} else if (limit_41 < 100) {
+			limit_41++;		
+			mmc_simple_cmd(request, SD_SEND_OP_COND, ocr, RESPONSE_R3);
+		} else{
+			/* reset the card to idle*/
+			mmc_simple_cmd(request, MMC_GO_IDLE_STATE, 0, RESPONSE_NONE);
+			mmcinfo.sd = 0;
+		}
+		break;
+
+        case SD_SEND_OP_COND:
+                retval = mmc_unpack_r3(request, &r3);
+                if (retval) {
+                  /* Try MMC card */
+                    mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+                    break;
+		}
+
+                DEBUG(2,"mmc_init_card_state: read ocr value = 0x%08x\n", r3.ocr);
+		
+		if(!(r3.ocr & MMC_CARD_BUSY || ocr == 0)){
+			udelay(10000);
+			mmc_simple_cmd(request, MMC_APP_CMD, 0, RESPONSE_R1);
+		}
+		else {
+		  /* Set the data bus width to 4 bits */
+                  mmcinfo.sd = 1; /* SD Card ready */
+                  mmcinfo.state = CARD_STATE_READY;
+		  mmc_simple_cmd(request, MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID);
+		}
+		break;
+
+	case MMC_SEND_OP_COND:
+		retval = mmc_unpack_r3(request, &r3);
+		if (retval) {
+			DEBUG(0,"mmc_init_card_state: failed SEND_OP_COND error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+
+		DEBUG(2,"mmc_init_card_state: read ocr value = 0x%08x\n", r3.ocr);
+		if (!(r3.ocr & MMC_CARD_BUSY)) {
+	                mmc_simple_cmd(request, MMC_SEND_OP_COND, MMC_OCR_ARG, RESPONSE_R3);
+		}
+		else {
+		        mmcinfo.sd = 0; /* MMC Card ready */
+			mmcinfo.state = CARD_STATE_READY;
+			mmc_simple_cmd(request, MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID);
+		}
+		break;
+		
+	case MMC_ALL_SEND_CID: 
+		retval = mmc_unpack_cid( request, &mmcinfo.cid );
+		mmc_dev.if_type = IF_TYPE_MMC;
+		mmc_dev.part_type = PART_TYPE_DOS;
+		mmc_dev.dev = 0;
+		mmc_dev.lun = 0;
+		mmc_dev.type = 0;
+		/* FIXME fill in the correct size (is set to 32MByte) */
+		mmc_dev.blksz = 512;
+		mmc_dev.lba = 0x10000;
+		mmc_dev.removable = 0;
+		
+		/*FIXME:ignore CRC error for CMD2/CMD9/CMD10 */
+		if ( retval && (retval != MMC_ERROR_CRC)) {
+			DEBUG(0,"mmc_init_card_state: unable to ALL_SEND_CID error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		mmcinfo.state = CARD_STATE_IDENT;
+		if(mmcinfo.sd)
+			mmc_simple_cmd(request, MMC_SET_RELATIVE_ADDR, 0, RESPONSE_R6);
+                else
+			mmc_simple_cmd(request, MMC_SET_RELATIVE_ADDR, ID_TO_RCA(mmcinfo.id) << 16, RESPONSE_R1);
+		break;
+
+        case MMC_SET_RELATIVE_ADDR:
+	        if (mmcinfo.sd)	{
+			retval = mmc_unpack_r6(request, &r1, mmcinfo.state, &mmcinfo.rca);
+			mmcinfo.rca = mmcinfo.rca << 16; 
+			DEBUG(2, "mmc_init_card_state: Get RCA from SD: 0x%04x Status: %x\n", mmcinfo.rca, r1.status);
+                } else {
+			retval = mmc_unpack_r1(request,&r1,mmcinfo.state);
+			mmcinfo.rca = ID_TO_RCA(mmcinfo.id) << 16;
+	        }
+		if (retval) {
+			DEBUG(0, "mmc_init_card_state: unable to SET_RELATIVE_ADDR error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		
+		mmcinfo.state = CARD_STATE_STBY;
+                mmc_simple_cmd(request, MMC_SEND_CSD, mmcinfo.rca, RESPONSE_R2_CSD);
+		
+		break;
+        
+	case MMC_SEND_CSD:
+		retval = mmc_unpack_csd(request, &mmcinfo.csd);
+			mmc_csd_t *csd = (mmc_csd_t *)retval;
+			memcpy(&mmc_csd, csd, sizeof(csd));
+			mmc_ready = 1;
+
+			printf("MMC card is ready\n");
+			/* FIXME add verbose printout for csd */
+                
+		/*FIXME:ignore CRC error for CMD2/CMD9/CMD10 */
+	        if (retval && (retval != MMC_ERROR_CRC)) {
+			DEBUG(0, "mmc_init_card_state: unable to SEND_CSD error=%d (%s)\n", 
+			      retval, mmc_result_to_string(retval));
+			return MMC_INIT_FAILED;
+		}
+		if (mmcinfo.csd.dsr_imp) {
+			DEBUG(0, "mmc_init_card_state: driver doesn't support setting DSR\n");
+		}
+		mmc_configure_card();
+		return MMC_INIT_PASSED;
+		
+	default:
+		DEBUG(0, "mmc_init_card_state: error!  Illegal last cmd %d\n", request->cmd);
+		return MMC_INIT_FAILED;
+	}
+
+	return MMC_INIT_DOING;
+}
+
+int mmc_init_card(void)
+{
+	struct mmc_request request;
+	int retval;
+
+	mmc_simple_cmd(&request, MMC_CIM_RESET, 0, RESPONSE_NONE); /* reset card */
+	mmc_simple_cmd(&request, MMC_GO_IDLE_STATE, 0, RESPONSE_NONE);
+	mmcinfo.sd = 1;  /* assuming a SD card */
+
+	while ((retval = mmc_init_card_state(&request)) == MMC_INIT_DOING)
+		;
+
+	if (retval == MMC_INIT_PASSED)
+		return MMC_NO_ERROR;
+	else
+		return MMC_NO_RESPONSE;
+}
+
+/****************************************************/
+/****************************************************/
+
+int mmc_init(int verbose)
+{
+	if (!__msc_card_detected())
+		return 1;
+	
+	printf("MMC card found\n");
+ 
+	// Step-1: init GPIO
+	__gpio_as_msc();
+
+	__msc_init_io();
+
+	// Step-2: turn on power of card
+	__msc_enable_power();
+
+	// Step-3: Reset MSC Controller.
+	__msc_reset();
+
+	// Step-3: mask all IRQs.
+	MMC_IRQ_MASK();	
+
+	// Step-4: stop MMC/SD clock
+	jz_mmc_stop_clock();
+	mmc_init_card();
+	mmc_select_card();
+
+	mmc_dev.block_read = mmc_bread; 
+	fat_register_device(&mmc_dev,1); /* partitions start counting with 1 */
+
+	return 0;
+}
+
+int mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+
+int mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000) {
+	return 1; 
+	} 
+	return 0;
+}
+/**************************************************************************
+ * Debugging functions
+ **************************************************************************/
+
+static char * mmc_result_strings[] = {
+	"NO_RESPONSE",
+	"NO_ERROR",
+	"ERROR_OUT_OF_RANGE",
+	"ERROR_ADDRESS",
+	"ERROR_BLOCK_LEN",
+	"ERROR_ERASE_SEQ",
+	"ERROR_ERASE_PARAM",
+	"ERROR_WP_VIOLATION",
+	"ERROR_CARD_IS_LOCKED",
+	"ERROR_LOCK_UNLOCK_FAILED",
+	"ERROR_COM_CRC",
+	"ERROR_ILLEGAL_COMMAND",
+	"ERROR_CARD_ECC_FAILED",
+	"ERROR_CC",
+	"ERROR_GENERAL",
+	"ERROR_UNDERRUN",
+	"ERROR_OVERRUN",
+	"ERROR_CID_CSD_OVERWRITE",
+	"ERROR_STATE_MISMATCH",
+	"ERROR_HEADER_MISMATCH",
+	"ERROR_TIMEOUT",
+	"ERROR_CRC",
+	"ERROR_DRIVER_FAILURE",
+};
+
+char * mmc_result_to_string(int i)
+{
+	return mmc_result_strings[i+1];
+}
+
+static char * card_state_strings[] = {
+	"empty",
+	"idle",
+	"ready",
+	"ident",
+	"stby",
+	"tran",
+	"data",
+	"rcv",
+	"prg",
+	"dis",
+};
+
+static inline char * card_state_to_string(int i)
+{
+	return card_state_strings[i+1];
+}
+
+/**************************************************************************
+ * Utility functions
+ **************************************************************************/
+
+#define PARSE_U32(_buf,_index) \
+	(((u32)_buf[_index]) << 24) | (((u32)_buf[_index+1]) << 16) | \
+        (((u32)_buf[_index+2]) << 8) | ((u32)_buf[_index+3]);
+
+#define PARSE_U16(_buf,_index) \
+	(((u16)_buf[_index]) << 8) | ((u16)_buf[_index+1]);
+
+int mmc_unpack_csd(struct mmc_request *request, struct mmc_csd *csd)
+{
+	u8 *buf = request->response;
+	int num = 0;
+	
+	if (request->result)
+		return request->result;
+
+	csd->csd_structure      = (buf[1] & 0xc0) >> 6;
+	if (csd->csd_structure)
+		sd2_0 = 1;
+	else
+		sd2_0 = 0;
+	
+	switch (csd->csd_structure) {
+	case 0 :
+		csd->taac               = buf[2];
+		csd->nsac               = buf[3];
+		csd->tran_speed         = buf[4];
+		csd->ccc                = (((u16)buf[5]) << 4) | ((buf[6] & 0xf0) >> 4);
+		csd->read_bl_len        = buf[6] & 0x0f;
+		/* for support 2GB card*/
+		if (csd->read_bl_len >= 10) 
+		{
+			num = csd->read_bl_len - 9;
+			csd->read_bl_len = 9;
+		}
+		
+		csd->read_bl_partial    = (buf[7] & 0x80) ? 1 : 0;
+		csd->write_blk_misalign = (buf[7] & 0x40) ? 1 : 0;
+		csd->read_blk_misalign  = (buf[7] & 0x20) ? 1 : 0;
+		csd->dsr_imp            = (buf[7] & 0x10) ? 1 : 0;
+		csd->c_size             = ((((u16)buf[7]) & 0x03) << 10) | (((u16)buf[8]) << 2) | (((u16)buf[9]) & 0xc0) >> 6;
+
+		if (num)
+			csd->c_size = csd->c_size << num;
+		
+		
+		csd->vdd_r_curr_min     = (buf[9] & 0x38) >> 3;
+		csd->vdd_r_curr_max     = buf[9] & 0x07;
+		csd->vdd_w_curr_min     = (buf[10] & 0xe0) >> 5;
+		csd->vdd_w_curr_max     = (buf[10] & 0x1c) >> 2;
+		csd->c_size_mult        = ((buf[10] & 0x03) << 1) | ((buf[11] & 0x80) >> 7);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			csd->erase.v22.sector_size    = (buf[11] & 0x7c) >> 2;
+			csd->erase.v22.erase_grp_size = ((buf[11] & 0x03) << 3) | ((buf[12] & 0xe0) >> 5);
+
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			csd->erase.v31.erase_grp_size = (buf[11] & 0x7c) >> 2;
+			csd->erase.v31.erase_grp_mult = ((buf[11] & 0x03) << 3) | ((buf[12] & 0xe0) >> 5);
+			break;
+		}
+		csd->wp_grp_size        = buf[12] & 0x1f;
+		csd->wp_grp_enable      = (buf[13] & 0x80) ? 1 : 0;
+		csd->default_ecc        = (buf[13] & 0x60) >> 5;
+		csd->r2w_factor         = (buf[13] & 0x1c) >> 2;
+		csd->write_bl_len       = ((buf[13] & 0x03) << 2) | ((buf[14] & 0xc0) >> 6);
+		if (csd->write_bl_len >= 10)
+			csd->write_bl_len = 9;
+		
+		csd->write_bl_partial   = (buf[14] & 0x20) ? 1 : 0;
+		csd->file_format_grp    = (buf[15] & 0x80) ? 1 : 0;
+		csd->copy               = (buf[15] & 0x40) ? 1 : 0;
+		csd->perm_write_protect = (buf[15] & 0x20) ? 1 : 0;
+		csd->tmp_write_protect  = (buf[15] & 0x10) ? 1 : 0;
+		csd->file_format        = (buf[15] & 0x0c) >> 2;
+		csd->ecc                = buf[15] & 0x03;
+		
+		DEBUG(2,"  csd_structure=%d  spec_vers=%d  taac=%02x  nsac=%02x  tran_speed=%02x\n"
+		      "  ccc=%04x  read_bl_len=%d  read_bl_partial=%d  write_blk_misalign=%d\n"
+		      "  read_blk_misalign=%d  dsr_imp=%d  c_size=%d  vdd_r_curr_min=%d\n"
+		      "  vdd_r_curr_max=%d  vdd_w_curr_min=%d  vdd_w_curr_max=%d  c_size_mult=%d\n"
+		      "  wp_grp_size=%d  wp_grp_enable=%d  default_ecc=%d  r2w_factor=%d\n"
+		      "  write_bl_len=%d  write_bl_partial=%d  file_format_grp=%d  copy=%d\n"
+		      "  perm_write_protect=%d  tmp_write_protect=%d  file_format=%d  ecc=%d\n",
+		      csd->csd_structure, csd->spec_vers, 
+		      csd->taac, csd->nsac, csd->tran_speed,
+		      csd->ccc, csd->read_bl_len, 
+		      csd->read_bl_partial, csd->write_blk_misalign,
+		      csd->read_blk_misalign, csd->dsr_imp, 
+		      csd->c_size, csd->vdd_r_curr_min,
+		      csd->vdd_r_curr_max, csd->vdd_w_curr_min, 
+		      csd->vdd_w_curr_max, csd->c_size_mult,
+		      csd->wp_grp_size, csd->wp_grp_enable,
+		      csd->default_ecc, csd->r2w_factor, 
+		      csd->write_bl_len, csd->write_bl_partial,
+		      csd->file_format_grp, csd->copy, 
+		      csd->perm_write_protect, csd->tmp_write_protect,
+		      csd->file_format, csd->ecc);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			DEBUG(2," V22 sector_size=%d erase_grp_size=%d\n", 
+			      csd->erase.v22.sector_size, 
+			      csd->erase.v22.erase_grp_size);
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			DEBUG(2," V31 erase_grp_size=%d erase_grp_mult=%d\n", 
+			      csd->erase.v31.erase_grp_size,
+			      csd->erase.v31.erase_grp_mult);
+			break;
+			
+		}
+		break;	
+		
+	case 1 :
+		csd->taac               = 0;
+		csd->nsac               = 0;
+		csd->tran_speed         = buf[4];
+		csd->ccc                = (((u16)buf[5]) << 4) | ((buf[6] & 0xf0) >> 4);
+
+		csd->read_bl_len        = 9;
+		csd->read_bl_partial    = 0;
+		csd->write_blk_misalign = 0;
+		csd->read_blk_misalign  = 0;
+		csd->dsr_imp            = (buf[7] & 0x10) ? 1 : 0;
+		csd->c_size             = ((((u16)buf[8]) & 0x3f) << 16) | (((u16)buf[9]) << 8) | ((u16)buf[10]) ;
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			csd->erase.v22.sector_size    = 0x7f;
+			csd->erase.v22.erase_grp_size = 0;
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			csd->erase.v31.erase_grp_size = 0x7f;
+			csd->erase.v31.erase_grp_mult = 0;
+			break;
+		}
+		csd->wp_grp_size        = 0;
+		csd->wp_grp_enable      = 0;
+		csd->default_ecc        = (buf[13] & 0x60) >> 5;
+		csd->r2w_factor         = 4;/* Unused */
+		csd->write_bl_len       = 9;
+		
+		csd->write_bl_partial   = 0;
+		csd->file_format_grp    = 0;
+		csd->copy               = (buf[15] & 0x40) ? 1 : 0;
+		csd->perm_write_protect = (buf[15] & 0x20) ? 1 : 0;
+		csd->tmp_write_protect  = (buf[15] & 0x10) ? 1 : 0;
+		csd->file_format        = 0;
+		csd->ecc                = buf[15] & 0x03;
+		
+		DEBUG(2,"  csd_structure=%d  spec_vers=%d  taac=%02x  nsac=%02x  tran_speed=%02x\n"
+		      "  ccc=%04x  read_bl_len=%d  read_bl_partial=%d  write_blk_misalign=%d\n"
+		      "  read_blk_misalign=%d  dsr_imp=%d  c_size=%d  vdd_r_curr_min=%d\n"
+		      "  vdd_r_curr_max=%d  vdd_w_curr_min=%d  vdd_w_curr_max=%d  c_size_mult=%d\n"
+		      "  wp_grp_size=%d  wp_grp_enable=%d  default_ecc=%d  r2w_factor=%d\n"
+		      "  write_bl_len=%d  write_bl_partial=%d  file_format_grp=%d  copy=%d\n"
+		      "  perm_write_protect=%d  tmp_write_protect=%d  file_format=%d  ecc=%d\n",
+		      csd->csd_structure, csd->spec_vers, 
+		      csd->taac, csd->nsac, csd->tran_speed,
+		      csd->ccc, csd->read_bl_len, 
+		      csd->read_bl_partial, csd->write_blk_misalign,
+		      csd->read_blk_misalign, csd->dsr_imp, 
+		      csd->c_size, csd->vdd_r_curr_min,
+		      csd->vdd_r_curr_max, csd->vdd_w_curr_min, 
+		      csd->vdd_w_curr_max, csd->c_size_mult,
+		      csd->wp_grp_size, csd->wp_grp_enable,
+		      csd->default_ecc, csd->r2w_factor, 
+		      csd->write_bl_len, csd->write_bl_partial,
+		      csd->file_format_grp, csd->copy, 
+		      csd->perm_write_protect, csd->tmp_write_protect,
+		      csd->file_format, csd->ecc);
+		switch (csd->csd_structure) {
+		case CSD_STRUCT_VER_1_0:
+		case CSD_STRUCT_VER_1_1:
+			DEBUG(2," V22 sector_size=%d erase_grp_size=%d\n", 
+			      csd->erase.v22.sector_size, 
+			      csd->erase.v22.erase_grp_size);
+			break;
+		case CSD_STRUCT_VER_1_2:
+		default:
+			DEBUG(2," V31 erase_grp_size=%d erase_grp_mult=%d\n", 
+			      csd->erase.v31.erase_grp_size,
+			      csd->erase.v31.erase_grp_mult);
+			break;
+		}
+	}
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+
+	return 0;
+}
+
+int mmc_unpack_r1(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state)
+{
+	u8 *buf = request->response;
+
+	if (request->result)        return request->result;
+
+	r1->cmd    = buf[0];
+	r1->status = PARSE_U32(buf,1);
+
+	DEBUG(2, "mmc_unpack_r1: cmd=%d status=%08x\n", r1->cmd, r1->status);
+
+	if (R1_STATUS(r1->status)) {
+		if (r1->status & R1_OUT_OF_RANGE)       return MMC_ERROR_OUT_OF_RANGE;
+		if (r1->status & R1_ADDRESS_ERROR)      return MMC_ERROR_ADDRESS;
+		if (r1->status & R1_BLOCK_LEN_ERROR)    return MMC_ERROR_BLOCK_LEN;
+		if (r1->status & R1_ERASE_SEQ_ERROR)    return MMC_ERROR_ERASE_SEQ;
+		if (r1->status & R1_ERASE_PARAM)        return MMC_ERROR_ERASE_PARAM;
+		if (r1->status & R1_WP_VIOLATION)       return MMC_ERROR_WP_VIOLATION;
+		//if (r1->status & R1_CARD_IS_LOCKED)     return MMC_ERROR_CARD_IS_LOCKED;
+		if (r1->status & R1_LOCK_UNLOCK_FAILED) return MMC_ERROR_LOCK_UNLOCK_FAILED;
+		if (r1->status & R1_COM_CRC_ERROR)      return MMC_ERROR_COM_CRC;
+		if (r1->status & R1_ILLEGAL_COMMAND)    return MMC_ERROR_ILLEGAL_COMMAND;
+		if (r1->status & R1_CARD_ECC_FAILED)    return MMC_ERROR_CARD_ECC_FAILED;
+		if (r1->status & R1_CC_ERROR)           return MMC_ERROR_CC;
+		if (r1->status & R1_ERROR)              return MMC_ERROR_GENERAL;
+		if (r1->status & R1_UNDERRUN)           return MMC_ERROR_UNDERRUN;
+		if (r1->status & R1_OVERRUN)            return MMC_ERROR_OVERRUN;
+		if (r1->status & R1_CID_CSD_OVERWRITE)  return MMC_ERROR_CID_CSD_OVERWRITE;
+	}
+
+	if (buf[0] != request->cmd) return MMC_ERROR_HEADER_MISMATCH;
+
+	/* This should be last - it's the least dangerous error */
+
+	return 0;
+}
+
+int mmc_unpack_scr(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, u32 *scr)
+{
+        u8 *buf = request->response;
+	if (request->result)        return request->result;
+        
+        *scr = PARSE_U32(buf, 5); /* Save SCR returned by the SD Card */
+        return mmc_unpack_r1(request, r1, state);
+        
+}
+
+int mmc_unpack_r6(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, int *rca)
+{
+	u8 *buf = request->response;
+
+	if (request->result)        return request->result;
+        
+        *rca = PARSE_U16(buf,1);  /* Save RCA returned by the SD Card */
+        
+        *(buf+1) = 0;
+        *(buf+2) = 0;
+        
+        return mmc_unpack_r1(request, r1, state);
+}   
+
+int mmc_unpack_cid(struct mmc_request *request, struct mmc_cid *cid)
+{
+	u8 *buf = request->response;
+	int i;
+
+	if (request->result) return request->result;
+
+	cid->mid = buf[1];
+	cid->oid = PARSE_U16(buf,2);
+	for (i = 0 ; i < 6 ; i++)
+		cid->pnm[i] = buf[4+i];
+	cid->pnm[6] = 0;
+	cid->prv = buf[10];
+	cid->psn = PARSE_U32(buf,11);
+	cid->mdt = buf[15];
+	
+	DEBUG(2,"mmc_unpack_cid: mid=%d oid=%d pnm=%s prv=%d.%d psn=%08x mdt=%d/%d\n",
+	      cid->mid, cid->oid, cid->pnm, 
+	      (cid->prv>>4), (cid->prv&0xf), 
+	      cid->psn, (cid->mdt>>4), (cid->mdt&0xf)+1997);
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+      	return 0;
+}
+
+int mmc_unpack_r3(struct mmc_request *request, struct mmc_response_r3 *r3)
+{
+	u8 *buf = request->response;
+
+	if (request->result) return request->result;
+
+	r3->ocr = PARSE_U32(buf,1);
+	DEBUG(2,"mmc_unpack_r3: ocr=%08x\n", r3->ocr);
+
+	if (buf[0] != 0x3f)  return MMC_ERROR_HEADER_MISMATCH;
+	return 0;
+}
+
+/**************************************************************************/
+
+#define KBPS 1
+#define MBPS 1000
+
+static u32 ts_exp[] = { 100*KBPS, 1*MBPS, 10*MBPS, 100*MBPS, 0, 0, 0, 0 };
+static u32 ts_mul[] = { 0,    1000, 1200, 1300, 1500, 2000, 2500, 3000, 
+			3500, 4000, 4500, 5000, 5500, 6000, 7000, 8000 };
+
+u32 mmc_tran_speed(u8 ts)
+{
+	u32 rate = ts_exp[(ts & 0x7)] * ts_mul[(ts & 0x78) >> 3];
+
+	if (rate <= 0) {
+		DEBUG(0, "mmc_tran_speed: error - unrecognized speed 0x%02x\n", ts);
+		return 1;
+	}
+
+	return rate;
+}
+
+/**************************************************************************/
+
+void mmc_send_cmd(struct mmc_request *request, int cmd, u32 arg, 
+		   u16 nob, u16 block_len, enum mmc_rsp_t rtype, u8 *buffer)
+{
+	request->cmd       = cmd;
+	request->arg       = arg;
+	request->rtype     = rtype;
+	request->nob       = nob;
+	request->block_len = block_len;
+	request->buffer    = buffer;
+	request->cnt       = nob * block_len;
+
+	jz_mmc_exec_cmd(request);
+}
+
+#endif	/* CONFIG_MMC */
+#endif  /* CONFIG_JZ4740 & CONFIG_JZ4730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_mmc.h u-boot-1.1.6/cpu/mips/jz_mmc.h
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_mmc.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_mmc.h	2008-12-12 19:43:00.000000000 +0800
@@ -0,0 +1,113 @@
+/*
+ *  linux/drivers/mmc/jz_mmc.h
+ *
+ *  Author: Vladimir Shebordaev, Igor Oblakov
+ *  Copyright:  MontaVista Software Inc.
+ *
+ *  $Id: jz_mmc.h,v 1.3 2007-06-15 08:04:20 jlwei Exp $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#ifndef __MMC_JZMMC_H__
+#define __MMC_JZMMC_H__
+
+#include "mmc_protocol.h"
+
+#define MMC_DEBUG_LEVEL		0		/* Enable Debug: 0 - no debug */
+
+#define MMC_BLOCK_SIZE		512		/* MMC/SD Block Size */
+
+#define ID_TO_RCA(x) ((x)+1)
+
+#define MMC_OCR_ARG		0x00ff8000	/* Argument of OCR */
+
+enum mmc_result_t {
+	MMC_NO_RESPONSE        = -1,
+	MMC_NO_ERROR           = 0,
+	MMC_ERROR_OUT_OF_RANGE,
+	MMC_ERROR_ADDRESS,
+	MMC_ERROR_BLOCK_LEN,
+	MMC_ERROR_ERASE_SEQ,
+	MMC_ERROR_ERASE_PARAM,
+	MMC_ERROR_WP_VIOLATION,
+	MMC_ERROR_CARD_IS_LOCKED,
+	MMC_ERROR_LOCK_UNLOCK_FAILED,
+	MMC_ERROR_COM_CRC,
+	MMC_ERROR_ILLEGAL_COMMAND,
+	MMC_ERROR_CARD_ECC_FAILED,
+	MMC_ERROR_CC,
+	MMC_ERROR_GENERAL,
+	MMC_ERROR_UNDERRUN,
+	MMC_ERROR_OVERRUN,
+	MMC_ERROR_CID_CSD_OVERWRITE,
+	MMC_ERROR_STATE_MISMATCH,
+	MMC_ERROR_HEADER_MISMATCH,
+	MMC_ERROR_TIMEOUT,
+	MMC_ERROR_CRC,
+	MMC_ERROR_DRIVER_FAILURE,
+};
+
+/* the information structure of MMC/SD Card */
+typedef struct MMC_INFO
+{
+	int             id;     /* Card index */
+        int             sd;     /* MMC or SD card */
+        int             rca;    /* RCA */
+        u32             scr;    /* SCR 63:32*/        
+	int             flags;  /* Ejected, inserted */
+	enum card_state state;  /* empty, ident, ready, whatever */
+
+	/* Card specific information */
+	struct mmc_cid  cid;
+	struct mmc_csd  csd;
+	u32             block_num;
+	u32             block_len;
+	u32             erase_unit;
+} mmc_info;
+
+mmc_info mmcinfo;
+
+struct mmc_request {
+	int               index;      /* Slot index - used for CS lines */
+	int               cmd;        /* Command to send */
+	u32               arg;        /* Argument to send */
+	enum mmc_rsp_t    rtype;      /* Response type expected */
+
+	/* Data transfer (these may be modified at the low level) */
+	u16               nob;        /* Number of blocks to transfer*/
+	u16               block_len;  /* Block length */
+	u8               *buffer;     /* Data buffer */
+	u32               cnt;        /* Data length, for PIO */
+
+	/* Results */
+	u8                response[18]; /* Buffer to store response - CRC is optional */
+	enum mmc_result_t result;
+};
+
+char * mmc_result_to_string(int);
+int    mmc_unpack_csd(struct mmc_request *request, struct mmc_csd *csd);
+int    mmc_unpack_r1(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state);
+int    mmc_unpack_r6(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, int *rca);
+int    mmc_unpack_scr(struct mmc_request *request, struct mmc_response_r1 *r1, enum card_state state, u32 *scr);
+int    mmc_unpack_cid(struct mmc_request *request, struct mmc_cid *cid);
+int    mmc_unpack_r3(struct mmc_request *request, struct mmc_response_r3 *r3);
+
+void   mmc_send_cmd(struct mmc_request *request, int cmd, u32 arg, 
+		     u16 nob, u16 block_len, enum mmc_rsp_t rtype, u8 *buffer);
+u32    mmc_tran_speed(u8 ts);
+void   jz_mmc_set_clock(int sd, u32 rate);
+void   jz_mmc_hardware_init(void);
+
+static inline void mmc_simple_cmd(struct mmc_request *request, int cmd, u32 arg, enum mmc_rsp_t rtype)
+{
+	mmc_send_cmd( request, cmd, arg, 0, 0, rtype, 0);
+}
+
+int mmc_init(int verbose);
+int mmc_read(ulong src, uchar *dst, int size);
+int mmc_write(uchar *src, ulong dst, int size);
+int mmc2info(ulong addr);
+
+#endif /* __MMC_JZMMC_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_serial.c u-boot-1.1.6/cpu/mips/jz_serial.c
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/jz_serial.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/jz_serial.c	2008-12-23 01:54:24.000000000 +0800
@@ -0,0 +1,167 @@
+/*
+ * Jz47xx UART support
+ *
+ * Hardcoded to UART 0 for now
+ * Options also hardcoded to 8N1
+ *
+ *  Copyright (c) 2005
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#if defined(CONFIG_JZ4730) || defined(CONFIG_JZ4740) || defined(CONFIG_JZ4750) \
+	|| defined(CONFIG_JZ4750D) || defined(CONFIG_JZ5730)
+
+#include <common.h>
+
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ4750)
+#include <asm/jz4750.h>
+#endif
+#if defined(CONFIG_JZ4750D)
+#include <asm/jz4750d.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+
+#undef UART_BASE
+#ifndef CFG_UART_BASE
+#define UART_BASE  UART0_BASE
+#else
+#define UART_BASE  CFG_UART_BASE
+#endif
+
+/******************************************************************************
+*
+* serial_init - initialize a channel
+*
+* This routine initializes the number of data bits, parity
+* and set the selected baud rate. Interrupts are disabled.
+* Set the modem control signals if the option is selected.
+*
+* RETURNS: N/A
+*/
+
+int serial_init (void)
+{
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+	volatile u8 *uart_fcr = (volatile u8 *)(UART_BASE + OFF_FCR);
+	volatile u8 *uart_lcr = (volatile u8 *)(UART_BASE + OFF_LCR);
+	volatile u8 *uart_ier = (volatile u8 *)(UART_BASE + OFF_IER);
+	volatile u8 *uart_sircr = (volatile u8 *)(UART_BASE + OFF_SIRCR);
+
+	/* Disable port interrupts while changing hardware */
+	*uart_ier = 0;
+
+	/* Disable UART unit function */
+	*uart_fcr = ~UART_FCR_UUE;
+
+	/* Set both receiver and transmitter in UART mode (not SIR) */
+	*uart_sircr = ~(SIRCR_RSIRE | SIRCR_TSIRE);
+
+	/* Set databits, stopbits and parity. (8-bit data, 1 stopbit, no parity) */
+	*uart_lcr = UART_LCR_WLEN_8 | UART_LCR_STOP_1;
+	
+	/* Set baud rate */
+	serial_setbrg();
+	
+	/* Enable UART unit, enable and clear FIFO */
+	*uart_fcr = UART_FCR_UUE | UART_FCR_FE | UART_FCR_TFLS | UART_FCR_RFLS;
+#endif
+	return 0;
+}
+
+void serial_setbrg (void)
+{
+	volatile u8 *uart_lcr = (volatile u8 *)(UART_BASE + OFF_LCR);
+	volatile u8 *uart_dlhr = (volatile u8 *)(UART_BASE + OFF_DLHR);
+	volatile u8 *uart_dllr = (volatile u8 *)(UART_BASE + OFF_DLLR);
+	u32 baud_div, tmp;
+
+#if defined(CONFIG_FPGA)
+	baud_div = (CFG_EXTAL / CFG_DIV) / 16 / CONFIG_BAUDRATE;
+#elif defined(CONFIG_JZ4750) || defined(CONFIG_JZ4750D)
+	if (CFG_EXTAL > 16000000) {
+		REG_CPM_CPCCR |= CPM_CPCCR_ECS;
+		baud_div = CFG_EXTAL / 32 / CONFIG_BAUDRATE;
+	} else {
+		REG_CPM_CPCCR &= ~CPM_CPCCR_ECS;
+		baud_div = CFG_EXTAL / 16 / CONFIG_BAUDRATE;
+	}
+#else /* CONFIG_JZ4740 | CONFIG_JZ4730 */
+	baud_div = CFG_EXTAL / 16 / CONFIG_BAUDRATE;
+#endif
+	tmp = *uart_lcr;
+	tmp |= UART_LCR_DLAB;
+	*uart_lcr = tmp;
+
+	*uart_dlhr = (baud_div >> 8) & 0xff;
+	*uart_dllr = baud_div & 0xff;
+
+	tmp &= ~UART_LCR_DLAB;
+	*uart_lcr = tmp;
+}
+
+void serial_putc (const char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART_BASE + OFF_TDR);
+
+	if (c == '\n') serial_putc ('\r');
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UART_LSR_TDRQ | UART_LSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+int serial_getc (void)
+{
+	volatile u8 *uart_rdr = (volatile u8 *)(UART_BASE + OFF_RDR);
+
+	while (!serial_tstc());
+
+	return *uart_rdr;
+}
+
+int serial_tstc (void)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART_BASE + OFF_LSR);
+
+	if (*uart_lsr & UART_LSR_DR) {
+		/* Data in rfifo */
+		return (1);
+	}
+	return 0;
+}
+
+#endif /* CONFIG_JZ4730 || CONFIG_JZ4740 || CONFIG_JZ4750 || CONFIG_JZ45730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/Makefile u-boot-1.1.6/cpu/mips/Makefile
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/Makefile	2007-10-31 00:43:57.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/Makefile	2009-02-03 21:03:48.000000000 +0800
@@ -26,8 +26,10 @@
 LIB	= $(obj)lib$(CPU).a
 
 START	= start.o
-COBJS	= asc_serial.o au1x00_serial.o au1x00_eth.o au1x00_usb_ohci.o \
-	  cpu.o interrupts.o incaip_clock.o
+COBJS	= jz4730.o jz4740.o jz5730.o jz_lcd.o jz4740_slcd.o jz_serial.o jz_eth.o jz_i2c.o \
+	  asc_serial.o au1x00_serial.o au1x00_eth.o au1x00_usb_ohci.o \
+	  cpu.o interrupts.o incaip_clock.o jz_mmc.o jz4730_nand.o jz4740_cpm_test.o \
+	  jz5730_nand.o jz4740_nand.o jz4750_nand.o jz_cs8900.o jz4750.o jz4750_mmc.o
 SOBJS	= incaip_wdt.o cache.o
 
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/mmc_protocol.h u-boot-1.1.6/cpu/mips/mmc_protocol.h
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/mmc_protocol.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/mmc_protocol.h	2007-04-16 15:49:06.000000000 +0800
@@ -0,0 +1,273 @@
+/*
+**********************************************************************
+*
+*                            uC/MMC
+*
+*             (c) Copyright 2005 - 2007, Ingenic Semiconductor, Inc
+*                      All rights reserved.
+*
+***********************************************************************
+
+----------------------------------------------------------------------
+File        : mmc_protocol.h 
+Purpose     : MMC protocol definitions.
+
+----------------------------------------------------------------------
+Version-Date-----Author-Explanation
+----------------------------------------------------------------------
+1.00.00 20060831 WeiJianli     First release
+
+----------------------------------------------------------------------
+Known problems or limitations with current version
+----------------------------------------------------------------------
+(none)
+---------------------------END-OF-HEADER------------------------------
+*/
+
+#ifndef __MMC_PROTOCOL__
+#define __MMC_PROTOCOL__
+
+/* Standard MMC/SD clock speeds */
+#define MMC_CLOCK_SLOW    400000      /* 400 kHz for initial setup */
+#define MMC_CLOCK_FAST  20000000      /* 20 MHz for maximum for normal operation */
+#define SD_CLOCK_FAST   24000000      /* 24 MHz for SD Cards */
+ 
+/* Extra MMC commands for state control */
+/* Use negative numbers to disambiguate */
+#define MMC_CIM_RESET            -1
+
+/* Standard MMC commands (3.1)           type  argument     response */
+   /* class 1 */
+#define	MMC_GO_IDLE_STATE         0   /* bc                          */
+#define MMC_SEND_OP_COND          1   /* bcr  [31:0] OCR         R3  */
+#define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
+#define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
+#define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+#define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
+#define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
+#define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
+#define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
+#define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
+#define MMC_SEND_STATUS	         13   /* ac   [31:16] RCA        R1  */
+#define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
+
+  /* class 2 */
+#define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
+#define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
+#define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
+
+  /* class 3 */
+#define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
+
+  /* class 4 */
+#define MMC_SET_BLOCK_COUNT      23   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_BLOCK          24   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_MULTIPLE_BLOCK 25   /* adtc                    R1  */
+#define MMC_PROGRAM_CID          26   /* adtc                    R1  */
+#define MMC_PROGRAM_CSD          27   /* adtc                    R1  */
+
+  /* class 6 */
+#define MMC_SET_WRITE_PROT       28   /* ac   [31:0] data addr   R1b */
+#define MMC_CLR_WRITE_PROT       29   /* ac   [31:0] data addr   R1b */
+#define MMC_SEND_WRITE_PROT      30   /* adtc [31:0] wpdata addr R1  */
+
+  /* class 5 */
+#define MMC_ERASE_GROUP_START    35   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE_GROUP_END      36   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE                37   /* ac                      R1b */
+
+  /* class 9 */
+#define MMC_FAST_IO              39   /* ac   <Complex>          R4  */
+#define MMC_GO_IRQ_STATE         40   /* bcr                     R5  */
+
+  /* class 7 */
+#define MMC_LOCK_UNLOCK          42   /* adtc                    R1b */
+
+  /* class 8 */
+#define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
+#define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1b */
+
+  /* SD class */
+#define SD_SEND_OP_COND          41   /* bcr  [31:0] OCR         R3  */
+#define SET_BUS_WIDTH            6    /* ac   [1:0] bus width    R1  */    
+#define SEND_SCR                 51   /* adtc [31:0] staff       R1  */   
+
+/* Don't change the order of these; they are used in dispatch tables */
+enum mmc_rsp_t {
+	RESPONSE_NONE   = 0,
+	RESPONSE_R1     = 1,
+	RESPONSE_R1B    = 2,
+	RESPONSE_R2_CID = 3,
+	RESPONSE_R2_CSD  = 4,
+	RESPONSE_R3      = 5,
+	RESPONSE_R4      = 6,
+	RESPONSE_R5      = 7,
+        RESPONSE_R6      = 8,
+};
+
+
+/*
+  MMC status in R1
+  Type
+  	e : error bit
+	s : status bit
+	r : detected and set for the actual command response
+	x : detected and set during command execution. the host must poll
+            the card by sending status command in order to read these bits.
+  Clear condition
+  	a : according to the card state
+	b : always related to the previous command. Reception of
+            a valid command will clear it (with a delay of one command)
+	c : clear by read
+ */
+
+#define R1_OUT_OF_RANGE		(1 << 31)	/* er, c */
+#define R1_ADDRESS_ERROR	(1 << 30)	/* erx, c */
+#define R1_BLOCK_LEN_ERROR	(1 << 29)	/* er, c */
+#define R1_ERASE_SEQ_ERROR      (1 << 28)	/* er, c */
+#define R1_ERASE_PARAM		(1 << 27)	/* ex, c */
+#define R1_WP_VIOLATION		(1 << 26)	/* erx, c */
+#define R1_CARD_IS_LOCKED	(1 << 25)	/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED	(1 << 24)	/* erx, c */
+#define R1_COM_CRC_ERROR	(1 << 23)	/* er, b */
+#define R1_ILLEGAL_COMMAND	(1 << 22)	/* er, b */
+#define R1_CARD_ECC_FAILED	(1 << 21)	/* ex, c */
+#define R1_CC_ERROR		(1 << 20)	/* erx, c */
+#define R1_ERROR		(1 << 19)	/* erx, c */
+#define R1_UNDERRUN		(1 << 18)	/* ex, c */
+#define R1_OVERRUN		(1 << 17)	/* ex, c */
+#define R1_CID_CSD_OVERWRITE	(1 << 16)	/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP	(1 << 15)	/* sx, c */
+#define R1_CARD_ECC_DISABLED	(1 << 14)	/* sx, a */
+#define R1_ERASE_RESET		(1 << 13)	/* sr, c */
+#define R1_STATUS(x)            (x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)    	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
+#define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
+#define R1_APP_CMD		(1 << 7)	/* sr, c */
+
+enum card_state {
+	CARD_STATE_EMPTY = -1,
+	CARD_STATE_IDLE	 = 0,
+	CARD_STATE_READY = 1,
+	CARD_STATE_IDENT = 2,
+	CARD_STATE_STBY	 = 3,
+	CARD_STATE_TRAN	 = 4,
+	CARD_STATE_DATA	 = 5,
+	CARD_STATE_RCV	 = 6,
+	CARD_STATE_PRG	 = 7,
+	CARD_STATE_DIS	 = 8,
+};
+
+/* These are unpacked versions of the actual responses */
+
+ struct mmc_response_r1 {
+	u8  cmd;
+	u32 status;
+};
+
+typedef struct mmc_cid {
+	u8  mid;
+	u16 oid;
+	u8  pnm[7];   // Product name (we null-terminate)
+	u8  prv;
+	u32 psn;
+	u8  mdt;
+}mmc_cid_t;
+
+typedef struct mmc_csd {
+	u8  csd_structure;
+	u8  spec_vers;
+	u8  taac;
+	u8  nsac;
+	u8  tran_speed;
+	u16 ccc;
+	u8  read_bl_len;
+	u8  read_bl_partial;
+	u8  write_blk_misalign;
+	u8  read_blk_misalign;
+	u8  dsr_imp;
+	u16 c_size;
+	u8  vdd_r_curr_min;
+	u8  vdd_r_curr_max;
+	u8  vdd_w_curr_min;
+	u8  vdd_w_curr_max;
+	u8  c_size_mult;
+	union {
+		struct { /* MMC system specification version 3.1 */
+			u8  erase_grp_size;  
+			u8  erase_grp_mult; 
+		} v31;
+		struct { /* MMC system specification version 2.2 */
+			u8  sector_size;
+			u8  erase_grp_size;
+		} v22;
+	} erase;
+	u8  wp_grp_size;
+	u8  wp_grp_enable;
+	u8  default_ecc;
+	u8  r2w_factor;
+	u8  write_bl_len;
+	u8  write_bl_partial;
+	u8  file_format_grp;
+	u8  copy;
+	u8  perm_write_protect;
+	u8  tmp_write_protect;
+	u8  file_format;
+	u8  ecc;
+}mmc_csd_t;;
+
+struct mmc_response_r3 {  
+	u32 ocr;
+}; 
+
+#define MMC_VDD_145_150	0x00000001	/* VDD voltage 1.45 - 1.50 */
+#define MMC_VDD_150_155	0x00000002	/* VDD voltage 1.50 - 1.55 */
+#define MMC_VDD_155_160	0x00000004	/* VDD voltage 1.55 - 1.60 */
+#define MMC_VDD_160_165	0x00000008	/* VDD voltage 1.60 - 1.65 */
+#define MMC_VDD_165_170	0x00000010	/* VDD voltage 1.65 - 1.70 */
+#define MMC_VDD_17_18	0x00000020	/* VDD voltage 1.7 - 1.8 */
+#define MMC_VDD_18_19	0x00000040	/* VDD voltage 1.8 - 1.9 */
+#define MMC_VDD_19_20	0x00000080	/* VDD voltage 1.9 - 2.0 */
+#define MMC_VDD_20_21	0x00000100	/* VDD voltage 2.0 ~ 2.1 */
+#define MMC_VDD_21_22	0x00000200	/* VDD voltage 2.1 ~ 2.2 */
+#define MMC_VDD_22_23	0x00000400	/* VDD voltage 2.2 ~ 2.3 */
+#define MMC_VDD_23_24	0x00000800	/* VDD voltage 2.3 ~ 2.4 */
+#define MMC_VDD_24_25	0x00001000	/* VDD voltage 2.4 ~ 2.5 */
+#define MMC_VDD_25_26	0x00002000	/* VDD voltage 2.5 ~ 2.6 */
+#define MMC_VDD_26_27	0x00004000	/* VDD voltage 2.6 ~ 2.7 */
+#define MMC_VDD_27_28	0x00008000	/* VDD voltage 2.7 ~ 2.8 */
+#define MMC_VDD_28_29	0x00010000	/* VDD voltage 2.8 ~ 2.9 */
+#define MMC_VDD_29_30	0x00020000	/* VDD voltage 2.9 ~ 3.0 */
+#define MMC_VDD_30_31	0x00040000	/* VDD voltage 3.0 ~ 3.1 */
+#define MMC_VDD_31_32	0x00080000	/* VDD voltage 3.1 ~ 3.2 */
+#define MMC_VDD_32_33	0x00100000	/* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34	0x00200000	/* VDD voltage 3.3 ~ 3.4 */
+#define MMC_VDD_34_35	0x00400000	/* VDD voltage 3.4 ~ 3.5 */
+#define MMC_VDD_35_36	0x00800000	/* VDD voltage 3.5 ~ 3.6 */
+#define MMC_CARD_BUSY	0x80000000	/* Card Power up status bit */
+
+
+/* CSD field definitions */
+ 
+#define CSD_STRUCT_VER_1_0  0           /* Valid for system specification 1.0 - 1.2 */
+#define CSD_STRUCT_VER_1_1  1           /* Valid for system specification 1.4 - 2.2 */
+#define CSD_STRUCT_VER_1_2  2           /* Valid for system specification 3.1       */
+
+#define CSD_SPEC_VER_0      0           /* Implements system specification 1.0 - 1.2 */
+#define CSD_SPEC_VER_1      1           /* Implements system specification 1.4 */
+#define CSD_SPEC_VER_2      2           /* Implements system specification 2.0 - 2.2 */
+#define CSD_SPEC_VER_3      3           /* Implements system specification 3.1 */
+
+#if MMC_DEBUG_LEVEL
+
+#define DEBUG(n, args...)			\
+    do {    \
+	if (n <=  MMC_DEBUG_LEVEL) {	\
+		printf(args);	\
+	}    \
+    } while(0)
+#else
+#define DEBUG(n, args...)
+#endif /* MMC_DEBUG_EN */
+
+#endif  /* __MMC_PROTOCOL__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/cpu/mips/start.S u-boot-1.1.6/cpu/mips/start.S
--- /develop/source/01boot/u-boot-1.1.6/cpu/mips/start.S	2007-10-31 00:43:57.000000000 +0800
+++ u-boot-1.1.6/cpu/mips/start.S	2008-12-23 01:54:24.000000000 +0800
@@ -22,12 +22,34 @@
  * MA 02111-1307 USA
  */
 
-
 #include <config.h>
 #include <version.h>
 #include <asm/regdef.h>
 #include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+
+#ifdef CONFIG_JZ4730
+#include <asm/jz4730.h>
+#endif
 
+#ifdef CONFIG_JZ4740
+#include <asm/jz4740.h>
+#endif
+
+#ifdef CONFIG_JZ4750
+#include <asm/jz4750.h>
+#endif
+
+#ifdef CONFIG_JZ4750D
+#include <asm/jz4750d.h>
+#endif
+	
+#if defined(CONFIG_JZ4750) || defined(CONFIG_JZ4750D)
+#define JZ4750_NANDBOOT_CFG0 (0x55555500 | (CFG_NAND_BW8*0xff))
+#define JZ4750_NANDBOOT_CFG1 0x55555555	
+#define JZ4750_NANDBOOT_CFG2 ((CFG_NAND_PAGE_SIZE==2048)&0xff0000) | ((CFG_NAND_PAGE_SIZE!=512)&0xff00) | ((CFG_NAND_ROW_CYCLE==3)&0xff)
+#endif
 
 #define RVECENT(f,n) \
    b f; nop
@@ -40,6 +62,28 @@
 	.globl _start
 	.text
 _start:
+#if defined(CONFIG_JZ4740)
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	.word JZ4740_NORBOOT_CFG	/* fetched during NOR Boot */
+#else
+#if defined(CONFIG_NAND_SPL)
+	.word JZ4740_NANDBOOT_CFG	/* fetched during NAND Boot */
+#endif
+#endif
+#endif /* CONFIG_JZ4740 */
+#if defined(CONFIG_JZ4750) || defined(CONFIG_JZ4750D)
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	.word JZ4750_NORBOOT_CFG	/* fetched during NOR Boot */
+#else
+#if defined(CONFIG_NAND_SPL) && !defined(CONFIG_MSC_SPL)
+	/* First three words fetched by CPU during NAND Boot */
+	.word JZ4750_NANDBOOT_CFG0
+	.word JZ4750_NANDBOOT_CFG1
+	.word JZ4750_NANDBOOT_CFG2
+#endif
+#endif
+#endif /* CONFIG_JZ4750 || CONFIG_JZ4750D */
+#if !defined(CONFIG_JzRISC)
 	RVECENT(reset,0)	/* U-boot entry point */
 	RVECENT(reset,1)	/* software reboot */
 #if defined(CONFIG_INCA_IP)
@@ -206,14 +250,61 @@
 	.word   0x00000000
 #endif /* CONFIG_PURPLE */
 	.align 4
+#endif /* CONFIG_JzRISC */
+
 reset:
 
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+
+#ifdef CONFIG_JZ4730
+
+	/* Disable interrupts */
+	la	t0, INTC_IMR
+	li	t1, 0xffffffff
+	sw	t1, 0(t0)
+
+	/*
+	 * Clear SCR.HGP
+	 */
+	la	t0, CPM_SCR
+	lw	t1, 0(t0)
+	ori	t1, 0x8
+	xori	t1, 0x8
+	sw	t1, 0(t0)
+
+	/*
+	 * Set usb port0 as host
+	 */
+	la	t0, HARB_HAPOR
+	lw	t1, 0(t0)
+	ori	t1, HARB_HAPOR_UCHSEL
+	sw	t1, 0(t0)
+
+	/*
+	 * Check reset status
+	 */
+	la	t0, CPM_RSTR
+	lw	t1, 0(t0)
+	andi	t1, 0x4
+	bnez	t1, resume_from_hibernate
+	nop
+#endif /* CONFIG_JZ4730 */
+
+#ifndef CONFIG_NAND_SPL
 	/* Clear watch registers.
 	 */
 	mtc0	zero, CP0_WATCHLO
 	mtc0	zero, CP0_WATCHHI
+#endif
 
 	/* STATUS register */
+#ifdef CONFIG_JzRISC
+	/* 
+	 * CU0=UM=EXL=IE=0, BEV=ERL=1, IP2~7=1
+	 */
+	li	t0, 0x0040FC04
+	mtc0	t0, CP0_STATUS
+#else
 #ifdef  CONFIG_TB0229
 	li	k0, ST0_CU0
 #else
@@ -222,17 +313,30 @@
 	li	k1, ~ST0_IE
 	and	k0, k1
 	mtc0	k0, CP0_STATUS
+#endif
 
 	/* CAUSE register */
+#ifdef CONFIG_JzRISC
+	/* IV=1, use the specical interrupt vector (0x200) */
+	li	t1, 0x00800000
+	mtc0	t1, CP0_CAUSE
+#else
 	mtc0	zero, CP0_CAUSE
+#endif
 
+#ifndef CONFIG_JzRISC
 	/* Init Timer */
 	mtc0	zero, CP0_COUNT
 	mtc0	zero, CP0_COMPARE
+#endif
 
+#endif /* !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL) */
+
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
 	/* CONFIG0 register */
 	li	t0, CONF_CM_UNCACHED
 	mtc0	t0, CP0_CONFIG
+#endif
 
 	/* Initialize GOT pointer.
 	*/
@@ -252,31 +356,75 @@
 	nop
 #endif
 
+/* JzRISC will init external memory in board_init_f,
+   which uses cache as stack and calls into C code. */
+#ifndef CONFIG_JzRISC
 	/* Initialize any external memory.
 	 */
 	la      t9, lowlevel_init
 	jalr    t9
 	nop
+#endif
 
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
 	/* Initialize caches...
 	 */
+#ifdef CONFIG_JzRISC
+	.set	mips32
+	mtc0	zero, CP0_TAGLO
+	mtc0	zero, CP0_TAGHI
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_DCACHE_SIZE
+1:
+	cache	Index_Store_Tag_D, 0(t0)
+	bne	t0, t1, 1b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_ICACHE_SIZE
+2:
+	cache	Index_Store_Tag_I, 0(t0)
+	bne	t0, t1, 2b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	/* Invalidate BTB */
+	mfc0	t0, CP0_CONFIG, 7
+	nop
+	ori	t0, 2
+	mtc0	t0, CP0_CONFIG, 7
+	nop
+
+	.set	mips2
+#else
 	la      t9, mips_cache_reset
 	jalr    t9
 	nop
+#endif
 
 	/* ... and enable them.
 	 */
 	li	t0, CONF_CM_CACHABLE_NONCOHERENT
 	mtc0	t0, CP0_CONFIG
+	nop
 
+#endif /* !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT) */
 
 	/* Set up temporary stack.
 	 */
+#ifndef CONFIG_JzRISC
 	li	a0, CFG_INIT_SP_OFFSET
 	la      t9, mips_cache_lock
 	jalr    t9
 	nop
+#endif
 
+#ifdef CONFIG_NAND_SPL
+	la	sp, 0x80004000
+	la	t9, nand_boot
+	j	t9
+	nop
+#else
 	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
 	la	sp, 0(t0)
 
@@ -300,7 +448,7 @@
 relocate_code:
 	move	sp, a0		/* Set new stack pointer		*/
 
-	li	t0, CFG_MONITOR_BASE
+	li	t0, TEXT_BASE
 	la	t3, in_ram
 	lw	t2, -12(t3)	/* t2 <-- uboot_end_data	*/
 	move	t1, a2
@@ -308,10 +456,10 @@
 	/*
 	 * Fix GOT pointer:
 	 *
-	 * New GOT-PTR = (old GOT-PTR - CFG_MONITOR_BASE) + Destination Address
+	 * New GOT-PTR = (old GOT-PTR - TEXT_BASE) + Destination Address
 	 */
 	move	t6, gp
-	sub	gp, CFG_MONITOR_BASE
+	sub	gp, TEXT_BASE
 	add	gp, a2			/* gp now adjusted		*/
 	sub	t6, gp, t6		/* t6 <-- relocation offset	*/
 
@@ -334,6 +482,35 @@
 
 	/* If caches were enabled, we would have to flush them here.
 	 */
+#ifdef CONFIG_JzRISC
+	/* flush d-cache */
+	.set	mips32
+	li	t0, KSEG0
+	addi	t1, t0, CFG_DCACHE_SIZE
+2:
+	cache	Index_Writeback_Inv_D, 0(t0)
+	bne	t0, t1, 2b
+	addi	t0, CFG_CACHELINE_SIZE
+
+	sync
+
+	/* flush i-cache */
+	li	t0, KSEG0
+	addi	t1, t0, CFG_ICACHE_SIZE
+3:
+	cache	Index_Invalidate_I, 0(t0)
+	bne	t0, t1, 3b
+	addi	t0, CFG_CACHELINE_SIZE
+
+	/* Invalidate BTB */
+	mfc0	t0, CP0_CONFIG, 7
+	nop
+	ori	t0, 2
+	mtc0	t0, CP0_CONFIG, 7
+	nop
+
+	.set	mips0
+#endif
 
 	/* Jump to where we've relocated ourselves.
 	 */
@@ -380,7 +557,9 @@
 
 	.end	relocate_code
 
+#endif /* CONFIG_NAND_SPL */
 
+#if !defined(CONFIG_JzRISC)
 	/* Exception handlers.
 	 */
 romReserved:
@@ -388,3 +567,109 @@
 
 romExcHandle:
 	b romExcHandle
+#endif
+
+#ifdef CONFIG_JZ4730
+
+/* These are the runtime values, modify them according to your platform. */
+#define PLCR1_VAL     0x1b000520
+#define CFCR_VAL      0x0c526220
+
+#define DMCR_VAL0     0x042a3211
+#define DMCR_VAL1     0x05aa3211 /*(DMCR_VAL0|EMC_DMCR_RFSH|EMC_DMCR_MRSET)*/
+
+#define RTCOR_VAL     0x10
+#define RTCSR_VAL     0x83
+
+	/*
+	 * cpu was reset from hibernate mode
+	 */
+resume_from_hibernate:
+	/*
+	 * Init PLL
+	 */
+	la	t0, 0xB0000000	/* CFCR */
+	li	t1, CFCR_VAL
+	sw	t1, 0(t0)
+
+	la	t0, 0xB0000010	/* PLCR1 */
+	li	t1, PLCR1_VAL
+	sw	t1, 0(t0)
+	nop;nop;nop;nop
+
+	/* Init caches */
+	.set	mips32
+	mtc0	zero, CP0_TAGLO
+	mtc0	zero, CP0_TAGHI
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_DCACHE_SIZE
+1:
+	cache	Index_Store_Tag_D, 0(t0)
+	cache	Index_Store_Tag_I, 0(t0)
+	bne	t0, t1, 1b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	/*
+	 * Init SDRAM
+	 */
+	la	t0, 0xB0010070	/* GPALR2 */
+	lw	t1, 0(t0)
+	li	t2, 0x3FFFFFFF
+	and	t1, t2
+	li	t2, 0x40000000
+	or	t1, t2
+	sw	t1, 0(t0)
+
+	la	t0, 0xB0010074	/* GPAUR2 */
+	lw	t1, 0(t0)
+	li	t2, 0xFFFF0000
+	and	t1, t2
+	li	t2, 0x00005555
+	or	t1, t2
+	sw	t1, 0(t0)
+
+	la	t0, 0xB3010000	/* EMC base address */
+
+	li	t1, DMCR_VAL0	/* DMCR */
+	sw	t1, 0x80(t0)
+
+	li	t1, RTCOR_VAL
+	sh	t1, 0x8c(t0)	/* RTCOR */
+
+	li	t1, RTCSR_VAL
+	sh	t1, 0x84(t0)	/* RTCSR */
+
+	/* precharge all chip-selects */
+	ori	t1, t0, 0xa088
+	sb	$0, 0(t1)
+	ori	t1, t0, 0xb088
+	sb	$0, 0(t1)
+
+	/* delay about 200us */
+	li	t1, 0x20000
+1:
+	bnez	t1, 1b
+	sub	t1, 1
+
+	la	t1, DMCR_VAL1	/* DMCR */
+	sw	t1, 0x80(t0)
+
+	/* write sdram mode register for each chip-select */
+	ori	t1, t0, 0xa088
+	sb	$0, 0(t1)
+	ori	t1, t0, 0xb088
+	sb	$0, 0(t1)
+
+	/*
+	 * jump to resume entry point
+	 */
+	la	t0, CPM_SPR
+	lw	t1, 0(t0)
+	li	t0, 0x80000000
+	or	t0, t1
+
+	j	t0
+	nop
+
+#endif /* CONFIG_JZ4730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/drivers/cfi_flash.c u-boot-1.1.6/drivers/cfi_flash.c
--- /develop/source/01boot/u-boot-1.1.6/drivers/cfi_flash.c	2007-10-31 00:43:23.000000000 +0800
+++ u-boot-1.1.6/drivers/cfi_flash.c	2007-03-01 16:31:12.000000000 +0800
@@ -1086,6 +1086,8 @@
 		     info->chipwidth <<= 1) {
 			flash_write_cmd (info, 0, 0, info->cmd_reset);
 			flash_write_cmd (info, 0, FLASH_OFFSET_CFI, FLASH_CMD_CFI);
+			/* wait for Flash data ready */
+			udelay(10);
 			if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
 			    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 1, 'R')
 			    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP + 2, 'Y')) {
diff -urN /develop/source/01boot/u-boot-1.1.6/drivers/cs8900.c u-boot-1.1.6/drivers/cs8900.c
--- /develop/source/01boot/u-boot-1.1.6/drivers/cs8900.c	2007-10-31 00:43:24.000000000 +0800
+++ u-boot-1.1.6/drivers/cs8900.c	2007-08-29 13:59:18.000000000 +0800
@@ -40,6 +40,7 @@
 #include <command.h>
 #include "cs8900.h"
 #include <net.h>
+#include "asm-mips/jz4740.h"
 
 #ifdef CONFIG_DRIVER_CS8900
 
@@ -181,9 +182,19 @@
 	get_reg_init_bus (PP_ChipID);
 }
 
-int eth_init (bd_t * bd)
+void gpio_init_cs8900(void)
 {
+	__gpio_as_func0(60);             //cs4 
+	__gpio_as_func0(61);             //cs4 
+	__gpio_as_func0(62);             //cs4 
+	__gpio_as_irq_high_level(59);    //irq
+	__gpio_disable_pull(59);         //disable pull
+	REG_EMC_SMCR4 |= (1 << 6);       //16bit
+}
 
+int eth_init (bd_t * bd)
+{
+	gpio_init_cs8900();
 	/* verify chip id */
 	if (get_reg_init_bus (PP_ChipID) != 0x630e) {
 		printf ("CS8900 Ethernet chip not found?!\n");
@@ -199,7 +210,7 @@
 	eth_reginit ();
 	return 0;
 }
-
+ 
 /* Get a data block via Ethernet */
 extern int eth_rx (void)
 {
diff -urN /develop/source/01boot/u-boot-1.1.6/drivers/nand/nand_base.c u-boot-1.1.6/drivers/nand/nand_base.c
--- /develop/source/01boot/u-boot-1.1.6/drivers/nand/nand_base.c	2007-10-31 00:43:23.000000000 +0800
+++ u-boot-1.1.6/drivers/nand/nand_base.c	2009-03-05 18:23:35.000000000 +0800
@@ -41,7 +41,7 @@
  *	The AG-AND chips have nice features for speed improvement,
  *	which are not supported yet. Read / program 4 pages in one go.
  *
- * $Id: nand_base.c,v 1.126 2004/12/13 11:22:25 lavinen Exp $
+ * $Id: nand_base.c,v 1.10 2008-07-09 04:49:15 lhhuang Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -88,6 +88,10 @@
 #include <jffs2/jffs2.h>
 #endif
 
+#ifndef CFG_NAND_BADBLOCK_PAGE
+#define CFG_NAND_BADBLOCK_PAGE 0 /* NAND bad block was marked at this page in a block, starting from 0 */
+#endif
+
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_oobinfo nand_oob_8 = {
 	.useecc = MTD_NANDECC_AUTOPLACE,
@@ -102,7 +106,116 @@
 	.eccpos = {0, 1, 2, 3, 6, 7},
 	.oobfree = { {8, 8} }
 };
-
+#if defined(CONFIG_JZ4740)
+static struct nand_oobinfo nand_oob_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 36,
+	.eccpos = {
+		6,  7,  8,  9,  10, 11, 12, 13,
+		14, 15, 16, 17, 18, 19, 20, 21,
+		22, 23, 24, 25, 26, 27, 28, 29,
+		30, 31, 32, 33, 34, 35, 36, 37,
+		38, 39, 40, 41},
+	.oobfree = { {2, 4}, {42, 22} }
+};
+static struct nand_oobinfo nand_oob_128 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 72,
+	.eccpos = {
+		6,  7,  8,  9,  10, 11, 12, 13,
+		14, 15, 16, 17, 18, 19, 20, 21,
+		22, 23, 24, 25, 26, 27, 28, 29,
+		30, 31, 32, 33, 34, 35, 36, 37,
+		38, 39, 40, 41, 42, 43, 44, 45,
+		46, 47, 48, 49, 50, 51, 52, 53,
+		54, 55, 56, 57, 58, 59, 60, 61,
+		62, 63,	64, 65,	66, 67,	68, 69,
+		70, 71,	72, 73,	74, 75, 76, 77},
+	.oobfree = { {2, 4}, {78, 50} }
+};
+#elif defined(CONFIG_JZ4750) ||  defined(CONFIG_JZ4750D)
+#if (CFG_NAND_BCH_BIT == 8)
+static struct nand_oobinfo nand_oob_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 52,
+	.eccpos = {
+		3,  4,  5,  6,  7,  8,  9,  10,
+		11, 12, 13, 14, 15, 16, 17, 18,
+		19, 20, 21, 22, 23, 24, 25, 26,
+		27, 28, 29, 30, 31, 32, 33, 34,
+		35, 36, 37, 38, 39, 40, 41, 42,
+		43, 44, 45, 46, 47, 48, 49, 50,
+		51, 52, 53, 54},
+	.oobfree = {{2, 1}, {55, 9}}
+};
+static struct nand_oobinfo nand_oob_128 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 104,
+	.eccpos = {
+		3,  4,  5,  6,  7,  8,  9,  10,
+		11, 12, 13, 14, 15, 16, 17, 18,
+		19, 20, 21, 22, 23, 24, 25, 26,
+		27, 28, 29, 30, 31, 32, 33, 34,
+		35, 36, 37, 38, 39, 40, 41, 42,
+		43, 44, 45, 46, 47, 48, 49, 50,
+		51, 52, 53, 54, 55, 56, 57, 58,
+		59, 60, 61, 62, 63, 64, 65, 66,
+		67, 68, 69, 70, 71, 72, 73, 74,
+		75, 76, 77, 78,	79, 80,	81, 82,
+		83, 84,	85, 86,	87, 88,	89, 90,
+		91, 92, 93, 94,	95, 96,	97, 98,
+		99, 100, 101, 102, 103,	104, 105,
+		106},
+	.oobfree = {{2, 1}, {107, 21}}
+};
+#else /* CFG_NAND_BCH_BIT == 4 */
+static struct nand_oobinfo nand_oob_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 28,
+	.eccpos = {
+		3,  4,  5,  6,  7,  8,  9,  10,
+		11, 12, 13, 14, 15, 16, 17, 18,
+		19, 20, 21, 22, 23, 24, 25, 26,
+		27, 28, 29, 30},
+	.oobfree = {{2, 1}, {31, 33}}
+};
+static struct nand_oobinfo nand_oob_128 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 56,
+	.eccpos = {
+		3,  4,  5,  6,  7,  8,  9,  10,
+		11, 12, 13, 14, 15, 16, 17, 18,
+		19, 20, 21, 22, 23, 24, 25, 26,
+		27, 28, 29, 30, 31, 32, 33, 34,
+		35, 36, 37, 38, 39, 40, 41, 42,
+		43, 44, 45, 46, 47, 48, 49, 50,
+		51, 52, 53, 54, 55, 56, 57, 58},
+	.oobfree = {{2, 1}, {59, 69}}
+};
+#endif
+#elif defined(CONFIG_JZ4730)
+static struct nand_oobinfo nand_oob_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 24,
+	.eccpos = {
+		4, 5, 6, 7, 8, 9, 10, 11,
+		12, 13,	14, 15,	16, 17,	18, 19,
+		20, 21,	22, 23,	24, 25,	26, 27},
+	.oobfree = { {2, 2}, {28, 36} }
+	};
+static struct nand_oobinfo nand_oob_128 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 48,
+	.eccpos = {
+		4, 5, 6, 7, 8, 9, 10, 11,
+		12, 13,	14, 15,	16, 17,	18, 19,
+		20, 21,	22, 23,	24, 25,	26, 27,
+		28, 29, 30, 31, 32, 33, 34, 35,
+		36, 37, 38, 39, 40, 41, 42, 43,
+		44, 45, 46, 47, 48, 49, 50, 51},
+	.oobfree = { {2, 2}, {52, 12} }
+	};
+#else
 static struct nand_oobinfo nand_oob_64 = {
 	.useecc = MTD_NANDECC_AUTOPLACE,
 	.eccbytes = 24,
@@ -111,7 +224,8 @@
 		48, 49, 50, 51, 52, 53, 54, 55,
 		56, 57, 58, 59, 60, 61, 62, 63},
 	.oobfree = { {2, 38} }
-};
+	};
+#endif
 
 /* This is used for padding purposes in nand_write_oob */
 static u_char ffchars[] = {
@@ -135,6 +249,7 @@
 static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
 static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+static int nand_read_oob_rs (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
 static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
 static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf);
 static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
@@ -151,6 +266,7 @@
 static void nand_sync (struct mtd_info *mtd);
 
 /* Some internal functions */
+static int nand_block_markbad (struct mtd_info *mtd, loff_t ofs);
 static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, u_char *oob_buf,
 		struct nand_oobinfo *oobsel, int mode);
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
@@ -420,6 +536,10 @@
  * @getchip:	0, if the chip is already selected
  *
  * Check, if the block is bad.
+ *
+ * Note by Ingenic: the bad block flag may be stored in ether the 
+ * first page or the last page of the block. So we need to define
+ * "CFG_NAND_BADBLOCK_PAGE" for checking bad block flag.
  */
 static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 {
@@ -439,6 +559,7 @@
 	} else
 		page = (int) ofs;
 
+	page += CFG_NAND_BADBLOCK_PAGE;
 	if (this->options & NAND_BUSWIDTH_16) {
 		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
 		bad = cpu_to_le16(this->read_word(mtd));
@@ -467,7 +588,11 @@
  *
  * This is the default implementation, which can be overridden by
  * a hardware specific driver.
-*/
+ *
+ * Note by Ingenic: the bad block flag may be stored in ether the first
+ * page or the last page of the block.So we need to define
+ * "CFG_NAND_BADBLOCK_PAGE" for marking bad block flag.
+ */
 static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
 	struct nand_chip *this = mtd->priv;
@@ -484,7 +609,7 @@
 		return nand_update_bbt (mtd, ofs);
 
 	/* We write two bytes, so we dont have to mess with 16 bit access */
-	ofs += mtd->oobsize + (this->badblockpos & ~0x01);
+	ofs += mtd->oobsize + CFG_NAND_BADBLOCK_PAGE * mtd->oobblock + (this->badblockpos & ~0x01);
 	return nand_write_oob (mtd, ofs , 2, &retlen, buf);
 }
 
@@ -891,7 +1016,8 @@
 	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
 {
 	int 	i, status;
-	u_char	ecc_code[32];
+//	u_char	ecc_code[32];
+	u_char	ecc_code[104];
 	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
 	uint  	*oob_config = oobsel->eccpos;
 	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
@@ -907,7 +1033,7 @@
 	switch (eccmode) {
 	/* No ecc, write all */
 	case NAND_ECC_NONE:
-		printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
+		//printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
 		this->write_buf(mtd, this->data_poi, mtd->oobblock);
 		break;
 
@@ -921,6 +1047,47 @@
 		}
 		this->write_buf(mtd, this->data_poi, mtd->oobblock);
 		break;
+	case NAND_ECC_HW7_512:
+	case NAND_ECC_HW13_512:
+		eccbytes = this->eccbytes;
+		for (; eccsteps; eccsteps--) {
+			/* enable hardware ecc logic for write */
+			this->enable_hwecc(mtd, NAND_ECC_WRITE);
+			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
+			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
+			for (i = 0; i < eccbytes; i++, eccidx++)
+				oob_buf[oob_config[eccidx]] = ecc_code[i];
+
+			/* If the hardware ecc provides syndromes then
+			 * the ecc code must be written immidiately after
+			 * the data bytes (words) */
+			if (this->options & NAND_HWECC_SYNDROME)
+				this->write_buf(mtd, ecc_code, eccbytes);
+			datidx += this->eccsize;
+		}
+		break;
+#if 0
+	case NAND_ECC_HW9_512:
+		this->write_buf(mtd, this->data_poi, mtd->oobblock);
+		eccbytes = this->eccbytes;
+		for (; eccsteps; eccsteps--) {
+
+			/* enable hardware ecc logic for write */
+			this->enable_hwecc(mtd, NAND_ECC_WRITE);
+			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
+			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
+			for (i = 0; i < eccbytes; i++, eccidx++)
+				oob_buf[oob_config[eccidx]] = ecc_code[i];
+
+			/* If the hardware ecc provides syndromes then
+			 * the ecc code must be written immidiately after
+			 * the data bytes (words) */
+			if (this->options & NAND_HWECC_SYNDROME)
+				this->write_buf(mtd, ecc_code, eccbytes);
+			datidx += this->eccsize;
+		}
+		break;
+#endif	
 	default:
 		eccbytes = this->eccbytes;
 		for (; eccsteps; eccsteps--) {
@@ -930,6 +1097,9 @@
 			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
 			for (i = 0; i < eccbytes; i++, eccidx++)
 				oob_buf[oob_config[eccidx]] = ecc_code[i];
+			oob_buf[2]=0;
+			oob_buf[3]=0;
+			oob_buf[4]=0;
 			/* If the hardware ecc provides syndromes then
 			 * the ecc code must be written immidiately after
 			 * the data bytes (words) */
@@ -991,7 +1161,7 @@
 	int 	i, j, datidx = 0, oobofs = 0, res = -EIO;
 	int	eccsteps = this->eccsteps;
 	int	hweccbytes;
-	u_char 	oobdata[64];
+	u_char 	oobdata[128];
 
 	hweccbytes = (this->options & NAND_HWECC_SYNDROME) ? (oobsel->eccbytes / eccsteps) : 0;
 
@@ -1105,23 +1275,25 @@
  *
  * NAND read with ECC
  */
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
+
+int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			     size_t * retlen, u_char * buf, u_char * oob_buf, 
+			     struct nand_oobinfo *oobsel)
 {
 	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
-	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
+	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0, nand_read_len = 0;
 	struct nand_chip *this = mtd->priv;
 	u_char *data_poi, *oob_data = oob_buf;
-	u_char ecc_calc[32];
-	u_char ecc_code[32];
-	int eccmode, eccsteps;
-	unsigned *oob_config;
-	int	datidx;
+	u_char ecc_calc[104];
+	u_char ecc_code[104]; /* increased from 36 to 52 for 8-bit bch */
+        int eccmode, eccsteps, datidx;
+	uint	*oob_config;
 	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
 	int	eccbytes;
 	int	compareecc = 1;
 	int	oobreadlen;
-
+	short   correct_flag = 1;
+	//int     bad_blk_cnt = 0;
 
 	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
@@ -1133,12 +1305,12 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	nand_get_device (this, mtd ,FL_READING);
+		nand_get_device (this, mtd, FL_READING);
 
 	/* use userspace supplied oobinfo, if zero */
 	if (oobsel == NULL)
 		oobsel = &mtd->oobinfo;
-
+	
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
 		oobsel = this->autooob;
@@ -1153,7 +1325,7 @@
 	/* First we calculate the starting page */
 	realpage = (int) (from >> this->page_shift);
 	page = realpage & this->pagemask;
-
+	
 	/* Get raw starting column */
 	col = from & (mtd->oobblock - 1);
 
@@ -1165,74 +1337,113 @@
 		compareecc = 0;
 
 	oobreadlen = mtd->oobsize;
-	if (this->options & NAND_HWECC_SYNDROME)
+
+	if (this->options & NAND_HWECC_SYNDROME) 
 		oobreadlen -= oobsel->eccbytes;
 
 	/* Loop until all data read */
 	while (read < len) {
-
+		
 		int aligned = (!col && (len - read) >= end);
-		/*
+		/* 
 		 * If the read is not page aligned, we have to read into data buffer
 		 * due to ecc, else we read into return buffer direct
 		 */
 		if (aligned)
 			data_poi = &buf[read];
-		else
+		else 
 			data_poi = this->data_buf;
-
-		/* Check, if we have this page in the buffer
+		/* Check, if we have this page in the buffer 
 		 *
 		 * FIXME: Make it work when we must provide oob data too,
 		 * check the usage of data_buf oob field
 		 */
+		
 		if (realpage == this->pagebuf && !oob_buf) {
 			/* aligned read ? */
 			if (aligned)
 				memcpy (data_poi, this->data_buf, end);
 			goto readdata;
 		}
+		/* get oob area, if we have no oob buffer from fs-driver */
+
+		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE)
+			oob_data = &this->data_buf[end];
+
+		if(NAND_ECC_HW9_512 == eccmode){
+			size_t oob_retlen;
+
+			nand_read_oob_rs(mtd, nand_read_len+from, mtd->oobsize, &oob_retlen, oob_data);
+
+#if 0
+
+			if((unsigned int)(nand_read_len+from)%mtd->erasesize == 0 && this->block_bad(mtd, page, 0)){
+				printk("Block %d is bad.\n",(unsigned int)(nand_read_len+from)/mtd->erasesize);
+				nand_read_len += mtd->erasesize;
+				realpage += mtd->erasesize / mtd->oobblock;
+				bad_blk_cnt++;
+				continue;
+			}
+
+			for( j = 0; j < oobsel->oobfree[0][1]; j++)
+				if(oob_data[2+j] != 0xff)
+					break;
+			if( j == oobsel->oobfree[0][1] )
+				correct_flag = 0;
+#endif
+
+			for (j = 0; j < oobsel->eccbytes; j++)
+				if (oob_data[oobsel->eccpos[j]] != 0xff)
+					break;
+			if(j == oobsel->eccbytes)
+				correct_flag = 0;
+		}
 
+		page = realpage & this->pagemask;
+//		printf("---------read page=0x%x\n",page);
 		/* Check, if we must send the read command */
 		if (sndcmd) {
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
 			sndcmd = 0;
-		}
-
+		}	
+#if 0
 		/* get oob area, if we have no oob buffer from fs-driver */
-		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
-			oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
+		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE)
 			oob_data = &this->data_buf[end];
-
+#endif
 		eccsteps = this->eccsteps;
-
 		switch (eccmode) {
 		case NAND_ECC_NONE: {	/* No ECC, Read in a page */
-/* XXX U-BOOT XXX */
 #if 0
 			static unsigned long lastwhinge = 0;
 			if ((lastwhinge / HZ) != (jiffies / HZ)) {
-				printk (KERN_WARNING "Reading data from NAND FLASH without ECC is not recommended\n");
+				//printk (KERN_WARNING "Reading data from NAND FLASH without ECC is not recommended\n");
 				lastwhinge = jiffies;
 			}
-#else
-			puts("Reading data from NAND FLASH without ECC is not recommended\n");
 #endif
 			this->read_buf(mtd, data_poi, end);
 			break;
 		}
-
+			
 		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
 			this->read_buf(mtd, data_poi, end);
-			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
+			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc) 
 				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
 			break;
+			
+		case NAND_ECC_HW9_512:
+			break;	
+
+		case NAND_ECC_HW7_512:
+		case NAND_ECC_HW13_512:
+			this->read_buf(mtd, data_poi, mtd->oobblock);
+			//	this->read_buf(mtd, oob_data, mtd->oobsize);
+			break;	
 
 		default:
 			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
 				this->enable_hwecc(mtd, NAND_ECC_READ);
 				this->read_buf(mtd, &data_poi[datidx], ecc);
-
 				/* HW ecc with syndrome calculation must read the
 				 * syndrome from flash immidiately after the data */
 				if (!compareecc) {
@@ -1243,59 +1454,117 @@
 					/* We calc error correction directly, it checks the hw
 					 * generator for an error, reads back the syndrome and
 					 * does the error correction on the fly */
-					if (this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]) == -1) {
-						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
+					ecc_status = this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]);
+					if ((ecc_status == -1) || (ecc_status > 0xff)) {
+						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " 
 							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
 						ecc_failed++;
 					}
 				} else {
 					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
-				}
+				}	
 			}
-			break;
+			
+			break;						
 		}
-
 		/* read oobdata */
-		this->read_buf(mtd, &oob_data[mtd->oobsize - oobreadlen], oobreadlen);
+		if(NAND_ECC_HW9_512 != eccmode)
+			this->read_buf(mtd, &oob_data[mtd->oobsize - oobreadlen], oobreadlen);
 
 		/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
 		if (!compareecc)
-			goto readoob;
-
+			goto readoob;	
 		/* Pick the ECC bytes out of the oob data */
-		for (j = 0; j < oobsel->eccbytes; j++)
+		for (j = 0; j < oobsel->eccbytes; j++) {
 			ecc_code[j] = oob_data[oob_config[j]];
+//			printf("ecc[%d]=0x%x\n",j,ecc_code[j]);
+		}
 
-		/* correct data, if neccecary */
-		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
-			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
-
-			/* Get next chunk of ecc bytes */
-			j += eccbytes;
-
-			/* Check, if we have a fs supplied oob-buffer,
-			 * This is the legacy mode. Used by YAFFS1
-			 * Should go away some day
-			 */
-			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
-				int *p = (int *)(&oob_data[mtd->oobsize]);
-				p[i] = ecc_status;
+
+		if(NAND_ECC_HW9_512 == eccmode){
+			for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
+				if(correct_flag)
+					this->enable_hwecc(mtd, NAND_ECC_READ);
+				this->read_buf(mtd, &data_poi[datidx], ecc);
+
+				if(correct_flag)
+					ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], NULL);
+				else
+					ecc_status = 0;
+
+				/* Get next chunk of ecc bytes */
+				j += eccbytes;
+			
+				/* Check, if we have a fs supplied oob-buffer, 
+				 * This is the legacy mode. Used by YAFFS1
+				 * Should go away some day
+				 */
+				if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) { 
+					printk("enter the yaffs1 legacy\n");
+					int *p = (int *)(&oob_data[mtd->oobsize]);
+					p[i] = ecc_status;
+				}
+			
+				if ((ecc_status == -1) || (ecc_status > 0xff)) {	
+					DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
+					ecc_failed++;
+				}
 			}
+		} else if ((NAND_ECC_HW13_512 == eccmode) || (NAND_ECC_HW7_512 == eccmode)) {
+			/* correct data, if neccecary */
+			for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
+				this->enable_hwecc(mtd, NAND_ECC_READ);
+				ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
+
+				/* Get next chunk of ecc bytes */
+				j += eccbytes;
 
-			if (ecc_status == -1) {
-				DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
-				ecc_failed++;
+				/* Check, if we have a fs supplied oob-buffer, 
+				 * This is the legacy mode. Used by YAFFS1
+				 * Should go away some day
+				 */
+				if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) { 
+					int *p = (int *)(&oob_data[mtd->oobsize]);
+					p[i] = ecc_status;
+				}
+			
+				if ((ecc_status == -1) || (ecc_status > 0xff)) {	
+					DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
+					ecc_failed++;
+				}
+			}
+		} else {
+			/* correct data, if neccecary */
+			for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
+				ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
+			
+				/* Get next chunk of ecc bytes */
+				j += eccbytes;
+			
+				/* Check, if we have a fs supplied oob-buffer, 
+				 * This is the legacy mode. Used by YAFFS1
+				 * Should go away some day
+				 */
+				if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) { 
+					int *p = (int *)(&oob_data[mtd->oobsize]);
+					p[i] = ecc_status;
+				}
+			
+				if ((ecc_status == -1) || (ecc_status > 0xff)) {	
+					DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
+					ecc_failed++;
+				}
 			}
 		}
 
-	readoob:
+	readoob:	
 		/* check, if we have a fs supplied oob-buffer */
 		if (oob_buf) {
 			/* without autoplace. Legacy mode used by YAFFS1 */
 			switch(oobsel->useecc) {
 			case MTD_NANDECC_AUTOPLACE:
-			case MTD_NANDECC_AUTOPL_USR:
 				/* Walk through the autoplace chunks */
+				mtd->oobavail = mtd->oobsize-(oobsel->eccbytes +2);
 				for (i = 0, j = 0; j < mtd->oobavail; i++) {
 					int from = oobsel->oobfree[i][0];
 					int num = oobsel->oobfree[i][1];
@@ -1313,47 +1582,48 @@
 		}
 	readdata:
 		/* Partial page read, transfer data into fs buffer */
-		if (!aligned) {
+		if (!aligned) { 
 			for (j = col; j < end && read < len; j++)
 				buf[read++] = data_poi[j];
-			this->pagebuf = realpage;
-		} else
+			this->pagebuf = realpage;	
+		} else{
 			read += mtd->oobblock;
+			nand_read_len += mtd->oobblock;
+			}
 
-		/* Apply delay or wait for ready/busy pin
+		/* Apply delay or wait for ready/busy pin 
 		 * Do this before the AUTOINCR check, so no problems
 		 * arise if a chip which does auto increment
 		 * is marked as NOAUTOINCR by the board driver.
 		*/
-		if (!this->dev_ready)
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
 			while (!this->dev_ready(mtd));
-
+			
 		if (read == len)
-			break;
+			break;	
 
 		/* For subsequent reads align to page boundary. */
 		col = 0;
 		/* Increment page address */
 		realpage++;
 
-		page = realpage & this->pagemask;
+//		page = realpage & this->pagemask;
 		/* Check, if we cross a chip boundary */
 		if (!page) {
 			chipnr++;
 			this->select_chip(mtd, -1);
 			this->select_chip(mtd, chipnr);
 		}
-		/* Check, if the chip supports auto page increment
-		 * or if we have hit a block boundary.
-		*/
+		/* Check, if the chip supports auto page increment 
+		 * or if we have hit a block boundary. 
+		*/ 
 		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
-			sndcmd = 1;
+			sndcmd = 1;				
 	}
-
 	/* Deselect and wake up anyone waiting on the device */
-	nand_release_device(mtd);
+		nand_release_device(mtd);
 
 	/*
 	 * Return success, if no ECC failures, else -EBADMSG
@@ -1364,6 +1634,96 @@
 	return ecc_failed ? -EBADMSG : 0;
 }
 
+static int nand_read_oob_rs (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	int i, col, page, chipnr;
+	struct nand_chip *this = mtd->priv;
+	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+
+	/* Shift to get page */
+	page = (int)(from >> this->page_shift);
+	chipnr = (int)(from >> this->chip_shift);
+	
+	/* Mask to get column */
+	col = from & (mtd->oobsize - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: Attempt read beyond end of device\n");
+		*retlen = 0;
+		return -EINVAL;
+	}
+#if 0
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd , FL_READING);
+
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+#endif
+	/* Send the read command */
+	this->cmdfunc (mtd, NAND_CMD_READOOB, col, page & this->pagemask);
+	/* 
+	 * Read the data, if we read more than one page
+	 * oob data, let the device transfer the data !
+	 */
+	i = 0;
+	while (i < len) {
+		int thislen = mtd->oobsize - col;
+		thislen = min_t(int, thislen, len);
+		this->read_buf(mtd, &buf[i], thislen);
+		i += thislen;
+		
+		/* Apply delay or wait for ready/busy pin 
+		 * Do this before the AUTOINCR check, so no problems
+		 * arise if a chip which does auto increment
+		 * is marked as NOAUTOINCR by the board driver.
+		*/
+		if (!this->dev_ready) 
+			udelay (this->chip_delay);
+		else
+			while (!this->dev_ready(mtd));
+//			nand_wait_ready(mtd);
+
+		/* Read more ? */
+		if (i < len) {
+			page++;
+			col = 0;
+
+			/* Check, if we cross a chip boundary */
+			if (!(page & this->pagemask)) {
+				chipnr++;
+				this->select_chip(mtd, -1);
+				this->select_chip(mtd, chipnr);
+			}
+				
+			/* Check, if the chip supports auto page increment 
+			 * or if we have hit a block boundary. 
+			*/ 
+			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
+				/* For subsequent page reads set offset to 0 */
+			        this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
+			}
+		}
+	}
+
+	/* Deselect and wake up anyone waiting on the device */
+//	nand_release_device(mtd);
+
+	/* De-select the NAND device */
+//	this->select_chip(mtd, -1);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+
+
 /**
  * nand_read_oob - [MTD Interface] NAND read out-of-band
  * @mtd:	MTD device structure
@@ -1612,7 +1972,7 @@
 static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
 			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
 {
-	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
+	int startpage, page, ret = -EIO, oob = 0, written = 0, written_len=0, chipnr;
 	int autoplace = 0, numpages, totalpages;
 	struct nand_chip *this = mtd->priv;
 	u_char *oobbuf, *bufstart;
@@ -1673,25 +2033,48 @@
 	numpages = min (ppblock - (startpage  & (ppblock - 1)), totalpages);
 	oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, autoplace, numpages);
 	bufstart = (u_char *)buf;
-
+	
+	
 	/* Loop until all data is written */
 	while (written < len) {
-
-		this->data_poi = (u_char*) &buf[written];
+#if 0
+		int i;
+		for(i=0;i<64;i++){
+			if(i%16==0)
+				printk("\n");
+			printk(" %02x ",oobbuf[i]);
+		}
+		printk("\n");
+#endif
+#if 0
+		/* Bad blocks management */
+		if ((written_len + (int)to)% mtd->erasesize == 0 && nand_block_bad(mtd, page, 0)){
+			printk("Skipping bad block at %x!\n ",(written_len +(int)to));
+			written_len += mtd->erasesize;
+			page += ppblock;
+			continue;
+		}
+#endif
+		
 		/* Write one page. If this is the last page to write
 		 * or the last page in this block, then use the
 		 * real pageprogram command, else select cached programming
 		 * if supported by the chip.
 		 */
+		this->data_poi = (u_char*) &buf[written];
 		ret = nand_write_page (mtd, this, page, &oobbuf[oob], oobsel, (--numpages > 0));
+
+		/*If fail, mark the bad block flag*/
 		if (ret) {
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: write_page failed %d\n", ret);
+			nand_block_markbad (mtd, written_len + to);
 			goto out;
 		}
 		/* Next oob page */
 		oob += mtd->oobsize;
 		/* Update written bytes count */
 		written += mtd->oobblock;
+		written_len += mtd->oobblock;
 		if (written == len)
 			goto cmp;
 
@@ -1746,7 +2129,6 @@
 out:
 	/* Deselect and wake up anyone waiting on the device */
 	nand_release_device(mtd);
-
 	return ret;
 }
 
@@ -2149,7 +2531,8 @@
 	while (len) {
 #ifndef NAND_ALLOW_ERASE_ALL
 		/* Check if we have a bad block, we do not erase bad blocks ! */
-		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
+		if (nand_block_checkbad(mtd, ((loff_t)(page + CFG_NAND_BADBLOCK_PAGE)) << this->page_shift, 0, allowbbt)) {
+
 			printk (KERN_WARNING "nand_erase: attempt to erase a bad block at page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			goto erase_exit;
@@ -2164,11 +2547,12 @@
 
 		status = this->waitfunc (mtd, this, FL_ERASING);
 
-		/* See if block erase succeeded */
+		/* See if block erase succeeded, if fail, mark the bad block flag */
 		if (status & 0x01) {
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: " "Failed erase, page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = (page << this->page_shift);
+			nand_block_markbad (mtd, instr->addr);
 			goto erase_exit;
 		}
 
@@ -2323,10 +2707,14 @@
 		if (nand_dev_id != nand_flash_ids[i].id)
 			continue;
 
+                /* Support nand larger than 2GB by changing its size to 2GB */
+		if (nand_flash_ids[i].chipsize > 2048)
+			nand_flash_ids[i].chipsize = 2048;
+
 		if (!mtd->name) mtd->name = nand_flash_ids[i].name;
 		this->chipsize = nand_flash_ids[i].chipsize << 20;
 
-		/* New devices have all the information in additional id bytes */
+ 		/* New devices have all the information in additional id bytes */
 		if (!nand_flash_ids[i].pagesize) {
 			int extid;
 			/* The 3rd id byte contains non relevant data ATM */
@@ -2337,7 +2725,7 @@
 			mtd->oobblock = 1024 << (extid & 0x3);
 			extid >>= 2;
 			/* Calc oobsize */
-			mtd->oobsize = (8 << (extid & 0x03)) * (mtd->oobblock / 512);
+			mtd->oobsize = (8 << (extid & 0x01)) * (mtd->oobblock / 512);
 			extid >>= 2;
 			/* Calc blocksize. Blocksize is multiples of 64KiB */
 			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
@@ -2350,6 +2738,7 @@
 			 * device id table */
 			mtd->erasesize = nand_flash_ids[i].erasesize;
 			mtd->oobblock = nand_flash_ids[i].pagesize;
+			
 			mtd->oobsize = mtd->oobblock / 32;
 			busw = nand_flash_ids[i].options & NAND_BUSWIDTH_16;
 		}
@@ -2459,6 +2848,8 @@
 	/* Preset the internal oob buffer */
 	memset(this->oob_buf, 0xff, mtd->oobsize << (this->phys_erase_shift - this->page_shift));
 
+	//printf("this->chip_shift=%d this->chipsize=0x%x mtd->size=0x%x\n",this->chip_shift,this->chipsize,mtd->size);
+
 	/* If no default placement scheme is given, select an
 	 * appropriate one */
 	if (!this->autooob) {
@@ -2474,6 +2865,9 @@
 		case 64:
 			this->autooob = &nand_oob_64;
 			break;
+		case 128:
+			this->autooob = &nand_oob_128;
+			break;
 		default:
 			printk (KERN_WARNING "No oob scheme defined for oobsize %d\n",
 				mtd->oobsize);
@@ -2522,11 +2916,22 @@
 			this->eccsize = 512; /* set eccsize to 512 */
 		break;
 
+	case NAND_ECC_HW9_512:
+	case NAND_ECC_HW7_512:
+	case NAND_ECC_HW13_512:
+		if (mtd->oobblock == 256) {
+			printk (KERN_WARNING "512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC \n");
+			this->eccmode = NAND_ECC_SOFT;
+			this->calculate_ecc = nand_calculate_ecc;
+			this->correct_data = nand_correct_data;
+		} else 
+			this->eccsize = 512; /* set eccsize to 512 */
+		break;
 	case NAND_ECC_HW3_256:
 		break;
 
 	case NAND_ECC_NONE:
-		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
+		//printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
 		this->eccmode = NAND_ECC_NONE;
 		break;
 
@@ -2544,6 +2949,15 @@
 	 * calculation step
 	*/
 	switch (this->eccmode) {
+	case NAND_ECC_HW9_512:
+		this->eccbytes = 9;
+		break;
+	case NAND_ECC_HW7_512:
+		this->eccbytes = 7;
+		break;
+	case NAND_ECC_HW13_512:
+		this->eccbytes = 13;
+		break;
 	case NAND_ECC_HW12_2048:
 		this->eccbytes += 4;
 	case NAND_ECC_HW8_512:
@@ -2552,12 +2966,12 @@
 		this->eccbytes += 3;
 	case NAND_ECC_HW3_512:
 	case NAND_ECC_HW3_256:
-		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
-			break;
-		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
-/*		BUG();	*/
+		break;
 	}
 
+	if (!(this->calculate_ecc && this->correct_data && this->enable_hwecc))
+		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
+
 	mtd->eccsize = this->eccsize;
 
 	/* Set the number of read / write steps for one page to ensure ECC generation */
@@ -2568,6 +2982,9 @@
 	case NAND_ECC_HW3_512:
 	case NAND_ECC_HW6_512:
 	case NAND_ECC_HW8_512:
+	case NAND_ECC_HW9_512:
+	case NAND_ECC_HW7_512:
+	case NAND_ECC_HW13_512:
 		this->eccsteps = mtd->oobblock / 512;
 		break;
 	case NAND_ECC_HW3_256:
@@ -2624,6 +3041,16 @@
 	mtd->block_isbad = nand_block_isbad;
 	mtd->block_markbad = nand_block_markbad;
 
+        /* adjust autooob.eccpos[] according to CFG_NAND_ECC_POS */
+#if defined(CFG_NAND_ECC_POS)
+	for (i = 0; i < this->autooob->eccbytes; i++) {
+		this->autooob->eccpos[i] = CFG_NAND_ECC_POS + i;
+	}
+	this->autooob->oobfree[0][1] = CFG_NAND_ECC_POS - 2;
+	this->autooob->oobfree[1][0] = CFG_NAND_ECC_POS + this->autooob->eccbytes;
+	this->autooob->oobfree[1][1] = mtd->oobsize - this->autooob->oobfree[1][0];
+#endif
+
 	/* and make the autooob the default one */
 	memcpy(&mtd->oobinfo, this->autooob, sizeof(mtd->oobinfo));
 /* XXX U-BOOT XXX */
@@ -2631,7 +3058,8 @@
 	mtd->owner = THIS_MODULE;
 #endif
 	/* Build bad block table */
-	return this->scan_bbt (mtd);
+//	return this->scan_bbt (mtd);
+	return 0; /* scan_bbt is time consuming, ingnore it. */
 }
 
 /**
diff -urN /develop/source/01boot/u-boot-1.1.6/drivers/nand/nand_bbt.c u-boot-1.1.6/drivers/nand/nand_bbt.c
--- /develop/source/01boot/u-boot-1.1.6/drivers/nand/nand_bbt.c	2007-10-31 00:43:23.000000000 +0800
+++ u-boot-1.1.6/drivers/nand/nand_bbt.c	2008-03-19 17:49:27.000000000 +0800
@@ -6,7 +6,7 @@
  *
  *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
  *
- * $Id: nand_bbt.c,v 1.28 2004/11/13 10:19:09 gleixner Exp $
+ * $Id: nand_bbt.c,v 1.4 2008-03-19 09:48:30 zyliu Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -63,6 +63,9 @@
 
 #include <asm/errno.h>
 
+#ifndef CFG_NAND_BADBLOCK_PAGE
+#define CFG_NAND_BADBLOCK_PAGE 0 /* NAND bad block was marked at this page in a block, starting from 0 */
+#endif
 /**
  * check_pattern - [GENERIC] check if a pattern is in the buffer
  * @buf:	the buffer to search
@@ -252,6 +255,10 @@
  *
  * Create a bad block table by scanning the device
  * for the given good/bad block identify pattern
+ *
+ * Note by Ingenic: the bad block flag may be stored in ether the 
+ * first page or the last page of the block. So we check both the
+ * first page and the last page of the block here.
  */
 static void create_bbt (struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)
 {
@@ -292,7 +299,8 @@
 	}
 
 	for (i = startblock; i < numblocks;) {
-		nand_read_raw (mtd, buf, from, readlen, ooblen);
+		/* Check the bad mark page of the block */
+		nand_read_raw (mtd, buf, from + CFG_NAND_BADBLOCK_PAGE * mtd->oobblock, readlen, ooblen);
 		for (j = 0; j < len; j++) {
 			if (check_pattern (&buf[j * scanlen], scanlen, mtd->oobblock, bd)) {
 				this->bbt[i >> 3] |= 0x03 << (i & 0x6);
@@ -367,6 +375,15 @@
 				}
 				break;
 			}
+			/* Read last page */
+			nand_read_raw (mtd, buf, (actblock << this->bbt_erase_shift) + (mtd->erasesize - mtd->oobblock), mtd->oobblock, mtd->oobsize);
+			if (!check_pattern(buf, scanlen, mtd->oobblock, td)) {
+				td->pages[i] = actblock << (this->bbt_erase_shift - this->page_shift);
+				if (td->options & NAND_BBT_VERSION) {
+					td->version[i] = buf[mtd->oobblock + td->veroffs];
+				}
+				break;
+			}
 		}
 		startblock += this->chipsize >> this->bbt_erase_shift;
 	}
diff -urN /develop/source/01boot/u-boot-1.1.6/drivers/nand/nand_ids.c u-boot-1.1.6/drivers/nand/nand_ids.c
--- /develop/source/01boot/u-boot-1.1.6/drivers/nand/nand_ids.c	2007-10-31 00:43:23.000000000 +0800
+++ u-boot-1.1.6/drivers/nand/nand_ids.c	2008-12-11 22:41:49.000000000 +0800
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
   *
- * $Id: nand_ids.c,v 1.10 2004/05/26 13:40:12 gleixner Exp $
+ * $Id: nand_ids.c,v 1.3 2008-04-24 03:17:15 zyliu Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -35,7 +35,10 @@
 	{"NAND 1MiB 3,3V 8-bit", 	0xe8, 256, 1, 0x1000, 0},
 	{"NAND 1MiB 3,3V 8-bit", 	0xec, 256, 1, 0x1000, 0},
 	{"NAND 2MiB 3,3V 8-bit", 	0xea, 256, 2, 0x1000, 0},
-	{"NAND 4MiB 3,3V 8-bit", 	0xd5, 512, 4, 0x2000, 0},
+
+	/*Next Chip ID is conflict with "NAND 2GiB 3,3V 8-bit", omit the chip*/
+	/*{"NAND 4MiB 3,3V 8-bit", 	0xd5, 512, 4, 0x2000, 0},*/
+
 	{"NAND 4MiB 3,3V 8-bit", 	0xe3, 512, 4, 0x2000, 0},
 	{"NAND 4MiB 3,3V 8-bit", 	0xe5, 512, 4, 0x2000, 0},
 	{"NAND 8MiB 3,3V 8-bit", 	0xd6, 512, 8, 0x2000, 0},
@@ -67,7 +70,7 @@
 
 	{"NAND 256MiB 3,3V 8-bit", 	0x71, 512, 256, 0x4000, 0},
 
-	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0},
+/*	{"NAND 512MiB 3,3V 8-bit", 	0xDC, 512, 512, 0x4000, 0}, */
 
 	/* These are the new chips with large page size. The pagesize
 	* and the erasesize is determined from the extended id bytes
@@ -102,6 +105,9 @@
 	{"NAND 2GiB 1,8V 16-bit", 	0xB5, 0, 2048, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
 	{"NAND 2GiB 3,3V 16-bit", 	0xC5, 0, 2048, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_BUSWIDTH_16 | NAND_NO_AUTOINCR},
 
+	/* 32 Gigabit */
+	{"NAND 4GiB 3,3V 8-bit",	0xD7, 0, 4096, 0, NAND_SAMSUNG_LP_OPTIONS | NAND_NO_AUTOINCR},
+
 	/* Renesas AND 1 Gigabit. Those chips do not support extended id and have a strange page/block layout !
 	 * The chosen minimum erasesize is 4 * 2 * 2048 = 16384 Byte, as those chips have an array of 4 page planes
 	 * 1 block = 2 pages, but due to plane arrangement the blocks 0-3 consists of page 0 + 4,1 + 5, 2 + 6, 3 + 7
@@ -123,6 +129,9 @@
 	{NAND_MFR_NATIONAL, "National"},
 	{NAND_MFR_RENESAS, "Renesas"},
 	{NAND_MFR_STMICRO, "ST Micro"},
+	{NAND_MFR_HYNIX, "Hynix"},
+	{NAND_MFR_MICRON, "Micron"},
+	{NAND_MFR_AMD, "AMD"},
 	{0x0, "Unknown"}
 };
 #endif
diff -urN /develop/source/01boot/u-boot-1.1.6/drivers/nand/nand_util.c u-boot-1.1.6/drivers/nand/nand_util.c
--- /develop/source/01boot/u-boot-1.1.6/drivers/nand/nand_util.c	2007-10-31 00:43:23.000000000 +0800
+++ u-boot-1.1.6/drivers/nand/nand_util.c	2008-11-25 01:54:18.000000000 +0800
@@ -315,7 +315,8 @@
 	/* make sure device page sizes are valid */
 	if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
 	    && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
-	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
+	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)
+	    && !(meminfo->oobsize == 128 && meminfo->oobblock == 4096)) {
 		printf("Unknown flash (not normal NAND)\n");
 		return -1;
 	}
@@ -470,7 +471,10 @@
 		if (result != 0) {
 			printf("writing NAND page at offset 0x%lx failed\n",
 			       mtdoffset);
-			goto restoreoob;
+			buffer -= mtdoffset - blockstart;
+			blockstart += meminfo->erasesize;
+			mtdoffset = blockstart;
+			continue;
 		}
 		imglen -= readlen;
 
@@ -520,6 +524,7 @@
  * @return		0 in case of success
  *
  */
+
 int nand_read_opts(nand_info_t *meminfo, const nand_read_options_t *opts)
 {
 	int imglen = opts->length;
@@ -536,7 +541,8 @@
 	/* make sure device page sizes are valid */
 	if (!(meminfo->oobsize == 16 && meminfo->oobblock == 512)
 	    && !(meminfo->oobsize == 8 && meminfo->oobblock == 256)
-	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)) {
+	    && !(meminfo->oobsize == 64 && meminfo->oobblock == 2048)
+	    && !(meminfo->oobsize == 128 && meminfo->oobblock == 4096)) {
 		printf("Unknown flash (not normal NAND)\n");
 		return -1;
 	}
diff -urN /develop/source/01boot/u-boot-1.1.6/examples/mips.lds u-boot-1.1.6/examples/mips.lds
--- /develop/source/01boot/u-boot-1.1.6/examples/mips.lds	2007-10-31 00:43:25.000000000 +0800
+++ u-boot-1.1.6/examples/mips.lds	2007-03-01 16:31:13.000000000 +0800
@@ -21,10 +21,8 @@
  * MA 02111-1307 USA
  */
 
-/*
-OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-bigmips")
-*/
-OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
 OUTPUT_ARCH(mips)
 SECTIONS
 {
diff -urN /develop/source/01boot/u-boot-1.1.6/fs/fat/fat.c u-boot-1.1.6/fs/fat/fat.c
--- /develop/source/01boot/u-boot-1.1.6/fs/fat/fat.c	2007-10-31 00:43:59.000000000 +0800
+++ u-boot-1.1.6/fs/fat/fat.c	2008-10-07 01:18:37.000000000 +0800
@@ -83,6 +83,9 @@
 		/* no signature found */
 		return -1;
 	}
+	if (buffer[450] != 11 && buffer[450] != 6 )
+		printf("I'm sorry we only support fat16 and fat32\n");
+
 	if(!strncmp((char *)&buffer[DOS_FS_TYPE_OFFSET],"FAT",3)) {
 		/* ok, we assume we are on a PBR only */
 		cur_part = 1;
@@ -109,6 +112,11 @@
 		part_offset=32;
 		cur_part = 1;
 #endif
+#if  (CONFIG_COMMANDS & CFG_CMD_MMC)
+		part_offset=(buffer[457] << 24) |( buffer[456] <<16 )| (buffer[455] << 8) | (buffer[454]);
+		cur_part = 1;
+#endif
+
 	}
 	return 0;
 }
@@ -231,6 +239,8 @@
 	/* Get the actual entry from the table */
 	switch (mydata->fatsize) {
 	case 32:
+		offset *=4;
+		ret = (mydata->fatbuf[3 + offset]<<24) |(mydata->fatbuf[2 + offset]<<16) | (mydata->fatbuf[1 + offset]<< 8)| (mydata->fatbuf[0 + offset]);
 		ret = FAT2CPU32(((__u32*)mydata->fatbuf)[offset]);
 		break;
 	case 16:
diff -urN /develop/source/01boot/u-boot-1.1.6/include/asm-mips/addrspace.h u-boot-1.1.6/include/asm-mips/addrspace.h
--- /develop/source/01boot/u-boot-1.1.6/include/asm-mips/addrspace.h	2007-10-31 00:43:18.000000000 +0800
+++ u-boot-1.1.6/include/asm-mips/addrspace.h	2007-03-01 16:58:38.000000000 +0800
@@ -44,7 +44,7 @@
  * Returns the uncached address of a sdram address
  */
 #ifndef __ASSEMBLY__
-#if defined(CONFIG_AU1X00) || defined(CONFIG_TB0229)
+#if defined(CONFIG_AU1X00) || defined(CONFIG_TB0229) || defined(CONFIG_JzRISC)
 /* We use a 36 bit physical address map here and
    cannot access physical memory directly from core */
 #define UNCACHED_SDRAM(a) (((unsigned long)(a)) | 0x20000000)
diff -urN /develop/source/01boot/u-boot-1.1.6/include/asm-mips/errno.h u-boot-1.1.6/include/asm-mips/errno.h
--- /develop/source/01boot/u-boot-1.1.6/include/asm-mips/errno.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/asm-mips/errno.h	2007-05-23 15:23:44.000000000 +0800
@@ -0,0 +1,138 @@
+#ifndef _MIPS_ERRNO_H
+#define _MIPS_ERRNO_H
+
+#define	EPERM		 1	/* Operation not permitted */
+#define	ENOENT		 2	/* No such file or directory */
+#define	ESRCH		 3	/* No such process */
+#define	EINTR		 4	/* Interrupted system call */
+#define	EIO		 5	/* I/O error */
+#define	ENXIO		 6	/* No such device or address */
+#define	E2BIG		 7	/* Arg list too long */
+#define	ENOEXEC		 8	/* Exec format error */
+#define	EBADF		 9	/* Bad file number */
+#define	ECHILD		10	/* No child processes */
+#define	EAGAIN		11	/* Try again */
+#define	ENOMEM		12	/* Out of memory */
+#define	EACCES		13	/* Permission denied */
+#define	EFAULT		14	/* Bad address */
+#define	ENOTBLK		15	/* Block device required */
+#define	EBUSY		16	/* Device or resource busy */
+#define	EEXIST		17	/* File exists */
+#define	EXDEV		18	/* Cross-device link */
+#define	ENODEV		19	/* No such device */
+#define	ENOTDIR		20	/* Not a directory */
+#define	EISDIR		21	/* Is a directory */
+#define	EINVAL		22	/* Invalid argument */
+#define	ENFILE		23	/* File table overflow */
+#define	EMFILE		24	/* Too many open files */
+#define	ENOTTY		25	/* Not a typewriter */
+#define	ETXTBSY		26	/* Text file busy */
+#define	EFBIG		27	/* File too large */
+#define	ENOSPC		28	/* No space left on device */
+#define	ESPIPE		29	/* Illegal seek */
+#define	EROFS		30	/* Read-only file system */
+#define	EMLINK		31	/* Too many links */
+#define	EPIPE		32	/* Broken pipe */
+#define	EDOM		33	/* Math argument out of domain of func */
+#define	ERANGE		34	/* Math result not representable */
+#define	EDEADLK		35	/* Resource deadlock would occur */
+#define	ENAMETOOLONG	36	/* File name too long */
+#define	ENOLCK		37	/* No record locks available */
+#define	ENOSYS		38	/* Function not implemented */
+#define	ENOTEMPTY	39	/* Directory not empty */
+#define	ELOOP		40	/* Too many symbolic links encountered */
+#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
+#define	ENOMSG		42	/* No message of desired type */
+#define	EIDRM		43	/* Identifier removed */
+#define	ECHRNG		44	/* Channel number out of range */
+#define	EL2NSYNC	45	/* Level 2 not synchronized */
+#define	EL3HLT		46	/* Level 3 halted */
+#define	EL3RST		47	/* Level 3 reset */
+#define	ELNRNG		48	/* Link number out of range */
+#define	EUNATCH		49	/* Protocol driver not attached */
+#define	ENOCSI		50	/* No CSI structure available */
+#define	EL2HLT		51	/* Level 2 halted */
+#define	EBADE		52	/* Invalid exchange */
+#define	EBADR		53	/* Invalid request descriptor */
+#define	EXFULL		54	/* Exchange full */
+#define	ENOANO		55	/* No anode */
+#define	EBADRQC		56	/* Invalid request code */
+#define	EBADSLT		57	/* Invalid slot */
+#define	EDEADLOCK	58	/* File locking deadlock error */
+#define	EBFONT		59	/* Bad font file format */
+#define	ENOSTR		60	/* Device not a stream */
+#define	ENODATA		61	/* No data available */
+#define	ETIME		62	/* Timer expired */
+#define	ENOSR		63	/* Out of streams resources */
+#define	ENONET		64	/* Machine is not on the network */
+#define	ENOPKG		65	/* Package not installed */
+#define	EREMOTE		66	/* Object is remote */
+#define	ENOLINK		67	/* Link has been severed */
+#define	EADV		68	/* Advertise error */
+#define	ESRMNT		69	/* Srmount error */
+#define	ECOMM		70	/* Communication error on send */
+#define	EPROTO		71	/* Protocol error */
+#define	EMULTIHOP	72	/* Multihop attempted */
+#define	EDOTDOT		73	/* RFS specific error */
+#define	EBADMSG		74	/* Not a data message */
+#define	EOVERFLOW	75	/* Value too large for defined data type */
+#define	ENOTUNIQ	76	/* Name not unique on network */
+#define	EBADFD		77	/* File descriptor in bad state */
+#define	EREMCHG		78	/* Remote address changed */
+#define	ELIBACC		79	/* Can not access a needed shared library */
+#define	ELIBBAD		80	/* Accessing a corrupted shared library */
+#define	ELIBSCN		81	/* .lib section in a.out corrupted */
+#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
+#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
+#define	EILSEQ		84	/* Illegal byte sequence */
+#define	ERESTART	85	/* Interrupted system call should be restarted */
+#define	ESTRPIPE	86	/* Streams pipe error */
+#define	EUSERS		87	/* Too many users */
+#define	ENOTSOCK	88	/* Socket operation on non-socket */
+#define	EDESTADDRREQ	89	/* Destination address required */
+#define	EMSGSIZE	90	/* Message too long */
+#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	92	/* Protocol not available */
+#define	EPROTONOSUPPORT	93	/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
+#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
+#define	EPFNOSUPPORT	96	/* Protocol family not supported */
+#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
+#define	EADDRINUSE	98	/* Address already in use */
+#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
+#define	ENETDOWN	100	/* Network is down */
+#define	ENETUNREACH	101	/* Network is unreachable */
+#define	ENETRESET	102	/* Network dropped connection because of reset */
+#define	ECONNABORTED	103	/* Software caused connection abort */
+#define	ECONNRESET	104	/* Connection reset by peer */
+#define	ENOBUFS		105	/* No buffer space available */
+#define	EISCONN		106	/* Transport endpoint is already connected */
+#define	ENOTCONN	107	/* Transport endpoint is not connected */
+#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
+#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
+#define	ETIMEDOUT	110	/* Connection timed out */
+#define	ECONNREFUSED	111	/* Connection refused */
+#define	EHOSTDOWN	112	/* Host is down */
+#define	EHOSTUNREACH	113	/* No route to host */
+#define	EALREADY	114	/* Operation already in progress */
+#define	EINPROGRESS	115	/* Operation now in progress */
+#define	ESTALE		116	/* Stale NFS file handle */
+#define	EUCLEAN		117	/* Structure needs cleaning */
+#define	ENOTNAM		118	/* Not a XENIX named type file */
+#define	ENAVAIL		119	/* No XENIX semaphores available */
+#define	EISNAM		120	/* Is a named type file */
+#define	EREMOTEIO	121	/* Remote I/O error */
+#define	EDQUOT		122	/* Quota exceeded */
+
+#define	ENOMEDIUM	123	/* No medium found */
+#define	EMEDIUMTYPE	124	/* Wrong medium type */
+
+/* Should never be seen by user programs */
+#define ERESTARTSYS	512
+#define ERESTARTNOINTR	513
+#define ERESTARTNOHAND	514	/* restart if no handler.. */
+#define ENOIOCTLCMD	515	/* No ioctl command */
+
+#define _LAST_ERRNO	515
+
+#endif
diff -urN /develop/source/01boot/u-boot-1.1.6/include/asm-mips/global_data.h u-boot-1.1.6/include/asm-mips/global_data.h
--- /develop/source/01boot/u-boot-1.1.6/include/asm-mips/global_data.h	2007-10-31 00:43:18.000000000 +0800
+++ u-boot-1.1.6/include/asm-mips/global_data.h	2008-01-23 12:12:45.000000000 +0800
@@ -39,6 +39,15 @@
 typedef	struct	global_data {
 	bd_t		*bd;
 	unsigned long	flags;
+#if defined(CONFIG_JZSOC)
+	/* There are other clocks in the Jz47xx or Jz5730*/
+	unsigned long	cpu_clk;	/* CPU core clock */
+	unsigned long	sys_clk;	/* System bus clock */
+	unsigned long	per_clk;	/* Peripheral bus clock */
+	unsigned long	mem_clk;	/* Memory bus clock */
+	unsigned long	dev_clk;	/* Device clock */
+	unsigned long   fb_base;        /* base address of framebuffer */
+#endif
 	unsigned long	baudrate;
 	unsigned long	have_console;	/* serial_init() was called */
 	unsigned long	ram_size;	/* RAM size */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz4730.h u-boot-1.1.6/include/asm-mips/jz4730.h
--- /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz4730.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/asm-mips/jz4730.h	2007-06-15 16:00:17.000000000 +0800
@@ -0,0 +1,5251 @@
+/*
+ * Include file for Ingenic Semiconductor's JZ4730 CPU.
+ */
+#ifndef __JZ4730_H__
+#define __JZ4730_H__
+
+#ifndef __ASSEMBLY__
+
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+
+#define cache_unroll(base,op)	        	\
+	__asm__ __volatile__("	         	\
+		.set noreorder;		        \
+		.set mips3;		        \
+		cache %1, (%0);	                \
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+static inline void jz_flush_dcache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_DCACHE_SIZE;
+	while (start < end) {
+		cache_unroll(start,Index_Writeback_Inv_D);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+static inline void jz_flush_icache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_ICACHE_SIZE;
+	while(start < end) {
+		cache_unroll(start,Index_Invalidate_I);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+/* cpu pipeline flush */
+static inline void jz_sync(void)
+{
+	__asm__ volatile ("sync");
+}
+
+static inline void jz_writeb(u32 address, u8 value)
+{
+	*((volatile u8 *)address) = value;
+}
+
+static inline void jz_writew(u32 address, u8 value)
+{
+	*((volatile u16 *)address) = value;
+}
+
+static inline void jz_writel(u32 address, u32 value)
+{
+	*((volatile u32 *)address) = value;
+}
+
+static inline u8 jz_readb(u32 address)
+{
+	return *((volatile u8 *)address);
+}
+
+static inline u16 jz_readw(u32 address)
+{
+	return *((volatile u16 *)address);
+}
+
+static inline u32 jz_readl(u32 address)
+{
+	return *((volatile u32 *)address);
+}
+
+#define REG8(addr)	*((volatile u8 *)(addr))
+#define REG16(addr)	*((volatile u16 *)(addr))
+#define REG32(addr)	*((volatile u32 *)(addr))
+
+#else
+
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+
+#endif /* !ASSEMBLY */
+
+#define	HARB_BASE	0xB3000000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	CIM_BASE	0xB3060000
+#define	ETH_BASE	0xB3100000
+#define	NBM_BASE	0xB3F00000
+
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	OST_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	WDT_BASE	0xB0004000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	UART2_BASE	0xB0032000
+#define	UART3_BASE	0xB0033000
+#define	FIR_BASE	0xB0040000
+#define	SCC_BASE	0xB0041000
+#define	SCC0_BASE	0xB0041000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SCC1_BASE	0xB0044000
+#define	PWM0_BASE	0xB0050000
+#define	PWM1_BASE	0xB0051000
+#define	DES_BASE	0xB0060000
+#define	UPRT_BASE	0xB0061000
+#define KBC_BASE	0xB0062000
+
+
+
+
+/*************************************************************************
+ * MSC
+ *************************************************************************/
+#define	MSC_STRPCL		(MSC_BASE + 0x000)
+#define	MSC_STAT		(MSC_BASE + 0x004)
+#define	MSC_CLKRT		(MSC_BASE + 0x008)
+#define	MSC_CMDAT		(MSC_BASE + 0x00C)
+#define	MSC_RESTO		(MSC_BASE + 0x010)
+#define	MSC_RDTO		(MSC_BASE + 0x014)
+#define	MSC_BLKLEN		(MSC_BASE + 0x018)
+#define	MSC_NOB			(MSC_BASE + 0x01C)
+#define	MSC_SNOB		(MSC_BASE + 0x020)
+#define	MSC_IMASK		(MSC_BASE + 0x024)
+#define	MSC_IREG		(MSC_BASE + 0x028)
+#define	MSC_CMD			(MSC_BASE + 0x02C)
+#define	MSC_ARG			(MSC_BASE + 0x030)
+#define	MSC_RES			(MSC_BASE + 0x034)
+#define	MSC_RXFIFO		(MSC_BASE + 0x038)
+#define	MSC_TXFIFO		(MSC_BASE + 0x03C)
+
+#define	REG_MSC_STRPCL		REG16(MSC_STRPCL)
+#define	REG_MSC_STAT		REG32(MSC_STAT)
+#define	REG_MSC_CLKRT		REG16(MSC_CLKRT)
+#define	REG_MSC_CMDAT		REG32(MSC_CMDAT)
+#define	REG_MSC_RESTO		REG16(MSC_RESTO)
+#define	REG_MSC_RDTO		REG16(MSC_RDTO)
+#define	REG_MSC_BLKLEN		REG16(MSC_BLKLEN)
+#define	REG_MSC_NOB		REG16(MSC_NOB)
+#define	REG_MSC_SNOB		REG16(MSC_SNOB)
+#define	REG_MSC_IMASK		REG16(MSC_IMASK)
+#define	REG_MSC_IREG		REG16(MSC_IREG)
+#define	REG_MSC_CMD		REG8(MSC_CMD)
+#define	REG_MSC_ARG		REG32(MSC_ARG)
+#define	REG_MSC_RES		REG16(MSC_RES)
+#define	REG_MSC_RXFIFO		REG32(MSC_RXFIFO)
+#define	REG_MSC_TXFIFO		REG32(MSC_TXFIFO)
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	  (0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	  (0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	  (0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	  (0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	  (0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	  (0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	  (0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	  (0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+
+#define	MSC_CMDAT_IO_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define CMDAT_BUS_WIDTH1	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define CMDAT_BUS_WIDTH4	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT)
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE  (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00)
+#define RTC_RSR		(RTC_BASE + 0x04)
+#define RTC_RSAR	(RTC_BASE + 0x08)
+#define RTC_RGR		(RTC_BASE + 0x0c)
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+
+#define RTC_RCR_HZ	(1 << 6)
+#define RTC_RCR_HZIE	(1 << 5)
+#define RTC_RCR_AF	(1 << 4)
+#define RTC_RCR_AIE	(1 << 3)
+#define RTC_RCR_AE	(1 << 2)
+#define RTC_RCR_START	(1 << 0)
+
+#define RTC_RGR_LOCK		(1 << 31)
+#define RTC_RGR_ADJ_BIT		16
+#define RTC_RGR_ADJ_MASK	(0x3ff << RTC_RGR_ADJ_BIT)
+#define RTC_RGR_DIV_BIT		0
+#define RTC_REG_DIV_MASK	(0xff << RTC_RGR_DIV_BIT)
+
+
+
+
+/*************************************************************************
+ * FIR
+ *************************************************************************/
+#define	FIR_TDR			(FIR_BASE + 0x000)
+#define	FIR_RDR			(FIR_BASE + 0x004)
+#define	FIR_TFLR		(FIR_BASE + 0x008)
+#define	FIR_AR			(FIR_BASE + 0x00C)
+#define	FIR_CR1			(FIR_BASE + 0x010)
+#define	FIR_CR2			(FIR_BASE + 0x014)
+#define	FIR_SR			(FIR_BASE + 0x018)
+
+#define	REG_FIR_TDR		REG8(FIR_TDR)
+#define	REG_FIR_RDR		REG8(FIR_RDR)
+#define REG_FIR_TFLR		REG16(FIR_TFLR)
+#define REG_FIR_AR		REG8(FIR_AR)
+#define	REG_FIR_CR1		REG8(FIR_CR1)
+#define	REG_FIR_CR2		REG16(FIR_CR2)
+#define REG_FIR_SR		REG16(FIR_SR)
+
+/* FIR Control Register 1 (FIR_CR1) */
+
+#define FIR_CR1_FIRUE		(1 << 7)
+#define FIR_CR1_ACE		(1 << 6)
+#define FIR_CR1_EOUS		(1 << 5)
+#define FIR_CR1_TIIE		(1 << 4)
+#define FIR_CR1_TFIE		(1 << 3)
+#define FIR_CR1_RFIE		(1 << 2)
+#define FIR_CR1_TXE		(1 << 1)
+#define FIR_CR1_RXE		(1 << 0)
+
+/* FIR Control Register 2 (FIR_CR2) */
+
+#define FIR_CR2_SIPE		(1 << 10)
+#define FIR_CR2_BCRC		(1 << 9)
+#define FIR_CR2_TFLRS		(1 << 8)
+#define FIR_CR2_ISS		(1 << 7)
+#define FIR_CR2_LMS		(1 << 6)
+#define FIR_CR2_TPPS		(1 << 5)
+#define FIR_CR2_RPPS		(1 << 4)
+#define FIR_CR2_TTRG_BIT	2
+#define FIR_CR2_TTRG_MASK	(0x3 << FIR_CR2_TTRG_BIT)
+  #define FIR_CR2_TTRG_16	  (0 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 16 */
+  #define FIR_CR2_TTRG_32	  (1 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 32 */
+  #define FIR_CR2_TTRG_64	  (2 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 64 */
+  #define FIR_CR2_TTRG_128	  (3 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 128 */
+#define FIR_CR2_RTRG_BIT	0
+#define FIR_CR2_RTRG_MASK	(0x3 << FIR_CR2_RTRG_BIT)
+  #define FIR_CR2_RTRG_16	  (0 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 16 */
+  #define FIR_CR2_RTRG_32	  (1 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 32 */
+  #define FIR_CR2_RTRG_64	  (2 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 64 */
+  #define FIR_CR2_RTRG_128	  (3 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 128 */
+
+/* FIR Status Register (FIR_SR) */
+
+#define FIR_SR_RFW		(1 << 12)
+#define FIR_SR_RFA		(1 << 11)
+#define FIR_SR_TFRTL		(1 << 10)
+#define FIR_SR_RFRTL		(1 << 9)
+#define FIR_SR_URUN		(1 << 8)
+#define FIR_SR_RFTE		(1 << 7)
+#define FIR_SR_ORUN		(1 << 6)
+#define FIR_SR_CRCE		(1 << 5)
+#define FIR_SR_FEND		(1 << 4)
+#define FIR_SR_TFF		(1 << 3)
+#define FIR_SR_RFE		(1 << 2)
+#define FIR_SR_TIDLE		(1 << 1)
+#define FIR_SR_RB		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * SCC
+ *************************************************************************/
+#define	SCC_DR(base)		((base) + 0x000)
+#define	SCC_FDR(base)		((base) + 0x004)
+#define	SCC_CR(base)		((base) + 0x008)
+#define	SCC_SR(base)		((base) + 0x00C)
+#define	SCC_TFR(base)		((base) + 0x010)
+#define	SCC_EGTR(base)		((base) + 0x014)
+#define	SCC_ECR(base)		((base) + 0x018)
+#define	SCC_RTOR(base)		((base) + 0x01C)
+
+#define REG_SCC_DR(base)	REG8(SCC_DR(base))
+#define REG_SCC_FDR(base)	REG8(SCC_FDR(base))
+#define REG_SCC_CR(base)	REG32(SCC_CR(base))
+#define REG_SCC_SR(base)	REG16(SCC_SR(base))
+#define REG_SCC_TFR(base)	REG16(SCC_TFR(base))
+#define REG_SCC_EGTR(base)	REG8(SCC_EGTR(base))
+#define REG_SCC_ECR(base)	REG32(SCC_ECR(base))
+#define REG_SCC_RTOR(base)	REG8(SCC_RTOR(base))
+
+/* SCC FIFO Data Count Register (SCC_FDR) */
+
+#define SCC_FDR_EMPTY		0x00
+#define SCC_FDR_FULL		0x10
+
+/* SCC Control Register (SCC_CR) */
+
+#define SCC_CR_SCCE		(1 << 31)
+#define SCC_CR_TRS		(1 << 30)
+#define SCC_CR_T2R		(1 << 29)
+#define SCC_CR_FDIV_BIT		24
+#define SCC_CR_FDIV_MASK	(0x3 << SCC_CR_FDIV_BIT)
+  #define SCC_CR_FDIV_1		  (0 << SCC_CR_FDIV_BIT) /* SCC_CLK frequency is the same as device clock */
+  #define SCC_CR_FDIV_2		  (1 << SCC_CR_FDIV_BIT) /* SCC_CLK frequency is half of device clock */
+#define SCC_CR_FLUSH		(1 << 23)
+#define SCC_CR_TRIG_BIT		16
+#define SCC_CR_TRIG_MASK	(0x3 << SCC_CR_TRIG_BIT)
+  #define SCC_CR_TRIG_1		  (0 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 1 */
+  #define SCC_CR_TRIG_4		  (1 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 4 */
+  #define SCC_CR_TRIG_8		  (2 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 8 */
+  #define SCC_CR_TRIG_14	  (3 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 14 */
+#define SCC_CR_TP		(1 << 15)
+#define SCC_CR_CONV		(1 << 14)
+#define SCC_CR_TXIE		(1 << 13)
+#define SCC_CR_RXIE		(1 << 12)
+#define SCC_CR_TENDIE		(1 << 11)
+#define SCC_CR_RTOIE		(1 << 10)
+#define SCC_CR_ECIE		(1 << 9)
+#define SCC_CR_EPIE		(1 << 8)
+#define SCC_CR_RETIE		(1 << 7)
+#define SCC_CR_EOIE		(1 << 6)
+#define SCC_CR_TSEND		(1 << 3)
+#define SCC_CR_PX_BIT		1
+#define SCC_CR_PX_MASK		(0x3 << SCC_CR_PX_BIT)
+  #define SCC_CR_PX_NOT_SUPPORT	  (0 << SCC_CR_PX_BIT) /* SCC does not support clock stop */
+  #define SCC_CR_PX_STOP_LOW	  (1 << SCC_CR_PX_BIT) /* SCC_CLK stops at state low */
+  #define SCC_CR_PX_STOP_HIGH	  (2 << SCC_CR_PX_BIT) /* SCC_CLK stops at state high */
+#define SCC_CR_CLKSTP		(1 << 0)
+
+/* SCC Status Register (SCC_SR) */
+
+#define SCC_SR_TRANS		(1 << 15)
+#define SCC_SR_ORER		(1 << 12)
+#define SCC_SR_RTO		(1 << 11)
+#define SCC_SR_PER		(1 << 10)
+#define SCC_SR_TFTG		(1 << 9)
+#define SCC_SR_RFTG		(1 << 8)
+#define SCC_SR_TEND		(1 << 7)
+#define SCC_SR_RETR_3		(1 << 4)
+#define SCC_SR_ECNTO		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * ETH
+ *************************************************************************/
+#define ETH_BMR		(ETH_BASE + 0x1000)
+#define ETH_TPDR	(ETH_BASE + 0x1004)
+#define ETH_RPDR	(ETH_BASE + 0x1008)
+#define ETH_RAR		(ETH_BASE + 0x100C)
+#define ETH_TAR		(ETH_BASE + 0x1010)
+#define ETH_SR		(ETH_BASE + 0x1014)
+#define ETH_CR		(ETH_BASE + 0x1018)
+#define ETH_IER		(ETH_BASE + 0x101C)
+#define ETH_MFCR	(ETH_BASE + 0x1020)
+#define ETH_CTAR	(ETH_BASE + 0x1050)
+#define ETH_CRAR	(ETH_BASE + 0x1054)
+#define ETH_MCR		(ETH_BASE + 0x0000)
+#define ETH_MAHR	(ETH_BASE + 0x0004)
+#define ETH_MALR	(ETH_BASE + 0x0008)
+#define ETH_HTHR	(ETH_BASE + 0x000C)
+#define ETH_HTLR	(ETH_BASE + 0x0010)
+#define ETH_MIAR	(ETH_BASE + 0x0014)
+#define ETH_MIDR	(ETH_BASE + 0x0018)
+#define ETH_FCR		(ETH_BASE + 0x001C)
+#define ETH_VTR1	(ETH_BASE + 0x0020)
+#define ETH_VTR2	(ETH_BASE + 0x0024)
+#define ETH_WKFR	(ETH_BASE + 0x0028)
+#define ETH_PMTR	(ETH_BASE + 0x002C)
+
+#define REG_ETH_BMR	REG32(ETH_BMR)
+#define REG_ETH_TPDR	REG32(ETH_TPDR)
+#define REG_ETH_RPDR	REG32(ETH_RPDR)
+#define REG_ETH_RAR	REG32(ETH_RAR)
+#define REG_ETH_TAR	REG32(ETH_TAR)
+#define REG_ETH_SR	REG32(ETH_SR)
+#define REG_ETH_CR	REG32(ETH_CR)
+#define REG_ETH_IER	REG32(ETH_IER)
+#define REG_ETH_MFCR	REG32(ETH_MFCR)
+#define REG_ETH_CTAR	REG32(ETH_CTAR)
+#define REG_ETH_CRAR	REG32(ETH_CRAR)
+#define REG_ETH_MCR	REG32(ETH_MCR)
+#define REG_ETH_MAHR	REG32(ETH_MAHR)
+#define REG_ETH_MALR	REG32(ETH_MALR)
+#define REG_ETH_HTHR	REG32(ETH_HTHR)
+#define REG_ETH_HTLR	REG32(ETH_HTLR)
+#define REG_ETH_MIAR	REG32(ETH_MIAR)
+#define REG_ETH_MIDR	REG32(ETH_MIDR)
+#define REG_ETH_FCR	REG32(ETH_FCR)
+#define REG_ETH_VTR1	REG32(ETH_VTR1)
+#define REG_ETH_VTR2	REG32(ETH_VTR2)
+#define REG_ETH_WKFR	REG32(ETH_WKFR)
+#define REG_ETH_PMTR	REG32(ETH_PMTR)
+
+/* Bus Mode Register (ETH_BMR) */
+
+#define ETH_BMR_DBO		(1 << 20)
+#define ETH_BMR_PBL_BIT		8
+#define ETH_BMR_PBL_MASK	(0x3f << ETH_BMR_PBL_BIT)
+  #define ETH_BMR_PBL_1		  (0x1 << ETH_BMR_PBL_BIT)
+  #define ETH_BMR_PBL_4		  (0x4 << ETH_BMR_PBL_BIT)
+#define ETH_BMR_BLE		(1 << 7)
+#define ETH_BMR_DSL_BIT		2
+#define ETH_BMR_DSL_MASK	(0x1f << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_0		  (0x0 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_1		  (0x1 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_2		  (0x2 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_4		  (0x4 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_8		  (0x8 << ETH_BMR_DSL_BIT)
+#define ETH_BMR_SWR		(1 << 0)
+
+/* DMA Status Register (ETH_SR) */
+
+#define ETH_SR_EB_BIT		23
+#define ETH_SR_EB_MASK		(0x7 << ETH_SR_EB_BIT)
+  #define ETH_SR_EB_TX_ABORT	  (0x1 << ETH_SR_EB_BIT)
+  #define ETH_SR_EB_RX_ABORT	  (0x2 << ETH_SR_EB_BIT)
+#define ETH_SR_TS_BIT		20
+#define ETH_SR_TS_MASK		(0x7 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_STOP	  (0x0 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_FTD		  (0x1 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_WEOT	  (0x2 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_QDAT	  (0x3 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_SUSPEND	  (0x6 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_CTD		  (0x7 << ETH_SR_TS_BIT)
+#define ETH_SR_RS_BIT		17
+#define ETH_SR_RS_MASK		(0x7 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_STOP	  (0x0 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_FRD		  (0x1 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_CEOR	  (0x2 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_WRP		  (0x3 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_SUSPEND	  (0x4 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_CRD		  (0x5 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_FCF		  (0x6 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_QRF		  (0x7 << ETH_SR_RS_BIT)
+#define ETH_SR_NIS		(1 << 16)
+#define ETH_SR_AIS		(1 << 15)
+#define ETH_SR_ERI		(1 << 14)
+#define ETH_SR_FBE		(1 << 13)
+#define ETH_SR_ETI		(1 << 10)
+#define ETH_SR_RWT		(1 << 9)
+#define ETH_SR_RPS		(1 << 8)
+#define ETH_SR_RU		(1 << 7)
+#define ETH_SR_RI		(1 << 6)
+#define ETH_SR_UNF		(1 << 5)
+#define ETH_SR_TJT		(1 << 3)
+#define ETH_SR_TU		(1 << 2)
+#define ETH_SR_TPS		(1 << 1)
+#define ETH_SR_TI		(1 << 0)
+
+/* Control (Operation Mode) Register (ETH_CR) */
+
+#define ETH_CR_TTM		(1 << 22)
+#define ETH_CR_SF		(1 << 21)
+#define ETH_CR_TR_BIT		14
+#define ETH_CR_TR_MASK		(0x3 << ETH_CR_TR_BIT)
+#define ETH_CR_ST		(1 << 13)
+#define ETH_CR_OSF		(1 << 2)
+#define ETH_CR_SR		(1 << 1)
+
+/* Interrupt Enable Register (ETH_IER) */
+
+#define ETH_IER_NI		(1 << 16)
+#define ETH_IER_AI		(1 << 15)
+#define ETH_IER_ERE		(1 << 14)
+#define ETH_IER_FBE		(1 << 13)
+#define ETH_IER_ET		(1 << 10)
+#define ETH_IER_RWE		(1 << 9)
+#define ETH_IER_RS		(1 << 8)
+#define ETH_IER_RU		(1 << 7)
+#define ETH_IER_RI		(1 << 6)
+#define ETH_IER_UN		(1 << 5)
+#define ETH_IER_TJ		(1 << 3)
+#define ETH_IER_TU		(1 << 2)
+#define ETH_IER_TS		(1 << 1)
+#define ETH_IER_TI		(1 << 0)
+
+/* Missed Frame and Buffer Overflow Counter Register (ETH_MFCR) */
+
+#define ETH_MFCR_OVERFLOW_BIT	17
+#define ETH_MFCR_OVERFLOW_MASK	(0x7ff << ETH_MFCR_OVERFLOW_BIT)
+#define ETH_MFCR_MFC_BIT	0
+#define ETH_MFCR_MFC_MASK	(0xffff << ETH_MFCR_MFC_BIT)
+
+/* MAC Control Register (ETH_MCR) */
+
+#define ETH_MCR_RA		(1 << 31)
+#define ETH_MCR_HBD		(1 << 28)
+#define ETH_MCR_PS		(1 << 27)
+#define ETH_MCR_DRO		(1 << 23)
+#define ETH_MCR_OM_BIT		21
+#define ETH_MCR_OM_MASK		(0x3 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_NORMAL	  (0x0 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_INTERNAL	  (0x1 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_EXTERNAL	  (0x2 << ETH_MCR_OM_BIT)
+#define ETH_MCR_F		(1 << 20)
+#define ETH_MCR_PM		(1 << 19)
+#define ETH_MCR_PR		(1 << 18)
+#define ETH_MCR_IF		(1 << 17)
+#define ETH_MCR_PB		(1 << 16)
+#define ETH_MCR_HO		(1 << 15)
+#define ETH_MCR_HP		(1 << 13)
+#define ETH_MCR_LCC		(1 << 12)
+#define ETH_MCR_DBF		(1 << 11)
+#define ETH_MCR_DTRY		(1 << 10)
+#define ETH_MCR_ASTP		(1 << 8)
+#define ETH_MCR_BOLMT_BIT	6
+#define ETH_MCR_BOLMT_MASK	(0x3 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_10	  (0 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_8	  (1 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_4	  (2 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_1	  (3 << ETH_MCR_BOLMT_BIT)
+#define ETH_MCR_DC		(1 << 5)
+#define ETH_MCR_TE		(1 << 3)
+#define ETH_MCR_RE		(1 << 2)
+
+/* MII Address Register (ETH_MIAR) */
+
+#define ETH_MIAR_PHY_ADDR_BIT	11
+#define ETH_MIAR_PHY_ADDR_MASK	(0x1f << ETH_MIAR_PHY_ADDR_BIT)
+#define ETH_MIAR_MII_REG_BIT	6
+#define ETH_MIAR_MII_REG_MASK	(0x1f << ETH_MIAR_MII_REG_BIT)
+#define ETH_MIAR_MII_WRITE	(1 << 1)
+#define ETH_MIAR_MII_BUSY	(1 << 0)
+
+/* Flow Control Register (ETH_FCR) */
+
+#define	ETH_FCR_PAUSE_TIME_BIT	16
+#define	ETH_FCR_PAUSE_TIME_MASK	(0xffff << ETH_FCR_PAUSE_TIME_BIT)
+#define	ETH_FCR_PCF		(1 << 2)
+#define	ETH_FCR_FCE		(1 << 1)
+#define	ETH_FCR_BUSY		(1 << 0)
+
+/* PMT Control and Status Register (ETH_PMTR) */
+
+#define ETH_PMTR_GU		(1 << 9)
+#define ETH_PMTR_RF		(1 << 6)
+#define ETH_PMTR_MF		(1 << 5)
+#define ETH_PMTR_RWK		(1 << 2)
+#define ETH_PMTR_MPK		(1 << 1)
+
+/* Receive Descriptor 0 (ETH_RD0) Bits */
+
+#define ETH_RD0_OWN		(1 << 31)
+#define ETH_RD0_FF		(1 << 30)
+#define ETH_RD0_FL_BIT		16
+#define ETH_RD0_FL_MASK		(0x3fff << ETH_RD0_FL_BIT)
+#define ETH_RD0_ES		(1 << 15)
+#define ETH_RD0_DE		(1 << 14)
+#define ETH_RD0_LE		(1 << 12)
+#define ETH_RD0_RF		(1 << 11)
+#define ETH_RD0_MF		(1 << 10)
+#define ETH_RD0_FD		(1 << 9)
+#define ETH_RD0_LD		(1 << 8)
+#define ETH_RD0_TL		(1 << 7)
+#define ETH_RD0_CS		(1 << 6)
+#define ETH_RD0_FT		(1 << 5)
+#define ETH_RD0_WT		(1 << 4)
+#define ETH_RD0_ME		(1 << 3)
+#define ETH_RD0_DB		(1 << 2)
+#define ETH_RD0_CE		(1 << 1)
+
+/* Receive Descriptor 1 (ETH_RD1) Bits */
+
+#define ETH_RD1_RER		(1 << 25)
+#define ETH_RD1_RCH		(1 << 24)
+#define ETH_RD1_RBS2_BIT	11
+#define ETH_RD1_RBS2_MASK	(0x7ff << ETH_RD1_RBS2_BIT)
+#define ETH_RD1_RBS1_BIT	0
+#define ETH_RD1_RBS1_MASK	(0x7ff << ETH_RD1_RBS1_BIT)
+
+/* Transmit Descriptor 0 (ETH_TD0) Bits */
+
+#define ETH_TD0_OWN		(1 << 31)
+#define ETH_TD0_FA		(1 << 15)
+#define ETH_TD0_LOC		(1 << 11)
+#define ETH_TD0_NC		(1 << 10)
+#define ETH_TD0_LC		(1 << 9)
+#define ETH_TD0_EC		(1 << 8)
+#define ETH_TD0_HBF		(1 << 7)
+#define ETH_TD0_CC_BIT		3
+#define ETH_TD0_CC_MASK		(0xf << ETH_TD0_CC_BIT)
+#define ETH_TD0_ED		(1 << 2)
+#define ETH_TD0_UF		(1 << 1)
+#define ETH_TD0_DF		(1 << 0)
+
+/* Transmit Descriptor 1 (ETH_TD1) Bits */
+
+#define ETH_TD1_IC		(1 << 31)
+#define ETH_TD1_LS		(1 << 30)
+#define ETH_TD1_FS		(1 << 29)
+#define ETH_TD1_AC		(1 << 26)
+#define ETH_TD1_TER		(1 << 25)
+#define ETH_TD1_TCH		(1 << 24)
+#define ETH_TD1_DPD		(1 << 23)
+#define ETH_TD1_TBS2_BIT	11
+#define ETH_TD1_TBS2_MASK	(0x7ff << ETH_TD1_TBS2_BIT)
+#define ETH_TD1_TBS1_BIT	0
+#define ETH_TD1_TBS1_MASK	(0x7ff << ETH_TD1_TBS1_BIT)
+
+
+
+
+/*************************************************************************
+ * WDT
+ *************************************************************************/
+#define WDT_WTCSR	(WDT_BASE + 0x00)
+#define WDT_WTCNT	(WDT_BASE + 0x04)
+
+#define REG_WDT_WTCSR	REG8(WDT_WTCSR)
+#define REG_WDT_WTCNT	REG32(WDT_WTCNT)
+
+#define WDT_WTCSR_START	(1 << 4)
+
+
+
+
+/*************************************************************************
+ * OST
+ *************************************************************************/
+#define OST_TER		(OST_BASE + 0x00)
+#define OST_TRDR(n)	(OST_BASE + 0x10 + ((n) * 0x20))
+#define OST_TCNT(n)	(OST_BASE + 0x14 + ((n) * 0x20))
+#define OST_TCSR(n)	(OST_BASE + 0x18 + ((n) * 0x20))
+#define OST_TCRB(n)	(OST_BASE + 0x1c + ((n) * 0x20))
+
+#define REG_OST_TER	REG8(OST_TER)
+#define REG_OST_TRDR(n)	REG32(OST_TRDR((n)))
+#define REG_OST_TCNT(n)	REG32(OST_TCNT((n)))
+#define REG_OST_TCSR(n)	REG16(OST_TCSR((n)))
+#define REG_OST_TCRB(n)	REG32(OST_TCRB((n)))
+
+#define OST_TCSR_BUSY		(1 << 7)
+#define OST_TCSR_UF		(1 << 6)
+#define OST_TCSR_UIE		(1 << 5)
+#define OST_TCSR_CKS_BIT	0
+#define OST_TCSR_CKS_MASK	(0x07 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_4	(0 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_16	(1 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_64	(2 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_256	(3 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_RTCCLK	(4 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_EXTAL	(5 << OST_TCSR_CKS_BIT)
+
+#define OST_TCSR0       OST_TCSR(0)
+#define OST_TCSR1       OST_TCSR(1)
+#define OST_TCSR2       OST_TCSR(2)
+#define OST_TRDR0       OST_TRDR(0)
+#define OST_TRDR1       OST_TRDR(1)
+#define OST_TRDR2       OST_TRDR(2)
+#define OST_TCNT0       OST_TCNT(0)
+#define OST_TCNT1       OST_TCNT(1)
+#define OST_TCNT2       OST_TCNT(2)
+#define OST_TCRB0       OST_TCRB(0)
+#define OST_TCRB1       OST_TCRB(1)
+#define OST_TCRB2       OST_TCRB(2)
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* register offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+
+/* register address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+
+#define UART1_RDR	(UART1_BASE + OFF_RDR)
+#define UART1_TDR	(UART1_BASE + OFF_TDR)
+#define UART1_DLLR	(UART1_BASE + OFF_DLLR)
+#define UART1_DLHR	(UART1_BASE + OFF_DLHR)
+#define UART1_IER	(UART1_BASE + OFF_IER)
+#define UART1_ISR	(UART1_BASE + OFF_ISR)
+#define UART1_FCR	(UART1_BASE + OFF_FCR)
+#define UART1_LCR	(UART1_BASE + OFF_LCR)
+#define UART1_MCR	(UART1_BASE + OFF_MCR)
+#define UART1_LSR	(UART1_BASE + OFF_LSR)
+#define UART1_MSR	(UART1_BASE + OFF_MSR)
+#define UART1_SPR	(UART1_BASE + OFF_SPR)
+#define UART1_SIRCR	(UART1_BASE + OFF_SIRCR)
+
+#define UART2_RDR	(UART2_BASE + OFF_RDR)
+#define UART2_TDR	(UART2_BASE + OFF_TDR)
+#define UART2_DLLR	(UART2_BASE + OFF_DLLR)
+#define UART2_DLHR	(UART2_BASE + OFF_DLHR)
+#define UART2_IER	(UART2_BASE + OFF_IER)
+#define UART2_ISR	(UART2_BASE + OFF_ISR)
+#define UART2_FCR	(UART2_BASE + OFF_FCR)
+#define UART2_LCR	(UART2_BASE + OFF_LCR)
+#define UART2_MCR	(UART2_BASE + OFF_MCR)
+#define UART2_LSR	(UART2_BASE + OFF_LSR)
+#define UART2_MSR	(UART2_BASE + OFF_MSR)
+#define UART2_SPR	(UART2_BASE + OFF_SPR)
+#define UART2_SIRCR	(UART2_BASE + OFF_SIRCR)
+
+#define UART3_RDR	(UART3_BASE + OFF_RDR)
+#define UART3_TDR	(UART3_BASE + OFF_TDR)
+#define UART3_DLLR	(UART3_BASE + OFF_DLLR)
+#define UART3_DLHR	(UART3_BASE + OFF_DLHR)
+#define UART3_IER	(UART3_BASE + OFF_IER)
+#define UART3_ISR	(UART3_BASE + OFF_ISR)
+#define UART3_FCR	(UART3_BASE + OFF_FCR)
+#define UART3_LCR	(UART3_BASE + OFF_LCR)
+#define UART3_MCR	(UART3_BASE + OFF_MCR)
+#define UART3_LSR	(UART3_BASE + OFF_LSR)
+#define UART3_MSR	(UART3_BASE + OFF_MSR)
+#define UART3_SPR	(UART3_BASE + OFF_SPR)
+#define UART3_SIRCR	(UART3_BASE + OFF_SIRCR)
+
+/*
+ * Define macros for UART_IER
+ * UART Interrupt Enable Register
+ */
+#define UART_IER_RIE	(1 << 0)	/* 0: receive fifo "full" interrupt disable */
+#define UART_IER_TIE	(1 << 1)	/* 0: transmit fifo "empty" interrupt disable */
+#define UART_IER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UART_IER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UART_IER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UART_ISR
+ * UART Interrupt Status Register
+ */
+#define UART_ISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UART_ISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UART_ISR_IID_MSI		(0 << 1)	/* Modem status interrupt */
+#define UART_ISR_IID_THRI	(1 << 1)	/* Transmitter holding register empty */
+#define UART_ISR_IID_RDI		(2 << 1)	/* Receiver data interrupt */
+#define UART_ISR_IID_RLSI	(3 << 1)	/* Receiver line status interrupt */
+#define UART_ISR_FFMS	(3 << 6)	/* FIFO mode select, set when UART_FCR.FE is set to 1 */
+#define UART_ISR_FFMS_NO_FIFO	(0 << 6)
+#define UART_ISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UART_FCR
+ * UART FIFO Control Register
+ */
+#define UART_FCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UART_FCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UART_FCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UART_FCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UART_FCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UART_FCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UART_FCR_RTRG_1	(0 << 6)
+#define UART_FCR_RTRG_4	(1 << 6)
+#define UART_FCR_RTRG_8	(2 << 6)
+#define UART_FCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UART_LCR
+ * UART Line Control Register
+ */
+#define UART_LCR_WLEN	(3 << 0)	/* word length */
+#define UART_LCR_WLEN_5	(0 << 0)
+#define UART_LCR_WLEN_6	(1 << 0)
+#define UART_LCR_WLEN_7	(2 << 0)
+#define UART_LCR_WLEN_8	(3 << 0)
+#define UART_LCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_1	(0 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_2	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+
+#define UART_LCR_PE	(1 << 3)	/* 0: parity disable */
+#define UART_LCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UART_LCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UART_LCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UART_LCR_DLAB	(1 << 7)	/* 0: access UART_RDR/TDR/IER  1: access UART_DLLR/DLHR */
+
+/*
+ * Define macros for UART_LSR
+ * UART Line Status Register
+ */
+#define UART_LSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UART_LSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UART_LSR_PER	(1 << 2)	/* 0: no parity error */
+#define UART_LSR_FER	(1 << 3)	/* 0; no framing error */
+#define UART_LSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UART_LSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UART_LSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UART_LSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UART_MCR
+ * UART Modem Control Register
+ */
+#define UART_MCR_DTR	(1 << 0)	/* 0: DTR_ ouput high */
+#define UART_MCR_RTS	(1 << 1)	/* 0: RTS_ output high */
+#define UART_MCR_OUT1	(1 << 2)	/* 0: UART_MSR.RI is set to 0 and RI_ input high */
+#define UART_MCR_OUT2	(1 << 3)	/* 0: UART_MSR.DCD is set to 0 and DCD_ input high */
+#define UART_MCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UART_MCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UART_MSR
+ * UART Modem Status Register
+ */
+#define UART_MSR_DCTS	(1 << 0)	/* 0: no change on CTS_ pin since last read of UART_MSR */
+#define UART_MSR_DDSR	(1 << 1)	/* 0: no change on DSR_ pin since last read of UART_MSR */
+#define UART_MSR_DRI	(1 << 2)	/* 0: no change on RI_ pin since last read of UART_MSR */
+#define UART_MSR_DDCD	(1 << 3)	/* 0: no change on DCD_ pin since last read of UART_MSR */
+#define UART_MSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+#define UART_MSR_DSR	(1 << 5)	/* 0: DSR_ pin is high */
+#define UART_MSR_RI	(1 << 6)	/* 0: RI_ pin is high */
+#define UART_MSR_DCD	(1 << 7)	/* 0: DCD_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)	/* 0: transmitter is in UART mode  1: IrDA mode */
+#define SIRCR_RSIRE	(1 << 1)	/* 0: receiver is in UART mode  1: IrDA mode */
+#define SIRCR_TPWS	(1 << 2)	/* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TXPL	(1 << 3)	/* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RXPL	(1 << 4)	/* 0: decoder interprets positive pulse as 0 */
+
+
+
+/*************************************************************************
+ * INTC
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+#define IRQ_I2C		1
+#define IRQ_PS2		2
+#define IRQ_UPRT	3
+#define IRQ_CORE	4
+#define IRQ_UART3	6
+#define IRQ_UART2	7
+#define IRQ_UART1	8
+#define IRQ_UART0	9
+#define IRQ_SCC1	10
+#define IRQ_SCC0	11
+#define IRQ_UDC		12
+#define IRQ_UHC		13
+#define IRQ_MSC		14
+#define IRQ_RTC		15
+#define IRQ_FIR		16
+#define IRQ_SSI		17
+#define IRQ_CIM		18
+#define IRQ_ETH		19
+#define IRQ_AIC		20
+#define IRQ_DMAC	21
+#define IRQ_OST2	22
+#define IRQ_OST1	23
+#define IRQ_OST0	24
+#define IRQ_GPIO3	25
+#define IRQ_GPIO2	26
+#define IRQ_GPIO1	27
+#define IRQ_GPIO0	28
+#define IRQ_LCD		30
+
+
+
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+
+/* CIM Configuration Register  (CIM_CFG) */
+
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14)
+#define	CIM_CFG_HSP		(1 << 13)
+#define	CIM_CFG_PCP		(1 << 12)
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+  #define CIM_CFG_DSM_NGCM	  (3 << CIM_CFG_DSM_BIT) /* Non-Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+
+#define	CIM_CTRL_MCLKDIV_BIT	24
+#define	CIM_CTRL_MCLKDIV_MASK	(0xff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+#define	CIM_CTRL_VDDM		(1 << 13)
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_RXF_TRIG_BIT	4
+#define	CIM_CTRL_RXF_TRIG_MASK	(0x7 << CIM_CTRL_RXF_TRIG_BIT)
+  #define CIM_CTRL_RXF_TRIG_4	  (0 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 4 */
+  #define CIM_CTRL_RXF_TRIG_8	  (1 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 8 */
+  #define CIM_CTRL_RXF_TRIG_12	  (2 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 12 */
+  #define CIM_CTRL_RXF_TRIG_16	  (3 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 16 */
+  #define CIM_CTRL_RXF_TRIG_20	  (4 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 20 */
+  #define CIM_CTRL_RXF_TRIG_24	  (5 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 24 */
+  #define CIM_CTRL_RXF_TRIG_28	  (6 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 28 */
+  #define CIM_CTRL_RXF_TRIG_32	  (7 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 32 */
+#define	CIM_CTRL_DMA_EN		(1 << 2)
+#define	CIM_CTRL_RXF_RST	(1 << 1)
+#define	CIM_CTRL_ENA		(1 << 0)
+
+/* CIM State Register  (CIM_STATE) */
+
+#define	CIM_STATE_DMA_SOF	(1 << 6)
+#define	CIM_STATE_DMA_EOF	(1 << 5)
+#define	CIM_STATE_DMA_STOP	(1 << 4)
+#define	CIM_STATE_RXF_OF	(1 << 3)
+#define	CIM_STATE_RXF_TRIG	(1 << 2)
+#define	CIM_STATE_RXF_EMPTY	(1 << 1)
+#define	CIM_STATE_VDD		(1 << 0)
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31)
+#define	CIM_CMD_EOFINT		(1 << 30)
+#define	CIM_CMD_STOP		(1 << 28)
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+
+
+
+/*************************************************************************
+ * PWM
+ *************************************************************************/
+#define	PWM_CTR(n)		(PWM##n##_BASE + 0x000)
+#define	PWM_PER(n)		(PWM##n##_BASE + 0x004)
+#define	PWM_DUT(n)		(PWM##n##_BASE + 0x008)
+
+#define	REG_PWM_CTR(n)		REG8(PWM_CTR(n))
+#define	REG_PWM_PER(n)		REG16(PWM_PER(n))
+#define REG_PWM_DUT(n)		REG16(PWM_DUT(n))
+
+/* PWM Control Register (PWM_CTR) */
+
+#define	PWM_CTR_EN		(1 << 7)
+#define	PWM_CTR_SD		(1 << 6)
+#define	PWM_CTR_PRESCALE_BIT	0
+#define	PWM_CTR_PRESCALE_MASK	(0x3f << PWM_CTR_PRESCALE_BIT)
+
+/* PWM Period Register (PWM_PER) */
+
+#define	PWM_PER_PERIOD_BIT	0
+#define	PWM_PER_PERIOD_MASK	(0x3ff << PWM_PER_PERIOD_BIT)
+
+/* PWM Duty Register (PWM_DUT) */
+
+#define PWM_DUT_FDUTY		(1 << 10)
+#define PWM_DUT_DUTY_BIT	0
+#define PWM_DUT_DUTY_MASK	(0x3ff << PWM_DUT_DUTY_BIT)
+
+
+
+
+/*************************************************************************
+ * EMC
+ *************************************************************************/
+#define EMC_BCR		(EMC_BASE + 0x00)
+#define EMC_SMCR0	(EMC_BASE + 0x10)
+#define EMC_SMCR1	(EMC_BASE + 0x14)
+#define EMC_SMCR2	(EMC_BASE + 0x18)
+#define EMC_SMCR3	(EMC_BASE + 0x1c)
+#define EMC_SMCR4	(EMC_BASE + 0x20)
+#define EMC_SMCR5	(EMC_BASE + 0x24)
+#define EMC_SMCR6	(EMC_BASE + 0x28)
+#define EMC_SMCR7	(EMC_BASE + 0x2c)
+#define EMC_SACR0	(EMC_BASE + 0x30)
+#define EMC_SACR1	(EMC_BASE + 0x34)
+#define EMC_SACR2	(EMC_BASE + 0x38)
+#define EMC_SACR3	(EMC_BASE + 0x3c)
+#define EMC_SACR4	(EMC_BASE + 0x40)
+#define EMC_SACR5	(EMC_BASE + 0x44)
+#define EMC_SACR6	(EMC_BASE + 0x48)
+#define EMC_SACR7	(EMC_BASE + 0x4c)
+#define EMC_NFCSR	(EMC_BASE + 0x50)
+#define EMC_NFECC	(EMC_BASE + 0x54)
+#define EMC_PCCR1	(EMC_BASE + 0x60)
+#define EMC_PCCR2	(EMC_BASE + 0x64)
+#define EMC_PCCR3	(EMC_BASE + 0x68)
+#define EMC_PCCR4	(EMC_BASE + 0x6c)
+#define EMC_DMCR	(EMC_BASE + 0x80)
+#define EMC_RTCSR	(EMC_BASE + 0x84)
+#define EMC_RTCNT	(EMC_BASE + 0x88)
+#define EMC_RTCOR	(EMC_BASE + 0x8c)
+#define EMC_DMAR1	(EMC_BASE + 0x90)
+#define EMC_DMAR2	(EMC_BASE + 0x94)
+#define EMC_DMAR3	(EMC_BASE + 0x98)
+#define EMC_DMAR4	(EMC_BASE + 0x9c)
+
+#define EMC_SDMR0	(EMC_BASE + 0xa000)
+#define EMC_SDMR1	(EMC_BASE + 0xb000)
+#define EMC_SDMR2	(EMC_BASE + 0xc000)
+#define EMC_SDMR3	(EMC_BASE + 0xd000)
+
+/* NAND command/address/data port */
+#define NAND_DATAPORT    0xB4000000  /* read-write area */
+#define NAND_COMMPORT    0xB4040000  /* write only area */
+#define NAND_ADDRPORT    0xB4080000  /* write only area */
+
+#define REG_EMC_BCR	REG32(EMC_BCR)
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SMCR5	REG32(EMC_SMCR5)
+#define REG_EMC_SMCR6	REG32(EMC_SMCR6)
+#define REG_EMC_SMCR7	REG32(EMC_SMCR7)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+#define REG_EMC_SACR5	REG32(EMC_SACR5)
+#define REG_EMC_SACR6	REG32(EMC_SACR6)
+#define REG_EMC_SACR7	REG32(EMC_SACR7)
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+#define REG_EMC_NFECC	REG32(EMC_NFECC)
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR1	REG32(EMC_DMAR1)
+#define REG_EMC_DMAR2	REG32(EMC_DMAR2)
+#define REG_EMC_DMAR3	REG32(EMC_DMAR3)
+#define REG_EMC_DMAR4	REG32(EMC_DMAR4)
+#define REG_EMC_PCCR1	REG32(EMC_PCCR1)
+#define REG_EMC_PCCR2	REG32(EMC_PCCR2)
+#define REG_EMC_PCCR3	REG32(EMC_PCCR3)
+#define REG_EMC_PCCR4	REG32(EMC_PCCR4)
+
+
+#define EMC_BCR_BRE		(1 << 1)
+
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+#define EMC_NFCSR_RB		(1 << 7)
+#define EMC_NFCSR_BOOT_SEL_BIT	4
+#define EMC_NFCSR_BOOT_SEL_MASK	(0x07 << EMC_NFCSR_BOOT_SEL_BIT)
+#define EMC_NFCSR_ERST		(1 << 3)
+#define EMC_NFCSR_ECCE		(1 << 2)
+#define EMC_NFCSR_FCE		(1 << 1)
+#define EMC_NFCSR_NFE		(1 << 0)
+
+#define EMC_NFECC_ECC2_BIT	16
+#define EMC_NFECC_ECC2_MASK	(0xff << EMC_NFECC_ECC2_BIT)
+#define EMC_NFECC_ECC1_BIT	8
+#define EMC_NFECC_ECC1_MASK	(0xff << EMC_NFECC_ECC1_BIT)
+#define EMC_NFECC_ECC0_BIT	0
+#define EMC_NFECC_ECC0_MASK	(0xff << EMC_NFECC_ECC0_BIT)
+
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+  #define EMC_DMCR_BW_32	(0 << EMC_DMCR_BW_BIT)
+  #define EMC_DMCR_BW_16	(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+  #define EMC_DMCR_BA_2		(0 << EMC_DMCR_BA_BIT)
+  #define EMC_DMCR_BA_4		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+  #define EMC_DMCR_CASL_2	(1 << EMC_DMCR_TCL_BIT)
+  #define EMC_DMCR_CASL_3	(2 << EMC_DMCR_TCL_BIT)
+
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+#define EMC_SDMR_BM		(1 << 9)
+#define EMC_SDMR_OM_BIT		7
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_INTR	(1 << EMC_SDMR_BT_BIT)
+#define EMC_SDMR_BL_BIT		0
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+#define EMC_PCCR12_AMW		(1 << 31)
+#define EMC_PCCR12_AMAS_BIT	28
+#define EMC_PCCR12_AMAS_MASK	(0x07 << EMC_PCCR12_AMAS_BIT)
+#define EMC_PCCR12_AMAH_BIT	24
+#define EMC_PCCR12_AMAH_MASK	(0x07 << EMC_PCCR12_AMAH_BIT)
+#define EMC_PCCR12_AMPW_BIT	20
+#define EMC_PCCR12_AMPW_MASK	(0x0f << EMC_PCCR12_AMPW_BIT)
+#define EMC_PCCR12_AMRT_BIT	16
+#define EMC_PCCR12_AMRT_MASK	(0x0f << EMC_PCCR12_AMRT_BIT)
+#define EMC_PCCR12_CMW		(1 << 15)
+#define EMC_PCCR12_CMAS_BIT	12
+#define EMC_PCCR12_CMAS_MASK	(0x07 << EMC_PCCR12_CMAS_BIT)
+#define EMC_PCCR12_CMAH_BIT	8
+#define EMC_PCCR12_CMAH_MASK	(0x07 << EMC_PCCR12_CMAH_BIT)
+#define EMC_PCCR12_CMPW_BIT	4
+#define EMC_PCCR12_CMPW_MASK	(0x0f << EMC_PCCR12_CMPW_BIT)
+#define EMC_PCCR12_CMRT_BIT	0
+#define EMC_PCCR12_CMRT_MASK	(0x07 << EMC_PCCR12_CMRT_BIT)
+
+#define EMC_PCCR34_DRS_BIT	16
+#define EMC_PCCR34_DRS_MASK	(0x03 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_SPKR	(1 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_IOIS16	(2 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_INPACK	(3 << EMC_PCCR34_DRS_BIT)
+#define EMC_PCCR34_IOIS16	(1 << 15)
+#define EMC_PCCR34_IOW		(1 << 14)
+#define EMC_PCCR34_TCB_BIT	12
+#define EMC_PCCR34_TCB_MASK	(0x03 << EMC_PCCR34_TCB_BIT)
+#define EMC_PCCR34_IORT_BIT	8
+#define EMC_PCCR34_IORT_MASK	(0x07 << EMC_PCCR34_IORT_BIT)
+#define EMC_PCCR34_IOAE_BIT	6
+#define EMC_PCCR34_IOAE_MASK	(0x03 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_NONE	(0 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_1	(1 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_2	(2 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_5	(3 << EMC_PCCR34_IOAE_BIT)
+#define EMC_PCCR34_IOAH_BIT	4
+#define EMC_PCCR34_IOAH_MASK	(0x03 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_NONE	(0 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_1	(1 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_2	(2 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_5	(3 << EMC_PCCR34_IOAH_BIT)
+#define EMC_PCCR34_IOPW_BIT	0
+#define EMC_PCCR34_IOPW_MASK	(0x0f << EMC_PCCR34_IOPW_BIT)
+
+
+
+
+/*************************************************************************
+ * GPIO
+ *************************************************************************/
+#define GPIO_GPDR(n)	(GPIO_BASE + (0x00 + (n)*0x30))
+#define GPIO_GPDIR(n)	(GPIO_BASE + (0x04 + (n)*0x30))
+#define GPIO_GPODR(n)	(GPIO_BASE + (0x08 + (n)*0x30))
+#define GPIO_GPPUR(n)	(GPIO_BASE + (0x0c + (n)*0x30))
+#define GPIO_GPALR(n)	(GPIO_BASE + (0x10 + (n)*0x30))
+#define GPIO_GPAUR(n)	(GPIO_BASE + (0x14 + (n)*0x30))
+#define GPIO_GPIDLR(n)	(GPIO_BASE + (0x18 + (n)*0x30))
+#define GPIO_GPIDUR(n)	(GPIO_BASE + (0x1c + (n)*0x30))
+#define GPIO_GPIER(n)	(GPIO_BASE + (0x20 + (n)*0x30))
+#define GPIO_GPIMR(n)	(GPIO_BASE + (0x24 + (n)*0x30))
+#define GPIO_GPFR(n)	(GPIO_BASE + (0x28 + (n)*0x30))
+
+#define REG_GPIO_GPDR(n)	REG32(GPIO_GPDR((n)))
+#define REG_GPIO_GPDIR(n)	REG32(GPIO_GPDIR((n)))
+#define REG_GPIO_GPODR(n)	REG32(GPIO_GPODR((n)))
+#define REG_GPIO_GPPUR(n)	REG32(GPIO_GPPUR((n)))
+#define REG_GPIO_GPALR(n)	REG32(GPIO_GPALR((n)))
+#define REG_GPIO_GPAUR(n)	REG32(GPIO_GPAUR((n)))
+#define REG_GPIO_GPIDLR(n)	REG32(GPIO_GPIDLR((n)))
+#define REG_GPIO_GPIDUR(n)	REG32(GPIO_GPIDUR((n)))
+#define REG_GPIO_GPIER(n)	REG32(GPIO_GPIER((n)))
+#define REG_GPIO_GPIMR(n)	REG32(GPIO_GPIMR((n)))
+#define REG_GPIO_GPFR(n)	REG32(GPIO_GPFR((n)))
+
+#define GPIO_IRQ_LOLEVEL  0
+#define GPIO_IRQ_HILEVEL  1
+#define GPIO_IRQ_FALLEDG  2
+#define GPIO_IRQ_RAISEDG  3
+
+#define IRQ_GPIO_0	48
+#define NUM_GPIO	100
+
+#define GPIO_GPDR0      GPIO_GPDR(0)
+#define GPIO_GPDR1      GPIO_GPDR(1)
+#define GPIO_GPDR2      GPIO_GPDR(2)
+#define GPIO_GPDR3      GPIO_GPDR(3)
+#define GPIO_GPDIR0     GPIO_GPDIR(0)
+#define GPIO_GPDIR1     GPIO_GPDIR(1)
+#define GPIO_GPDIR2     GPIO_GPDIR(2)
+#define GPIO_GPDIR3     GPIO_GPDIR(3)
+#define GPIO_GPODR0     GPIO_GPODR(0)
+#define GPIO_GPODR1     GPIO_GPODR(1)
+#define GPIO_GPODR2     GPIO_GPODR(2)
+#define GPIO_GPODR3     GPIO_GPODR(3)
+#define GPIO_GPPUR0     GPIO_GPPUR(0)
+#define GPIO_GPPUR1     GPIO_GPPUR(1)
+#define GPIO_GPPUR2     GPIO_GPPUR(2)
+#define GPIO_GPPUR3     GPIO_GPPUR(3)
+#define GPIO_GPALR0     GPIO_GPALR(0)
+#define GPIO_GPALR1     GPIO_GPALR(1)
+#define GPIO_GPALR2     GPIO_GPALR(2)
+#define GPIO_GPALR3     GPIO_GPALR(3)
+#define GPIO_GPAUR0     GPIO_GPAUR(0)
+#define GPIO_GPAUR1     GPIO_GPAUR(1)
+#define GPIO_GPAUR2     GPIO_GPAUR(2)
+#define GPIO_GPAUR3     GPIO_GPAUR(3)
+#define GPIO_GPIDLR0    GPIO_GPIDLR(0)
+#define GPIO_GPIDLR1    GPIO_GPIDLR(1)
+#define GPIO_GPIDLR2    GPIO_GPIDLR(2)
+#define GPIO_GPIDLR3    GPIO_GPIDLR(3)
+#define GPIO_GPIDUR0    GPIO_GPIDUR(0)
+#define GPIO_GPIDUR1    GPIO_GPIDUR(1)
+#define GPIO_GPIDUR2    GPIO_GPIDUR(2)
+#define GPIO_GPIDUR3    GPIO_GPIDUR(3)
+#define GPIO_GPIER0     GPIO_GPIER(0)
+#define GPIO_GPIER1     GPIO_GPIER(1)
+#define GPIO_GPIER2     GPIO_GPIER(2)
+#define GPIO_GPIER3     GPIO_GPIER(3)
+#define GPIO_GPIMR0     GPIO_GPIMR(0)
+#define GPIO_GPIMR1     GPIO_GPIMR(1)
+#define GPIO_GPIMR2     GPIO_GPIMR(2)
+#define GPIO_GPIMR3     GPIO_GPIMR(3)
+#define GPIO_GPFR0      GPIO_GPFR(0)
+#define GPIO_GPFR1      GPIO_GPFR(1)
+#define GPIO_GPFR2      GPIO_GPFR(2)
+#define GPIO_GPFR3      GPIO_GPFR(3)
+
+
+/*************************************************************************
+ * HARB
+ *************************************************************************/
+#define	HARB_HAPOR		(HARB_BASE + 0x000)
+#define	HARB_HMCTR		(HARB_BASE + 0x010)
+#define	HARB_HME8H		(HARB_BASE + 0x014)
+#define	HARB_HMCR1		(HARB_BASE + 0x018)
+#define	HARB_HMER2		(HARB_BASE + 0x01C)
+#define	HARB_HMER3		(HARB_BASE + 0x020)
+#define	HARB_HMLTR		(HARB_BASE + 0x024)
+
+#define	REG_HARB_HAPOR		REG32(HARB_HAPOR)
+#define	REG_HARB_HMCTR		REG32(HARB_HMCTR)
+#define	REG_HARB_HME8H		REG32(HARB_HME8H)
+#define	REG_HARB_HMCR1		REG32(HARB_HMCR1)
+#define	REG_HARB_HMER2		REG32(HARB_HMER2)
+#define	REG_HARB_HMER3		REG32(HARB_HMER3)
+#define	REG_HARB_HMLTR		REG32(HARB_HMLTR)
+
+/* HARB Priority Order Register (HARB_HAPOR) */
+
+#define	HARB_HAPOR_UCHSEL 		(1 << 7)
+#define	HARB_HAPOR_PRIO_BIT		0
+#define	HARB_HAPOR_PRIO_MASK		(0xf << HARB_HAPOR_PRIO_BIT)
+
+/* AHB Monitor Control Register (HARB_HMCTR) */
+
+#define	HARB_HMCTR_HET3_BIT		20
+#define	HARB_HMCTR_HET3_MASK		(0xf << HARB_HMCTR_HET3_BIT)
+#define	HARB_HMCTR_HMS3_BIT		16
+#define	HARB_HMCTR_HMS3_MASK		(0xf << HARB_HMCTR_HMS3_BIT)
+#define	HARB_HMCTR_HET2_BIT		12
+#define	HARB_HMCTR_HET2_MASK		(0xf << HARB_HMCTR_HET2_BIT)
+#define	HARB_HMCTR_HMS2_BIT		8
+#define	HARB_HMCTR_HMS2_MASK		(0xf << HARB_HMCTR_HMS2_BIT)
+#define	HARB_HMCTR_HOVF3		(1 << 7)
+#define	HARB_HMCTR_HOVF2		(1 << 6)
+#define	HARB_HMCTR_HOVF1		(1 << 5)
+#define	HARB_HMCTR_HRST			(1 << 4)
+#define	HARB_HMCTR_HEE3			(1 << 2)
+#define	HARB_HMCTR_HEE2			(1 << 1)
+#define	HARB_HMCTR_HEE1			(1 << 0)
+
+/* AHB Monitor Event 8bits High Register (HARB_HME8H) */
+
+#define HARB_HME8H_HC8H1_BIT		16
+#define HARB_HME8H_HC8H1_MASK		(0xff << HARB_HME8H_HC8H1_BIT)
+#define HARB_HME8H_HC8H2_BIT		8
+#define HARB_HME8H_HC8H2_MASK		(0xff << HARB_HME8H_HC8H2_BIT)
+#define HARB_HME8H_HC8H3_BIT		0
+#define HARB_HME8H_HC8H3_MASK		(0xff << HARB_HME8H_HC8H3_BIT)
+
+/* AHB Monitor Latency Register (HARB_HMLTR) */
+
+#define HARB_HMLTR_HLT2_BIT		16
+#define HARB_HMLTR_HLT2_MASK		(0xffff << HARB_HMLTR_HLT2_BIT)
+#define HARB_HMLTR_HLT3_BIT		0
+#define HARB_HMLTR_HLT3_MASK		(0xffff << HARB_HMLTR_HLT3_BIT)
+
+
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * UDC
+ *************************************************************************/
+#define UDC_EP0InCR	(UDC_BASE + 0x00)
+#define UDC_EP0InSR	(UDC_BASE + 0x04)
+#define UDC_EP0InBSR	(UDC_BASE + 0x08)
+#define UDC_EP0InMPSR	(UDC_BASE + 0x0c)
+#define UDC_EP0InDesR	(UDC_BASE + 0x14)
+#define UDC_EP1InCR	(UDC_BASE + 0x20)
+#define UDC_EP1InSR	(UDC_BASE + 0x24)
+#define UDC_EP1InBSR	(UDC_BASE + 0x28)
+#define UDC_EP1InMPSR	(UDC_BASE + 0x2c)
+#define UDC_EP1InDesR	(UDC_BASE + 0x34)
+#define UDC_EP2InCR	(UDC_BASE + 0x40)
+#define UDC_EP2InSR	(UDC_BASE + 0x44)
+#define UDC_EP2InBSR	(UDC_BASE + 0x48)
+#define UDC_EP2InMPSR	(UDC_BASE + 0x4c)
+#define UDC_EP2InDesR	(UDC_BASE + 0x54)
+#define UDC_EP3InCR	(UDC_BASE + 0x60)
+#define UDC_EP3InSR	(UDC_BASE + 0x64)
+#define UDC_EP3InBSR	(UDC_BASE + 0x68)
+#define UDC_EP3InMPSR	(UDC_BASE + 0x6c)
+#define UDC_EP3InDesR	(UDC_BASE + 0x74)
+#define UDC_EP4InCR	(UDC_BASE + 0x80)
+#define UDC_EP4InSR	(UDC_BASE + 0x84)
+#define UDC_EP4InBSR	(UDC_BASE + 0x88)
+#define UDC_EP4InMPSR	(UDC_BASE + 0x8c)
+#define UDC_EP4InDesR	(UDC_BASE + 0x94)
+
+#define UDC_EP0OutCR	(UDC_BASE + 0x200)
+#define UDC_EP0OutSR	(UDC_BASE + 0x204)
+#define UDC_EP0OutPFNR	(UDC_BASE + 0x208)
+#define UDC_EP0OutMPSR	(UDC_BASE + 0x20c)
+#define UDC_EP0OutSBPR	(UDC_BASE + 0x210)
+#define UDC_EP0OutDesR	(UDC_BASE + 0x214)
+#define UDC_EP5OutCR	(UDC_BASE + 0x2a0)
+#define UDC_EP5OutSR	(UDC_BASE + 0x2a4)
+#define UDC_EP5OutPFNR	(UDC_BASE + 0x2a8)
+#define UDC_EP5OutMPSR	(UDC_BASE + 0x2ac)
+#define UDC_EP5OutDesR	(UDC_BASE + 0x2b4)
+#define UDC_EP6OutCR	(UDC_BASE + 0x2c0)
+#define UDC_EP6OutSR	(UDC_BASE + 0x2c4)
+#define UDC_EP6OutPFNR	(UDC_BASE + 0x2c8)
+#define UDC_EP6OutMPSR	(UDC_BASE + 0x2cc)
+#define UDC_EP6OutDesR	(UDC_BASE + 0x2d4)
+#define UDC_EP7OutCR	(UDC_BASE + 0x2e0)
+#define UDC_EP7OutSR	(UDC_BASE + 0x2e4)
+#define UDC_EP7OutPFNR	(UDC_BASE + 0x2e8)
+#define UDC_EP7OutMPSR	(UDC_BASE + 0x2ec)
+#define UDC_EP7OutDesR	(UDC_BASE + 0x2f4)
+
+#define UDC_DevCFGR	(UDC_BASE + 0x400)
+#define UDC_DevCR	(UDC_BASE + 0x404)
+#define UDC_DevSR	(UDC_BASE + 0x408)
+#define UDC_DevIntR	(UDC_BASE + 0x40c)
+#define UDC_DevIntMR	(UDC_BASE + 0x410)
+#define UDC_EPIntR	(UDC_BASE + 0x414)
+#define UDC_EPIntMR	(UDC_BASE + 0x418)
+
+#define UDC_STCMAR	(UDC_BASE + 0x500)
+#define UDC_EP0InfR	(UDC_BASE + 0x504)
+#define UDC_EP1InfR	(UDC_BASE + 0x508)
+#define UDC_EP2InfR	(UDC_BASE + 0x50c)
+#define UDC_EP3InfR	(UDC_BASE + 0x510)
+#define UDC_EP4InfR	(UDC_BASE + 0x514)
+#define UDC_EP5InfR	(UDC_BASE + 0x518)
+#define UDC_EP6InfR	(UDC_BASE + 0x51c)
+#define UDC_EP7InfR	(UDC_BASE + 0x520)
+
+#define UDC_TXCONFIRM	(UDC_BASE + 0x41C)
+#define UDC_TXZLP	(UDC_BASE + 0x420)
+#define UDC_RXCONFIRM	(UDC_BASE + 0x41C)
+
+#define UDC_RXFIFO	(UDC_BASE + 0x800)
+#define UDC_TXFIFOEP0	(UDC_BASE + 0x840)
+
+#define REG_UDC_EP0InCR		REG32(UDC_EP0InCR)
+#define REG_UDC_EP0InSR		REG32(UDC_EP0InSR)
+#define REG_UDC_EP0InBSR	REG32(UDC_EP0InBSR)
+#define REG_UDC_EP0InMPSR	REG32(UDC_EP0InMPSR)
+#define REG_UDC_EP0InDesR	REG32(UDC_EP0InDesR)
+#define REG_UDC_EP1InCR		REG32(UDC_EP1InCR)
+#define REG_UDC_EP1InSR		REG32(UDC_EP1InSR)
+#define REG_UDC_EP1InBSR	REG32(UDC_EP1InBSR)
+#define REG_UDC_EP1InMPSR	REG32(UDC_EP1InMPSR)
+#define REG_UDC_EP1InDesR	REG32(UDC_EP1InDesR)
+#define REG_UDC_EP2InCR		REG32(UDC_EP2InCR)
+#define REG_UDC_EP2InSR		REG32(UDC_EP2InSR)
+#define REG_UDC_EP2InBSR	REG32(UDC_EP2InBSR)
+#define REG_UDC_EP2InMPSR	REG32(UDC_EP2InMPSR)
+#define REG_UDC_EP2InDesR	REG32(UDC_EP2InDesR)
+#define REG_UDC_EP3InCR		REG32(UDC_EP3InCR)
+#define REG_UDC_EP3InSR		REG32(UDC_EP3InSR)
+#define REG_UDC_EP3InBSR	REG32(UDC_EP3InBSR)
+#define REG_UDC_EP3InMPSR	REG32(UDC_EP3InMPSR)
+#define REG_UDC_EP3InDesR	REG32(UDC_EP3InDesR)
+#define REG_UDC_EP4InCR		REG32(UDC_EP4InCR)
+#define REG_UDC_EP4InSR		REG32(UDC_EP4InSR)
+#define REG_UDC_EP4InBSR	REG32(UDC_EP4InBSR)
+#define REG_UDC_EP4InMPSR	REG32(UDC_EP4InMPSR)
+#define REG_UDC_EP4InDesR	REG32(UDC_EP4InDesR)
+
+#define REG_UDC_EP0OutCR	REG32(UDC_EP0OutCR)
+#define REG_UDC_EP0OutSR	REG32(UDC_EP0OutSR)
+#define REG_UDC_EP0OutPFNR	REG32(UDC_EP0OutPFNR)
+#define REG_UDC_EP0OutMPSR	REG32(UDC_EP0OutMPSR)
+#define REG_UDC_EP0OutSBPR	REG32(UDC_EP0OutSBPR)
+#define REG_UDC_EP0OutDesR	REG32(UDC_EP0OutDesR)
+#define REG_UDC_EP5OutCR	REG32(UDC_EP5OutCR)
+#define REG_UDC_EP5OutSR	REG32(UDC_EP5OutSR)
+#define REG_UDC_EP5OutPFNR	REG32(UDC_EP5OutPFNR)
+#define REG_UDC_EP5OutMPSR	REG32(UDC_EP5OutMPSR)
+#define REG_UDC_EP5OutDesR	REG32(UDC_EP5OutDesR)
+#define REG_UDC_EP6OutCR	REG32(UDC_EP6OutCR)
+#define REG_UDC_EP6OutSR	REG32(UDC_EP6OutSR)
+#define REG_UDC_EP6OutPFNR	REG32(UDC_EP6OutPFNR)
+#define REG_UDC_EP6OutMPSR	REG32(UDC_EP6OutMPSR)
+#define REG_UDC_EP6OutDesR	REG32(UDC_EP6OutDesR)
+#define REG_UDC_EP7OutCR	REG32(UDC_EP7OutCR)
+#define REG_UDC_EP7OutSR	REG32(UDC_EP7OutSR)
+#define REG_UDC_EP7OutPFNR	REG32(UDC_EP7OutPFNR)
+#define REG_UDC_EP7OutMPSR	REG32(UDC_EP7OutMPSR)
+#define REG_UDC_EP7OutDesR	REG32(UDC_EP7OutDesR)
+
+#define REG_UDC_DevCFGR		REG32(UDC_DevCFGR)
+#define REG_UDC_DevCR		REG32(UDC_DevCR)
+#define REG_UDC_DevSR		REG32(UDC_DevSR)
+#define REG_UDC_DevIntR		REG32(UDC_DevIntR)
+#define REG_UDC_DevIntMR	REG32(UDC_DevIntMR)
+#define REG_UDC_EPIntR		REG32(UDC_EPIntR)
+#define REG_UDC_EPIntMR		REG32(UDC_EPIntMR)
+
+#define REG_UDC_STCMAR		REG32(UDC_STCMAR)
+#define REG_UDC_EP0InfR		REG32(UDC_EP0InfR)
+#define REG_UDC_EP1InfR		REG32(UDC_EP1InfR)
+#define REG_UDC_EP2InfR		REG32(UDC_EP2InfR)
+#define REG_UDC_EP3InfR		REG32(UDC_EP3InfR)
+#define REG_UDC_EP4InfR		REG32(UDC_EP4InfR)
+#define REG_UDC_EP5InfR		REG32(UDC_EP5InfR)
+#define REG_UDC_EP6InfR		REG32(UDC_EP6InfR)
+#define REG_UDC_EP7InfR		REG32(UDC_EP7InfR)
+
+#define UDC_DevCFGR_PI		(1 << 5)
+#define UDC_DevCFGR_SS		(1 << 4)
+#define UDC_DevCFGR_SP		(1 << 3)
+#define UDC_DevCFGR_RW		(1 << 2)
+#define UDC_DevCFGR_SPD_BIT	0
+#define UDC_DevCFGR_SPD_MASK	(0x03 << UDC_DevCFGR_SPD_BIT)
+  #define UDC_DevCFGR_SPD_HS	(0 << UDC_DevCFGR_SPD_BIT)
+  #define UDC_DevCFGR_SPD_LS	(2 << UDC_DevCFGR_SPD_BIT)
+  #define UDC_DevCFGR_SPD_FS	(3 << UDC_DevCFGR_SPD_BIT)
+
+#define UDC_DevCR_DM		(1 << 9)
+#define UDC_DevCR_BE		(1 << 5)
+#define UDC_DevCR_RES		(1 << 0)
+
+#define UDC_DevSR_ENUMSPD_BIT	13
+#define UDC_DevSR_ENUMSPD_MASK	(0x03 << UDC_DevSR_ENUMSPD_BIT)
+  #define UDC_DevSR_ENUMSPD_HS	(0 << UDC_DevSR_ENUMSPD_BIT)
+  #define UDC_DevSR_ENUMSPD_LS	(2 << UDC_DevSR_ENUMSPD_BIT)
+  #define UDC_DevSR_ENUMSPD_FS	(3 << UDC_DevSR_ENUMSPD_BIT)
+#define UDC_DevSR_SUSP		(1 << 12)
+#define UDC_DevSR_ALT_BIT	8
+#define UDC_DevSR_ALT_MASK	(0x0f << UDC_DevSR_ALT_BIT)
+#define UDC_DevSR_INTF_BIT	4
+#define UDC_DevSR_INTF_MASK	(0x0f << UDC_DevSR_INTF_BIT)
+#define UDC_DevSR_CFG_BIT	0
+#define UDC_DevSR_CFG_MASK	(0x0f << UDC_DevSR_CFG_BIT)
+
+#define UDC_DevIntR_ENUM	(1 << 6)
+#define UDC_DevIntR_SOF		(1 << 5)
+#define UDC_DevIntR_US		(1 << 4)
+#define UDC_DevIntR_UR		(1 << 3)
+#define UDC_DevIntR_SI		(1 << 1)
+#define UDC_DevIntR_SC		(1 << 0)
+
+#define UDC_EPIntR_OUTEP_BIT	16
+#define UDC_EPIntR_OUTEP_MASK	(0xffff << UDC_EPIntR_OUTEP_BIT)
+#define UDC_EPIntR_OUTEP0       0x00010000
+#define UDC_EPIntR_OUTEP5       0x00200000
+#define UDC_EPIntR_OUTEP6       0x00400000
+#define UDC_EPIntR_OUTEP7       0x00800000
+#define UDC_EPIntR_INEP_BIT	0
+#define UDC_EPIntR_INEP_MASK	(0xffff << UDC_EPIntR_INEP_BIT)
+#define UDC_EPIntR_INEP0        0x00000001
+#define UDC_EPIntR_INEP1        0x00000002
+#define UDC_EPIntR_INEP2        0x00000004
+#define UDC_EPIntR_INEP3        0x00000008
+#define UDC_EPIntR_INEP4        0x00000010
+
+
+#define UDC_EPIntMR_OUTEP_BIT	16
+#define UDC_EPIntMR_OUTEP_MASK	(0xffff << UDC_EPIntMR_OUTEP_BIT)
+#define UDC_EPIntMR_INEP_BIT	0
+#define UDC_EPIntMR_INEP_MASK	(0xffff << UDC_EPIntMR_INEP_BIT)
+
+#define UDC_EPCR_ET_BIT		4
+#define UDC_EPCR_ET_MASK	(0x03 << UDC_EPCR_ET_BIT)
+  #define UDC_EPCR_ET_CTRL	(0 << UDC_EPCR_ET_BIT)
+  #define UDC_EPCR_ET_ISO	(1 << UDC_EPCR_ET_BIT)
+  #define UDC_EPCR_ET_BULK	(2 << UDC_EPCR_ET_BIT)
+  #define UDC_EPCR_ET_INTR	(3 << UDC_EPCR_ET_BIT)
+#define UDC_EPCR_SN		(1 << 2)
+#define UDC_EPCR_F		(1 << 1)
+#define UDC_EPCR_S		(1 << 0)
+
+#define UDC_EPSR_RXPKTSIZE_BIT	11
+#define UDC_EPSR_RXPKTSIZE_MASK	(0x7ff << UDC_EPSR_RXPKTSIZE_BIT)
+#define UDC_EPSR_IN		(1 << 6)
+#define UDC_EPSR_OUT_BIT	4
+#define UDC_EPSR_OUT_MASK	(0x03 << UDC_EPSR_OUT_BIT)
+  #define UDC_EPSR_OUT_NONE	(0 << UDC_EPSR_OUT_BIT)
+  #define UDC_EPSR_OUT_RCVDATA	(1 << UDC_EPSR_OUT_BIT)
+  #define UDC_EPSR_OUT_RCVSETUP	(2 << UDC_EPSR_OUT_BIT)
+#define UDC_EPSR_PID_BIT	0
+#define UDC_EPSR_PID_MASK	(0x0f << UDC_EPSR_PID_BIT)
+
+#define UDC_EPInfR_MPS_BIT	19
+#define UDC_EPInfR_MPS_MASK	(0x3ff << UDC_EPInfR_MPS_BIT)
+#define UDC_EPInfR_ALTS_BIT	15
+#define UDC_EPInfR_ALTS_MASK	(0x0f << UDC_EPInfR_ALTS_BIT)
+#define UDC_EPInfR_IFN_BIT	11
+#define UDC_EPInfR_IFN_MASK	(0x0f << UDC_EPInfR_IFN_BIT)
+#define UDC_EPInfR_CGN_BIT	7
+#define UDC_EPInfR_CGN_MASK	(0x0f << UDC_EPInfR_CGN_BIT)
+#define UDC_EPInfR_EPT_BIT	5
+#define UDC_EPInfR_EPT_MASK	(0x03 << UDC_EPInfR_EPT_BIT)
+  #define UDC_EPInfR_EPT_CTRL	(0 << UDC_EPInfR_EPT_BIT)
+  #define UDC_EPInfR_EPT_ISO	(1 << UDC_EPInfR_EPT_BIT)
+  #define UDC_EPInfR_EPT_BULK	(2 << UDC_EPInfR_EPT_BIT)
+  #define UDC_EPInfR_EPT_INTR	(3 << UDC_EPInfR_EPT_BIT)
+#define UDC_EPInfR_EPD		(1 << 4)
+  #define UDC_EPInfR_EPD_OUT	(0 << 4)
+  #define UDC_EPInfR_EPD_IN	(1 << 4)
+
+#define UDC_EPInfR_EPN_BIT	0
+#define UDC_EPInfR_EPN_MASK	(0xf << UDC_EPInfR_EPN_BIT)
+
+
+
+
+/*************************************************************************
+ * DMAC 
+ *************************************************************************/
+#define DMAC_DSAR(n)	(DMAC_BASE + (0x00 + (n) * 0x20))
+#define DMAC_DDAR(n)	(DMAC_BASE + (0x04 + (n) * 0x20))
+#define DMAC_DTCR(n)	(DMAC_BASE + (0x08 + (n) * 0x20))
+#define DMAC_DRSR(n)	(DMAC_BASE + (0x0c + (n) * 0x20))
+#define DMAC_DCCSR(n)	(DMAC_BASE + (0x10 + (n) * 0x20))
+#define DMAC_DMAIPR	(DMAC_BASE + 0xf8)
+#define DMAC_DMACR	(DMAC_BASE + 0xfc)
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DDAR(n)	REG32(DMAC_DDAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DMAIPR		REG32(DMAC_DMAIPR)
+#define REG_DMAC_DMACR		REG32(DMAC_DMACR)
+
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x1f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_EXTREXTR		(0 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PCMCIAOUT	(4 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PCMCIAIN		(5 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO		(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_DESOUT		(10 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_DESIN		(11 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3OUT		(14 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3IN		(15 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2OUT		(16 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2IN		(17 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1OUT		(18 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1IN		(19 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT		(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN		(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIOUT		(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIIN		(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT		(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN		(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCOUT		(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCIN		(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_OST2		(28 << DMAC_DRSR_RS_BIT)
+
+#define DMAC_DCCSR_EACKS	(1 << 31)
+#define DMAC_DCCSR_EACKM	(1 << 30)
+#define DMAC_DCCSR_ERDM_BIT	28
+#define DMAC_DCCSR_ERDM_MASK	(0x03 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_LLEVEL	(0 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_FEDGE		(1 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_HLEVEL	(2 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_REDGE		(3 << DMAC_DCCSR_ERDM_BIT)
+#define DMAC_DCCSR_EOPM		(1 << 27)
+#define DMAC_DCCSR_SAM		(1 << 23)
+#define DMAC_DCCSR_DAM		(1 << 22)
+#define DMAC_DCCSR_RDIL_BIT	16
+#define DMAC_DCCSR_RDIL_MASK	(0x0f << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_IGN	(0 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_2	(1 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_4	(2 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_8	(3 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_12	(4 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_16	(5 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_20	(6 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_24	(7 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_28	(8 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_32	(9 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_48	(10 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_60	(11 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_64	(12 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_124	(13 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_128	(14 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_200	(15 << DMAC_DCCSR_RDIL_BIT)
+#define DMAC_DCCSR_SWDH_BIT	14
+#define DMAC_DCCSR_SWDH_MASK	(0x03 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_32	(0 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_8	(1 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_16	(2 << DMAC_DCCSR_SWDH_BIT)
+#define DMAC_DCCSR_DWDH_BIT	12
+#define DMAC_DCCSR_DWDH_MASK	(0x03 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_32	(0 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_8	(1 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_16	(2 << DMAC_DCCSR_DWDH_BIT)
+#define DMAC_DCCSR_DS_BIT	8
+#define DMAC_DCCSR_DS_MASK	(0x07 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_32b	(0 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_8b	(1 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_16b	(2 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_16B	(3 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_32B	(4 << DMAC_DCCSR_DS_BIT)
+#define DMAC_DCCSR_TM		(1 << 7)
+#define DMAC_DCCSR_AR		(1 << 4)
+#define DMAC_DCCSR_TC		(1 << 3)
+#define DMAC_DCCSR_HLT		(1 << 2)
+#define DMAC_DCCSR_TCIE		(1 << 1)
+#define DMAC_DCCSR_CHDE		(1 << 0)
+
+#define DMAC_DMAIPR_CINT_BIT	8
+#define DMAC_DMAIPR_CINT_MASK	(0xff << DMAC_DMAIPR_CINT_BIT)
+
+#define DMAC_DMACR_PR_BIT	8
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_01234567	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_02314675	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_20136457	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_ROUNDROBIN	(3 << DMAC_DMACR_PR_BIT)
+#define DMAC_DMACR_HTR		(1 << 3)
+#define DMAC_DMACR_AER		(1 << 2)
+#define DMAC_DMACR_DME		(1 << 0)
+
+#define IRQ_DMA_0	32
+#define NUM_DMA		6
+
+
+/*************************************************************************
+ * AIC 
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_AUSEL		(1 << 4)
+#define	AIC_FR_RST		(1 << 3)
+#define	AIC_FR_BCKD		(1 << 2)
+#define	AIC_FR_SYNCD		(1 << 1)
+#define	AIC_FR_ENB		(1 << 0)
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_RDMS		(1 << 15)
+#define	AIC_CR_TDMS		(1 << 14)
+#define	AIC_CR_FLUSH		(1 << 8)
+#define	AIC_CR_EROR		(1 << 6)
+#define	AIC_CR_ETUR		(1 << 5)
+#define	AIC_CR_ERFS		(1 << 4)
+#define	AIC_CR_ETFS		(1 << 3)
+#define	AIC_CR_ENLBF		(1 << 2)
+#define	AIC_CR_ERPL		(1 << 1)
+#define	AIC_CR_EREC		(1 << 0)
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit */
+#define	AIC_ACCR1_XS_BIT	0
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18)
+#define	AIC_ACCR2_ESADR		(1 << 17)
+#define	AIC_ACCR2_ECADT		(1 << 16)
+#define	AIC_ACCR2_OASS_BIT	8
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)
+#define	AIC_ACCR2_SR		(1 << 2)
+#define	AIC_ACCR2_SS		(1 << 1)
+#define	AIC_ACCR2_SA		(1 << 0)
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12)
+#define	AIC_I2SCR_WL_BIT	1
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0)
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24
+#define	AIC_SR_RFL_MASK		(0x1f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8
+#define	AIC_SR_TFL_MASK		(0x1f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6)
+#define	AIC_SR_TUR		(1 << 5)
+#define	AIC_SR_RFS		(1 << 4)
+#define	AIC_SR_TFS		(1 << 3)
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_CRDY		(1 << 20)
+#define	AIC_ACSR_CLPM		(1 << 19)
+#define	AIC_ACSR_RSTO		(1 << 18)
+#define	AIC_ACSR_SADR		(1 << 17)
+#define	AIC_ACSR_CADT		(1 << 16)
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+
+
+/*************************************************************************
+ * LCD 
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00)
+#define LCD_VSYNC	(LCD_BASE + 0x04)
+#define LCD_HSYNC	(LCD_BASE + 0x08)
+#define LCD_VAT		(LCD_BASE + 0x0c)
+#define LCD_DAH		(LCD_BASE + 0x10)
+#define LCD_DAV		(LCD_BASE + 0x14)
+#define LCD_PS		(LCD_BASE + 0x18)
+#define LCD_CLS		(LCD_BASE + 0x1c)
+#define LCD_SPL		(LCD_BASE + 0x20)
+#define LCD_REV		(LCD_BASE + 0x24)
+#define LCD_CTRL	(LCD_BASE + 0x30)
+#define LCD_STATE	(LCD_BASE + 0x34)
+#define LCD_IID		(LCD_BASE + 0x38)
+#define LCD_DA0		(LCD_BASE + 0x40)
+#define LCD_SA0		(LCD_BASE + 0x44)
+#define LCD_FID0	(LCD_BASE + 0x48)
+#define LCD_CMD0	(LCD_BASE + 0x4c)
+#define LCD_DA1		(LCD_BASE + 0x50)
+#define LCD_SA1		(LCD_BASE + 0x54)
+#define LCD_FID1	(LCD_BASE + 0x58)
+#define LCD_CMD1	(LCD_BASE + 0x5c)
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+#define LCD_CFG_PDW_BIT		4
+#define LCD_CFG_PDW_MASK	(0x03 << LCD_DEV_PDW_BIT)
+  #define LCD_CFG_PDW_1		(0 << LCD_DEV_PDW_BIT)
+  #define LCD_CFG_PDW_2		(1 << LCD_DEV_PDW_BIT)
+  #define LCD_CFG_PDW_4		(2 << LCD_DEV_PDW_BIT)
+  #define LCD_CFG_PDW_8		(3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_MODE_BIT	0
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_SHARP_HR		(1 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_CASIO_TFT	(2 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_SAMSUNG_ALPHA	(3 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(5 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_DEV_MODE_BIT)
+
+#define LCD_VSYNC_VPS_BIT	16
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+#define LCD_HSYNC_HPS_BIT	16
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+#define LCD_VAT_HT_BIT		16
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+#define LCD_DAH_HDS_BIT		16
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+#define LCD_DAV_VDS_BIT		16
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+#define LCD_CTRL_BST_BIT	28
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT)
+#define LCD_CTRL_RGB555		(1 << 27)
+#define LCD_CTRL_OFUP		(1 << 26)
+#define LCD_CTRL_FRC_BIT	24
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT)
+#define LCD_CTRL_PDD_BIT	16
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13)
+#define LCD_CTRL_SOFM		(1 << 12)
+#define LCD_CTRL_OFUM		(1 << 11)
+#define LCD_CTRL_IFUM0		(1 << 10)
+#define LCD_CTRL_IFUM1		(1 << 9)
+#define LCD_CTRL_LDDM		(1 << 8)
+#define LCD_CTRL_QDM		(1 << 7)
+#define LCD_CTRL_BEDN		(1 << 6)
+#define LCD_CTRL_PEDN		(1 << 5)
+#define LCD_CTRL_DIS		(1 << 4)
+#define LCD_CTRL_ENA		(1 << 3)
+#define LCD_CTRL_BPP_BIT	0
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT)
+
+#define LCD_STATE_QD		(1 << 7)
+#define LCD_STATE_EOF		(1 << 5)
+#define LCD_STATE_SOF		(1 << 4)
+#define LCD_STATE_OFU		(1 << 3)
+#define LCD_STATE_IFU0		(1 << 2)
+#define LCD_STATE_IFU1		(1 << 1)
+#define LCD_STATE_LDD		(1 << 0)
+
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+
+
+
+/*************************************************************************
+ * DES
+ *************************************************************************/
+#define	DES_CR1			(DES_BASE + 0x000)
+#define	DES_CR2			(DES_BASE + 0x004)
+#define	DES_SR			(DES_BASE + 0x008)
+#define	DES_K1L			(DES_BASE + 0x010)
+#define	DES_K1R			(DES_BASE + 0x014)
+#define	DES_K2L			(DES_BASE + 0x018)
+#define	DES_K2R			(DES_BASE + 0x01C)
+#define	DES_K3L			(DES_BASE + 0x020)
+#define	DES_K3R			(DES_BASE + 0x024)
+#define	DES_IVL			(DES_BASE + 0x028)
+#define	DES_IVR			(DES_BASE + 0x02C)
+#define	DES_DIN			(DES_BASE + 0x030)
+#define	DES_DOUT		(DES_BASE + 0x034)
+
+#define REG_DES_CR1		REG32(DES_CR1)
+#define REG_DES_CR2		REG32(DES_CR2)
+#define REG_DES_SR		REG32(DES_SR)
+#define REG_DES_K1L		REG32(DES_K1L)
+#define REG_DES_K1R		REG32(DES_K1R)
+#define REG_DES_K2L		REG32(DES_K2L)
+#define REG_DES_K2R		REG32(DES_K2R)
+#define REG_DES_K3L		REG32(DES_K3L)
+#define REG_DES_K3R		REG32(DES_K3R)
+#define REG_DES_IVL		REG32(DES_IVL)
+#define REG_DES_IVR		REG32(DES_IVR)
+#define REG_DES_DIN		REG32(DES_DIN)
+#define REG_DES_DOUT		REG32(DES_DOUT)
+
+/* DES Control Register 1 (DES_CR1) */
+
+#define	DES_CR1_EN 		(1 << 0)
+
+/* DES Control Register 2 (DES_CR2) */
+
+#define	DES_CR2_ENDEC 		(1 << 3)
+#define	DES_CR2_MODE 		(1 << 2)
+#define	DES_CR2_ALG 		(1 << 1)
+#define	DES_CR2_DMAE		(1 << 0)
+
+/* DES State Register (DES_SR) */
+
+#define DES_SR_IN_FULL		(1 << 5)
+#define DES_SR_IN_LHF		(1 << 4)
+#define DES_SR_IN_EMPTY		(1 << 3)
+#define DES_SR_OUT_FULL		(1 << 2)
+#define DES_SR_OUT_GHF		(1 << 1)
+#define DES_SR_OUT_EMPTY	(1 << 0)
+
+
+
+
+/*************************************************************************
+ * CPM
+ *************************************************************************/
+#define CPM_CFCR	(CPM_BASE+0x00)
+#define CPM_PLCR1	(CPM_BASE+0x10)
+#define CPM_OCR		(CPM_BASE+0x1c)
+#define CPM_CFCR2	(CPM_BASE+0x60)
+#define CPM_LPCR	(CPM_BASE+0x04)
+#define CPM_RSTR	(CPM_BASE+0x08)
+#define CPM_MSCR	(CPM_BASE+0x20)
+#define CPM_SCR		(CPM_BASE+0x24)
+#define CPM_WRER	(CPM_BASE+0x28)
+#define CPM_WFER	(CPM_BASE+0x2c)
+#define CPM_WER		(CPM_BASE+0x30)
+#define CPM_WSR		(CPM_BASE+0x34)
+#define CPM_GSR0	(CPM_BASE+0x38)
+#define CPM_GSR1	(CPM_BASE+0x3c)
+#define CPM_GSR2	(CPM_BASE+0x40)
+#define CPM_SPR		(CPM_BASE+0x44)
+#define CPM_GSR3	(CPM_BASE+0x48)
+
+#define REG_CPM_CFCR	REG32(CPM_CFCR)
+#define REG_CPM_PLCR1	REG32(CPM_PLCR1)
+#define REG_CPM_OCR	REG32(CPM_OCR)
+#define REG_CPM_CFCR2	REG32(CPM_CFCR2)
+#define REG_CPM_LPCR	REG32(CPM_LPCR)
+#define REG_CPM_RSTR	REG32(CPM_RSTR)
+#define REG_CPM_MSCR	REG32(CPM_MSCR)
+#define REG_CPM_SCR	REG32(CPM_SCR)
+#define REG_CPM_WRER	REG32(CPM_WRER)
+#define REG_CPM_WFER	REG32(CPM_WFER)
+#define REG_CPM_WER	REG32(CPM_WER)
+#define REG_CPM_WSR	REG32(CPM_WSR)
+#define REG_CPM_GSR0	REG32(CPM_GSR0)
+#define REG_CPM_GSR1	REG32(CPM_GSR1)
+#define REG_CPM_GSR2	REG32(CPM_GSR2)
+#define REG_CPM_SPR	REG32(CPM_SPR)
+#define REG_CPM_GSR3	REG32(CPM_GSR3)
+
+#define CPM_CFCR_SSI		(1 << 31)
+#define CPM_CFCR_LCD		(1 << 30)
+#define CPM_CFCR_I2S		(1 << 29)
+#define CPM_CFCR_UCS		(1 << 28)
+#define CPM_CFCR_UFR_BIT	25
+#define CPM_CFCR_UFR_MASK	(0x07 << CPM_CFCR_UFR_BIT)
+#define CPM_CFCR_MSC		(1 << 24)
+#define CPM_CFCR_CKOEN2		(1 << 23)
+#define CPM_CFCR_CKOEN1		(1 << 22)
+#define CPM_CFCR_UPE		(1 << 20)
+#define CPM_CFCR_MFR_BIT	16
+#define CPM_CFCR_MFR_MASK	(0x0f << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_1		(0 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_2		(1 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_3		(2 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_4		(3 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_6		(4 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_8		(5 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_12		(6 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_16		(7 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_24		(8 << CPM_CFCR_MFR_BIT)
+  #define CFCR_MDIV_32		(9 << CPM_CFCR_MFR_BIT)
+#define CPM_CFCR_LFR_BIT	12
+#define CPM_CFCR_LFR_MASK	(0x0f << CPM_CFCR_LFR_BIT)
+#define CPM_CFCR_PFR_BIT	8
+#define CPM_CFCR_PFR_MASK	(0x0f << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_1		(0 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_2		(1 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_3		(2 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_4		(3 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_6		(4 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_8		(5 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_12		(6 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_16		(7 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_24		(8 << CPM_CFCR_PFR_BIT)
+  #define CFCR_PDIV_32		(9 << CPM_CFCR_PFR_BIT)
+#define CPM_CFCR_SFR_BIT	4
+#define CPM_CFCR_SFR_MASK	(0x0f << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_1		(0 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_2		(1 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_3		(2 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_4		(3 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_6		(4 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_8		(5 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_12		(6 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_16		(7 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_24		(8 << CPM_CFCR_SFR_BIT)
+  #define CFCR_SDIV_32		(9 << CPM_CFCR_SFR_BIT)
+#define CPM_CFCR_IFR_BIT	0
+#define CPM_CFCR_IFR_MASK	(0x0f << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_1		(0 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_2		(1 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_3		(2 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_4		(3 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_6		(4 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_8		(5 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_12		(6 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_16		(7 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_24		(8 << CPM_CFCR_IFR_BIT)
+  #define CFCR_IDIV_32		(9 << CPM_CFCR_IFR_BIT)
+
+#define CPM_PLCR1_PLL1FD_BIT	23
+#define CPM_PLCR1_PLL1FD_MASK	(0x1ff << CPM_PLCR1_PLL1FD_BIT)
+#define CPM_PLCR1_PLL1RD_BIT	18
+#define CPM_PLCR1_PLL1RD_MASK	(0x1f << CPM_PLCR1_PLL1RD_BIT)
+#define CPM_PLCR1_PLL1OD_BIT	16
+#define CPM_PLCR1_PLL1OD_MASK	(0x03 << CPM_PLCR1_PLL1OD_BIT)
+#define CPM_PLCR1_PLL1S		(1 << 10)
+#define CPM_PLCR1_PLL1BP	(1 << 9)
+#define CPM_PLCR1_PLL1EN	(1 << 8)
+#define CPM_PLCR1_PLL1ST_BIT	0
+#define CPM_PLCR1_PLL1ST_MASK	(0xff << CPM_PLCR1_PLL1ST_BIT)
+
+#define CPM_OCR_O1ST_BIT	16
+#define CPM_OCR_O1ST_MASK	(0xff << CPM_OCR_O1ST_BIT)
+#define CPM_OCR_EXT_RTC_CLK	(1<<8)
+#define CPM_OCR_SUSPEND_PHY1	(1<<7)
+#define CPM_OCR_SUSPEND_PHY0	(1<<6)
+
+#define CPM_CFCR2_PXFR_BIT	0
+#define CPM_CFCR2_PXFR_MASK	(0x1ff << CPM_CFCR2_PXFR_BIT)
+
+#define CPM_LPCR_DUTY_BIT	3
+#define CPM_LPCR_DUTY_MASK	(0x1f << CPM_LPCR_DUTY_BIT)
+#define CPM_LPCR_DOZE		(1 << 2)
+#define CPM_LPCR_LPM_BIT	0
+#define CPM_LPCR_LPM_MASK	(0x03 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_IDLE		(0 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_SLEEP		(1 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_HIBERNATE	(2 << CPM_LPCR_LPM_BIT)
+
+#define CPM_RSTR_SR		(1 << 2)
+#define CPM_RSTR_WR		(1 << 1)
+#define CPM_RSTR_HR		(1 << 0)
+
+#define CPM_MSCR_MSTP_BIT	0
+#define CPM_MSCR_MSTP_MASK	(0x1ffffff << CPM_MSCR_MSTP_BIT)
+  #define CPM_MSCR_MSTP_UART0	0
+  #define CPM_MSCR_MSTP_UART1	1
+  #define CPM_MSCR_MSTP_UART2	2
+  #define CPM_MSCR_MSTP_OST	3
+  #define CPM_MSCR_MSTP_DMAC	5
+  #define CPM_MSCR_MSTP_UHC	6
+  #define CPM_MSCR_MSTP_LCD	7
+  #define CPM_MSCR_MSTP_I2C	8
+  #define CPM_MSCR_MSTP_AICPCLK 9
+  #define CPM_MSCR_MSTP_PWM0	10
+  #define CPM_MSCR_MSTP_PWM1	11
+  #define CPM_MSCR_MSTP_SSI	12
+  #define CPM_MSCR_MSTP_MSC	13
+  #define CPM_MSCR_MSTP_SCC	14
+  #define CPM_MSCR_MSTP_AICBCLK	18
+  #define CPM_MSCR_MSTP_UART3	20
+  #define CPM_MSCR_MSTP_ETH	21
+  #define CPM_MSCR_MSTP_KBC	22
+  #define CPM_MSCR_MSTP_CIM	23
+  #define CPM_MSCR_MSTP_UDC	24
+  #define CPM_MSCR_MSTP_UPRT	25
+
+#define CPM_SCR_O1SE		(1 << 4)
+#define CPM_SCR_HGP		(1 << 3)
+#define CPM_SCR_HZP		(1 << 2)
+#define CPM_SCR_HZM		(1 << 1)
+
+#define CPM_WRER_RE_BIT		0
+#define CPM_WRER_RE_MASK	(0xffff << CPM_WRER_RE_BIT)
+
+#define CPM_WFER_FE_BIT		0
+#define CPM_WFER_FE_MASK	(0xffff << CPM_WFER_FE_BIT)
+
+#define CPM_WER_WERTC		(1 << 31)
+#define CPM_WER_WEETH		(1 << 30)
+#define CPM_WER_WE_BIT		0
+#define CPM_WER_WE_MASK		(0xffff << CPM_WER_WE_BIT)
+
+#define CPM_WSR_WSRTC		(1 << 31)
+#define CPM_WSR_WSETH		(1 << 30)
+#define CPM_WSR_WS_BIT		0
+#define CPM_WSR_WS_MASK		(0xffff << CPM_WSR_WS_BIT)
+
+
+
+
+/*************************************************************************
+ * SSI
+ *************************************************************************/
+#define	SSI_DR			(SSI_BASE + 0x000)
+#define	SSI_CR0			(SSI_BASE + 0x004)
+#define	SSI_CR1			(SSI_BASE + 0x008)
+#define	SSI_SR			(SSI_BASE + 0x00C)
+#define	SSI_ITR			(SSI_BASE + 0x010)
+#define	SSI_ICR			(SSI_BASE + 0x014)
+#define	SSI_GR			(SSI_BASE + 0x018)
+
+#define	REG_SSI_DR		REG32(SSI_DR)
+#define	REG_SSI_CR0		REG16(SSI_CR0)
+#define	REG_SSI_CR1		REG32(SSI_CR1)
+#define	REG_SSI_SR		REG32(SSI_SR)
+#define	REG_SSI_ITR		REG16(SSI_ITR)
+#define	REG_SSI_ICR		REG8(SSI_ICR)
+#define	REG_SSI_GR		REG16(SSI_GR)
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_TTRG_BIT	10
+#define SSI_CR1_TTRG_MASK	(0x3 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_1	  (0 << SSI_CR1_TTRG_BIT)/* Less than or equal to 1 */
+  #define SSI_CR1_TTRG_4	  (1 << SSI_CR1_TTRG_BIT) /* Less than or equal to 4 */
+  #define SSI_CR1_TTRG_8	  (2 << SSI_CR1_TTRG_BIT) /* Less than or equal to 8 */
+  #define SSI_CR1_TTRG_14	  (3 << SSI_CR1_TTRG_BIT) /* Less than or equal to 14 */
+#define SSI_CR1_RTRG_BIT	8
+#define SSI_CR1_RTRG_MASK	(0x3 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_1	  (0 << SSI_CR1_RTRG_BIT) /* More than or equal to 1 */
+  #define SSI_CR1_RTRG_4	  (1 << SSI_CR1_RTRG_BIT) /* More than or equal to 4 */
+  #define SSI_CR1_RTRG_8	  (2 << SSI_CR1_RTRG_BIT) /* More than or equal to 8 */
+  #define SSI_CR1_RTRG_14	  (3 << SSI_CR1_RTRG_BIT) /* More than or equal to 14 */
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	13
+#define SSI_SR_TFIFONUM_MASK	(0x1f << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0x1f << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+#ifndef __ASSEMBLY__
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+
+#define __msc_start_op() \
+  ( REG_MSC_STRPCL = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(to) 	( REG_MSC_RESTO = to )
+#define __msc_set_rdto(to) 	( REG_MSC_RDTO = to )
+#define __msc_set_cmd(cmd) 	( REG_MSC_CMD = cmd )
+#define __msc_set_arg(arg) 	( REG_MSC_ARG = arg )
+#define __msc_set_nob(nob) 	( REG_MSC_NOB = nob )
+#define __msc_get_nob() 	( REG_MSC_NOB )
+#define __msc_set_blklen(len) 	( REG_MSC_BLKLEN = len )
+#define __msc_set_cmdat(cmdat) 	( REG_MSC_CMDAT = cmdat )
+#define __msc_set_cmdat_ioabort() 	( REG_MSC_CMDAT |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init() 	( REG_MSC_CMDAT |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy() 	( REG_MSC_CMDAT |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream() ( REG_MSC_CMDAT |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block() ( REG_MSC_CMDAT &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write() ( REG_MSC_CMDAT |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(r) 				\
+do { 								\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat() \
+  REG_MSC_CMDAT &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask() 		( REG_MSC_IMASK )
+#define __msc_mask_all_intrs() 		( REG_MSC_IMASK = 0xff )
+#define __msc_unmask_all_intrs() 	( REG_MSC_IMASK = 0x00 )
+#define __msc_mask_rd() 		( REG_MSC_IMASK |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd() 		( REG_MSC_IMASK &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr() 		( REG_MSC_IMASK |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr() 		( REG_MSC_IMASK &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres() 		( REG_MSC_IMASK |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres() 	( REG_MSC_IMASK &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone() 	( REG_MSC_IMASK |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone() 	( REG_MSC_IMASK &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone() 		( REG_MSC_IMASK |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone() 		( REG_MSC_IMASK &= ~MSC_IMASK_PRG_DONE )
+
+/* n=1,2,4,8,16,32,64,128 */
+#define __msc_set_clkrt_div(n) 				\
+do { 							\
+	REG_MSC_CLKRT &= ~MSC_CLKRT_CLK_RATE_MASK; 	\
+	REG_MSC_CLKRT |= MSC_CLKRT_CLK_RATE_DIV_##n;	\
+} while(0)
+
+#define __msc_get_ireg() 		( REG_MSC_IREG )
+#define __msc_ireg_rd() 		( REG_MSC_IREG & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr() 		( REG_MSC_IREG & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res() 	( REG_MSC_IREG & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done() 	( REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done() 		( REG_MSC_IREG & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res() 	( REG_MSC_IREG = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done() ( REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done() 	( REG_MSC_IREG = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat() 		( REG_MSC_STAT )
+#define __msc_stat_not_end_cmd_res() 	( (REG_MSC_STAT & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err() \
+  ( REG_MSC_STAT & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo() 		( REG_MSC_RES )
+#define __msc_rd_rxfifo()  		( REG_MSC_RXFIFO )
+#define __msc_wr_txfifo(v)  		( REG_MSC_TXFIFO = v )
+
+#define __msc_reset() 						\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk() 					\
+do { 								\
+	REG_MSC_STRPCL &= ~MSC_STRPCL_CLOCK_CONTROL_MASK;	\
+	REG_MSC_STRPCL |= MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk() 					\
+do { 								\
+	REG_MSC_STRPCL &= ~MSC_STRPCL_CLOCK_CONTROL_MASK;	\
+	REG_MSC_STRPCL |= MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/***************************************************************************
+ * RTC
+ ***************************************************************************/
+
+#define __rtc_start()	                ( REG_RTC_RCR |= RTC_RCR_START )
+#define __rtc_stop()	                ( REG_RTC_RCR &= ~RTC_RCR_START )
+
+#define __rtc_enable_alarm()	        ( REG_RTC_RCR |= RTC_RCR_AE )
+#define __rtc_disable_alarm()	        ( REG_RTC_RCR &= ~RTC_RCR_AE )
+#define __rtc_enable_alarm_irq()	( REG_RTC_RCR |= RTC_RCR_AIE )
+#define __rtc_disable_alarm_irq()	( REG_RTC_RCR &= ~RTC_RCR_AIE )
+
+#define __rtc_enable_1hz_irq()		( REG_RTC_RCR |= RTC_RCR_HZIE )
+#define __rtc_disable_1hz_irq()		( REG_RTC_RCR &= ~RTC_RCR_HZIE )
+
+#define __rtc_is_alarm_flag()		( REG_RTC_RCR & RTC_RCR_AF )
+#define __rtc_is_1hz_flag()		( REG_RTC_RCR & RTC_RCR_HZ )
+#define __rtc_clear_alarm_flag()	( REG_RTC_RCR &= ~RTC_RCR_AF )
+#define __rtc_clear_1hz_flag()		( REG_RTC_RCR &= ~RTC_RCR_HZ )
+
+#define __rtc_set_second(s)	        ( REG_RTC_RSR = (s) )
+#define __rtc_get_second()	        REG_RTC_RSR
+#define __rtc_set_alarm(s)	        ( REG_RTC_RSAR = (s) )
+#define __rtc_get_alarm()	        REG_RTC_RSAR
+
+#define __rtc_adjust_1hz(f32k) \
+  ( REG_RTC_RGR = (REG_RTC_RGR & ~(RTC_REG_DIV_MASK | RTC_RGR_ADJ_MASK)) | f32k | 0 )
+#define __rtc_lock_1hz()	( REG_RTC_RGR |= RTC_RGR_LOCK )
+
+
+/***************************************************************************
+ * FIR
+ ***************************************************************************/
+
+/* enable/disable fir unit */
+#define __fir_enable()		( REG_FIR_CR1 |= FIR_CR1_FIRUE )
+#define __fir_disable()		( REG_FIR_CR1 &= ~FIR_CR1_FIRUE )
+
+/* enable/disable address comparison */
+#define __fir_enable_ac()	( REG_FIR_CR1 |= FIR_CR1_ACE )
+#define __fir_disable_ac()	( REG_FIR_CR1 &= ~FIR_CR1_ACE )
+
+/* select frame end mode as underrun or normal */
+#define __fir_set_eous()	( REG_FIR_CR1 |= FIR_CR1_EOUS )
+#define __fir_clear_eous()	( REG_FIR_CR1 &= ~FIR_CR1_EOUS )
+
+/* enable/disable transmitter idle interrupt */
+#define __fir_enable_tii()	( REG_FIR_CR1 |= FIR_CR1_TIIE )
+#define __fir_disable_tii()	( REG_FIR_CR1 &= ~FIR_CR1_TIIE )
+
+/* enable/disable transmit FIFO service request interrupt */
+#define __fir_enable_tfi()	( REG_FIR_CR1 |= FIR_CR1_TFIE )
+#define __fir_disable_tfi()	( REG_FIR_CR1 &= ~FIR_CR1_TFIE )
+
+/* enable/disable receive FIFO service request interrupt */
+#define __fir_enable_rfi()	( REG_FIR_CR1 |= FIR_CR1_RFIE )
+#define __fir_disable_rfi()	( REG_FIR_CR1 &= ~FIR_CR1_RFIE )
+
+/* enable/disable tx function */
+#define __fir_tx_enable()	( REG_FIR_CR1 |= FIR_CR1_TXE )
+#define __fir_tx_disable()	( REG_FIR_CR1 &= ~FIR_CR1_TXE )
+
+/* enable/disable rx function */
+#define __fir_rx_enable()	( REG_FIR_CR1 |= FIR_CR1_RXE )
+#define __fir_rx_disable()	( REG_FIR_CR1 &= ~FIR_CR1_RXE )
+
+
+/* enable/disable serial infrared interaction pulse (SIP) */
+#define __fir_enable_sip()	( REG_FIR_CR2 |= FIR_CR2_SIPE )
+#define __fir_disable_sip()	( REG_FIR_CR2 &= ~FIR_CR2_SIPE )
+
+/* un-inverted CRC value is sent out */
+#define __fir_enable_bcrc()	( REG_FIR_CR2 |= FIR_CR2_BCRC )
+
+/* inverted CRC value is sent out */
+#define __fir_disable_bcrc()	( REG_FIR_CR2 &= ~FIR_CR2_BCRC )
+
+/* enable/disable Transmit Frame Length Register */
+#define __fir_enable_tflr()	( REG_FIR_CR2 |= FIR_CR2_TFLRS )
+#define __fir_disable_tflr()	( REG_FIR_CR2 &= ~FIR_CR2_TFLRS )
+
+/* Preamble is transmitted in idle state */
+#define __fir_set_iss()	( REG_FIR_CR2 |= FIR_CR2_ISS )
+
+/* Abort symbol is transmitted in idle state */
+#define __fir_clear_iss()	( REG_FIR_CR2 &= ~FIR_CR2_ISS )
+
+/* enable/disable loopback mode */
+#define __fir_enable_loopback()	( REG_FIR_CR2 |= FIR_CR2_LMS )
+#define __fir_disable_loopback()	( REG_FIR_CR2 &= ~FIR_CR2_LMS )
+
+/* select transmit pin polarity */
+#define __fir_tpp_negative()	( REG_FIR_CR2 |= FIR_CR2_TPPS )
+#define __fir_tpp_positive()	( REG_FIR_CR2 &= ~FIR_CR2_TPPS )
+
+/* select receive pin polarity */
+#define __fir_rpp_negative()	( REG_FIR_CR2 |= FIR_CR2_RPPS )
+#define __fir_rpp_positive()	( REG_FIR_CR2 &= ~FIR_CR2_RPPS )
+
+/* n=16,32,64,128 */
+#define __fir_set_txfifo_trigger(n) 		\
+do { 						\
+	REG_FIR_CR2 &= ~FIR_CR2_TTRG_MASK;	\
+	REG_FIR_CR2 |= FIR_CR2_TTRG_##n;	\
+} while (0)
+
+/* n=16,32,64,128 */
+#define __fir_set_rxfifo_trigger(n) 		\
+do { 						\
+	REG_FIR_CR2 &= ~FIR_CR2_RTRG_MASK;	\
+	REG_FIR_CR2 |= FIR_CR2_RTRG_##n;	\
+} while (0)
+
+
+/* FIR status checking */
+
+#define __fir_test_rfw()	( REG_FIR_SR & FIR_SR_RFW )
+#define __fir_test_rfa()	( REG_FIR_SR & FIR_SR_RFA )
+#define __fir_test_tfrtl()	( REG_FIR_SR & FIR_SR_TFRTL )
+#define __fir_test_rfrtl()	( REG_FIR_SR & FIR_SR_RFRTL )
+#define __fir_test_urun()	( REG_FIR_SR & FIR_SR_URUN )
+#define __fir_test_rfte()	( REG_FIR_SR & FIR_SR_RFTE )
+#define __fir_test_orun()	( REG_FIR_SR & FIR_SR_ORUN )
+#define __fir_test_crce()	( REG_FIR_SR & FIR_SR_CRCE )
+#define __fir_test_fend()	( REG_FIR_SR & FIR_SR_FEND )
+#define __fir_test_tff()	( REG_FIR_SR & FIR_SR_TFF )
+#define __fir_test_rfe()	( REG_FIR_SR & FIR_SR_RFE )
+#define __fir_test_tidle()	( REG_FIR_SR & FIR_SR_TIDLE )
+#define __fir_test_rb()		( REG_FIR_SR & FIR_SR_RB )
+
+#define __fir_clear_status()					\
+do { 								\
+	REG_FIR_SR |= FIR_SR_RFW | FIR_SR_RFA | FIR_SR_URUN;	\
+} while (0)
+
+#define __fir_clear_rfw()	( REG_FIR_SR |= FIR_SR_RFW )
+#define __fir_clear_rfa()	( REG_FIR_SR |= FIR_SR_RFA )
+#define __fir_clear_urun()	( REG_FIR_SR |= FIR_SR_URUN )
+
+#define __fir_set_tflr(len)			\
+do { 						\
+	REG_FIR_TFLR = len; 			\
+} while (0)
+
+#define __fir_set_addr(a)	( REG_FIR_AR = (a) )
+
+#define __fir_write_data(data)	( REG_FIR_TDR = data )
+#define __fir_read_data(data)	( data = REG_FIR_RDR )
+
+/***************************************************************************
+ * SCC
+ ***************************************************************************/
+
+#define __scc_enable(base)	( REG_SCC_CR(base) |= SCC_CR_SCCE )
+#define __scc_disable(base)	( REG_SCC_CR(base) &= ~SCC_CR_SCCE )
+
+#define __scc_set_tx_mode(base)	( REG_SCC_CR(base) |= SCC_CR_TRS )
+#define __scc_set_rx_mode(base)	( REG_SCC_CR(base) &= ~SCC_CR_TRS )
+
+#define __scc_enable_t2r(base)	( REG_SCC_CR(base) |= SCC_CR_T2R )
+#define __scc_disable_t2r(base)	( REG_SCC_CR(base) &= ~SCC_CR_T2R )
+
+#define __scc_clk_as_devclk(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_FDIV_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_FDIV_1;		\
+} while (0)
+
+#define __scc_clk_as_half_devclk(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_FDIV_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_FDIV_2;		\
+} while (0)
+
+/* n=1,4,8,14 */
+#define __scc_set_fifo_trigger(base, n)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_TRIG_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_TRIG_##n;		\
+} while (0)
+
+#define __scc_set_protocol(base, p)		\
+do {						\
+	if (p)					\
+	  	REG_SCC_CR(base) |= SCC_CR_TP;	\
+	else					\
+	 	REG_SCC_CR(base) &= ~SCC_CR_TP;	\
+} while (0)
+
+#define __scc_flush_fifo(base)	( REG_SCC_CR(base) |= SCC_CR_FLUSH )
+
+#define __scc_set_invert_mode(base)	( REG_SCC_CR(base) |= SCC_CR_CONV )
+#define __scc_set_direct_mode(base)	( REG_SCC_CR(base) &= ~SCC_CR_CONV )
+
+#define SCC_ERR_INTRS \
+    ( SCC_CR_ECIE | SCC_CR_EPIE | SCC_CR_RETIE | SCC_CR_EOIE )
+#define SCC_ALL_INTRS \
+    ( SCC_CR_TXIE | SCC_CR_RXIE | SCC_CR_TENDIE | SCC_CR_RTOIE | \
+      SCC_CR_ECIE | SCC_CR_EPIE | SCC_CR_RETIE | SCC_CR_EOIE )
+
+#define __scc_enable_err_intrs(base)	( REG_SCC_CR(base) |= SCC_ERR_INTRS )
+#define __scc_disable_err_intrs(base)	( REG_SCC_CR(base) &= ~SCC_ERR_INTRS )
+
+#define SCC_ALL_ERRORS \
+    ( SCC_SR_ORER | SCC_SR_RTO | SCC_SR_PER | SCC_SR_RETR_3 | SCC_SR_ECNTO)
+
+#define __scc_clear_errors(base)	( REG_SCC_SR(base) &= ~SCC_ALL_ERRORS )
+
+#define __scc_enable_all_intrs(base)	( REG_SCC_CR(base) |= SCC_ALL_INTRS )
+#define __scc_disable_all_intrs(base)	( REG_SCC_CR(base) &= ~SCC_ALL_INTRS )
+
+#define __scc_enable_tx_intr(base)	( REG_SCC_CR(base) |= SCC_CR_TXIE | SCC_CR_TENDIE )
+#define __scc_disable_tx_intr(base)	( REG_SCC_CR(base) &= ~(SCC_CR_TXIE | SCC_CR_TENDIE) )
+
+#define __scc_enable_rx_intr(base)	( REG_SCC_CR(base) |= SCC_CR_RXIE)
+#define __scc_disable_rx_intr(base)	( REG_SCC_CR(base) &= ~SCC_CR_RXIE)
+
+#define __scc_set_tsend(base)		( REG_SCC_CR(base) |= SCC_CR_TSEND )
+#define __scc_clear_tsend(base)		( REG_SCC_CR(base) &= ~SCC_CR_TSEND )
+
+#define __scc_set_clockstop(base)	( REG_SCC_CR(base) |= SCC_CR_CLKSTP )
+#define __scc_clear_clockstop(base)	( REG_SCC_CR(base) &= ~SCC_CR_CLKSTP )
+
+#define __scc_clockstop_low(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_PX_MASK;		\
+  REG_SCC_CR(base) |= SCC_CR_PX_STOP_LOW;	\
+} while (0)
+
+#define __scc_clockstop_high(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_PX_MASK;		\
+  REG_SCC_CR(base) |= SCC_CR_PX_STOP_HIGH;	\
+} while (0)
+
+
+/* SCC status checking */
+#define __scc_check_transfer_status(base)  ( REG_SCC_SR(base) & SCC_SR_TRANS )
+#define __scc_check_rx_overrun_error(base) ( REG_SCC_SR(base) & SCC_SR_ORER )
+#define __scc_check_rx_timeout(base)	   ( REG_SCC_SR(base) & SCC_SR_RTO )
+#define __scc_check_parity_error(base)	   ( REG_SCC_SR(base) & SCC_SR_PER )
+#define __scc_check_txfifo_trigger(base)   ( REG_SCC_SR(base) & SCC_SR_TFTG )
+#define __scc_check_rxfifo_trigger(base)   ( REG_SCC_SR(base) & SCC_SR_RFTG )
+#define __scc_check_tx_end(base)	   ( REG_SCC_SR(base) & SCC_SR_TEND )
+#define __scc_check_retx_3(base)	   ( REG_SCC_SR(base) & SCC_SR_RETR_3 )
+#define __scc_check_ecnt_overflow(base)	   ( REG_SCC_SR(base) & SCC_SR_ECNTO )
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+
+#define __wdt_set_count(count) ( REG_WDT_WTCNT = (count) )
+#define __wdt_start()          ( REG_WDT_WTCSR |= WDT_WTCSR_START )
+#define __wdt_stop()           ( REG_WDT_WTCSR &= ~WDT_WTCSR_START )
+
+
+/***************************************************************************
+ * OST
+ ***************************************************************************/
+
+#define __ost_enable_all()         ( REG_OST_TER |= 0x07 )
+#define __ost_disable_all()        ( REG_OST_TER &= ~0x07 )
+#define __ost_enable_channel(n)    ( REG_OST_TER |= (1 << (n)) )
+#define __ost_disable_channel(n)   ( REG_OST_TER &= ~(1 << (n)) )
+#define __ost_set_reload(n, val)   ( REG_OST_TRDR(n) = (val) )
+#define __ost_set_count(n, val)    ( REG_OST_TCNT(n) = (val) )
+#define __ost_get_count(n)         ( REG_OST_TCNT(n) )
+#define __ost_set_clock(n, cs)     ( REG_OST_TCSR(n) |= (cs) )
+#define __ost_set_mode(n, val)     ( REG_OST_TCSR(n) = (val) )
+#define __ost_enable_interrupt(n)  ( REG_OST_TCSR(n) |= OST_TCSR_UIE )
+#define __ost_disable_interrupt(n) ( REG_OST_TCSR(n) &= ~OST_TCSR_UIE )
+#define __ost_uf_detected(n)       ( REG_OST_TCSR(n) & OST_TCSR_UF )
+#define __ost_clear_uf(n)          ( REG_OST_TCSR(n) &= ~OST_TCSR_UF )
+#define __ost_is_busy(n)           ( REG_OST_TCSR(n) & OST_TCSR_BUSY )
+#define __ost_clear_busy(n)        ( REG_OST_TCSR(n) &= ~OST_TCSR_BUSY )
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) = UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(n, devclk, baud)						\
+  do {											\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLLR) = (devclk / 16 / baud) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_PER) != 0 )
+
+#define __uart_clear_errors(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTSR_RFER) )
+
+#define __uart_transmit_fifo_empty(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TDRQ) != 0 )
+
+#define __uart_transmit_end(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TEMT) != 0 )
+
+#define __uart_transmit_char(n, ch) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_TDR) = (ch)
+
+#define __uart_receive_fifo_full(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_ready(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_char(n) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_RDR)
+
+#define __uart_disable_irda() \
+  ( REG8(IRDA_BASE + OFF_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(IRDA_BASE + OFF_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) )
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+  ( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+  ( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_PACK_MASK; 		\
+    REG_CIM_CFG |= (CIM_CFG_PACK_##n); 		\
+} while (0)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CPM; 		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CIM; 		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_GCM; 		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_NGCM; 		\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+    REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;			\
+    REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+
+#define __cim_enable_sof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_stop_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_FRC_##n; 		\
+} while (0)
+
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n; 	\
+} while (0)
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dam_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+/***************************************************************************
+ * PWM
+ ***************************************************************************/
+
+/* n is the pwm channel (0,1,..) */
+#define __pwm_enable_module(n)		( REG_PWM_CTR(n) |= PWM_CTR_EN )
+#define __pwm_disable_module(n)		( REG_PWM_CTR(n) &= ~PWM_CTR_EN )
+#define __pwm_graceful_shutdown_mode(n)	( REG_PWM_CTR(n) &= ~PWM_CTR_SD )
+#define __pwm_abrupt_shutdown_mode(n)	( REG_PWM_CTR(n) |= PWM_CTR_SD )
+#define __pwm_set_full_duty(n)		( REG_PWM_DUT(n) |= PWM_DUT_FDUTY )
+
+#define __pwm_set_prescale(n, p) \
+  ( REG_PWM_CTR(n) = ((REG_PWM_CTR(n) & ~PWM_CTR_PRESCALE_MASK) | (p) ) )
+#define __pwm_set_period(n, p) \
+  ( REG_PWM_PER(n) = ( (REG_PWM_PER(n) & ~PWM_PER_PERIOD_MASK) | (p) ) )
+#define __pwm_set_duty(n, d) \
+  ( REG_PWM_DUT(n) = ( (REG_PWM_DUT(n) & ~PWM_DUT_FDUTY) | (d) ) )
+
+/***************************************************************************
+ * EMC
+ ***************************************************************************/
+
+#define __emc_enable_split() ( REG_EMC_BCR = EMC_BCR_BRE )
+#define __emc_disable_split() ( REG_EMC_BCR = 0 )
+
+#define __emc_smem_bus_width(n) /* 8, 16 or 32*/		\
+	( REG_EMC_SMCR = (REG_EMC_SMCR & EMC_SMCR_BW_MASK) |	\
+			 EMC_SMCR_BW_##n##BIT )
+#define __emc_smem_byte_control() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR | EMC_SMCR_BCM )
+#define __emc_normal_smem() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR & ~EMC_SMCR_SMT )
+#define __emc_burst_smem() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR | EMC_SMCR_SMT )
+#define __emc_smem_burstlen(n) /* 4, 8, 16 or 32 */ \
+	( REG_EMC_SMCR = (REG_EMC_SMCR & EMC_SMCR_BL_MASK) | (EMC_SMCR_BL_##n )
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+/* p is the port number (0,1,2,3)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-124), regardless of the port
+ * m is the interrupt manner (low/high/falling/rising)
+ */
+
+#define __gpio_port_data(p)	( REG_GPIO_GPDR(p) )
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    unsigned int tmp;				\
+    REG_GPIO_GPIER(p) &= ~(1 << (o));		\
+    REG_GPIO_GPDIR(p) |= (1 << (o));		\
+    if (o < 16) {				\
+	tmp = REG_GPIO_GPALR(p);		\
+	tmp &= ~(3 << ((o) << 1));		\
+	REG_GPIO_GPALR(p) = tmp;		\
+    } else {					\
+	tmp = REG_GPIO_GPAUR(p);		\
+	tmp &= ~(3 << (((o) - 16)<< 1));	\
+	REG_GPIO_GPAUR(p) = tmp;		\
+    }						\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    unsigned int tmp;				\
+    REG_GPIO_GPIER(p) &= ~(1 << (o));		\
+    REG_GPIO_GPDIR(p) &= ~(1 << (o));		\
+    if (o < 16) {				\
+	tmp = REG_GPIO_GPALR(p);		\
+	tmp &= ~(3 << ((o) << 1));		\
+	REG_GPIO_GPALR(p) = tmp;		\
+    } else {					\
+	tmp = REG_GPIO_GPAUR(p);		\
+	tmp &= ~(3 << (((o) - 16)<< 1));	\
+	REG_GPIO_GPAUR(p) = tmp;		\
+    }						\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_data(p) |= (1 << o);	\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_data(p) &= ~(1 << o);	\
+} while (0)
+
+static __inline__ unsigned int __gpio_get_pin(unsigned int n)
+{
+	unsigned int p, o;
+	p = (n) / 32;
+	o = (n) % 32;
+	if (__gpio_port_data(p) & (1 << o))
+		return 1;
+	else
+		return 0;
+}
+
+
+#define __gpio_set_irq_detect_manner(p, o, m)	\
+do {						\
+    unsigned int tmp;				\
+    if (o < 16) {				\
+	tmp = REG_GPIO_GPIDLR(p);		\
+	tmp &= ~(3 << ((o) << 1));		\
+	tmp |= ((m) << ((o) << 1));		\
+	REG_GPIO_GPIDLR(p) = tmp;		\
+    } else {					\
+	o -= 16;				\
+	tmp = REG_GPIO_GPIDUR(p);		\
+	tmp &= ~(3 << ((o) << 1));		\
+	tmp |= ((m) << ((o) << 1));		\
+	REG_GPIO_GPIDUR(p) = tmp;		\
+    }						\
+} while (0)
+
+#define __gpio_port_as_irq(p, o, m)		\
+do {						\
+    __gpio_set_irq_detect_manner(p, o, m);  	\
+    __gpio_port_as_input(p, o);			\
+    REG_GPIO_GPIER(p) |= (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq(n, m)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+        __gpio_port_as_irq(p, o, m);  		\
+} while (0)
+
+
+#define __gpio_as_irq_high_level(n)	__gpio_as_irq(n, GPIO_IRQ_HILEVEL)
+#define __gpio_as_irq_low_level(n)	__gpio_as_irq(n, GPIO_IRQ_LOLEVEL)
+#define __gpio_as_irq_fall_edge(n)	__gpio_as_irq(n, GPIO_IRQ_FALLEDG)
+#define __gpio_as_irq_rise_edge(n)	__gpio_as_irq(n, GPIO_IRQ_RAISEDG)
+
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPIER(p) &= ~(1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPIER(n) |= (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPFR(p) |= (1 << o);		\
+} while (0)
+
+
+static __inline__ unsigned int __gpio_get_irq(void)
+{
+	unsigned int tmp, i;
+
+	tmp = REG_GPIO_GPFR(3);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return 0x60 + i;
+	tmp = REG_GPIO_GPFR(2);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return 0x40 + i;
+	tmp = REG_GPIO_GPFR(1);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return 0x20 + i;
+	tmp = REG_GPIO_GPFR(0);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return i;
+	return 0;
+}
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_GPFR((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPPUR(p) |= (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPPUR(p) &= ~(1 << o);		\
+} while (0)
+
+/* Init the alternate function pins */
+
+
+#define __gpio_as_ssi()				\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xFC00FFFF;	\
+	REG_GPIO_GPALR(2) |= 0x01550000;	\
+} while (0)
+
+#define __gpio_as_uart3()			\
+do {						\
+	REG_GPIO_GPAUR(0) &= 0xFFFF0000;	\
+	REG_GPIO_GPAUR(0) |= 0x00005555;	\
+} while (0)
+
+#define __gpio_as_uart2()			\
+do {						\
+	REG_GPIO_GPALR(3) &= 0x3FFFFFFF;	\
+	REG_GPIO_GPALR(3) |= 0x40000000;	\
+	REG_GPIO_GPAUR(3) &= 0xF3FFFFFF;	\
+	REG_GPIO_GPAUR(3) |= 0x04000000;	\
+} while (0)
+
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_GPAUR(0) &= 0xFFF0FFFF;	\
+	REG_GPIO_GPAUR(0) |= 0x00050000;	\
+} while (0)
+
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_GPAUR(3) &= 0x0FFFFFFF;	\
+	REG_GPIO_GPAUR(3) |= 0x50000000;	\
+} while (0)
+
+
+#define __gpio_as_scc0()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xFFFFFFCC;	\
+	REG_GPIO_GPALR(2) |= 0x00000011;	\
+} while (0)
+
+#define __gpio_as_scc1()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xFFFFFF33;	\
+	REG_GPIO_GPALR(2) |= 0x00000044;	\
+} while (0)
+
+#define __gpio_as_scc()				\
+do {						\
+	__gpio_as_scc0();			\
+	__gpio_as_scc1();			\
+} while (0)
+
+#define __gpio_as_dma()				\
+do {						\
+	REG_GPIO_GPALR(0) &= 0x00FFFFFF;	\
+	REG_GPIO_GPALR(0) |= 0x55000000;	\
+	REG_GPIO_GPAUR(0) &= 0xFF0FFFFF;	\
+	REG_GPIO_GPAUR(0) |= 0x00500000;	\
+} while (0)
+
+#define __gpio_as_msc()				\
+do {						\
+	REG_GPIO_GPALR(1) &= 0xFFFF000F;	\
+	REG_GPIO_GPALR(1) |= 0x00005550;	\
+} while (0)
+
+#define __gpio_as_pcmcia()			\
+do {						\
+	REG_GPIO_GPAUR(2) &= 0xF000FFFF;	\
+	REG_GPIO_GPAUR(2) |= 0x05550000;	\
+} while (0)
+
+#define __gpio_as_emc()				\
+do {						\
+	REG_GPIO_GPALR(2) &= 0x3FFFFFFF;	\
+	REG_GPIO_GPALR(2) |= 0x40000000;	\
+	REG_GPIO_GPAUR(2) &= 0xFFFF0000;	\
+	REG_GPIO_GPAUR(2) |= 0x00005555;	\
+} while (0)
+
+#define __gpio_as_lcd_slave()			\
+do {						\
+	REG_GPIO_GPALR(1) &= 0x0000FFFF;	\
+	REG_GPIO_GPALR(1) |= 0x55550000;	\
+	REG_GPIO_GPAUR(1) &= 0x00000000;	\
+	REG_GPIO_GPAUR(1) |= 0x55555555;	\
+} while (0)
+
+#define __gpio_as_lcd_master()			\
+do {						\
+	REG_GPIO_GPALR(1) &= 0x0000FFFF;	\
+	REG_GPIO_GPALR(1) |= 0x55550000;	\
+	REG_GPIO_GPAUR(1) &= 0x00000000;	\
+	REG_GPIO_GPAUR(1) |= 0x556A5555;	\
+} while (0)
+
+#define __gpio_as_usb()				\
+do {						\
+	REG_GPIO_GPAUR(0) &= 0x00FFFFFF;	\
+	REG_GPIO_GPAUR(0) |= 0x55000000;	\
+} while (0)
+
+#define __gpio_as_ac97()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xC3FF03FF;	\
+	REG_GPIO_GPALR(2) |= 0x24005400;	\
+} while (0)
+
+#define __gpio_as_i2s_slave()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xC3FF0CFF;	\
+	REG_GPIO_GPALR(2) |= 0x14005100;	\
+} while (0)
+
+#define __gpio_as_i2s_master()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xC3FF0CFF;	\
+	REG_GPIO_GPALR(2) |= 0x28005100;	\
+} while (0)
+
+#define __gpio_as_eth()				\
+do {						\
+	REG_GPIO_GPAUR(3) &= 0xFC000000;	\
+	REG_GPIO_GPAUR(3) |= 0x01555555;	\
+} while (0)
+
+#define __gpio_as_pwm()				\
+do {						\
+	REG_GPIO_GPAUR(2) &= 0x0FFFFFFF;	\
+	REG_GPIO_GPAUR(2) |= 0x50000000;	\
+} while (0)
+
+#define __gpio_as_ps2()				\
+do {						\
+	REG_GPIO_GPALR(1) &= 0xFFFFFFF0;	\
+	REG_GPIO_GPALR(1) |= 0x00000005;	\
+} while (0)
+
+#define __gpio_as_uprt()			\
+do {						\
+	REG_GPIO_GPALR(1) &= 0x0000000F;	\
+	REG_GPIO_GPALR(1) |= 0x55555550;	\
+	REG_GPIO_GPALR(3) &= 0xC0000000;	\
+	REG_GPIO_GPALR(3) |= 0x15555555;	\
+} while (0)
+
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_GPALR(0) &= 0xFF000000;	\
+	REG_GPIO_GPALR(0) |= 0x00555555;	\
+} while (0)
+
+/***************************************************************************
+ * HARB
+ ***************************************************************************/
+
+#define __harb_usb0_udc()			\
+do {						\
+  REG_HARB_HAPOR &= ~HARB_HAPOR_UCHSEL; 	\
+} while (0)
+
+#define __harb_usb0_uhc()			\
+do {						\
+  REG_HARB_HAPOR |= HARB_HAPOR_UCHSEL; 		\
+} while (0)
+
+#define __harb_set_priority(n)			\
+do {						\
+  REG_HARB_HAPOR = ((REG_HARB_HAPOR & ~HARB_HAPOR_PRIO_MASK) | n);	\
+} while (0)
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+/***************************************************************************
+ * UDC
+ ***************************************************************************/
+
+#define __udc_set_16bit_phy()		( REG_UDC_DevCFGR |= UDC_DevCFGR_PI )
+#define __udc_set_8bit_phy()		( REG_UDC_DevCFGR &= ~UDC_DevCFGR_PI )
+
+#define __udc_enable_sync_frame()	( REG_UDC_DevCFGR |= UDC_DevCFGR_SS )
+#define __udc_disable_sync_frame()	( REG_UDC_DevCFGR &= ~UDC_DevCFGR_SS )
+
+#define __udc_self_powered()		( REG_UDC_DevCFGR |= UDC_DevCFGR_SP )
+#define __udc_bus_powered()		( REG_UDC_DevCFGR &= ~UDC_DevCFGR_SP )
+
+#define __udc_enable_remote_wakeup()	( REG_UDC_DevCFGR |= UDC_DevCFGR_RW )
+#define __udc_disable_remote_wakeup()	( REG_UDC_DevCFGR &= ~UDC_DevCFGR_RW )
+
+#define __udc_set_speed_high()				\
+do {							\
+	REG_UDC_DevCFGR &= ~UDC_DevCFGR_SPD_MASK;	\
+	REG_UDC_DevCFGR |= UDC_DevCFGR_SPD_HS;		\
+} while (0)
+
+#define __udc_set_speed_full()				\
+do {							\
+	REG_UDC_DevCFGR &= ~UDC_DevCFGR_SPD_MASK;	\
+	REG_UDC_DevCFGR |= UDC_DevCFGR_SPD_FS;		\
+} while (0)
+
+#define __udc_set_speed_low()				\
+do {							\
+	REG_UDC_DevCFGR &= ~UDC_DevCFGR_SPD_MASK;	\
+	REG_UDC_DevCFGR |= UDC_DevCFGR_SPD_LS;		\
+} while (0)
+
+
+#define __udc_set_dma_mode()		( REG_UDC_DevCR |= UDC_DevCR_DM )
+#define __udc_set_slave_mode()		( REG_UDC_DevCR &= ~UDC_DevCR_DM )
+#define __udc_set_big_endian()		( REG_UDC_DevCR |= UDC_DevCR_BE )
+#define __udc_set_little_endian()	( REG_UDC_DevCR &= ~UDC_DevCR_BE )
+#define __udc_generate_resume()		( REG_UDC_DevCR |= UDC_DevCR_RES )
+#define __udc_clear_resume()		( REG_UDC_DevCR &= ~UDC_DevCR_RES )
+
+
+#define __udc_get_enumarated_speed()	( REG_UDC_DevSR & UDC_DevSR_ENUMSPD_MASK )
+#define __udc_suspend_detected()	( REG_UDC_DevSR & UDC_DevSR_SUSP )
+#define __udc_get_alternate_setting()	( (REG_UDC_DevSR & UDC_DevSR_ALT_MASK) >> UDC_DevSR_ALT_BIT )
+#define __udc_get_interface_number()	( (REG_UDC_DevSR & UDC_DevSR_INTF_MASK) >> UDC_DevSR_INTF_BIT )
+#define __udc_get_config_number()	( (REG_UDC_DevSR & UDC_DevSR_CFG_MASK) >> UDC_DevSR_CFG_BIT )
+
+
+#define __udc_sof_detected(r)		( (r) & UDC_DevIntR_SOF )
+#define __udc_usb_suspend_detected(r)	( (r) & UDC_DevIntR_US )
+#define __udc_usb_reset_detected(r)	( (r) & UDC_DevIntR_UR )
+#define __udc_set_interface_detected(r)	( (r) & UDC_DevIntR_SI )
+#define __udc_set_config_detected(r)	( (r) & UDC_DevIntR_SC )
+
+#define __udc_clear_sof()		( REG_UDC_DevIntR |= UDC_DevIntR_SOF )
+#define __udc_clear_usb_suspend()	( REG_UDC_DevIntR |= UDC_DevIntR_US )
+#define __udc_clear_usb_reset()		( REG_UDC_DevIntR |= UDC_DevIntR_UR )
+#define __udc_clear_set_interface()	( REG_UDC_DevIntR |= UDC_DevIntR_SI )
+#define __udc_clear_set_config()	( REG_UDC_DevIntR |= UDC_DevIntR_SC )
+
+#define __udc_mask_sof()		( REG_UDC_DevIntMR |= UDC_DevIntR_SOF )
+#define __udc_mask_usb_suspend()	( REG_UDC_DevIntMR |= UDC_DevIntR_US )
+#define __udc_mask_usb_reset()		( REG_UDC_DevIntMR |= UDC_DevIntR_UR )
+#define __udc_mask_set_interface()	( REG_UDC_DevIntMR |= UDC_DevIntR_SI )
+#define __udc_mask_set_config()		( REG_UDC_DevIntMR |= UDC_DevIntR_SC )
+#define __udc_mask_all_dev_intrs() \
+  ( REG_UDC_DevIntMR = UDC_DevIntR_SOF | UDC_DevIntR_US | \
+      UDC_DevIntR_UR | UDC_DevIntR_SI | UDC_DevIntR_SC )
+
+#define __udc_unmask_sof()		( REG_UDC_DevIntMR &= ~UDC_DevIntR_SOF )
+#define __udc_unmask_usb_suspend()	( REG_UDC_DevIntMR &= ~UDC_DevIntR_US )
+#define __udc_unmask_usb_reset()	( REG_UDC_DevIntMR &= ~UDC_DevIntR_UR )
+#define __udc_unmask_set_interface()	( REG_UDC_DevIntMR &= ~UDC_DevIntR_SI )
+#define __udc_unmask_set_config()	( REG_UDC_DevIntMR &= ~UDC_DevIntR_SC )
+#if 0
+#define __udc_unmask_all_dev_intrs() \
+  ( REG_UDC_DevIntMR = ~(UDC_DevIntR_SOF | UDC_DevIntR_US | \
+      UDC_DevIntR_UR | UDC_DevIntR_SI | UDC_DevIntR_SC) )
+#else
+#define __udc_unmask_all_dev_intrs() \
+  ( REG_UDC_DevIntMR = 0x00000000 )
+#endif
+
+
+#define __udc_ep0out_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_OUTEP_MASK) >> (UDC_EPIntR_OUTEP_BIT + 0)) & 0x1 )
+#define __udc_ep5out_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_OUTEP_MASK) >> (UDC_EPIntR_OUTEP_BIT + 5)) & 0x1 )
+#define __udc_ep6out_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_OUTEP_MASK) >> (UDC_EPIntR_OUTEP_BIT + 6)) & 0x1 )
+#define __udc_ep7out_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_OUTEP_MASK) >> (UDC_EPIntR_OUTEP_BIT + 7)) & 0x1 )
+
+#define __udc_ep0in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 0)) & 0x1 )
+#define __udc_ep1in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 1)) & 0x1 )
+#define __udc_ep2in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 2)) & 0x1 )
+#define __udc_ep3in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 3)) & 0x1 )
+#define __udc_ep4in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 4)) & 0x1 )
+
+
+#define __udc_mask_ep0out_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_OUTEP_BIT + 0)) )
+#define __udc_mask_ep5out_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_OUTEP_BIT + 5)) )
+#define __udc_mask_ep6out_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_OUTEP_BIT + 6)) )
+#define __udc_mask_ep7out_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_OUTEP_BIT + 7)) )
+
+#define __udc_unmask_ep0out_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_OUTEP_BIT + 0)) )
+#define __udc_unmask_ep5out_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_OUTEP_BIT + 5)) )
+#define __udc_unmask_ep6out_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_OUTEP_BIT + 6)) )
+#define __udc_unmask_ep7out_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_OUTEP_BIT + 7)) )
+
+#define __udc_mask_ep0in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 0)) )
+#define __udc_mask_ep1in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 1)) )
+#define __udc_mask_ep2in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 2)) )
+#define __udc_mask_ep3in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 3)) )
+#define __udc_mask_ep4in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 4)) )
+
+#define __udc_unmask_ep0in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 0)) )
+#define __udc_unmask_ep1in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 1)) )
+#define __udc_unmask_ep2in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 2)) )
+#define __udc_unmask_ep3in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 3)) )
+#define __udc_unmask_ep4in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 4)) )
+
+#define __udc_mask_all_ep_intrs() \
+  ( REG_UDC_EPIntMR = 0xffffffff )
+#define __udc_unmask_all_ep_intrs() \
+  ( REG_UDC_EPIntMR = 0x00000000 )
+
+
+/* ep0 only CTRL, ep1 only INTR, ep2/3/5/6 only BULK, ep4/7 only ISO */
+#define __udc_config_endpoint_type()						\
+do {										\
+  REG_UDC_EP0InCR = (REG_UDC_EP0InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_CTRL;	\
+  REG_UDC_EP0OutCR = (REG_UDC_EP0OutCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_CTRL;	\
+  REG_UDC_EP1InCR = (REG_UDC_EP1InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_INTR;	\
+  REG_UDC_EP2InCR = (REG_UDC_EP2InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_BULK;	\
+  REG_UDC_EP3InCR = (REG_UDC_EP3InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_BULK;	\
+  REG_UDC_EP4InCR = (REG_UDC_EP4InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_ISO;	\
+  REG_UDC_EP5OutCR = (REG_UDC_EP5OutCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_BULK;	\
+  REG_UDC_EP6OutCR = (REG_UDC_EP6OutCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_BULK;	\
+  REG_UDC_EP7OutCR = (REG_UDC_EP7OutCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_ISO;	\
+} while (0)
+
+#define __udc_enable_ep0out_snoop_mode()  ( REG_UDC_EP0OutCR |= UDC_EPCR_SN )
+#define __udc_enable_ep5out_snoop_mode()  ( REG_UDC_EP5OutCR |= UDC_EPCR_SN )
+#define __udc_enable_ep6out_snoop_mode()  ( REG_UDC_EP6OutCR |= UDC_EPCR_SN )
+#define __udc_enable_ep7out_snoop_mode()  ( REG_UDC_EP7OutCR |= UDC_EPCR_SN )
+
+#define __udc_disable_ep0out_snoop_mode() ( REG_UDC_EP0OutCR &= ~UDC_EPCR_SN )
+#define __udc_disable_ep5out_snoop_mode() ( REG_UDC_EP5OutCR &= ~UDC_EPCR_SN )
+#define __udc_disable_ep6out_snoop_mode() ( REG_UDC_EP6OutCR &= ~UDC_EPCR_SN )
+#define __udc_disable_ep7out_snoop_mode() ( REG_UDC_EP7OutCR &= ~UDC_EPCR_SN )
+
+#define __udc_flush_ep0in_fifo()  ( REG_UDC_EP0InCR |= UDC_EPCR_F )
+#define __udc_flush_ep1in_fifo()  ( REG_UDC_EP1InCR |= UDC_EPCR_F )
+#define __udc_flush_ep2in_fifo()  ( REG_UDC_EP2InCR |= UDC_EPCR_F )
+#define __udc_flush_ep3in_fifo()  ( REG_UDC_EP3InCR |= UDC_EPCR_F )
+#define __udc_flush_ep4in_fifo()  ( REG_UDC_EP4InCR |= UDC_EPCR_F )
+
+#define __udc_unflush_ep0in_fifo()  ( REG_UDC_EP0InCR &= ~UDC_EPCR_F )
+#define __udc_unflush_ep1in_fifo()  ( REG_UDC_EP1InCR &= ~UDC_EPCR_F )
+#define __udc_unflush_ep2in_fifo()  ( REG_UDC_EP2InCR &= ~UDC_EPCR_F )
+#define __udc_unflush_ep3in_fifo()  ( REG_UDC_EP3InCR &= ~UDC_EPCR_F )
+#define __udc_unflush_ep4in_fifo()  ( REG_UDC_EP4InCR &= ~UDC_EPCR_F )
+
+#define __udc_enable_ep0in_stall()  ( REG_UDC_EP0InCR |= UDC_EPCR_S )
+#define __udc_enable_ep0out_stall() ( REG_UDC_EP0OutCR |= UDC_EPCR_S )
+#define __udc_enable_ep1in_stall()  ( REG_UDC_EP1InCR |= UDC_EPCR_S )
+#define __udc_enable_ep2in_stall()  ( REG_UDC_EP2InCR |= UDC_EPCR_S )
+#define __udc_enable_ep3in_stall()  ( REG_UDC_EP3InCR |= UDC_EPCR_S )
+#define __udc_enable_ep4in_stall()  ( REG_UDC_EP4InCR |= UDC_EPCR_S )
+#define __udc_enable_ep5out_stall() ( REG_UDC_EP5OutCR |= UDC_EPCR_S )
+#define __udc_enable_ep6out_stall() ( REG_UDC_EP6OutCR |= UDC_EPCR_S )
+#define __udc_enable_ep7out_stall() ( REG_UDC_EP7OutCR |= UDC_EPCR_S )
+
+#define __udc_disable_ep0in_stall()  ( REG_UDC_EP0InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep0out_stall() ( REG_UDC_EP0OutCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep1in_stall()  ( REG_UDC_EP1InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep2in_stall()  ( REG_UDC_EP2InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep3in_stall()  ( REG_UDC_EP3InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep4in_stall()  ( REG_UDC_EP4InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep5out_stall() ( REG_UDC_EP5OutCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep6out_stall() ( REG_UDC_EP6OutCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep7out_stall() ( REG_UDC_EP7OutCR &= ~UDC_EPCR_S )
+
+
+#define __udc_ep0out_packet_size() \
+  ( (REG_UDC_EP0OutSR & UDC_EPSR_RXPKTSIZE_MASK) >> UDC_EPSR_RXPKTSIZE_BIT )
+#define __udc_ep5out_packet_size() \
+  ( (REG_UDC_EP5OutSR & UDC_EPSR_RXPKTSIZE_MASK) >> UDC_EPSR_RXPKTSIZE_BIT )
+#define __udc_ep6out_packet_size() \
+  ( (REG_UDC_EP6OutSR & UDC_EPSR_RXPKTSIZE_MASK) >> UDC_EPSR_RXPKTSIZE_BIT )
+#define __udc_ep7out_packet_size() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_RXPKTSIZE_MASK) >> UDC_EPSR_RXPKTSIZE_BIT )
+
+#define __udc_ep0in_received_intoken()   ( (REG_UDC_EP0InSR & UDC_EPSR_IN) )
+#define __udc_ep1in_received_intoken()   ( (REG_UDC_EP1InSR & UDC_EPSR_IN) )
+#define __udc_ep2in_received_intoken()   ( (REG_UDC_EP2InSR & UDC_EPSR_IN) )
+#define __udc_ep3in_received_intoken()   ( (REG_UDC_EP3InSR & UDC_EPSR_IN) )
+#define __udc_ep4in_received_intoken()   ( (REG_UDC_EP4InSR & UDC_EPSR_IN) )
+
+#define __udc_ep0out_received_none() \
+  ( (REG_UDC_EP0OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_NONE )
+#define __udc_ep0out_received_data() \
+  ( (REG_UDC_EP0OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVDATA )
+#define __udc_ep0out_received_setup() \
+  ( (REG_UDC_EP0OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVSETUP )
+
+#define __udc_ep5out_received_none() \
+  ( (REG_UDC_EP5OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_NONE )
+#define __udc_ep5out_received_data() \
+  ( (REG_UDC_EP5OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVDATA )
+#define __udc_ep5out_received_setup() \
+  ( (REG_UDC_EP5OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVSETUP )
+
+#define __udc_ep6out_received_none() \
+  ( (REG_UDC_EP6OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_NONE )
+#define __udc_ep6out_received_data() \
+  ( (REG_UDC_EP6OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVDATA )
+#define __udc_ep6out_received_setup() \
+  ( (REG_UDC_EP6OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVSETUP )
+
+#define __udc_ep7out_received_none() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_NONE )
+#define __udc_ep7out_received_data() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVDATA )
+#define __udc_ep7out_received_setup() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVSETUP )
+
+/* ep7out ISO only */
+#define __udc_ep7out_get_pid() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_PID_MASK) >> UDC_EPSR_PID_BIT )
+
+
+#define __udc_ep0in_set_buffer_size(n) ( REG_UDC_EP0InBSR = (n) )
+#define __udc_ep1in_set_buffer_size(n) ( REG_UDC_EP1InBSR = (n) )
+#define __udc_ep2in_set_buffer_size(n) ( REG_UDC_EP2InBSR = (n) )
+#define __udc_ep3in_set_buffer_size(n) ( REG_UDC_EP3InBSR = (n) )
+#define __udc_ep4in_set_buffer_size(n) ( REG_UDC_EP4InBSR = (n) )
+
+#define __udc_ep0out_get_frame_number(n) ( UDC_EP0OutPFNR )
+#define __udc_ep5out_get_frame_number(n) ( UDC_EP5OutPFNR )
+#define __udc_ep6out_get_frame_number(n) ( UDC_EP6OutPFNR )
+#define __udc_ep7out_get_frame_number(n) ( UDC_EP7OutPFNR )
+
+
+#define __udc_ep0in_set_max_packet_size(n)  ( REG_UDC_EP0InMPSR = (n) )
+#define __udc_ep0out_set_max_packet_size(n) ( REG_UDC_EP0OutMPSR = (n) )
+#define __udc_ep1in_set_max_packet_size(n)  ( REG_UDC_EP1InMPSR = (n) )
+#define __udc_ep2in_set_max_packet_size(n)  ( REG_UDC_EP2InMPSR = (n) )
+#define __udc_ep3in_set_max_packet_size(n)  ( REG_UDC_EP3InMPSR = (n) )
+#define __udc_ep4in_set_max_packet_size(n)  ( REG_UDC_EP4InMPSR = (n) )
+#define __udc_ep5out_set_max_packet_size(n) ( REG_UDC_EP5OutMPSR = (n) )
+#define __udc_ep6out_set_max_packet_size(n) ( REG_UDC_EP6OutMPSR = (n) )
+#define __udc_ep7out_set_max_packet_size(n) ( REG_UDC_EP7OutMPSR = (n) )
+
+/* set to 0xFFFF for UDC */
+#define __udc_set_setup_command_address(n)  ( REG_UDC_STCMAR = (n) )
+
+/* Init and configure EPxInfR(x=0,1,2,3,4,5,6,7)
+ * c: Configuration number to which this endpoint belongs
+ * i: Interface number to which this endpoint belongs
+ * a: Alternate setting to which this endpoint belongs
+ * p: max Packet size of this endpoint
+ */
+
+#define __udc_ep0info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP0InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP0InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP0InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP0InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP0InfR |= UDC_EPInfR_EPT_CTRL; 		\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP0InfR |= UDC_EPInfR_EPD_OUT; 		\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP0InfR |= (0 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep1info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP1InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP1InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP1InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP1InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP1InfR |= UDC_EPInfR_EPT_INTR; 		\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP1InfR |= UDC_EPInfR_EPD_IN; 		\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP1InfR |= (1 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep2info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP2InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP2InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP2InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP2InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP2InfR |= UDC_EPInfR_EPT_BULK; 		\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP2InfR |= UDC_EPInfR_EPD_IN; 		\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP2InfR |= (2 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep3info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP3InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP3InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP3InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP3InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP3InfR |= UDC_EPInfR_EPT_BULK; 		\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP3InfR |= UDC_EPInfR_EPD_IN; 		\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP3InfR |= (3 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep4info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP4InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP4InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP4InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP4InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP4InfR |= UDC_EPInfR_EPT_ISO; 		\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP4InfR |= UDC_EPInfR_EPD_IN; 		\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP4InfR |= (4 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep5info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP5InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP5InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP5InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP5InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP5InfR |= UDC_EPInfR_EPT_BULK; 		\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP5InfR |= UDC_EPInfR_EPD_OUT; 		\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP5InfR |= (5 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep6info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP6InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP6InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP6InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP6InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP6InfR |= UDC_EPInfR_EPT_BULK; 		\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP6InfR |= UDC_EPInfR_EPD_OUT; 		\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP6InfR |= (6 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep7info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP7InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP7InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP7InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP7InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP7InfR |= UDC_EPInfR_EPT_ISO; 		\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP7InfR |= UDC_EPInfR_EPD_OUT; 		\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP7InfR |= (7 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* n is the DMA channel (0 - 7) */
+
+#define __dmac_enable_all_channels() \
+  ( REG_DMAC_DMACR |= DMAC_DMACR_DME | DMAC_DMACR_PR_ROUNDROBIN )
+#define __dmac_disable_all_channels() \
+  ( REG_DMAC_DMACR &= ~DMAC_DMACR_DME )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(p) 				\
+do {							\
+	REG_DMAC_DMACR &= ~DMAC_DMACR_PR_MASK;		\
+	REG_DMAC_DMACR |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error() ( REG_DMAC_DMACR & DMAC_DMACR_HTR )
+#define __dmac_test_addr_error() ( REG_DMAC_DMACR & DMAC_DMACR_AER )
+
+#define __dmac_enable_channel(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_CHDE )
+#define __dmac_disable_channel(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_CHDE )
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR(n) & DMAC_DCCSR_CHDE )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_TCIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TCIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_TC )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_AR )
+
+#define __dmac_channel_clear_transmit_halt(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT )
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TC )
+#define __dmac_channel_clear_address_error(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR )
+
+#define __dmac_channel_set_single_mode(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TM )
+#define __dmac_channel_set_block_mode(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_TM )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_32b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_16b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_8b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_16B;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_32B;		\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DWDH_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SWDH_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_RDIL_MASK;		\
+	REG_DMAC_DCCSR(n) |= ((v) << DMAC_DCCSR_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DAM )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DAM )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SAM )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_SAM )
+
+#define __dmac_channel_set_eop_high(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EOPM )
+#define __dmac_channel_set_eop_low(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EOPM )
+
+#define __dmac_channel_set_erdm(n,m)				\
+do {								\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SWDH_MASK;		\
+	REG_DMAC_DCCSR(n) |= ((m) << DMAC_DCCSR_ERDM_BIT);	\
+} while (0)
+
+#define __dmac_channel_set_eackm(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EACKM )
+#define __dmac_channel_clear_eackm(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EACKM )
+
+#define __dmac_channel_set_eacks(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EACKS )
+#define __dmac_channel_clear_eacks(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EACKS )
+
+
+#define __dmac_channel_irq_detected(n) \
+  ( REG_DMAC_DCCSR(n) & (DMAC_DCCSR_TC | DMAC_DCCSR_AR) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i=0;i<NUM_DMA;i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+#define __aic_reset()		( REG_AIC_FR |= AIC_FR_RST )
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(1);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+//#define Jz_AC97_RESET_BUG 1
+#ifndef Jz_AC97_RESET_BUG
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(1);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+#else
+#define __ac97_cold_reset_codec()		\
+ do {						\
+        __gpio_as_output(111); /* SDATA_OUT */	\
+        __gpio_as_output(110); /* SDATA_IN */	\
+        __gpio_as_output(112); /* SYNC */	\
+        __gpio_as_output(114); /* RESET# */	\
+	__gpio_clear_pin(111);			\
+	__gpio_clear_pin(110);			\
+	__gpio_clear_pin(112);			\
+	__gpio_clear_pin(114);			\
+	udelay(2);				\
+	__gpio_set_pin(114);			\
+	udelay(1);				\
+	__gpio_as_ac97();			\
+ } while (0)
+#endif
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_left_justified() ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )
+
+#define __i2s_stop_clock()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_clock()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+
+#define __i2s_is_busy() ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+        __gpio_as_output(111); /* SDATA_OUT */	\
+        __gpio_as_input(110); /* SDATA_IN */	\
+        __gpio_as_output(112); /* SYNC */	\
+        __gpio_as_output(114); /* RESET# */	\
+	__gpio_clear_pin(111);			\
+	__gpio_clear_pin(110);			\
+	__gpio_clear_pin(112);			\
+	__gpio_clear_pin(114);			\
+        __gpio_as_i2s_master();			\
+ } while (0)
+
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+#define __lcd_panel_white()		( REG_LCD_DEV |= LCD_DEV_WHITE )
+#define __lcd_panel_black()		( REG_LCD_DEV &= ~LCD_DEV_WHITE )
+
+/* n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_DEV &= ~LCD_DEV_PDW_MASK; 	\
+	REG_LCD_DEV |= LCD_DEV_PDW_n##;		\
+} while (0)
+
+/* m=LCD_DEV_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_DEV &= ~LCD_DEV_MODE_MASK;	\
+	REG_LCD_DEV |= (m);			\
+} while(0)
+
+/* n = 0-255 */
+#define __lcd_disable_ac_bias()		( REG_LCD_IO = 0xff )
+#define __lcd_set_ac_bias(n) 			\
+do {						\
+	REG_LCD_IO &= ~LCD_IO_ACB_MASK;		\
+	REG_LCD_IO |= ((n) << LCD_IO_ACB_BIT);	\
+} while(0)
+
+#define __lcd_io_set_dir()		( REG_LCD_IO |= LCD_IO_DIR )
+#define __lcd_io_clr_dir()		( REG_LCD_IO &= ~LCD_IO_DIR )
+
+#define __lcd_io_set_dep()		( REG_LCD_IO |= LCD_IO_DEP )
+#define __lcd_io_clr_dep()		( REG_LCD_IO &= ~LCD_IO_DEP )
+
+#define __lcd_io_set_vsp()		( REG_LCD_IO |= LCD_IO_VSP )
+#define __lcd_io_clr_vsp()		( REG_LCD_IO &= ~LCD_IO_VSP )
+
+#define __lcd_io_set_hsp()		( REG_LCD_IO |= LCD_IO_HSP )
+#define __lcd_io_clr_hsp()		( REG_LCD_IO &= ~LCD_IO_HSP )
+
+#define __lcd_io_set_pcp()		( REG_LCD_IO |= LCD_IO_PCP )
+#define __lcd_io_clr_pcp()		( REG_LCD_IO &= ~LCD_IO_PCP )
+
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+
+
+/***************************************************************************
+ * DES
+ ***************************************************************************/
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_plcr1_fd() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1FD_MASK) >> CPM_PLCR1_PLL1FD_BIT)
+#define __cpm_plcr1_rd() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1RD_MASK) >> CPM_PLCR1_PLL1RD_BIT)
+#define __cpm_plcr1_od() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1OD_MASK) >> CPM_PLCR1_PLL1OD_BIT)
+#define __cpm_cfcr_mfr() \
+	((REG_CPM_CFCR & CPM_CFCR_MFR_MASK) >> CPM_CFCR_MFR_BIT)
+#define __cpm_cfcr_pfr() \
+	((REG_CPM_CFCR & CPM_CFCR_PFR_MASK) >> CPM_CFCR_PFR_BIT)
+#define __cpm_cfcr_sfr() \
+	((REG_CPM_CFCR & CPM_CFCR_SFR_MASK) >> CPM_CFCR_SFR_BIT)
+#define __cpm_cfcr_ifr() \
+	((REG_CPM_CFCR & CPM_CFCR_IFR_MASK) >> CPM_CFCR_IFR_BIT)
+
+static __inline__ unsigned int __cpm_divisor_encode(unsigned int n)
+{
+	unsigned int encode[10] = {1,2,3,4,6,8,12,16,24,32};
+	int i;
+	for (i=0;i<10;i++)
+		if (n < encode[i])
+			break;
+	return i;
+}
+
+#define __cpm_set_mclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_MFR_MASK) | \
+		       ((n) << (CPM_CFCR_MFR_BIT)); \
+} while (0)
+
+#define __cpm_set_pclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_PFR_MASK) | \
+		       ((n) << (CPM_CFCR_PFR_BIT)); \
+} while (0)
+
+#define __cpm_set_sclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_SFR_MASK) | \
+		       ((n) << (CPM_CFCR_SFR_BIT)); \
+} while (0)
+
+#define __cpm_set_iclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_IFR_MASK) | \
+		       ((n) << (CPM_CFCR_IFR_BIT)); \
+} while (0)
+
+#define __cpm_set_lcdclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_LFR_MASK) | \
+		       ((n) << (CPM_CFCR_LFR_BIT)); \
+} while (0)
+
+#define __cpm_enable_cko1()  (REG_CPM_CFCR |= CPM_CFCR_CKOEN1)
+#define __cpm_enable_cko2()  (REG_CPM_CFCR |= CPM_CFCR_CKOEN2)
+#define __cpm_disable_cko1()  (REG_CPM_CFCR &= ~CPM_CFCR_CKOEN1)
+#define __cpm_disable_cko2()  (REG_CPM_CFCR &= ~CPM_CFCR_CKOEN2)
+
+#define __cpm_idle_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_IDLE)
+#define __cpm_sleep_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_SLEEP)
+#define __cpm_hibernate_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_HIBERNATE)
+
+#define __cpm_start_uart0() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UART0))
+#define __cpm_start_uart1() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UART1))
+#define __cpm_start_uart2() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UART2))
+#define __cpm_start_uart3() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UART3))
+#define __cpm_start_ost() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_OST))
+#define __cpm_start_dmac() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_DMAC))
+#define __cpm_start_uhc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UHC))
+#define __cpm_start_lcd() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_LCD))
+#define __cpm_start_i2c() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_I2C))
+#define __cpm_start_aic_pclk() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_AICPCLK))
+#define __cpm_start_aic_bitclk() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_AICBCLK))
+#define __cpm_start_pwm0() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_PWM0))
+#define __cpm_start_pwm1() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_PWM1))
+#define __cpm_start_ssi() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_SSI))
+#define __cpm_start_msc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_MSC))
+#define __cpm_start_scc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_SCC))
+#define __cpm_start_eth() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_ETH))
+#define __cpm_start_kbc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_KBC))
+#define __cpm_start_cim() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_CIM))
+#define __cpm_start_udc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UDC))
+#define __cpm_start_uprt() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UPRT))
+#define __cpm_start_all() (REG_CPM_MSCR = 0)
+
+#define __cpm_stop_uart0() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UART0))
+#define __cpm_stop_uart1() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UART1))
+#define __cpm_stop_uart2() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UART2))
+#define __cpm_stop_uart3() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UART3))
+#define __cpm_stop_ost() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_OST))
+#define __cpm_stop_dmac() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_DMAC))
+#define __cpm_stop_uhc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UHC))
+#define __cpm_stop_lcd() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_LCD))
+#define __cpm_stop_i2c() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_I2C))
+#define __cpm_stop_aic_pclk() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_AICPCLK))
+#define __cpm_stop_aic_bitclk() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_AICBCLK))
+#define __cpm_stop_pwm0() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_PWM0))
+#define __cpm_stop_pwm1() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_PWM1))
+#define __cpm_stop_ssi() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_SSI))
+#define __cpm_stop_msc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_MSC))
+#define __cpm_stop_scc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_SCC))
+#define __cpm_stop_eth() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_ETH))
+#define __cpm_stop_kbc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_KBC))
+#define __cpm_stop_cim() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_CIM))
+#define __cpm_stop_udc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UDC))
+#define __cpm_stop_uprt() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UPRT))
+#define __cpm_stop_all() (REG_CPM_MSCR = 0xffffffff)
+
+#define __cpm_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (p == 0)				\
+		REG_CPM_GSR0 |= (1 << o);	\
+	else if (p == 1)			\
+		REG_CPM_GSR1 |= (1 << o);	\
+	else if (p == 2)			\
+		REG_CPM_GSR2 |= (1 << o);	\
+	else if (p == 3)			\
+		REG_CPM_GSR3 |= (1 << o);	\
+} while (0)
+
+#define __cpm_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (p == 0)				\
+		REG_CPM_GSR0 &= ~(1 << o);	\
+	else if (p == 1)			\
+		REG_CPM_GSR1 &= ~(1 << o);	\
+	else if (p == 2)			\
+		REG_CPM_GSR2 &= ~(1 << o);	\
+	else if (p == 3)			\
+		REG_CPM_GSR3 &= ~(1 << o);	\
+} while (0)
+
+
+#define __cpm_select_msc_clk(type) \
+do {                               \
+  if (type == 0)                   \
+    REG_CPM_CFCR &= ~CPM_CFCR_MSC; \
+  else                             \
+    REG_CPM_CFCR |= CPM_CFCR_MSC;  \
+  REG_CPM_CFCR |= CPM_CFCR_UPE;    \
+} while(0)
+
+
+/***************************************************************************
+ * SSI
+ ***************************************************************************/
+
+#define __ssi_enable()    ( REG_SSI_CR0 |= SSI_CR0_SSIE )
+#define __ssi_disable()   ( REG_SSI_CR0 &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce() ( REG_SSI_CR0 &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode() ( REG_SSI_ITR &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2() 		\
+do { 					\
+	REG_SSI_CR0 |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 &= ~SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_select_gpc() 		\
+do { 					\
+	REG_SSI_CR0 &= ~SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 |= SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_loopback()  ( REG_SSI_CR0 |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback() ( REG_SSI_CR0 &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive()   ( REG_SSI_CR0 &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive()  ( REG_SSI_CR0 |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive() 	\
+  ( REG_SSI_CR0 |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo()   ( REG_SSI_CR0 |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo()   ( REG_SSI_CR0 |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo() \
+  ( REG_SSI_CR0 |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit() ( REG_SSI_CR1 &= ~SSI_CR1_UNFIN )
+
+/* Motorola's SPI format, set 1 delay */
+#define __ssi_spi_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SPI; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN); 	\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SSP; 			\
+} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format() 				\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_MW1; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+	REG_SSI_CR0 &= ~SSI_CR0_RFINE; 				\
+} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+ /* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	| SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	\
+
+#define __ssi_spi_set_misc(frmhl,endian,flen,mcom,pha,pol)	\
+do { 								\
+	REG_SSI_CR1 &= ~SSICR1_MISC_MASK; 			\
+	REG_SSI_CR1 |= ((frmhl) << 30) | ((endian) << 25) | 	\
+		 (((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+	         ((pha) << 1) | (pol); 				\
+} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb() ( REG_SSI_CR1 &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb() ( REG_SSI_CR1 |= SSI_CR1_LFST )
+
+/* n = 2 - 17 */
+#define __ssi_set_frame_length(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_FLEN_MASK) | SSI_CR1_FLEN_##n##BIT) )
+
+/* n = 1 - 16 */
+#define __ssi_set_microwire_command_length(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##n##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_PHA) | (n&0x1)) )
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_POL) | (n&0x1)) )
+
+/* n = 1,4,8,14 */
+#define __ssi_set_tx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_TTRG_MASK; 	\
+	REG_SSI_CR1 |= SSI_CR1_TTRG_##n; 	\
+} while (0)
+
+/* n = 1,4,8,14 */
+#define __ssi_set_rx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_RTRG_MASK; 	\
+	REG_SSI_CR1 |= SSI_CR1_RTRG_##n; 	\
+} while (0)
+
+#define __ssi_get_txfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_clear_errors() \
+    ( REG_SSI_SR &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_transfer_end()	( REG_SSI_SR & SSI_SR_END )
+#define __ssi_is_busy()		( REG_SSI_SR & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full()	( REG_SSI_SR & SSI_SR_TFF )
+#define __ssi_rxfifo_empty()	( REG_SSI_SR & SSI_SR_RFE )
+#define __ssi_rxfifo_noempty()	( REG_SSI_SR & SSI_SR_RFHF )
+
+#define __ssi_set_clk(dev_clk, ssi_clk) \
+  ( REG_SSI_GR = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data()    REG_SSI_DR
+#define __ssi_transmit_data(v)  ( REG_SSI_DR = (v) )
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+
+#define __wdt_set_count(count) ( REG_WDT_WTCNT = (count) )
+#define __wdt_start()          ( REG_WDT_WTCSR |= WDT_WTCSR_START )
+#define __wdt_stop()           ( REG_WDT_WTCSR &= ~WDT_WTCSR_START )
+
+
+/***************************************************************************
+ ***************************************************************************/
+
+/* 
+ * CPU clocks
+ */
+#ifdef CFG_EXTAL
+#define JZ_EXTAL		CFG_EXTAL
+#else
+#define JZ_EXTAL		3686400
+#endif
+#define JZ_EXTAL2		32768 /* RTC clock */
+
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned int nf, nr, no, pllout;
+	unsigned long plcr = REG_CPM_PLCR1;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if (plcr & CPM_PLCR1_PLL1EN) {
+		nf = (plcr & CPM_PLCR1_PLL1FD_MASK) >> CPM_PLCR1_PLL1FD_BIT;
+		nr = (plcr & CPM_PLCR1_PLL1RD_MASK) >> CPM_PLCR1_PLL1RD_BIT;
+		no = od[((plcr & CPM_PLCR1_PLL1OD_MASK) >> CPM_PLCR1_PLL1OD_BIT)];
+		pllout = (JZ_EXTAL) / ((nr+2) * no) * (nf+2);
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+static __inline__ unsigned int __cpm_get_iclk(void)
+{
+	unsigned int iclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		iclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_IFR_MASK) >> CPM_CFCR_IFR_BIT];
+	else
+		iclk = JZ_EXTAL;
+	return iclk;
+}
+
+static __inline__ unsigned int __cpm_get_sclk(void)
+{
+	unsigned int sclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		sclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_SFR_MASK) >> CPM_CFCR_SFR_BIT];
+	else
+		sclk = JZ_EXTAL;
+	return sclk;
+}
+
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	unsigned int mclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		mclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_MFR_MASK) >> CPM_CFCR_MFR_BIT];
+	else
+		mclk = JZ_EXTAL;
+	return mclk;
+}
+
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+	unsigned int devclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		devclk = __cpm_get_pllout() /
+			 div[(cfcr & CPM_CFCR_PFR_MASK) >> CPM_CFCR_PFR_BIT];
+	else
+		devclk = JZ_EXTAL;
+	return devclk;
+}
+
+static __inline__ unsigned int __cpm_get_devclk(void)
+{
+	unsigned int devclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		devclk = __cpm_get_pllout() /
+			 div[(cfcr & CPM_CFCR_PFR_MASK) >> CPM_CFCR_PFR_BIT];
+	else
+		devclk = JZ_EXTAL;
+	return devclk;
+}
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __JZ4730_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz4740.h u-boot-1.1.6/include/asm-mips/jz4740.h
--- /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz4740.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/asm-mips/jz4740.h	2009-02-03 21:04:51.000000000 +0800
@@ -0,0 +1,4908 @@
+/*
+ * Include file for Ingenic Semiconductor's JZ4740 CPU.
+ */
+#ifndef __JZ4740_H__
+#define __JZ4740_H__
+
+#ifndef __ASSEMBLY__
+#define UCOS_CSP 0
+
+#if UCOS_CSP
+#define __KERNEL__
+#include <bsp.h>
+#include <types.h>
+
+#include <sysdefs.h>
+#include <cacheops.h>
+#define KSEG0 KSEG0BASE
+#else
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+#endif
+
+#define cache_unroll(base,op)	        	\
+	__asm__ __volatile__("	         	\
+		.set noreorder;		        \
+		.set mips3;		        \
+		cache %1, (%0);	                \
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+static inline void jz_flush_dcache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_DCACHE_SIZE;
+	while (start < end) {
+		cache_unroll(start,Index_Writeback_Inv_D);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+static inline void jz_flush_icache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_ICACHE_SIZE;
+	while(start < end) {
+		cache_unroll(start,Index_Invalidate_I);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+/* cpu pipeline flush */
+static inline void jz_sync(void)
+{
+	__asm__ volatile ("sync");
+}
+
+static inline void jz_writeb(u32 address, u8 value)
+{
+	*((volatile u8 *)address) = value;
+}
+
+static inline void jz_writew(u32 address, u16 value)
+{
+	*((volatile u16 *)address) = value;
+}
+
+static inline void jz_writel(u32 address, u32 value)
+{
+	*((volatile u32 *)address) = value;
+}
+
+static inline u8 jz_readb(u32 address)
+{
+	return *((volatile u8 *)address);
+}
+
+static inline u16 jz_readw(u32 address)
+{
+	return *((volatile u16 *)address);
+}
+
+static inline u32 jz_readl(u32 address)
+{
+	return *((volatile u32 *)address);
+}
+
+#define REG8(addr)	*((volatile u8 *)(addr))
+#define REG16(addr)	*((volatile u16 *)(addr))
+#define REG32(addr)	*((volatile u32 *)(addr))
+
+#else
+
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+
+#endif /* !ASSEMBLY */
+
+//----------------------------------------------------------------------
+// Boot ROM Specification
+//
+
+/* NOR Boot config */
+#define JZ4740_NORBOOT_8BIT	0x00000000	/* 8-bit data bus flash */
+#define JZ4740_NORBOOT_16BIT	0x10101010	/* 16-bit data bus flash */
+#define JZ4740_NORBOOT_32BIT	0x20202020	/* 32-bit data bus flash */
+
+/* NAND Boot config */
+#define JZ4740_NANDBOOT_B8R3	0xffffffff	/* 8-bit bus & 3 row cycles */
+#define JZ4740_NANDBOOT_B8R2	0xf0f0f0f0	/* 8-bit bus & 2 row cycles */
+#define JZ4740_NANDBOOT_B16R3	0x0f0f0f0f	/* 16-bit bus & 3 row cycles */
+#define JZ4740_NANDBOOT_B16R2	0x00000000	/* 16-bit bus & 2 row cycles */
+
+
+//----------------------------------------------------------------------
+// Register Definitions
+//
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	TCU_BASE	0xB0002000
+#define	WDT_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	ICDC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SADC_BASE	0xB0070000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	SLCD_BASE	0xB3050000
+#define	CIM_BASE	0xB3060000
+#define	ETH_BASE	0xB3100000
+
+
+/*************************************************************************
+ * INTC (Interrupt Controller)
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+// 1st-level interrupts
+#define IRQ_I2C		1
+#define IRQ_UHC		3
+#define IRQ_UART0	9
+#define IRQ_SADC	12
+#define IRQ_MSC		14
+#define IRQ_RTC		15
+#define IRQ_SSI		16
+#define IRQ_CIM		17
+#define IRQ_AIC		18
+#define IRQ_ETH		19
+#define IRQ_DMAC	20
+#define IRQ_TCU2	21
+#define IRQ_TCU1	22
+#define IRQ_TCU0	23
+#define IRQ_UDC 	24
+#define IRQ_GPIO3	25
+#define IRQ_GPIO2	26
+#define IRQ_GPIO1	27
+#define IRQ_GPIO0	28
+#define IRQ_IPU		29
+#define IRQ_LCD		30
+
+// 2nd-level interrupts
+#define IRQ_DMA_0	32  /* 32 to 37 for DMAC channel 0 to 5 */
+#define IRQ_GPIO_0	48  /* 48 to 175 for GPIO pin 0 to 127 */
+
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00) /* RTC Control Register */
+#define RTC_RSR		(RTC_BASE + 0x04) /* RTC Second Register */
+#define RTC_RSAR	(RTC_BASE + 0x08) /* RTC Second Alarm Register */
+#define RTC_RGR		(RTC_BASE + 0x0c) /* RTC Regulator Register */
+
+#define RTC_HCR		(RTC_BASE + 0x20) /* Hibernate Control Register */
+#define RTC_HWFCR	(RTC_BASE + 0x24) /* Hibernate Wakeup Filter Counter Reg */
+#define RTC_HRCR	(RTC_BASE + 0x28) /* Hibernate Reset Counter Register */
+#define RTC_HWCR	(RTC_BASE + 0x2c) /* Hibernate Wakeup Control Register */
+#define RTC_HWRSR	(RTC_BASE + 0x30) /* Hibernate Wakeup Status Register */
+#define RTC_HSPR	(RTC_BASE + 0x34) /* Hibernate Scratch Pattern Register */
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+#define REG_RTC_HCR	REG32(RTC_HCR)
+#define REG_RTC_HWFCR	REG32(RTC_HWFCR)
+#define REG_RTC_HRCR	REG32(RTC_HRCR)
+#define REG_RTC_HWCR	REG32(RTC_HWCR)
+#define REG_RTC_HWRSR	REG32(RTC_HWRSR)
+#define REG_RTC_HSPR	REG32(RTC_HSPR)
+
+/* RTC Control Register */
+#define RTC_RCR_WRDY	(1 << 7)  /* Write Ready Flag */
+#define RTC_RCR_HZ	(1 << 6)  /* 1Hz Flag */
+#define RTC_RCR_HZIE	(1 << 5)  /* 1Hz Interrupt Enable */
+#define RTC_RCR_AF	(1 << 4)  /* Alarm Flag */
+#define RTC_RCR_AIE	(1 << 3)  /* Alarm Interrupt Enable */
+#define RTC_RCR_AE	(1 << 2)  /* Alarm Enable */
+#define RTC_RCR_RTCE	(1 << 0)  /* RTC Enable */
+
+/* RTC Regulator Register */
+#define RTC_RGR_LOCK		(1 << 31) /* Lock Bit */
+#define RTC_RGR_ADJC_BIT	16
+#define RTC_RGR_ADJC_MASK	(0x3ff << RTC_RGR_ADJC_BIT)
+#define RTC_RGR_NC1HZ_BIT	0
+#define RTC_RGR_NC1HZ_MASK	(0xffff << RTC_RGR_NC1HZ_BIT)
+
+/* Hibernate Control Register */
+#define RTC_HCR_PD		(1 << 0)  /* Power Down */
+
+/* Hibernate Wakeup Filter Counter Register */
+#define RTC_HWFCR_BIT		5
+#define RTC_HWFCR_MASK		(0x7ff << RTC_HWFCR_BIT)
+
+/* Hibernate Reset Counter Register */
+#define RTC_HRCR_BIT		5
+#define RTC_HRCR_MASK		(0x7f << RTC_HRCR_BIT)
+
+/* Hibernate Wakeup Control Register */
+#define RTC_HWCR_EALM		(1 << 0)  /* RTC alarm wakeup enable */
+
+/* Hibernate Wakeup Status Register */
+#define RTC_HWRSR_HR		(1 << 5)  /* Hibernate reset */
+#define RTC_HWRSR_PPR		(1 << 4)  /* PPR reset */
+#define RTC_HWRSR_PIN		(1 << 1)  /* Wakeup pin status bit */
+#define RTC_HWRSR_ALM		(1 << 0)  /* RTC alarm status bit */
+
+
+/*************************************************************************
+ * CPM (Clock reset and Power control Management)
+ *************************************************************************/
+#define CPM_CPCCR	(CPM_BASE+0x00)
+#define CPM_CPPCR	(CPM_BASE+0x10)
+#define CPM_I2SCDR	(CPM_BASE+0x60)
+#define CPM_LPCDR	(CPM_BASE+0x64)
+#define CPM_MSCCDR	(CPM_BASE+0x68)
+#define CPM_UHCCDR	(CPM_BASE+0x6C)
+
+#define CPM_LCR		(CPM_BASE+0x04)
+#define CPM_CLKGR	(CPM_BASE+0x20)
+#define CPM_SCR		(CPM_BASE+0x24)
+
+#define CPM_HCR		(CPM_BASE+0x30)
+#define CPM_HWFCR	(CPM_BASE+0x34)
+#define CPM_HRCR	(CPM_BASE+0x38)
+#define CPM_HWCR	(CPM_BASE+0x3c)
+#define CPM_HWSR	(CPM_BASE+0x40)
+#define CPM_HSPR	(CPM_BASE+0x44)
+
+#define CPM_RSR		(CPM_BASE+0x08)
+
+
+#define REG_CPM_CPCCR	REG32(CPM_CPCCR)
+#define REG_CPM_CPPCR	REG32(CPM_CPPCR)
+#define REG_CPM_I2SCDR	REG32(CPM_I2SCDR)
+#define REG_CPM_LPCDR	REG32(CPM_LPCDR)
+#define REG_CPM_MSCCDR	REG32(CPM_MSCCDR)
+#define REG_CPM_UHCCDR	REG32(CPM_UHCCDR)
+
+#define REG_CPM_LCR	REG32(CPM_LCR)
+#define REG_CPM_CLKGR	REG32(CPM_CLKGR)
+#define REG_CPM_SCR	REG32(CPM_SCR)
+#define REG_CPM_HCR	REG32(CPM_HCR)
+#define REG_CPM_HWFCR	REG32(CPM_HWFCR)
+#define REG_CPM_HRCR	REG32(CPM_HRCR)
+#define REG_CPM_HWCR	REG32(CPM_HWCR)
+#define REG_CPM_HWSR	REG32(CPM_HWSR)
+#define REG_CPM_HSPR	REG32(CPM_HSPR)
+
+#define REG_CPM_RSR	REG32(CPM_RSR)
+
+
+/* Clock Control Register */
+#define CPM_CPCCR_I2CS		(1 << 31)
+#define CPM_CPCCR_CLKOEN	(1 << 30)
+#define CPM_CPCCR_UCS		(1 << 29)
+#define CPM_CPCCR_UDIV_BIT	23
+#define CPM_CPCCR_UDIV_MASK	(0x3f << CPM_CPCCR_UDIV_BIT)
+#define CPM_CPCCR_CE		(1 << 22)
+#define CPM_CPCCR_PCS		(1 << 21)
+#define CPM_CPCCR_LDIV_BIT	16
+#define CPM_CPCCR_LDIV_MASK	(0x1f << CPM_CPCCR_LDIV_BIT)
+#define CPM_CPCCR_MDIV_BIT	12
+#define CPM_CPCCR_MDIV_MASK	(0x0f << CPM_CPCCR_MDIV_BIT)
+#define CPM_CPCCR_PDIV_BIT	8
+#define CPM_CPCCR_PDIV_MASK	(0x0f << CPM_CPCCR_PDIV_BIT)
+#define CPM_CPCCR_HDIV_BIT	4
+#define CPM_CPCCR_HDIV_MASK	(0x0f << CPM_CPCCR_HDIV_BIT)
+#define CPM_CPCCR_CDIV_BIT	0
+#define CPM_CPCCR_CDIV_MASK	(0x0f << CPM_CPCCR_CDIV_BIT)
+
+/* I2S Clock Divider Register */
+#define CPM_I2SCDR_I2SDIV_BIT	0
+#define CPM_I2SCDR_I2SDIV_MASK	(0x1ff << CPM_I2SCDR_I2SDIV_BIT)
+
+/* LCD Pixel Clock Divider Register */
+#define CPM_LPCDR_PIXDIV_BIT	0
+#define CPM_LPCDR_PIXDIV_MASK	(0x1ff << CPM_LPCDR_PIXDIV_BIT)
+
+/* MSC Clock Divider Register */
+#define CPM_MSCCDR_MSCDIV_BIT	0
+#define CPM_MSCCDR_MSCDIV_MASK	(0x1f << CPM_MSCCDR_MSCDIV_BIT)
+
+/* PLL Control Register */
+#define CPM_CPPCR_PLLM_BIT	23
+#define CPM_CPPCR_PLLM_MASK	(0x1ff << CPM_CPPCR_PLLM_BIT)
+#define CPM_CPPCR_PLLN_BIT	18
+#define CPM_CPPCR_PLLN_MASK	(0x1f << CPM_CPPCR_PLLN_BIT)
+#define CPM_CPPCR_PLLOD_BIT	16
+#define CPM_CPPCR_PLLOD_MASK	(0x03 << CPM_CPPCR_PLLOD_BIT)
+#define CPM_CPPCR_PLLS		(1 << 10)
+#define CPM_CPPCR_PLLBP		(1 << 9)
+#define CPM_CPPCR_PLLEN		(1 << 8)
+#define CPM_CPPCR_PLLST_BIT	0
+#define CPM_CPPCR_PLLST_MASK	(0xff << CPM_CPPCR_PLLST_BIT)
+
+/* Low Power Control Register */
+#define CPM_LCR_DOZE_DUTY_BIT 	3
+#define CPM_LCR_DOZE_DUTY_MASK 	(0x1f << CPM_LCR_DOZE_DUTY_BIT)
+#define CPM_LCR_DOZE_ON		(1 << 2)
+#define CPM_LCR_LPM_BIT		0
+#define CPM_LCR_LPM_MASK	(0x3 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_IDLE	(0x0 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_SLEEP	(0x1 << CPM_LCR_LPM_BIT)
+
+/* Clock Gate Register */
+#define CPM_CLKGR_UART1		(1 << 15)
+#define CPM_CLKGR_UHC		(1 << 14)
+#define CPM_CLKGR_IPU		(1 << 13)
+#define CPM_CLKGR_DMAC		(1 << 12)
+#define CPM_CLKGR_UDC		(1 << 11)
+#define CPM_CLKGR_LCD		(1 << 10)
+#define CPM_CLKGR_CIM		(1 << 9)
+#define CPM_CLKGR_SADC		(1 << 8)
+#define CPM_CLKGR_MSC		(1 << 7)
+#define CPM_CLKGR_AIC1		(1 << 6)
+#define CPM_CLKGR_AIC2		(1 << 5)
+#define CPM_CLKGR_SSI		(1 << 4)
+#define CPM_CLKGR_I2C		(1 << 3)
+#define CPM_CLKGR_RTC		(1 << 2)
+#define CPM_CLKGR_TCU		(1 << 1)
+#define CPM_CLKGR_UART0		(1 << 0)
+
+/* Sleep Control Register */
+#define CPM_SCR_O1ST_BIT	8
+#define CPM_SCR_O1ST_MASK	(0xff << CPM_SCR_O1ST_BIT)
+#define CPM_SCR_USBPHY_ENABLE	(1 << 6)
+#define CPM_SCR_OSC_ENABLE	(1 << 4)
+
+/* Hibernate Control Register */
+#define CPM_HCR_PD		(1 << 0)
+
+/* Wakeup Filter Counter Register in Hibernate Mode */
+#define CPM_HWFCR_TIME_BIT	0
+#define CPM_HWFCR_TIME_MASK	(0x3ff << CPM_HWFCR_TIME_BIT)
+
+/* Reset Counter Register in Hibernate Mode */
+#define CPM_HRCR_TIME_BIT	0
+#define CPM_HRCR_TIME_MASK	(0x7f << CPM_HRCR_TIME_BIT)
+
+/* Wakeup Control Register in Hibernate Mode */
+#define CPM_HWCR_WLE_LOW	(0 << 2)
+#define CPM_HWCR_WLE_HIGH	(1 << 2)
+#define CPM_HWCR_PIN_WAKEUP	(1 << 1)
+#define CPM_HWCR_RTC_WAKEUP	(1 << 0)
+
+/* Wakeup Status Register in Hibernate Mode */
+#define CPM_HWSR_WSR_PIN	(1 << 1)
+#define CPM_HWSR_WSR_RTC	(1 << 0)
+
+/* Reset Status Register */
+#define CPM_RSR_HR		(1 << 2)
+#define CPM_RSR_WR		(1 << 1)
+#define CPM_RSR_PR		(1 << 0)
+
+
+/*************************************************************************
+ * TCU (Timer Counter Unit)
+ *************************************************************************/
+#define TCU_TSR		(TCU_BASE + 0x1C) /* Timer Stop Register */
+#define TCU_TSSR	(TCU_BASE + 0x2C) /* Timer Stop Set Register */
+#define TCU_TSCR	(TCU_BASE + 0x3C) /* Timer Stop Clear Register */
+#define TCU_TER		(TCU_BASE + 0x10) /* Timer Counter Enable Register */
+#define TCU_TESR	(TCU_BASE + 0x14) /* Timer Counter Enable Set Register */
+#define TCU_TECR	(TCU_BASE + 0x18) /* Timer Counter Enable Clear Register */
+#define TCU_TFR		(TCU_BASE + 0x20) /* Timer Flag Register */
+#define TCU_TFSR	(TCU_BASE + 0x24) /* Timer Flag Set Register */
+#define TCU_TFCR	(TCU_BASE + 0x28) /* Timer Flag Clear Register */
+#define TCU_TMR		(TCU_BASE + 0x30) /* Timer Mask Register */
+#define TCU_TMSR	(TCU_BASE + 0x34) /* Timer Mask Set Register */
+#define TCU_TMCR	(TCU_BASE + 0x38) /* Timer Mask Clear Register */
+#define TCU_TDFR0	(TCU_BASE + 0x40) /* Timer Data Full Register */
+#define TCU_TDHR0	(TCU_BASE + 0x44) /* Timer Data Half Register */
+#define TCU_TCNT0	(TCU_BASE + 0x48) /* Timer Counter Register */
+#define TCU_TCSR0	(TCU_BASE + 0x4C) /* Timer Control Register */
+#define TCU_TDFR1	(TCU_BASE + 0x50)
+#define TCU_TDHR1	(TCU_BASE + 0x54)
+#define TCU_TCNT1	(TCU_BASE + 0x58)
+#define TCU_TCSR1	(TCU_BASE + 0x5C)
+#define TCU_TDFR2	(TCU_BASE + 0x60)
+#define TCU_TDHR2	(TCU_BASE + 0x64)
+#define TCU_TCNT2	(TCU_BASE + 0x68)
+#define TCU_TCSR2	(TCU_BASE + 0x6C)
+#define TCU_TDFR3	(TCU_BASE + 0x70)
+#define TCU_TDHR3	(TCU_BASE + 0x74)
+#define TCU_TCNT3	(TCU_BASE + 0x78)
+#define TCU_TCSR3	(TCU_BASE + 0x7C)
+#define TCU_TDFR4	(TCU_BASE + 0x80)
+#define TCU_TDHR4	(TCU_BASE + 0x84)
+#define TCU_TCNT4	(TCU_BASE + 0x88)
+#define TCU_TCSR4	(TCU_BASE + 0x8C)
+#define TCU_TDFR5	(TCU_BASE + 0x90)
+#define TCU_TDHR5	(TCU_BASE + 0x94)
+#define TCU_TCNT5	(TCU_BASE + 0x98)
+#define TCU_TCSR5	(TCU_BASE + 0x9C)
+
+#define REG_TCU_TSR	REG32(TCU_TSR)
+#define REG_TCU_TSSR	REG32(TCU_TSSR)
+#define REG_TCU_TSCR	REG32(TCU_TSCR)
+#define REG_TCU_TER	REG8(TCU_TER)
+#define REG_TCU_TESR	REG8(TCU_TESR)
+#define REG_TCU_TECR	REG8(TCU_TECR)
+#define REG_TCU_TFR	REG32(TCU_TFR)
+#define REG_TCU_TFSR	REG32(TCU_TFSR)
+#define REG_TCU_TFCR	REG32(TCU_TFCR)
+#define REG_TCU_TMR	REG32(TCU_TMR)
+#define REG_TCU_TMSR	REG32(TCU_TMSR)
+#define REG_TCU_TMCR	REG32(TCU_TMCR)
+#define REG_TCU_TDFR0	REG16(TCU_TDFR0)
+#define REG_TCU_TDHR0	REG16(TCU_TDHR0)
+#define REG_TCU_TCNT0	REG16(TCU_TCNT0)
+#define REG_TCU_TCSR0	REG16(TCU_TCSR0)
+#define REG_TCU_TDFR1	REG16(TCU_TDFR1)
+#define REG_TCU_TDHR1	REG16(TCU_TDHR1)
+#define REG_TCU_TCNT1	REG16(TCU_TCNT1)
+#define REG_TCU_TCSR1	REG16(TCU_TCSR1)
+#define REG_TCU_TDFR2	REG16(TCU_TDFR2)
+#define REG_TCU_TDHR2	REG16(TCU_TDHR2)
+#define REG_TCU_TCNT2	REG16(TCU_TCNT2)
+#define REG_TCU_TCSR2	REG16(TCU_TCSR2)
+#define REG_TCU_TDFR3	REG16(TCU_TDFR3)
+#define REG_TCU_TDHR3	REG16(TCU_TDHR3)
+#define REG_TCU_TCNT3	REG16(TCU_TCNT3)
+#define REG_TCU_TCSR3	REG16(TCU_TCSR3)
+#define REG_TCU_TDFR4	REG16(TCU_TDFR4)
+#define REG_TCU_TDHR4	REG16(TCU_TDHR4)
+#define REG_TCU_TCNT4	REG16(TCU_TCNT4)
+#define REG_TCU_TCSR4	REG16(TCU_TCSR4)
+
+// n = 0,1,2,3,4,5
+#define TCU_TDFR(n)	(TCU_BASE + (0x40 + (n)*0x10)) /* Timer Data Full Reg */
+#define TCU_TDHR(n)	(TCU_BASE + (0x44 + (n)*0x10)) /* Timer Data Half Reg */
+#define TCU_TCNT(n)	(TCU_BASE + (0x48 + (n)*0x10)) /* Timer Counter Reg */
+#define TCU_TCSR(n)	(TCU_BASE + (0x4C + (n)*0x10)) /* Timer Control Reg */
+
+#define REG_TCU_TDFR(n)	REG16(TCU_TDFR((n)))
+#define REG_TCU_TDHR(n)	REG16(TCU_TDHR((n)))
+#define REG_TCU_TCNT(n)	REG16(TCU_TCNT((n)))
+#define REG_TCU_TCSR(n)	REG16(TCU_TCSR((n)))
+
+// Register definitions
+#define TCU_TCSR_PWM_SD		(1 << 9)
+#define TCU_TCSR_PWM_INITL_HIGH	(1 << 8)
+#define TCU_TCSR_PWM_EN		(1 << 7)
+#define TCU_TCSR_PRESCALE_BIT	3
+#define TCU_TCSR_PRESCALE_MASK	(0x7 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1	(0x0 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE4	(0x1 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE16	(0x2 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE64	(0x3 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE256	(0x4 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1024	(0x5 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_EXT_EN		(1 << 2)
+#define TCU_TCSR_RTC_EN		(1 << 1)
+#define TCU_TCSR_PCK_EN		(1 << 0)
+
+#define TCU_TER_TCEN5		(1 << 5)
+#define TCU_TER_TCEN4		(1 << 4)
+#define TCU_TER_TCEN3		(1 << 3)
+#define TCU_TER_TCEN2		(1 << 2)
+#define TCU_TER_TCEN1		(1 << 1)
+#define TCU_TER_TCEN0		(1 << 0)
+
+#define TCU_TESR_TCST5		(1 << 5)
+#define TCU_TESR_TCST4		(1 << 4)
+#define TCU_TESR_TCST3		(1 << 3)
+#define TCU_TESR_TCST2		(1 << 2)
+#define TCU_TESR_TCST1		(1 << 1)
+#define TCU_TESR_TCST0		(1 << 0)
+
+#define TCU_TECR_TCCL5		(1 << 5)
+#define TCU_TECR_TCCL4		(1 << 4)
+#define TCU_TECR_TCCL3		(1 << 3)
+#define TCU_TECR_TCCL2		(1 << 2)
+#define TCU_TECR_TCCL1		(1 << 1)
+#define TCU_TECR_TCCL0		(1 << 0)
+
+#define TCU_TFR_HFLAG5		(1 << 21)
+#define TCU_TFR_HFLAG4		(1 << 20)
+#define TCU_TFR_HFLAG3		(1 << 19)
+#define TCU_TFR_HFLAG2		(1 << 18)
+#define TCU_TFR_HFLAG1		(1 << 17)
+#define TCU_TFR_HFLAG0		(1 << 16)
+#define TCU_TFR_FFLAG5		(1 << 5)
+#define TCU_TFR_FFLAG4		(1 << 4)
+#define TCU_TFR_FFLAG3		(1 << 3)
+#define TCU_TFR_FFLAG2		(1 << 2)
+#define TCU_TFR_FFLAG1		(1 << 1)
+#define TCU_TFR_FFLAG0		(1 << 0)
+
+#define TCU_TFSR_HFLAG5		(1 << 21)
+#define TCU_TFSR_HFLAG4		(1 << 20)
+#define TCU_TFSR_HFLAG3		(1 << 19)
+#define TCU_TFSR_HFLAG2		(1 << 18)
+#define TCU_TFSR_HFLAG1		(1 << 17)
+#define TCU_TFSR_HFLAG0		(1 << 16)
+#define TCU_TFSR_FFLAG5		(1 << 5)
+#define TCU_TFSR_FFLAG4		(1 << 4)
+#define TCU_TFSR_FFLAG3		(1 << 3)
+#define TCU_TFSR_FFLAG2		(1 << 2)
+#define TCU_TFSR_FFLAG1		(1 << 1)
+#define TCU_TFSR_FFLAG0		(1 << 0)
+
+#define TCU_TFCR_HFLAG5		(1 << 21)
+#define TCU_TFCR_HFLAG4		(1 << 20)
+#define TCU_TFCR_HFLAG3		(1 << 19)
+#define TCU_TFCR_HFLAG2		(1 << 18)
+#define TCU_TFCR_HFLAG1		(1 << 17)
+#define TCU_TFCR_HFLAG0		(1 << 16)
+#define TCU_TFCR_FFLAG5		(1 << 5)
+#define TCU_TFCR_FFLAG4		(1 << 4)
+#define TCU_TFCR_FFLAG3		(1 << 3)
+#define TCU_TFCR_FFLAG2		(1 << 2)
+#define TCU_TFCR_FFLAG1		(1 << 1)
+#define TCU_TFCR_FFLAG0		(1 << 0)
+
+#define TCU_TMR_HMASK5		(1 << 21)
+#define TCU_TMR_HMASK4		(1 << 20)
+#define TCU_TMR_HMASK3		(1 << 19)
+#define TCU_TMR_HMASK2		(1 << 18)
+#define TCU_TMR_HMASK1		(1 << 17)
+#define TCU_TMR_HMASK0		(1 << 16)
+#define TCU_TMR_FMASK5		(1 << 5)
+#define TCU_TMR_FMASK4		(1 << 4)
+#define TCU_TMR_FMASK3		(1 << 3)
+#define TCU_TMR_FMASK2		(1 << 2)
+#define TCU_TMR_FMASK1		(1 << 1)
+#define TCU_TMR_FMASK0		(1 << 0)
+
+#define TCU_TMSR_HMST5		(1 << 21)
+#define TCU_TMSR_HMST4		(1 << 20)
+#define TCU_TMSR_HMST3		(1 << 19)
+#define TCU_TMSR_HMST2		(1 << 18)
+#define TCU_TMSR_HMST1		(1 << 17)
+#define TCU_TMSR_HMST0		(1 << 16)
+#define TCU_TMSR_FMST5		(1 << 5)
+#define TCU_TMSR_FMST4		(1 << 4)
+#define TCU_TMSR_FMST3		(1 << 3)
+#define TCU_TMSR_FMST2		(1 << 2)
+#define TCU_TMSR_FMST1		(1 << 1)
+#define TCU_TMSR_FMST0		(1 << 0)
+
+#define TCU_TMCR_HMCL5		(1 << 21)
+#define TCU_TMCR_HMCL4		(1 << 20)
+#define TCU_TMCR_HMCL3		(1 << 19)
+#define TCU_TMCR_HMCL2		(1 << 18)
+#define TCU_TMCR_HMCL1		(1 << 17)
+#define TCU_TMCR_HMCL0		(1 << 16)
+#define TCU_TMCR_FMCL5		(1 << 5)
+#define TCU_TMCR_FMCL4		(1 << 4)
+#define TCU_TMCR_FMCL3		(1 << 3)
+#define TCU_TMCR_FMCL2		(1 << 2)
+#define TCU_TMCR_FMCL1		(1 << 1)
+#define TCU_TMCR_FMCL0		(1 << 0)
+
+#define TCU_TSR_WDTS		(1 << 16)
+#define TCU_TSR_STOP5		(1 << 5)
+#define TCU_TSR_STOP4		(1 << 4)
+#define TCU_TSR_STOP3		(1 << 3)
+#define TCU_TSR_STOP2		(1 << 2)
+#define TCU_TSR_STOP1		(1 << 1)
+#define TCU_TSR_STOP0		(1 << 0)
+
+#define TCU_TSSR_WDTSS		(1 << 16)
+#define TCU_TSSR_STPS5		(1 << 5)
+#define TCU_TSSR_STPS4		(1 << 4)
+#define TCU_TSSR_STPS3		(1 << 3)
+#define TCU_TSSR_STPS2		(1 << 2)
+#define TCU_TSSR_STPS1		(1 << 1)
+#define TCU_TSSR_STPS0		(1 << 0)
+
+#define TCU_TSSR_WDTSC		(1 << 16)
+#define TCU_TSSR_STPC5		(1 << 5)
+#define TCU_TSSR_STPC4		(1 << 4)
+#define TCU_TSSR_STPC3		(1 << 3)
+#define TCU_TSSR_STPC2		(1 << 2)
+#define TCU_TSSR_STPC1		(1 << 1)
+#define TCU_TSSR_STPC0		(1 << 0)
+
+
+/*************************************************************************
+ * WDT (WatchDog Timer)
+ *************************************************************************/
+#define WDT_TDR		(WDT_BASE + 0x00)
+#define WDT_TCER	(WDT_BASE + 0x04)
+#define WDT_TCNT	(WDT_BASE + 0x08)
+#define WDT_TCSR	(WDT_BASE + 0x0C)
+
+#define REG_WDT_TDR	REG16(WDT_TDR)
+#define REG_WDT_TCER	REG8(WDT_TCER)
+#define REG_WDT_TCNT	REG16(WDT_TCNT)
+#define REG_WDT_TCSR	REG16(WDT_TCSR)
+
+// Register definition
+#define WDT_TCSR_PRESCALE_BIT	3
+#define WDT_TCSR_PRESCALE_MASK	(0x7 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1	(0x0 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE4	(0x1 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE16	(0x2 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE64	(0x3 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE256	(0x4 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1024	(0x5 << WDT_TCSR_PRESCALE_BIT)
+#define WDT_TCSR_EXT_EN		(1 << 2)
+#define WDT_TCSR_RTC_EN		(1 << 1)
+#define WDT_TCSR_PCK_EN		(1 << 0)
+
+#define WDT_TCER_TCEN		(1 << 0)
+
+
+/*************************************************************************
+ * DMAC (DMA Controller)
+ *************************************************************************/
+
+#define MAX_DMA_NUM	6  /* max 6 channels */
+
+#define DMAC_DSAR(n)	(DMAC_BASE + (0x00 + (n) * 0x20)) /* DMA source address */
+#define DMAC_DTAR(n)	(DMAC_BASE + (0x04 + (n) * 0x20)) /* DMA target address */
+#define DMAC_DTCR(n)	(DMAC_BASE + (0x08 + (n) * 0x20)) /* DMA transfer count */
+#define DMAC_DRSR(n)	(DMAC_BASE + (0x0c + (n) * 0x20)) /* DMA request source */
+#define DMAC_DCCSR(n)	(DMAC_BASE + (0x10 + (n) * 0x20)) /* DMA control/status */
+#define DMAC_DCMD(n)	(DMAC_BASE + (0x14 + (n) * 0x20)) /* DMA command */
+#define DMAC_DDA(n)	(DMAC_BASE + (0x18 + (n) * 0x20)) /* DMA descriptor address */
+#define DMAC_DMACR	(DMAC_BASE + 0x0300)              /* DMA control register */
+#define DMAC_DMAIPR	(DMAC_BASE + 0x0304)              /* DMA interrupt pending */
+#define DMAC_DMADBR	(DMAC_BASE + 0x0308)              /* DMA doorbell */
+#define DMAC_DMADBSR	(DMAC_BASE + 0x030C)              /* DMA doorbell set */
+
+// channel 0
+#define DMAC_DSAR0      DMAC_DSAR(0)
+#define DMAC_DTAR0      DMAC_DTAR(0)
+#define DMAC_DTCR0      DMAC_DTCR(0)
+#define DMAC_DRSR0      DMAC_DRSR(0)
+#define DMAC_DCCSR0     DMAC_DCCSR(0)
+#define DMAC_DCMD0	DMAC_DCMD(0)
+#define DMAC_DDA0	DMAC_DDA(0)
+
+// channel 1
+#define DMAC_DSAR1      DMAC_DSAR(1)
+#define DMAC_DTAR1      DMAC_DTAR(1)
+#define DMAC_DTCR1      DMAC_DTCR(1)
+#define DMAC_DRSR1      DMAC_DRSR(1)
+#define DMAC_DCCSR1     DMAC_DCCSR(1)
+#define DMAC_DCMD1	DMAC_DCMD(1)
+#define DMAC_DDA1	DMAC_DDA(1)
+
+// channel 2
+#define DMAC_DSAR2      DMAC_DSAR(2)
+#define DMAC_DTAR2      DMAC_DTAR(2)
+#define DMAC_DTCR2      DMAC_DTCR(2)
+#define DMAC_DRSR2      DMAC_DRSR(2)
+#define DMAC_DCCSR2     DMAC_DCCSR(2)
+#define DMAC_DCMD2	DMAC_DCMD(2)
+#define DMAC_DDA2	DMAC_DDA(2)
+
+// channel 3
+#define DMAC_DSAR3      DMAC_DSAR(3)
+#define DMAC_DTAR3      DMAC_DTAR(3)
+#define DMAC_DTCR3      DMAC_DTCR(3)
+#define DMAC_DRSR3      DMAC_DRSR(3)
+#define DMAC_DCCSR3     DMAC_DCCSR(3)
+#define DMAC_DCMD3	DMAC_DCMD(3)
+#define DMAC_DDA3	DMAC_DDA(3)
+
+// channel 4
+#define DMAC_DSAR4      DMAC_DSAR(4)
+#define DMAC_DTAR4      DMAC_DTAR(4)
+#define DMAC_DTCR4      DMAC_DTCR(4)
+#define DMAC_DRSR4      DMAC_DRSR(4)
+#define DMAC_DCCSR4     DMAC_DCCSR(4)
+#define DMAC_DCMD4	DMAC_DCMD(4)
+#define DMAC_DDA4	DMAC_DDA(4)
+
+// channel 5
+#define DMAC_DSAR5      DMAC_DSAR(5)
+#define DMAC_DTAR5      DMAC_DTAR(5)
+#define DMAC_DTCR5      DMAC_DTCR(5)
+#define DMAC_DRSR5      DMAC_DRSR(5)
+#define DMAC_DCCSR5     DMAC_DCCSR(5)
+#define DMAC_DCMD5	DMAC_DCMD(5)
+#define DMAC_DDA5	DMAC_DDA(5)
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DTAR(n)	REG32(DMAC_DTAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DCMD(n)	REG32(DMAC_DCMD((n)))
+#define REG_DMAC_DDA(n)		REG32(DMAC_DDA((n)))
+#define REG_DMAC_DMACR		REG32(DMAC_DMACR)
+#define REG_DMAC_DMAIPR		REG32(DMAC_DMAIPR)
+#define REG_DMAC_DMADBR		REG32(DMAC_DMADBR)
+#define REG_DMAC_DMADBSR	REG32(DMAC_DMADBSR)
+
+// DMA request source register
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x1f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO	(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT	(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN	(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIOUT	(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIIN	(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT	(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN	(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCOUT	(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCIN	(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TCU	(28 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SADC	(29 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SLCD	(30 << DMAC_DRSR_RS_BIT)
+
+// DMA channel control/status register
+#define DMAC_DCCSR_NDES		(1 << 31) /* descriptor (0) or not (1) ? */
+#define DMAC_DCCSR_CDOA_BIT	16        /* copy of DMA offset address */
+#define DMAC_DCCSR_CDOA_MASK	(0xff << DMAC_DCCSR_CDOA_BIT)
+#define DMAC_DCCSR_INV		(1 << 6)  /* descriptor invalid */
+#define DMAC_DCCSR_AR		(1 << 4)  /* address error */
+#define DMAC_DCCSR_TT		(1 << 3)  /* transfer terminated */
+#define DMAC_DCCSR_HLT		(1 << 2)  /* DMA halted */
+#define DMAC_DCCSR_CT		(1 << 1)  /* count terminated */
+#define DMAC_DCCSR_EN		(1 << 0)  /* channel enable bit */
+
+// DMA channel command register 
+#define DMAC_DCMD_SAI		(1 << 23) /* source address increment */
+#define DMAC_DCMD_DAI		(1 << 22) /* dest address increment */
+#define DMAC_DCMD_RDIL_BIT	16        /* request detection interval length */
+#define DMAC_DCMD_RDIL_MASK	(0x0f << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_IGN	(0 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_2	(1 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_4	(2 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_8	(3 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_12	(4 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_16	(5 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_20	(6 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_24	(7 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_28	(8 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_32	(9 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_48	(10 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_60	(11 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_64	(12 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_124	(13 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_128	(14 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_200	(15 << DMAC_DCMD_RDIL_BIT)
+#define DMAC_DCMD_SWDH_BIT	14  /* source port width */
+#define DMAC_DCMD_SWDH_MASK	(0x03 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_32	(0 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_8	(1 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_16	(2 << DMAC_DCMD_SWDH_BIT)
+#define DMAC_DCMD_DWDH_BIT	12  /* dest port width */
+#define DMAC_DCMD_DWDH_MASK	(0x03 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_32	(0 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_8	(1 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_16	(2 << DMAC_DCMD_DWDH_BIT)
+#define DMAC_DCMD_DS_BIT	8  /* transfer data size of a data unit */
+#define DMAC_DCMD_DS_MASK	(0x07 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BIT	(0 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_8BIT	(1 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BIT	(2 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BYTE	(3 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BYTE	(4 << DMAC_DCMD_DS_BIT)
+#define DMAC_DCMD_TM		(1 << 7)  /* transfer mode: 0-single 1-block */
+#define DMAC_DCMD_DES_V		(1 << 4)  /* descriptor valid flag */
+#define DMAC_DCMD_DES_VM	(1 << 3)  /* descriptor valid mask: 1:support V-bit */
+#define DMAC_DCMD_DES_VIE	(1 << 2)  /* DMA valid error interrupt enable */
+#define DMAC_DCMD_TIE		(1 << 1)  /* DMA transfer interrupt enable */
+#define DMAC_DCMD_LINK		(1 << 0)  /* descriptor link enable */
+
+// DMA descriptor address register
+#define DMAC_DDA_BASE_BIT	12  /* descriptor base address */
+#define DMAC_DDA_BASE_MASK	(0x0fffff << DMAC_DDA_BASE_BIT)
+#define DMAC_DDA_OFFSET_BIT	4  /* descriptor offset address */
+#define DMAC_DDA_OFFSET_MASK	(0x0ff << DMAC_DDA_OFFSET_BIT)
+
+// DMA control register
+#define DMAC_DMACR_PR_BIT	8  /* channel priority mode */
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_012345	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_023145	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_201345	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_RR	(3 << DMAC_DMACR_PR_BIT) /* round robin */
+#define DMAC_DMACR_HLT		(1 << 3)  /* DMA halt flag */
+#define DMAC_DMACR_AR		(1 << 2)  /* address error flag */
+#define DMAC_DMACR_DMAE		(1 << 0)  /* DMA enable bit */
+
+// DMA doorbell register
+#define DMAC_DMADBR_DB5		(1 << 5)  /* doorbell for channel 5 */
+#define DMAC_DMADBR_DB4		(1 << 5)  /* doorbell for channel 4 */
+#define DMAC_DMADBR_DB3		(1 << 5)  /* doorbell for channel 3 */
+#define DMAC_DMADBR_DB2		(1 << 5)  /* doorbell for channel 2 */
+#define DMAC_DMADBR_DB1		(1 << 5)  /* doorbell for channel 1 */
+#define DMAC_DMADBR_DB0		(1 << 5)  /* doorbell for channel 0 */
+
+// DMA doorbell set register
+#define DMAC_DMADBSR_DBS5	(1 << 5)  /* enable doorbell for channel 5 */
+#define DMAC_DMADBSR_DBS4	(1 << 5)  /* enable doorbell for channel 4 */
+#define DMAC_DMADBSR_DBS3	(1 << 5)  /* enable doorbell for channel 3 */
+#define DMAC_DMADBSR_DBS2	(1 << 5)  /* enable doorbell for channel 2 */
+#define DMAC_DMADBSR_DBS1	(1 << 5)  /* enable doorbell for channel 1 */
+#define DMAC_DMADBSR_DBS0	(1 << 5)  /* enable doorbell for channel 0 */
+
+// DMA interrupt pending register
+#define DMAC_DMAIPR_CIRQ5	(1 << 5)  /* irq pending status for channel 5 */
+#define DMAC_DMAIPR_CIRQ4	(1 << 4)  /* irq pending status for channel 4 */
+#define DMAC_DMAIPR_CIRQ3	(1 << 3)  /* irq pending status for channel 3 */
+#define DMAC_DMAIPR_CIRQ2	(1 << 2)  /* irq pending status for channel 2 */
+#define DMAC_DMAIPR_CIRQ1	(1 << 1)  /* irq pending status for channel 1 */
+#define DMAC_DMAIPR_CIRQ0	(1 << 0)  /* irq pending status for channel 0 */
+
+
+/*************************************************************************
+ * GPIO (General-Purpose I/O Ports)
+ *************************************************************************/
+#define MAX_GPIO_NUM	128
+
+//n = 0,1,2,3
+#define GPIO_PXPIN(n)	(GPIO_BASE + (0x00 + (n)*0x100)) /* PIN Level Register */
+#define GPIO_PXDAT(n)	(GPIO_BASE + (0x10 + (n)*0x100)) /* Port Data Register */
+#define GPIO_PXDATS(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Data Set Register */
+#define GPIO_PXDATC(n)	(GPIO_BASE + (0x18 + (n)*0x100)) /* Port Data Clear Register */
+#define GPIO_PXIM(n)	(GPIO_BASE + (0x20 + (n)*0x100)) /* Interrupt Mask Register */
+#define GPIO_PXIMS(n)	(GPIO_BASE + (0x24 + (n)*0x100)) /* Interrupt Mask Set Reg */
+#define GPIO_PXIMC(n)	(GPIO_BASE + (0x28 + (n)*0x100)) /* Interrupt Mask Clear Reg */
+#define GPIO_PXPE(n)	(GPIO_BASE + (0x30 + (n)*0x100)) /* Pull Enable Register */
+#define GPIO_PXPES(n)	(GPIO_BASE + (0x34 + (n)*0x100)) /* Pull Enable Set Reg. */
+#define GPIO_PXPEC(n)	(GPIO_BASE + (0x38 + (n)*0x100)) /* Pull Enable Clear Reg. */
+#define GPIO_PXFUN(n)	(GPIO_BASE + (0x40 + (n)*0x100)) /* Function Register */
+#define GPIO_PXFUNS(n)	(GPIO_BASE + (0x44 + (n)*0x100)) /* Function Set Register */
+#define GPIO_PXFUNC(n)	(GPIO_BASE + (0x48 + (n)*0x100)) /* Function Clear Register */
+#define GPIO_PXSEL(n)	(GPIO_BASE + (0x50 + (n)*0x100)) /* Select Register */
+#define GPIO_PXSELS(n)	(GPIO_BASE + (0x54 + (n)*0x100)) /* Select Set Register */
+#define GPIO_PXSELC(n)	(GPIO_BASE + (0x58 + (n)*0x100)) /* Select Clear Register */
+#define GPIO_PXDIR(n)	(GPIO_BASE + (0x60 + (n)*0x100)) /* Direction Register */
+#define GPIO_PXDIRS(n)	(GPIO_BASE + (0x64 + (n)*0x100)) /* Direction Set Register */
+#define GPIO_PXDIRC(n)	(GPIO_BASE + (0x68 + (n)*0x100)) /* Direction Clear Register */
+#define GPIO_PXTRG(n)	(GPIO_BASE + (0x70 + (n)*0x100)) /* Trigger Register */
+#define GPIO_PXTRGS(n)	(GPIO_BASE + (0x74 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXTRGC(n)	(GPIO_BASE + (0x78 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXFLG(n)	(GPIO_BASE + (0x80 + (n)*0x100)) /* Port Flag Register */
+#define GPIO_PXFLGC(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Flag clear Register */
+
+#define REG_GPIO_PXPIN(n)	REG32(GPIO_PXPIN((n)))  /* PIN level */
+#define REG_GPIO_PXDAT(n)	REG32(GPIO_PXDAT((n)))  /* 1: interrupt pending */
+#define REG_GPIO_PXDATS(n)	REG32(GPIO_PXDATS((n)))
+#define REG_GPIO_PXDATC(n)	REG32(GPIO_PXDATC((n)))
+#define REG_GPIO_PXIM(n)	REG32(GPIO_PXIM((n)))   /* 1: mask pin interrupt */
+#define REG_GPIO_PXIMS(n)	REG32(GPIO_PXIMS((n)))
+#define REG_GPIO_PXIMC(n)	REG32(GPIO_PXIMC((n)))
+#define REG_GPIO_PXPE(n)	REG32(GPIO_PXPE((n)))   /* 1: disable pull up/down */
+#define REG_GPIO_PXPES(n)	REG32(GPIO_PXPES((n)))
+#define REG_GPIO_PXPEC(n)	REG32(GPIO_PXPEC((n)))
+#define REG_GPIO_PXFUN(n)	REG32(GPIO_PXFUN((n)))  /* 0:GPIO or intr, 1:FUNC */
+#define REG_GPIO_PXFUNS(n)	REG32(GPIO_PXFUNS((n)))
+#define REG_GPIO_PXFUNC(n)	REG32(GPIO_PXFUNC((n)))
+#define REG_GPIO_PXSEL(n)	REG32(GPIO_PXSEL((n))) /* 0:GPIO/Fun0,1:intr/fun1*/
+#define REG_GPIO_PXSELS(n)	REG32(GPIO_PXSELS((n)))
+#define REG_GPIO_PXSELC(n)	REG32(GPIO_PXSELC((n)))
+#define REG_GPIO_PXDIR(n)	REG32(GPIO_PXDIR((n))) /* 0:input/low-level-trig/falling-edge-trig, 1:output/high-level-trig/rising-edge-trig */
+#define REG_GPIO_PXDIRS(n)	REG32(GPIO_PXDIRS((n)))
+#define REG_GPIO_PXDIRC(n)	REG32(GPIO_PXDIRC((n)))
+#define REG_GPIO_PXTRG(n)	REG32(GPIO_PXTRG((n))) /* 0:level-trigger, 1:edge-trigger */
+#define REG_GPIO_PXTRGS(n)	REG32(GPIO_PXTRGS((n)))
+#define REG_GPIO_PXTRGC(n)	REG32(GPIO_PXTRGC((n)))
+#define REG_GPIO_PXFLG(n)	REG32(GPIO_PXFLG((n))) /* interrupt flag */
+#define REG_GPIO_PXFLGC(n)	REG32(GPIO_PXFLGC((n))) /* interrupt flag */
+
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* Register Offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+#define OFF_UMR		(0x24)	/* RW 8b H'00, UART M Register */
+#define OFF_UACR	(0x28)	/* RW 8b H'00, UART Add Cycle Register */
+
+/* Register Address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+#define UART0_UMR	(UART0_BASE + OFF_UMR)
+#define UART0_UACR	(UART0_BASE + OFF_UACR)
+
+/*
+ * Define macros for UART_IER
+ * UART Interrupt Enable Register
+ */
+#define UART_IER_RIE	(1 << 0)	/* 0: receive fifo "full" interrupt disable */
+#define UART_IER_TIE	(1 << 1)	/* 0: transmit fifo "empty" interrupt disable */
+#define UART_IER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UART_IER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UART_IER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UART_ISR
+ * UART Interrupt Status Register
+ */
+#define UART_ISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UART_ISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UART_ISR_IID_MSI		(0 << 1)	/* Modem status interrupt */
+#define UART_ISR_IID_THRI	(1 << 1)	/* Transmitter holding register empty */
+#define UART_ISR_IID_RDI		(2 << 1)	/* Receiver data interrupt */
+#define UART_ISR_IID_RLSI	(3 << 1)	/* Receiver line status interrupt */
+#define UART_ISR_FFMS	(3 << 6)	/* FIFO mode select, set when UART_FCR.FE is set to 1 */
+#define UART_ISR_FFMS_NO_FIFO	(0 << 6)
+#define UART_ISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UART_FCR
+ * UART FIFO Control Register
+ */
+#define UART_FCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UART_FCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UART_FCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UART_FCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UART_FCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UART_FCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UART_FCR_RTRG_1	(0 << 6)
+#define UART_FCR_RTRG_4	(1 << 6)
+#define UART_FCR_RTRG_8	(2 << 6)
+#define UART_FCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UART_LCR
+ * UART Line Control Register
+ */
+#define UART_LCR_WLEN	(3 << 0)	/* word length */
+#define UART_LCR_WLEN_5	(0 << 0)
+#define UART_LCR_WLEN_6	(1 << 0)
+#define UART_LCR_WLEN_7	(2 << 0)
+#define UART_LCR_WLEN_8	(3 << 0)
+#define UART_LCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_1	(0 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_2	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+
+#define UART_LCR_PE	(1 << 3)	/* 0: parity disable */
+#define UART_LCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UART_LCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UART_LCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UART_LCR_DLAB	(1 << 7)	/* 0: access UART_RDR/TDR/IER  1: access UART_DLLR/DLHR */
+
+/*
+ * Define macros for UART_LSR
+ * UART Line Status Register
+ */
+#define UART_LSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UART_LSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UART_LSR_PER	(1 << 2)	/* 0: no parity error */
+#define UART_LSR_FER	(1 << 3)	/* 0; no framing error */
+#define UART_LSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UART_LSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UART_LSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UART_LSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UART_MCR
+ * UART Modem Control Register
+ */
+#define UART_MCR_DTR	(1 << 0)	/* 0: DTR_ ouput high */
+#define UART_MCR_RTS	(1 << 1)	/* 0: RTS_ output high */
+#define UART_MCR_OUT1	(1 << 2)	/* 0: UART_MSR.RI is set to 0 and RI_ input high */
+#define UART_MCR_OUT2	(1 << 3)	/* 0: UART_MSR.DCD is set to 0 and DCD_ input high */
+#define UART_MCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UART_MCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UART_MSR
+ * UART Modem Status Register
+ */
+#define UART_MSR_DCTS	(1 << 0)	/* 0: no change on CTS_ pin since last read of UART_MSR */
+#define UART_MSR_DDSR	(1 << 1)	/* 0: no change on DSR_ pin since last read of UART_MSR */
+#define UART_MSR_DRI	(1 << 2)	/* 0: no change on RI_ pin since last read of UART_MSR */
+#define UART_MSR_DDCD	(1 << 3)	/* 0: no change on DCD_ pin since last read of UART_MSR */
+#define UART_MSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+#define UART_MSR_DSR	(1 << 5)	/* 0: DSR_ pin is high */
+#define UART_MSR_RI	(1 << 6)	/* 0: RI_ pin is high */
+#define UART_MSR_DCD	(1 << 7)	/* 0: DCD_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)	/* 0: transmitter is in UART mode  1: IrDA mode */
+#define SIRCR_RSIRE	(1 << 1)	/* 0: receiver is in UART mode  1: IrDA mode */
+#define SIRCR_TPWS	(1 << 2)	/* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TXPL	(1 << 3)	/* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RXPL	(1 << 4)	/* 0: decoder interprets positive pulse as 0 */
+
+
+/*************************************************************************
+ * AIC (AC97/I2S Controller)
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12        /* Receive FIFO Threshold */
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8         /* Transmit FIFO Threshold */
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_ICDC		(1 << 5)  /* External(0) or Internal CODEC(1) */
+#define	AIC_FR_AUSEL		(1 << 4)  /* AC97(0) or I2S/MSB-justified(1) */
+#define	AIC_FR_RST		(1 << 3)  /* AIC registers reset */
+#define	AIC_FR_BCKD		(1 << 2)  /* I2S BIT_CLK direction, 0:input,1:output */
+#define	AIC_FR_SYNCD		(1 << 1)  /* I2S SYNC direction, 0:input,1:output */
+#define	AIC_FR_ENB		(1 << 0)  /* AIC enable bit */
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_OSS_BIT		19  /* Output Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_OSS_MASK		(0x7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0x0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(0x1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(0x2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(0x3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(0x4 << AIC_CR_OSS_BIT)
+#define	AIC_CR_ISS_BIT		16  /* Input Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_ISS_MASK		(0x7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0x0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(0x1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(0x2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(0x3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(0x4 << AIC_CR_ISS_BIT)
+#define	AIC_CR_RDMS		(1 << 15)  /* Receive DMA enable */
+#define	AIC_CR_TDMS		(1 << 14)  /* Transmit DMA enable */
+#define	AIC_CR_M2S		(1 << 11)  /* Mono to Stereo enable */
+#define	AIC_CR_ENDSW		(1 << 10)  /* Endian switch enable */
+#define	AIC_CR_AVSTSU		(1 << 9)   /* Signed <-> Unsigned toggle enable */
+#define	AIC_CR_FLUSH		(1 << 8)   /* Flush FIFO */
+#define	AIC_CR_EROR		(1 << 6)   /* Enable ROR interrupt */
+#define	AIC_CR_ETUR		(1 << 5)   /* Enable TUR interrupt */
+#define	AIC_CR_ERFS		(1 << 4)   /* Enable RFS interrupt */
+#define	AIC_CR_ETFS		(1 << 3)   /* Enable TFS interrupt */
+#define	AIC_CR_ENLBF		(1 << 2)   /* Enable Loopback Function */
+#define	AIC_CR_ERPL		(1 << 1)   /* Enable Playback Function */
+#define	AIC_CR_EREC		(1 << 0)   /* Enable Record Function */
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16          /* Receive Valid Slots */
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit, PCM Left */
+#define	AIC_ACCR1_XS_BIT	0          /* Transmit Valid Slots */
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit, PCM Left */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18) /* Enable RSTO interrupt */
+#define	AIC_ACCR2_ESADR		(1 << 17) /* Enable SADR interrupt */
+#define	AIC_ACCR2_ECADT		(1 << 16) /* Enable CADT interrupt */
+#define	AIC_ACCR2_OASS_BIT	8  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)  /* SDATA_OUT output value */
+#define	AIC_ACCR2_SR		(1 << 2)  /* RESET# pin level */
+#define	AIC_ACCR2_SS		(1 << 1)  /* SYNC pin level */
+#define	AIC_ACCR2_SA		(1 << 0)  /* SYNC and SDATA_OUT alternation */
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12) /* Stop BIT_CLK for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_BIT	1  /* Input/Output Sample Size for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0) /* 0:I2S, 1:MSB-justified */
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24  /* Receive FIFO Level */
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8   /* Transmit FIFO level */
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6) /* Receive FIFO Overrun */
+#define	AIC_SR_TUR		(1 << 5) /* Transmit FIFO Underrun */
+#define	AIC_SR_RFS		(1 << 4) /* Receive FIFO Service Request */
+#define	AIC_SR_TFS		(1 << 3) /* Transmit FIFO Service Request */
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_SLTERR		(1 << 21) /* Slot Error Flag */
+#define	AIC_ACSR_CRDY		(1 << 20) /* External CODEC Ready Flag */
+#define	AIC_ACSR_CLPM		(1 << 19) /* External CODEC low power mode flag */
+#define	AIC_ACSR_RSTO		(1 << 18) /* External CODEC regs read status timeout */
+#define	AIC_ACSR_SADR		(1 << 17) /* External CODEC regs status addr and data received */
+#define	AIC_ACSR_CADT		(1 << 16) /* Command Address and Data Transmitted */
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)  /* AIC Busy in I2S/MSB-justified format */
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+/*************************************************************************
+ * ICDC (Internal CODEC)
+ *************************************************************************/
+#define	ICDC_CR			(ICDC_BASE + 0x0400)  /* ICDC Control Register */
+#define	ICDC_APWAIT		(ICDC_BASE + 0x0404)  /* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APPRE		(ICDC_BASE + 0x0408)  /* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APHPEN		(ICDC_BASE + 0x040C)  /* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APSR		(ICDC_BASE + 0x0410)  /* Anti-Pop Status Register */
+#define ICDC_CDCCR1             (ICDC_BASE + 0x0080)
+#define ICDC_CDCCR2             (ICDC_BASE + 0x0084)
+
+#define	REG_ICDC_CR		REG32(ICDC_CR)
+#define	REG_ICDC_APWAIT		REG32(ICDC_APWAIT)
+#define	REG_ICDC_APPRE		REG32(ICDC_APPRE)
+#define	REG_ICDC_APHPEN		REG32(ICDC_APHPEN)
+#define	REG_ICDC_APSR		REG32(ICDC_APSR)
+#define REG_ICDC_CDCCR1         REG32(ICDC_CDCCR1)
+#define REG_ICDC_CDCCR2         REG32(ICDC_CDCCR2)
+
+/* ICDC Control Register */
+#define	ICDC_CR_LINVOL_BIT	24 /* LINE Input Volume Gain: GAIN=LINVOL*1.5-34.5 */
+#define	ICDC_CR_LINVOL_MASK	(0x1f << ICDC_CR_LINVOL_BIT)
+#define	ICDC_CR_ASRATE_BIT	20 /* Audio Sample Rate */
+#define	ICDC_CR_ASRATE_MASK	(0x0f << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_8000	(0x0 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_11025	(0x1 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_12000	(0x2 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_16000	(0x3 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_22050	(0x4 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_24000	(0x5 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_32000	(0x6 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_44100	(0x7 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_48000	(0x8 << ICDC_CR_ASRATE_BIT)
+#define	ICDC_CR_MICBG_BIT	18 /* MIC Boost Gain */
+#define	ICDC_CR_MICBG_MASK	(0x3 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_0DB	(0x0 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_6DB	(0x1 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_12DB	(0x2 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_20DB	(0x3 << ICDC_CR_MICBG_BIT)
+#define	ICDC_CR_HPVOL_BIT	16 /* Headphone Volume Gain */
+#define	ICDC_CR_HPVOL_MASK	(0x3 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_0DB	(0x0 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_2DB	(0x1 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_4DB	(0x2 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_6DB	(0x3 << ICDC_CR_HPVOL_BIT)
+#define ICDC_CR_ELINEIN		(1 << 13) /* Enable LINE Input */
+#define ICDC_CR_EMIC		(1 << 12) /* Enable MIC Input */
+#define ICDC_CR_SW1ON		(1 << 11) /* Switch 1 in CODEC is on */
+#define ICDC_CR_EADC		(1 << 10) /* Enable ADC */
+#define ICDC_CR_SW2ON		(1 << 9)  /* Switch 2 in CODEC is on */
+#define ICDC_CR_EDAC		(1 << 8)  /* Enable DAC */
+#define ICDC_CR_HPMUTE		(1 << 5)  /* Headphone Mute */
+#define ICDC_CR_HPTON		(1 << 4)  /* Headphone Amplifier Trun On */
+#define ICDC_CR_HPTOFF		(1 << 3)  /* Headphone Amplifier Trun Off */
+#define ICDC_CR_TAAP		(1 << 2)  /* Turn Around of the Anti-Pop Procedure */
+#define ICDC_CR_EAP		(1 << 1)  /* Enable Anti-Pop Procedure */
+#define ICDC_CR_SUSPD		(1 << 0)  /* CODEC Suspend */
+
+/* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APWAIT_WAITSN_BIT	0
+#define	ICDC_APWAIT_WAITSN_MASK	(0x7ff << ICDC_APWAIT_WAITSN_BIT)
+
+/* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APPRE_PRESN_BIT	0
+#define	ICDC_APPRE_PRESN_MASK	(0x1ff << ICDC_APPRE_PRESN_BIT)
+
+/* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APHPEN_HPENSN_BIT	0
+#define	ICDC_APHPEN_HPENSN_MASK	(0x3fff << ICDC_APHPEN_HPENSN_BIT)
+
+/* Anti-Pop Status Register */
+#define	ICDC_SR_HPST_BIT	14  /* Headphone Amplifier State */
+#define	ICDC_SR_HPST_MASK	(0x7 << ICDC_SR_HPST_BIT)
+#define ICDC_SR_HPST_HP_OFF	 (0x0 << ICDC_SR_HPST_BIT) /* HP amplifier is off */
+#define ICDC_SR_HPST_TON_WAIT	 (0x1 << ICDC_SR_HPST_BIT) /* wait state in turn-on */
+  #define ICDC_SR_HPST_TON_PRE	 (0x2 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-on */
+#define ICDC_SR_HPST_TON_HPEN	 (0x3 << ICDC_SR_HPST_BIT) /* HP enable state in turn-on */
+  #define ICDC_SR_HPST_TOFF_HPEN (0x4 << ICDC_SR_HPST_BIT) /* HP enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_PRE  (0x5 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_WAIT (0x6 << ICDC_SR_HPST_BIT) /* wait state in turn-off */
+  #define ICDC_SR_HPST_HP_ON	 (0x7 << ICDC_SR_HPST_BIT) /* HP amplifier is on */
+#define	ICDC_SR_SNCNT_BIT	0  /* Sample Number Counter */
+#define	ICDC_SR_SNCNT_MASK	(0x3fff << ICDC_SR_SNCNT_BIT)
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+/*************************************************************************
+ * SSI
+ *************************************************************************/
+#define	SSI_DR			(SSI_BASE + 0x000)
+#define	SSI_CR0			(SSI_BASE + 0x004)
+#define	SSI_CR1			(SSI_BASE + 0x008)
+#define	SSI_SR			(SSI_BASE + 0x00C)
+#define	SSI_ITR			(SSI_BASE + 0x010)
+#define	SSI_ICR			(SSI_BASE + 0x014)
+#define	SSI_GR			(SSI_BASE + 0x018)
+
+#define	REG_SSI_DR		REG32(SSI_DR)
+#define	REG_SSI_CR0		REG16(SSI_CR0)
+#define	REG_SSI_CR1		REG32(SSI_CR1)
+#define	REG_SSI_SR		REG32(SSI_SR)
+#define	REG_SSI_ITR		REG16(SSI_ITR)
+#define	REG_SSI_ICR		REG8(SSI_ICR)
+#define	REG_SSI_GR		REG16(SSI_GR)
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_TTRG_BIT	16
+#define SSI_CR1_TTRG_MASK	(0xf << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_1	  (0 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_8	  (1 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_16	  (2 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_24	  (3 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_32	  (4 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_40	  (5 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_48	  (6 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_56	  (7 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_64	  (8 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_72	  (9 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_80	  (10<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_88	  (11<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_96	  (12<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_104	  (13<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_112	  (14<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_120	  (15<< SSI_CR1_TTRG_BIT)
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_RTRG_BIT	8
+#define SSI_CR1_RTRG_MASK	(0xf << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_1	  (0 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_8	  (1 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_16	  (2 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_24	  (3 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_32	  (4 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_40	  (5 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_48	  (6 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_56	  (7 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_64	  (8 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_72	  (9 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_80	  (10<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_88	  (11<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_96	  (12<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_104	  (13<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_112	  (14<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_120	  (15<< SSI_CR1_RTRG_BIT)
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	16
+#define SSI_SR_TFIFONUM_MASK	(0xff << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0xff << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+
+/*************************************************************************
+ * MSC
+ *************************************************************************/
+#define	MSC_STRPCL		(MSC_BASE + 0x000)
+#define	MSC_STAT		(MSC_BASE + 0x004)
+#define	MSC_CLKRT		(MSC_BASE + 0x008)
+#define	MSC_CMDAT		(MSC_BASE + 0x00C)
+#define	MSC_RESTO		(MSC_BASE + 0x010)
+#define	MSC_RDTO		(MSC_BASE + 0x014)
+#define	MSC_BLKLEN		(MSC_BASE + 0x018)
+#define	MSC_NOB			(MSC_BASE + 0x01C)
+#define	MSC_SNOB		(MSC_BASE + 0x020)
+#define	MSC_IMASK		(MSC_BASE + 0x024)
+#define	MSC_IREG		(MSC_BASE + 0x028)
+#define	MSC_CMD			(MSC_BASE + 0x02C)
+#define	MSC_ARG			(MSC_BASE + 0x030)
+#define	MSC_RES			(MSC_BASE + 0x034)
+#define	MSC_RXFIFO		(MSC_BASE + 0x038)
+#define	MSC_TXFIFO		(MSC_BASE + 0x03C)
+
+#define	REG_MSC_STRPCL		REG16(MSC_STRPCL)
+#define	REG_MSC_STAT		REG32(MSC_STAT)
+#define	REG_MSC_CLKRT		REG16(MSC_CLKRT)
+#define	REG_MSC_CMDAT		REG32(MSC_CMDAT)
+#define	REG_MSC_RESTO		REG16(MSC_RESTO)
+#define	REG_MSC_RDTO		REG16(MSC_RDTO)
+#define	REG_MSC_BLKLEN		REG16(MSC_BLKLEN)
+#define	REG_MSC_NOB		REG16(MSC_NOB)
+#define	REG_MSC_SNOB		REG16(MSC_SNOB)
+#define	REG_MSC_IMASK		REG16(MSC_IMASK)
+#define	REG_MSC_IREG		REG16(MSC_IREG)
+#define	REG_MSC_CMD		REG8(MSC_CMD)
+#define	REG_MSC_ARG		REG32(MSC_ARG)
+#define	REG_MSC_RES		REG16(MSC_RES)
+#define	REG_MSC_RXFIFO		REG32(MSC_RXFIFO)
+#define	REG_MSC_TXFIFO		REG32(MSC_TXFIFO)
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	  (0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	  (0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	  (0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	  (0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	  (0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	  (0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	  (0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	  (0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+
+#define	MSC_CMDAT_IO_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define CMDAT_BUS_WIDTH1	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define CMDAT_BUS_WIDTH4	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT)
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE  (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+
+/*************************************************************************
+ * EMC (External Memory Controller)
+ *************************************************************************/
+#define EMC_BCR		(EMC_BASE + 0x0)  /* BCR */
+
+#define EMC_SMCR0	(EMC_BASE + 0x10)  /* Static Memory Control Register 0 */
+#define EMC_SMCR1	(EMC_BASE + 0x14)  /* Static Memory Control Register 1 */
+#define EMC_SMCR2	(EMC_BASE + 0x18)  /* Static Memory Control Register 2 */
+#define EMC_SMCR3	(EMC_BASE + 0x1c)  /* Static Memory Control Register 3 */
+#define EMC_SMCR4	(EMC_BASE + 0x20)  /* Static Memory Control Register 4 */
+#define EMC_SACR0	(EMC_BASE + 0x30)  /* Static Memory Bank 0 Addr Config Reg */
+#define EMC_SACR1	(EMC_BASE + 0x34)  /* Static Memory Bank 1 Addr Config Reg */
+#define EMC_SACR2	(EMC_BASE + 0x38)  /* Static Memory Bank 2 Addr Config Reg */
+#define EMC_SACR3	(EMC_BASE + 0x3c)  /* Static Memory Bank 3 Addr Config Reg */
+#define EMC_SACR4	(EMC_BASE + 0x40)  /* Static Memory Bank 4 Addr Config Reg */
+
+#define EMC_NFCSR	(EMC_BASE + 0x050) /* NAND Flash Control/Status Register */
+#define EMC_NFECR	(EMC_BASE + 0x100) /* NAND Flash ECC Control Register */
+#define EMC_NFECC	(EMC_BASE + 0x104) /* NAND Flash ECC Data Register */
+#define EMC_NFPAR0	(EMC_BASE + 0x108) /* NAND Flash RS Parity 0 Register */
+#define EMC_NFPAR1	(EMC_BASE + 0x10c) /* NAND Flash RS Parity 1 Register */
+#define EMC_NFPAR2	(EMC_BASE + 0x110) /* NAND Flash RS Parity 2 Register */
+#define EMC_NFINTS	(EMC_BASE + 0x114) /* NAND Flash Interrupt Status Register */
+#define EMC_NFINTE	(EMC_BASE + 0x118) /* NAND Flash Interrupt Enable Register */
+#define EMC_NFERR0	(EMC_BASE + 0x11c) /* NAND Flash RS Error Report 0 Register */
+#define EMC_NFERR1	(EMC_BASE + 0x120) /* NAND Flash RS Error Report 1 Register */
+#define EMC_NFERR2	(EMC_BASE + 0x124) /* NAND Flash RS Error Report 2 Register */
+#define EMC_NFERR3	(EMC_BASE + 0x128) /* NAND Flash RS Error Report 3 Register */
+
+#define EMC_DMCR	(EMC_BASE + 0x80)  /* DRAM Control Register */
+#define EMC_RTCSR	(EMC_BASE + 0x84)  /* Refresh Time Control/Status Register */
+#define EMC_RTCNT	(EMC_BASE + 0x88)  /* Refresh Timer Counter */
+#define EMC_RTCOR	(EMC_BASE + 0x8c)  /* Refresh Time Constant Register */
+#define EMC_DMAR0	(EMC_BASE + 0x90)  /* SDRAM Bank 0 Addr Config Register */
+#define EMC_SDMR0	(EMC_BASE + 0xa000) /* Mode Register of SDRAM bank 0 */
+
+#define REG_EMC_BCR	REG32(EMC_BCR)
+
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+#define REG_EMC_NFECR	REG32(EMC_NFECR)
+#define REG_EMC_NFECC	REG32(EMC_NFECC)
+#define REG_EMC_NFPAR0	REG32(EMC_NFPAR0)
+#define REG_EMC_NFPAR1	REG32(EMC_NFPAR1)
+#define REG_EMC_NFPAR2	REG32(EMC_NFPAR2)
+#define REG_EMC_NFINTS	REG32(EMC_NFINTS)
+#define REG_EMC_NFINTE	REG32(EMC_NFINTE)
+#define REG_EMC_NFERR0	REG32(EMC_NFERR0)
+#define REG_EMC_NFERR1	REG32(EMC_NFERR1)
+#define REG_EMC_NFERR2	REG32(EMC_NFERR2)
+#define REG_EMC_NFERR3	REG32(EMC_NFERR3)
+
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR0	REG32(EMC_DMAR0)
+
+/* Static Memory Control Register */
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+/* Static Memory Bank Addr Config Reg */
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+/* NAND Flash Control/Status Register */
+#define EMC_NFCSR_NFCE4		(1 << 7) /* NAND Flash Enable */
+#define EMC_NFCSR_NFE4		(1 << 6) /* NAND Flash FCE# Assertion Enable */
+#define EMC_NFCSR_NFCE3		(1 << 5)
+#define EMC_NFCSR_NFE3		(1 << 4)
+#define EMC_NFCSR_NFCE2		(1 << 3)
+#define EMC_NFCSR_NFE2		(1 << 2)
+#define EMC_NFCSR_NFCE1		(1 << 1)
+#define EMC_NFCSR_NFE1		(1 << 0)
+
+/* NAND Flash ECC Control Register */
+#define EMC_NFECR_PRDY		(1 << 4) /* Parity Ready */
+#define EMC_NFECR_RS_DECODING	(0 << 3) /* RS is in decoding phase */
+#define EMC_NFECR_RS_ENCODING	(1 << 3) /* RS is in encoding phase */
+#define EMC_NFECR_HAMMING	(0 << 2) /* Select HAMMING Correction Algorithm */
+#define EMC_NFECR_RS		(1 << 2) /* Select RS Correction Algorithm */
+#define EMC_NFECR_ERST		(1 << 1) /* ECC Reset */
+#define EMC_NFECR_ECCE		(1 << 0) /* ECC Enable */
+
+/* NAND Flash ECC Data Register */
+#define EMC_NFECC_ECC2_BIT	16
+#define EMC_NFECC_ECC2_MASK	(0xff << EMC_NFECC_ECC2_BIT)
+#define EMC_NFECC_ECC1_BIT	8
+#define EMC_NFECC_ECC1_MASK	(0xff << EMC_NFECC_ECC1_BIT)
+#define EMC_NFECC_ECC0_BIT	0
+#define EMC_NFECC_ECC0_MASK	(0xff << EMC_NFECC_ECC0_BIT)
+
+/* NAND Flash Interrupt Status Register */
+#define EMC_NFINTS_ERRCNT_BIT	29       /* Error Count */
+#define EMC_NFINTS_ERRCNT_MASK	(0x7 << EMC_NFINTS_ERRCNT_BIT)
+#define EMC_NFINTS_PADF		(1 << 4) /* Padding Finished */
+#define EMC_NFINTS_DECF		(1 << 3) /* Decoding Finished */
+#define EMC_NFINTS_ENCF		(1 << 2) /* Encoding Finished */
+#define EMC_NFINTS_UNCOR	(1 << 1) /* Uncorrectable Error Occurred */
+#define EMC_NFINTS_ERR		(1 << 0) /* Error Occurred */
+
+/* NAND Flash Interrupt Enable Register */
+#define EMC_NFINTE_PADFE	(1 << 4) /* Padding Finished Interrupt Enable */
+#define EMC_NFINTE_DECFE	(1 << 3) /* Decoding Finished Interrupt Enable */
+#define EMC_NFINTE_ENCFE	(1 << 2) /* Encoding Finished Interrupt Enable */
+#define EMC_NFINTE_UNCORE	(1 << 1) /* Uncorrectable Error Occurred Intr Enable */
+#define EMC_NFINTE_ERRE		(1 << 0) /* Error Occurred Interrupt */
+
+/* NAND Flash RS Error Report Register */
+#define EMC_NFERR_INDEX_BIT	16       /* Error Symbol Index */
+#define EMC_NFERR_INDEX_MASK	(0x1ff << EMC_NFERR_INDEX_BIT)
+#define EMC_NFERR_MASK_BIT	0        /* Error Symbol Value */
+#define EMC_NFERR_MASK_MASK	(0x1ff << EMC_NFERR_MASK_BIT)
+
+
+/* DRAM Control Register */
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+/* Refresh Time Control/Status Register */
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+/* SDRAM Bank Address Configuration Register */
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+/* Mode Register of SDRAM bank 0 */
+#define EMC_SDMR_BM		(1 << 9) /* Write Burst Mode */
+#define EMC_SDMR_OM_BIT		7        /* Operating Mode */
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4        /* CAS Latency */
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3        /* Burst Type */
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT) /* Sequential */
+  #define EMC_SDMR_BT_INT	(1 << EMC_SDMR_BT_BIT) /* Interleave */
+#define EMC_SDMR_BL_BIT		0        /* Burst Length */
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+
+/* CIM Configuration Register  (CIM_CFG) */
+
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14)
+#define	CIM_CFG_HSP		(1 << 13)
+#define	CIM_CFG_PCP		(1 << 12)
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+  #define CIM_CFG_DSM_NGCM	  (3 << CIM_CFG_DSM_BIT) /* Non-Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+
+#define	CIM_CTRL_MCLKDIV_BIT	24
+#define	CIM_CTRL_MCLKDIV_MASK	(0xff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+#define	CIM_CTRL_VDDM		(1 << 13)
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_RXF_TRIG_BIT	4
+#define	CIM_CTRL_RXF_TRIG_MASK	(0x7 << CIM_CTRL_RXF_TRIG_BIT)
+  #define CIM_CTRL_RXF_TRIG_4	  (0 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 4 */
+  #define CIM_CTRL_RXF_TRIG_8	  (1 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 8 */
+  #define CIM_CTRL_RXF_TRIG_12	  (2 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 12 */
+  #define CIM_CTRL_RXF_TRIG_16	  (3 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 16 */
+  #define CIM_CTRL_RXF_TRIG_20	  (4 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 20 */
+  #define CIM_CTRL_RXF_TRIG_24	  (5 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 24 */
+  #define CIM_CTRL_RXF_TRIG_28	  (6 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 28 */
+  #define CIM_CTRL_RXF_TRIG_32	  (7 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 32 */
+#define	CIM_CTRL_DMA_EN		(1 << 2)
+#define	CIM_CTRL_RXF_RST	(1 << 1)
+#define	CIM_CTRL_ENA		(1 << 0)
+
+/* CIM State Register  (CIM_STATE) */
+
+#define	CIM_STATE_DMA_SOF	(1 << 6)
+#define	CIM_STATE_DMA_EOF	(1 << 5)
+#define	CIM_STATE_DMA_STOP	(1 << 4)
+#define	CIM_STATE_RXF_OF	(1 << 3)
+#define	CIM_STATE_RXF_TRIG	(1 << 2)
+#define	CIM_STATE_RXF_EMPTY	(1 << 1)
+#define	CIM_STATE_VDD		(1 << 0)
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31)
+#define	CIM_CMD_EOFINT		(1 << 30)
+#define	CIM_CMD_STOP		(1 << 28)
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+
+/*************************************************************************
+ * SADC (Smart A/D Controller)
+ *************************************************************************/
+
+#define SADC_ENA	(SADC_BASE + 0x00)  /* ADC Enable Register */
+#define SADC_CFG	(SADC_BASE + 0x04)  /* ADC Configure Register */
+#define SADC_CTRL	(SADC_BASE + 0x08)  /* ADC Control Register */
+#define SADC_STATE	(SADC_BASE + 0x0C)  /* ADC Status Register*/
+#define SADC_SAMETIME	(SADC_BASE + 0x10)  /* ADC Same Point Time Register */
+#define SADC_WAITTIME	(SADC_BASE + 0x14)  /* ADC Wait Time Register */
+#define SADC_TSDAT	(SADC_BASE + 0x18)  /* ADC Touch Screen Data Register */
+#define SADC_BATDAT	(SADC_BASE + 0x1C)  /* ADC PBAT Data Register */
+#define SADC_SADDAT	(SADC_BASE + 0x20)  /* ADC SADCIN Data Register */
+
+#define REG_SADC_ENA		REG8(SADC_ENA)
+#define REG_SADC_CFG		REG32(SADC_CFG)
+#define REG_SADC_CTRL		REG8(SADC_CTRL)
+#define REG_SADC_STATE		REG8(SADC_STATE)
+#define REG_SADC_SAMETIME	REG16(SADC_SAMETIME)
+#define REG_SADC_WAITTIME	REG16(SADC_WAITTIME)
+#define REG_SADC_TSDAT		REG32(SADC_TSDAT)
+#define REG_SADC_BATDAT		REG16(SADC_BATDAT)
+#define REG_SADC_SADDAT		REG16(SADC_SADDAT)
+
+/* ADC Enable Register */
+#define SADC_ENA_ADEN		(1 << 7)  /* Touch Screen Enable */
+#define SADC_ENA_TSEN		(1 << 2)  /* Touch Screen Enable */
+#define SADC_ENA_PBATEN		(1 << 1)  /* PBAT Enable */
+#define SADC_ENA_SADCINEN	(1 << 0)  /* SADCIN Enable */
+
+/* ADC Configure Register */
+#define SADC_CFG_CLKOUT_NUM_BIT	16
+#define SADC_CFG_CLKOUT_NUM_MASK (0x7 << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_TS_DMA		(1 << 15)  /* Touch Screen DMA Enable */
+#define SADC_CFG_XYZ_BIT	13  /* XYZ selection */
+#define SADC_CFG_XYZ_MASK	(0x3 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XY		(0 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ		(1 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ1Z2	(2 << SADC_CFG_XYZ_BIT)
+#define SADC_CFG_SNUM_BIT	10  /* Sample Number */
+#define SADC_CFG_SNUM_MASK	(0x7 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_1	(0x0 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_2	(0x1 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_3	(0x2 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_4	(0x3 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_5	(0x4 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_6	(0x5 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_8	(0x6 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_9	(0x7 << SADC_CFG_SNUM_BIT)
+#define SADC_CFG_CLKDIV_BIT	5  /* AD Converter frequency clock divider */
+#define SADC_CFG_CLKDIV_MASK	(0x1f << SADC_CFG_CLKDIV_BIT)
+#define SADC_CFG_PBAT_HIGH	(0 << 4)  /* PBAT >= 2.5V */
+#define SADC_CFG_PBAT_LOW	(1 << 4)  /* PBAT < 2.5V */
+#define SADC_CFG_CMD_BIT	0  /* ADC Command */
+#define SADC_CFG_CMD_MASK	(0xf << SADC_CFG_CMD_BIT)
+  #define SADC_CFG_CMD_X_SE	(0x0 << SADC_CFG_CMD_BIT) /* X Single-End */
+  #define SADC_CFG_CMD_Y_SE	(0x1 << SADC_CFG_CMD_BIT) /* Y Single-End */
+  #define SADC_CFG_CMD_X_DIFF	(0x2 << SADC_CFG_CMD_BIT) /* X Differential */
+  #define SADC_CFG_CMD_Y_DIFF	(0x3 << SADC_CFG_CMD_BIT) /* Y Differential */
+  #define SADC_CFG_CMD_Z1_DIFF	(0x4 << SADC_CFG_CMD_BIT) /* Z1 Differential */
+  #define SADC_CFG_CMD_Z2_DIFF	(0x5 << SADC_CFG_CMD_BIT) /* Z2 Differential */
+  #define SADC_CFG_CMD_Z3_DIFF	(0x6 << SADC_CFG_CMD_BIT) /* Z3 Differential */
+  #define SADC_CFG_CMD_Z4_DIFF	(0x7 << SADC_CFG_CMD_BIT) /* Z4 Differential */
+  #define SADC_CFG_CMD_TP_SE	(0x8 << SADC_CFG_CMD_BIT) /* Touch Pressure */
+  #define SADC_CFG_CMD_PBATH_SE	(0x9 << SADC_CFG_CMD_BIT) /* PBAT >= 2.5V */
+  #define SADC_CFG_CMD_PBATL_SE	(0xa << SADC_CFG_CMD_BIT) /* PBAT < 2.5V */
+  #define SADC_CFG_CMD_SADCIN_SE (0xb << SADC_CFG_CMD_BIT) /* Measure SADCIN */
+  #define SADC_CFG_CMD_INT_PEN	(0xc << SADC_CFG_CMD_BIT) /* INT_PEN Enable */
+
+/* ADC Control Register */
+#define SADC_CTRL_PENDM		(1 << 4)  /* Pen Down Interrupt Mask */
+#define SADC_CTRL_PENUM		(1 << 3)  /* Pen Up Interrupt Mask */
+#define SADC_CTRL_TSRDYM	(1 << 2)  /* Touch Screen Data Ready Interrupt Mask */
+#define SADC_CTRL_PBATRDYM	(1 << 1)  /* PBAT Data Ready Interrupt Mask */
+#define SADC_CTRL_SRDYM		(1 << 0)  /* SADCIN Data Ready Interrupt Mask */
+
+/* ADC Status Register */
+#define SADC_STATE_TSBUSY	(1 << 7)  /* TS A/D is working */
+#define SADC_STATE_PBATBUSY	(1 << 6)  /* PBAT A/D is working */
+#define SADC_STATE_SBUSY	(1 << 5)  /* SADCIN A/D is working */
+#define SADC_STATE_PEND		(1 << 4)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PENU		(1 << 3)  /* Pen Up Interrupt Flag */
+#define SADC_STATE_TSRDY	(1 << 2)  /* Touch Screen Data Ready Interrupt Flag */
+#define SADC_STATE_PBATRDY	(1 << 1)  /* PBAT Data Ready Interrupt Flag */
+#define SADC_STATE_SRDY		(1 << 0)  /* SADCIN Data Ready Interrupt Flag */
+
+/* ADC Touch Screen Data Register */
+#define SADC_TSDAT_DATA0_BIT	0
+#define SADC_TSDAT_DATA0_MASK	(0xfff << SADC_TSDAT_DATA0_BIT)
+#define SADC_TSDAT_TYPE0	(1 << 15)
+#define SADC_TSDAT_DATA1_BIT	16
+#define SADC_TSDAT_DATA1_MASK	(0xfff << SADC_TSDAT_DATA1_BIT)
+#define SADC_TSDAT_TYPE1	(1 << 31)
+
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+
+#define SLCD_CFG	(SLCD_BASE + 0xA0)  /* SLCD Configure Register */
+#define SLCD_CTRL	(SLCD_BASE + 0xA4)  /* SLCD Control Register */
+#define SLCD_STATE	(SLCD_BASE + 0xA8)  /* SLCD Status Register */
+#define SLCD_DATA	(SLCD_BASE + 0xAC)  /* SLCD Data Register */
+#define SLCD_FIFO	(SLCD_BASE + 0xB0)  /* SLCD FIFO Register */
+
+#define REG_SLCD_CFG	REG32(SLCD_CFG)
+#define REG_SLCD_CTRL	REG8(SLCD_CTRL)
+#define REG_SLCD_STATE	REG8(SLCD_STATE)
+#define REG_SLCD_DATA	REG32(SLCD_DATA)
+#define REG_SLCD_FIFO	REG32(SLCD_FIFO)
+
+/* SLCD Configure Register */
+#define SLCD_CFG_BURST_BIT	14
+#define SLCD_CFG_BURST_MASK	(0x3 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_4_WORD	(0 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_8_WORD	(1 << SLCD_CFG_BURST_BIT)
+#define SLCD_CFG_DWIDTH_BIT	10
+#define SLCD_CFG_DWIDTH_MASK	(0x7 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_18	(0 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_16	(1 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x3	(2 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x2	(3 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x1	(4 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_9_x2	(4 << SLCD_CFG_DWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_16BIT	(0 << 8)
+#define SLCD_CFG_CWIDTH_8BIT	(1 << 8)
+#define SLCD_CFG_CWIDTH_18BIT	(2 << 8)
+#define SLCD_CFG_CS_ACTIVE_LOW	(0 << 4)
+#define SLCD_CFG_CS_ACTIVE_HIGH	(1 << 4)
+#define SLCD_CFG_RS_CMD_LOW	(0 << 3)
+#define SLCD_CFG_RS_CMD_HIGH	(1 << 3)
+#define SLCD_CFG_CLK_ACTIVE_FALLING	(0 << 1)
+#define SLCD_CFG_CLK_ACTIVE_RISING	(1 << 1)
+#define SLCD_CFG_TYPE_PARALLEL	(0 << 0)
+#define SLCD_CFG_TYPE_SERIAL	(1 << 0)
+
+/* SLCD Control Register */
+#define SLCD_CTRL_DMA_EN	(1 << 0)
+
+/* SLCD Status Register */
+#define SLCD_STATE_BUSY		(1 << 0)
+
+/* SLCD Data Register */
+#define SLCD_DATA_RS_DATA	(0 << 31)
+#define SLCD_DATA_RS_COMMAND	(1 << 31)
+
+/* SLCD FIFO Register */
+#define SLCD_FIFO_RS_DATA	(0 << 31)
+#define SLCD_FIFO_RS_COMMAND	(1 << 31)
+
+
+/*************************************************************************
+ * LCD (LCD Controller)
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00) /* LCD Configure Register */
+#define LCD_VSYNC	(LCD_BASE + 0x04) /* Vertical Synchronize Register */
+#define LCD_HSYNC	(LCD_BASE + 0x08) /* Horizontal Synchronize Register */
+#define LCD_VAT		(LCD_BASE + 0x0c) /* Virtual Area Setting Register */
+#define LCD_DAH		(LCD_BASE + 0x10) /* Display Area Horizontal Start/End Point */
+#define LCD_DAV		(LCD_BASE + 0x14) /* Display Area Vertical Start/End Point */
+#define LCD_PS		(LCD_BASE + 0x18) /* PS Signal Setting */
+#define LCD_CLS		(LCD_BASE + 0x1c) /* CLS Signal Setting */
+#define LCD_SPL		(LCD_BASE + 0x20) /* SPL Signal Setting */
+#define LCD_REV		(LCD_BASE + 0x24) /* REV Signal Setting */
+#define LCD_CTRL	(LCD_BASE + 0x30) /* LCD Control Register */
+#define LCD_STATE	(LCD_BASE + 0x34) /* LCD Status Register */
+#define LCD_IID		(LCD_BASE + 0x38) /* Interrupt ID Register */
+#define LCD_DA0		(LCD_BASE + 0x40) /* Descriptor Address Register 0 */
+#define LCD_SA0		(LCD_BASE + 0x44) /* Source Address Register 0 */
+#define LCD_FID0	(LCD_BASE + 0x48) /* Frame ID Register 0 */
+#define LCD_CMD0	(LCD_BASE + 0x4c) /* DMA Command Register 0 */
+#define LCD_DA1		(LCD_BASE + 0x50) /* Descriptor Address Register 1 */
+#define LCD_SA1		(LCD_BASE + 0x54) /* Source Address Register 1 */
+#define LCD_FID1	(LCD_BASE + 0x58) /* Frame ID Register 1 */
+#define LCD_CMD1	(LCD_BASE + 0x5c) /* DMA Command Register 1 */
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+/* LCD Configure Register */
+#define LCD_CFG_LCDPIN_BIT	31  /* LCD pins selection */
+#define LCD_CFG_LCDPIN_MASK	(0x1 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_LCD	(0x0 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_SLCD	(0x1 << LCD_CFG_LCDPIN_BIT)
+#define LCD_CFG_PSM		(1 << 23) /* PS signal mode */
+#define LCD_CFG_CLSM		(1 << 22) /* CLS signal mode */
+#define LCD_CFG_SPLM		(1 << 21) /* SPL signal mode */
+#define LCD_CFG_REVM		(1 << 20) /* REV signal mode */
+#define LCD_CFG_HSYNM		(1 << 19) /* HSYNC signal mode */
+#define LCD_CFG_PCLKM		(1 << 18) /* PCLK signal mode */
+#define LCD_CFG_INVDAT		(1 << 17) /* Inverse output data */
+#define LCD_CFG_SYNDIR_IN	(1 << 16) /* VSYNC&HSYNC direction */
+#define LCD_CFG_PSP		(1 << 15) /* PS pin reset state */
+#define LCD_CFG_CLSP		(1 << 14) /* CLS pin reset state */
+#define LCD_CFG_SPLP		(1 << 13) /* SPL pin reset state */
+#define LCD_CFG_REVP		(1 << 12) /* REV pin reset state */
+#define LCD_CFG_HSP		(1 << 11) /* HSYNC pority:0-active high,1-active low */
+#define LCD_CFG_PCP		(1 << 10) /* PCLK pority:0-rising,1-falling */
+#define LCD_CFG_DEP		(1 << 9)  /* DE pority:0-active high,1-active low */
+#define LCD_CFG_VSP		(1 << 8)  /* VSYNC pority:0-rising,1-falling */
+#define LCD_CFG_PDW_BIT		4  /* STN pins utilization */
+#define LCD_CFG_PDW_MASK	(0x3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_PDW_1		(0 << LCD_CFG_PDW_BIT) /* LCD_D[0] */
+  #define LCD_CFG_PDW_2		(1 << LCD_CFG_PDW_BIT) /* LCD_D[0:1] */
+  #define LCD_CFG_PDW_4		(2 << LCD_CFG_PDW_BIT) /* LCD_D[0:3]/LCD_D[8:11] */
+  #define LCD_CFG_PDW_8		(3 << LCD_CFG_PDW_BIT) /* LCD_D[0:7]/LCD_D[8:15] */
+#define LCD_CFG_MODE_BIT	0  /* Display Device Mode Select */
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_CFG_MODE_BIT) /* 16,18 bit TFT */
+  #define LCD_CFG_MODE_SPECIAL_TFT_1	(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_2	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_3	(3 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(5 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SERIAL_TFT	(12 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_18BIT_TFT  (13 << LCD_CFG_MODE_BIT)
+  /* JZ47XX defines */
+  #define LCD_CFG_MODE_SHARP_HR		(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_CASIO_TFT	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SAMSUNG_ALPHA	(3 << LCD_CFG_MODE_BIT)
+
+
+
+/* Vertical Synchronize Register */
+#define LCD_VSYNC_VPS_BIT	16  /* VSYNC pulse start in line clock, fixed to 0 */
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0   /* VSYNC pulse end in line clock */
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+/* Horizontal Synchronize Register */
+#define LCD_HSYNC_HPS_BIT	16  /* HSYNC pulse start position in dot clock */
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0   /* HSYNC pulse end position in dot clock */
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+/* Virtual Area Setting Register */
+#define LCD_VAT_HT_BIT		16  /* Horizontal Total size in dot clock */
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0   /* Vertical Total size in dot clock */
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+/* Display Area Horizontal Start/End Point Register */
+#define LCD_DAH_HDS_BIT		16  /* Horizontal display area start in dot clock */
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0   /* Horizontal display area end in dot clock */
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+/* Display Area Vertical Start/End Point Register */
+#define LCD_DAV_VDS_BIT		16  /* Vertical display area start in line clock */
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0   /* Vertical display area end in line clock */
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+/* PS Signal Setting */
+#define LCD_PS_PSS_BIT		16  /* PS signal start position in dot clock */
+#define LCD_PS_PSS_MASK		(0xffff << LCD_PS_PSS_BIT)
+#define LCD_PS_PSE_BIT		0   /* PS signal end position in dot clock */
+#define LCD_PS_PSE_MASK		(0xffff << LCD_PS_PSE_BIT)
+
+/* CLS Signal Setting */
+#define LCD_CLS_CLSS_BIT	16  /* CLS signal start position in dot clock */
+#define LCD_CLS_CLSS_MASK	(0xffff << LCD_CLS_CLSS_BIT)
+#define LCD_CLS_CLSE_BIT	0   /* CLS signal end position in dot clock */
+#define LCD_CLS_CLSE_MASK	(0xffff << LCD_CLS_CLSE_BIT)
+
+/* SPL Signal Setting */
+#define LCD_SPL_SPLS_BIT	16  /* SPL signal start position in dot clock */
+#define LCD_SPL_SPLS_MASK	(0xffff << LCD_SPL_SPLS_BIT)
+#define LCD_SPL_SPLE_BIT	0   /* SPL signal end position in dot clock */
+#define LCD_SPL_SPLE_MASK	(0xffff << LCD_SPL_SPLE_BIT)
+
+/* REV Signal Setting */
+#define LCD_REV_REVS_BIT	16  /* REV signal start position in dot clock */
+#define LCD_REV_REVS_MASK	(0xffff << LCD_REV_REVS_BIT)
+
+/* LCD Control Register */
+#define LCD_CTRL_BST_BIT	28  /* Burst Length Selection */
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT) /* 4-word */
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT) /* 8-word */
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT) /* 16-word */
+#define LCD_CTRL_RGB565		(0 << 27) /* RGB565 mode */
+#define LCD_CTRL_RGB555		(1 << 27) /* RGB555 mode */
+#define LCD_CTRL_OFUP		(1 << 26) /* Output FIFO underrun protection enable */
+#define LCD_CTRL_FRC_BIT	24  /* STN FRC Algorithm Selection */
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT) /* 16 grayscale */
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT) /* 4 grayscale */
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT) /* 2 grayscale */
+#define LCD_CTRL_PDD_BIT	16  /* Load Palette Delay Counter */
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13) /* EOF interrupt mask */
+#define LCD_CTRL_SOFM		(1 << 12) /* SOF interrupt mask */
+#define LCD_CTRL_OFUM		(1 << 11) /* Output FIFO underrun interrupt mask */
+#define LCD_CTRL_IFUM0		(1 << 10) /* Input FIFO 0 underrun interrupt mask */
+#define LCD_CTRL_IFUM1		(1 << 9)  /* Input FIFO 1 underrun interrupt mask */
+#define LCD_CTRL_LDDM		(1 << 8)  /* LCD disable done interrupt mask */
+#define LCD_CTRL_QDM		(1 << 7)  /* LCD quick disable done interrupt mask */
+#define LCD_CTRL_BEDN		(1 << 6)  /* Endian selection */
+#define LCD_CTRL_PEDN		(1 << 5)  /* Endian in byte:0-msb first, 1-lsb first */
+#define LCD_CTRL_DIS		(1 << 4)  /* Disable indicate bit */
+#define LCD_CTRL_ENA		(1 << 3)  /* LCD enable bit */
+#define LCD_CTRL_BPP_BIT	0  /* Bits Per Pixel */
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT) /* 1 bpp */
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT) /* 2 bpp */
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT) /* 4 bpp */
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT) /* 8 bpp */
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT) /* 15/16 bpp */
+  #define LCD_CTRL_BPP_18_24	(5 << LCD_CTRL_BPP_BIT) /* 18/24/32 bpp */
+
+/* LCD Status Register */
+#define LCD_STATE_QD		(1 << 7) /* Quick Disable Done */
+#define LCD_STATE_EOF		(1 << 5) /* EOF Flag */
+#define LCD_STATE_SOF		(1 << 4) /* SOF Flag */
+#define LCD_STATE_OFU		(1 << 3) /* Output FIFO Underrun */
+#define LCD_STATE_IFU0		(1 << 2) /* Input FIFO 0 Underrun */
+#define LCD_STATE_IFU1		(1 << 1) /* Input FIFO 1 Underrun */
+#define LCD_STATE_LDD		(1 << 0) /* LCD Disabled */
+
+/* DMA Command Register */
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+
+/*************************************************************************
+ * USB Device
+ *************************************************************************/
+#define USB_BASE  UDC_BASE
+
+#define USB_REG_FADDR		(USB_BASE + 0x00) /* Function Address 8-bit */
+#define USB_REG_POWER		(USB_BASE + 0x01) /* Power Managemetn 8-bit */
+#define USB_REG_INTRIN		(USB_BASE + 0x02) /* Interrupt IN 16-bit */
+#define USB_REG_INTROUT		(USB_BASE + 0x04) /* Interrupt OUT 16-bit */
+#define USB_REG_INTRINE		(USB_BASE + 0x06) /* Intr IN enable 16-bit */
+#define USB_REG_INTROUTE	(USB_BASE + 0x08) /* Intr OUT enable 16-bit */
+#define USB_REG_INTRUSB		(USB_BASE + 0x0a) /* Interrupt USB 8-bit */
+#define USB_REG_INTRUSBE	(USB_BASE + 0x0b) /* Interrupt USB Enable 8-bit */
+#define USB_REG_FRAME		(USB_BASE + 0x0c) /* Frame number 16-bit */
+#define USB_REG_INDEX		(USB_BASE + 0x0e) /* Index register 8-bit */
+#define USB_REG_TESTMODE	(USB_BASE + 0x0f) /* USB test mode 8-bit */
+
+#define USB_REG_CSR0		(USB_BASE + 0x12) /* EP0 CSR 8-bit */
+#define USB_REG_INMAXP		(USB_BASE + 0x10) /* EP1-2 IN Max Pkt Size 16-bit */
+#define USB_REG_INCSR		(USB_BASE + 0x12) /* EP1-2 IN CSR LSB 8/16bit */
+#define USB_REG_INCSRH		(USB_BASE + 0x13) /* EP1-2 IN CSR MSB 8-bit */
+#define USB_REG_OUTMAXP		(USB_BASE + 0x14) /* EP1 OUT Max Pkt Size 16-bit */
+#define USB_REG_OUTCSR		(USB_BASE + 0x16) /* EP1 OUT CSR LSB 8/16bit */
+#define USB_REG_OUTCSRH		(USB_BASE + 0x17) /* EP1 OUT CSR MSB 8-bit */
+#define USB_REG_OUTCOUNT	(USB_BASE + 0x18) /* bytes in EP0/1 OUT FIFO 16-bit */
+
+#define USB_FIFO_EP0		(USB_BASE + 0x20)
+#define USB_FIFO_EP1		(USB_BASE + 0x24)
+#define USB_FIFO_EP2		(USB_BASE + 0x28)
+
+#define USB_REG_EPINFO		(USB_BASE + 0x78) /* Endpoint information */
+#define USB_REG_RAMINFO		(USB_BASE + 0x79) /* RAM information */
+
+#define USB_REG_INTR		(USB_BASE + 0x200) /* DMA pending interrupts */
+#define USB_REG_CNTL1		(USB_BASE + 0x204) /* DMA channel 1 control */
+#define USB_REG_ADDR1		(USB_BASE + 0x208) /* DMA channel 1 AHB memory addr */
+#define USB_REG_COUNT1		(USB_BASE + 0x20c) /* DMA channel 1 byte count */
+#define USB_REG_CNTL2		(USB_BASE + 0x214) /* DMA channel 2 control */
+#define USB_REG_ADDR2		(USB_BASE + 0x218) /* DMA channel 2 AHB memory addr */
+#define USB_REG_COUNT2		(USB_BASE + 0x21c) /* DMA channel 2 byte count */
+
+
+/* Power register bit masks */
+#define USB_POWER_SUSPENDM	0x01
+#define USB_POWER_RESUME	0x04
+#define USB_POWER_HSMODE	0x10
+#define USB_POWER_HSENAB	0x20
+#define USB_POWER_SOFTCONN	0x40
+
+/* Interrupt register bit masks */
+#define USB_INTR_SUSPEND	0x01
+#define USB_INTR_RESUME		0x02
+#define USB_INTR_RESET		0x04
+
+#define USB_INTR_EP0		0x0001
+#define USB_INTR_INEP1		0x0002
+#define USB_INTR_INEP2		0x0004
+#define USB_INTR_OUTEP1		0x0002
+
+/* CSR0 bit masks */
+#define USB_CSR0_OUTPKTRDY	0x01
+#define USB_CSR0_INPKTRDY	0x02
+#define USB_CSR0_SENTSTALL	0x04
+#define USB_CSR0_DATAEND	0x08
+#define USB_CSR0_SETUPEND	0x10
+#define USB_CSR0_SENDSTALL	0x20
+#define USB_CSR0_SVDOUTPKTRDY	0x40
+#define USB_CSR0_SVDSETUPEND	0x80
+
+/* Endpoint CSR register bits */
+#define USB_INCSRH_AUTOSET	0x80
+#define USB_INCSRH_ISO		0x40
+#define USB_INCSRH_MODE		0x20
+#define USB_INCSRH_DMAREQENAB	0x10
+#define USB_INCSRH_DMAREQMODE	0x04
+#define USB_INCSR_CDT		0x40
+#define USB_INCSR_SENTSTALL	0x20
+#define USB_INCSR_SENDSTALL	0x10
+#define USB_INCSR_FF		0x08
+#define USB_INCSR_UNDERRUN	0x04
+#define USB_INCSR_FFNOTEMPT	0x02
+#define USB_INCSR_INPKTRDY	0x01
+#define USB_OUTCSRH_AUTOCLR	0x80
+#define USB_OUTCSRH_ISO		0x40
+#define USB_OUTCSRH_DMAREQENAB	0x20
+#define USB_OUTCSRH_DNYT	0x10
+#define USB_OUTCSRH_DMAREQMODE	0x08
+#define USB_OUTCSR_CDT		0x80
+#define USB_OUTCSR_SENTSTALL	0x40
+#define USB_OUTCSR_SENDSTALL	0x20
+#define USB_OUTCSR_FF		0x10
+#define USB_OUTCSR_DATAERR	0x08
+#define USB_OUTCSR_OVERRUN	0x04
+#define USB_OUTCSR_FFFULL	0x02
+#define USB_OUTCSR_OUTPKTRDY	0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK		0x01
+#define USB_TEST_J		0x02
+#define USB_TEST_K		0x04
+#define USB_TEST_PACKET		0x08
+
+/* DMA control bits */
+#define USB_CNTL_ENA		0x01
+#define USB_CNTL_DIR_IN		0x02
+#define USB_CNTL_MODE_1		0x04
+#define USB_CNTL_INTR_EN	0x08
+#define USB_CNTL_EP(n)		((n) << 4)
+#define USB_CNTL_BURST_0	(0 << 9)
+#define USB_CNTL_BURST_4	(1 << 9)
+#define USB_CNTL_BURST_8	(2 << 9)
+#define USB_CNTL_BURST_16	(3 << 9)
+
+
+//----------------------------------------------------------------------
+//
+// Module Operation Definitions
+//
+//----------------------------------------------------------------------
+#ifndef __ASSEMBLY__
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+//------------------------------------------------------
+// GPIO Pins Description
+//
+// PORT 0:
+//
+// PIN/BIT N		FUNC0		FUNC1
+//	0		D0		-
+//	1		D1		-
+//	2		D2		-
+//	3		D3		-
+//	4		D4		-
+//	5		D5		-
+//	6		D6		-
+//	7		D7		-
+//	8		D8		-
+//	9		D9		-
+//	10		D10		-
+//	11		D11		-
+//	12		D12		-
+//	13		D13		-
+//	14		D14		-
+//	15		D15		-
+//	16		D16		-
+//	17		D17		-
+//	18		D18		-
+//	19		D19		-
+//	20		D20		-
+//	21		D21		-
+//	22		D22		-
+//	23		D23		-
+//	24		D24		-
+//	25		D25		-
+//	26		D26		-
+//	27		D27		-
+//	28		D28		-
+//	29		D29		-
+//	30		D30		-
+//	31		D31		-
+//
+//------------------------------------------------------
+// PORT 1:
+//
+// PIN/BIT N		FUNC0		FUNC1
+//	0		A0		-
+//	1		A1		-
+//	2		A2		-
+//	3		A3		-
+//	4		A4		-
+//	5		A5		-
+//	6		A6		-
+//	7		A7		-
+//	8		A8		-
+//	9		A9		-
+//	10		A10		-
+//	11		A11		-
+//	12		A12		-
+//	13		A13		-
+//	14		A14		-
+//	15		A15/CL		-
+//	16		A16/AL		-
+//	17		LCD_CLS		A21
+//	18		LCD_SPL		A22
+//	19		DCS#		-
+//	20		RAS#		-
+//	21		CAS#		-
+//	22		RDWE#/BUFD#	-
+//	23		CKE		-
+//	24		CKO		-
+//	25		CS1#		-
+//	26		CS2#		-
+//	27		CS3#		-
+//	28		CS4#		-
+//	29		RD#		-
+//	30		WR#		-
+//	31		WE0#		-
+//
+// Note: PIN15&16 are CL&AL when connecting to NAND flash.
+//------------------------------------------------------
+// PORT 2:
+//
+// PIN/BIT N		FUNC0		FUNC1
+//	0		LCD_D0		-
+//	1		LCD_D1		-
+//	2		LCD_D2		-
+//	3		LCD_D3		-
+//	4		LCD_D4		-
+//	5		LCD_D5		-
+//	6		LCD_D6		-
+//	7		LCD_D7		-
+//	8		LCD_D8		-
+//	9		LCD_D9		-
+//	10		LCD_D10		-
+//	11		LCD_D11		-
+//	12		LCD_D12		-
+//	13		LCD_D13		-
+//	14		LCD_D14		-
+//	15		LCD_D15		-
+//	16		LCD_D16		-
+//	17		LCD_D17		-
+//	18		LCD_PCLK	-
+//	19		LCD_HSYNC	-
+//	20		LCD_VSYNC	-
+//	21		LCD_DE		-
+//	22		LCD_PS		A19
+//	23		LCD_REV		A20
+//	24		WE1#		-
+//	25		WE2#		-
+//	26		WE3#		-
+//	27		WAIT#		-
+//	28		FRE#		-
+//	29		FWE#		-
+//	30(NOTE:FRB#)	-		-
+//	31		-		-
+//
+// NOTE(1): PIN30 is used for FRB# when connecting to NAND flash.
+//------------------------------------------------------
+// PORT 3:
+//
+// PIN/BIT N		FUNC0		FUNC1
+//	0		CIM_D0		-
+//	1		CIM_D1		-
+//	2		CIM_D2		-
+//	3		CIM_D3		-
+//	4		CIM_D4		-
+//	5		CIM_D5		-
+//	6		CIM_D6		-
+//	7		CIM_D7		-
+//	8		MSC_CMD		-
+//	9		MSC_CLK		-
+//	10		MSC_D0		-
+//	11		MSC_D1		-
+//	12		MSC_D2		-
+//	13		MSC_D3		-
+//	14		CIM_MCLK	-
+//	15		CIM_PCLK	-
+//	16		CIM_VSYNC	-
+//	17		CIM_HSYNC	-
+//	18		SSI_CLK		SCLK_RSTN
+//	19		SSI_CE0#	BIT_CLK(AIC)
+//	20		SSI_DT		SDATA_OUT(AIC)
+//	21		SSI_DR		SDATA_IN(AIC)
+//	22		SSI_CE1#&GPC	SYNC(AIC)
+//	23		PWM0		I2C_SDA
+//	24		PWM1		I2C_SCK
+//	25		PWM2		UART0_TxD
+//	26		PWM3		UART0_RxD
+//	27		PWM4		A17
+//	28		PWM5		A18
+//	29		-		-
+//	30		PWM6		UART0_CTS/UART1_RxD
+//	31		PWM7		UART0_RTS/UART1_TxD
+//
+//////////////////////////////////////////////////////////
+
+/* 
+ * p is the port number (0,1,2,3)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-127), regardless of the port
+ */
+
+//-------------------------------------------
+// Function Pins Mode
+
+#define __gpio_as_func0(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func1(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A16, DCS#, RAS#, CAS#, CKE#, 
+ * RDWE#, CKO#, WE0#, WE1#, WE2#, WE3#
+ */
+#define __gpio_as_sdram_32bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;	\
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;	\
+	REG_GPIO_PXPES(1) = 0x81f9ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x07000000;	\
+	REG_GPIO_PXSELC(2) = 0x07000000;	\
+	REG_GPIO_PXPES(2) = 0x07000000;		\
+} while (0)
+
+/*
+ * D0 ~ D15, A0 ~ A16, DCS#, RAS#, CAS#, CKE#, 
+ * RDWE#, CKO#, WE0#, WE1#
+ */
+#define __gpio_as_sdram_16bit_4720()		\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x5442bfaa;	\
+	REG_GPIO_PXSELC(0) = 0x5442bfaa;	\
+	REG_GPIO_PXPES(0) = 0x5442bfaa;		\
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;	\
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;	\
+	REG_GPIO_PXPES(1) = 0x81f9ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x01000000;	\
+	REG_GPIO_PXSELC(2) = 0x01000000;	\
+	REG_GPIO_PXPES(2) = 0x01000000;		\
+} while (0)
+
+/*
+ * D0 ~ D15, A0 ~ A16, DCS#, RAS#, CAS#, CKE#, 
+ * RDWE#, CKO#, WE0#, WE1#
+ */
+#define __gpio_as_sdram_16bit_4725()		\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;	\
+	REG_GPIO_PXPES(0) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;	\
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;	\
+	REG_GPIO_PXPES(1) = 0x81f9ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x01000000;	\
+	REG_GPIO_PXSELC(2) = 0x01000000;	\
+	REG_GPIO_PXPES(2) = 0x01000000;		\
+} while (0)
+
+
+/*
+ * CS1#, CLE, ALE, FRE#, FWE#, FRB#, RDWE#/BUFD#
+ */
+#define __gpio_as_nand()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0x02018000;	\
+	REG_GPIO_PXSELC(1) = 0x02018000;	\
+	REG_GPIO_PXPES(1) = 0x02018000;		\
+	REG_GPIO_PXFUNS(2) = 0x30000000;	\
+	REG_GPIO_PXSELC(2) = 0x30000000;	\
+	REG_GPIO_PXPES(2) = 0x30000000;		\
+	REG_GPIO_PXFUNC(2) = 0x40000000;	\
+	REG_GPIO_PXSELC(2) = 0x40000000;	\
+	REG_GPIO_PXDIRC(2) = 0x40000000;	\
+	REG_GPIO_PXPES(2) = 0x40000000;		\
+	REG_GPIO_PXFUNS(1) = 0x00400000;	\
+	REG_GPIO_PXSELC(1) = 0x00400000;	\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D7
+ */
+#define __gpio_as_nor_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x000000ff;	\
+	REG_GPIO_PXSELC(0) = 0x000000ff;	\
+	REG_GPIO_PXPES(0) = 0x000000ff;		\
+	REG_GPIO_PXFUNS(1) = 0x7041ffff;	\
+	REG_GPIO_PXSELC(1) = 0x7041ffff;	\
+	REG_GPIO_PXPES(1) = 0x7041ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x00060000;	\
+	REG_GPIO_PXSELS(1) = 0x00060000;	\
+	REG_GPIO_PXPES(1) = 0x00060000;		\
+	REG_GPIO_PXFUNS(2) = 0x08000000;	\
+	REG_GPIO_PXSELC(2) = 0x08000000;	\
+	REG_GPIO_PXPES(2) = 0x08000000;		\
+	REG_GPIO_PXFUNS(2) = 0x00c00000;	\
+	REG_GPIO_PXSELS(2) = 0x00c00000;	\
+	REG_GPIO_PXPES(2) = 0x00c00000;		\
+	REG_GPIO_PXFUNS(3) = 0x18000000;	\
+	REG_GPIO_PXSELS(3) = 0x18000000;	\
+	REG_GPIO_PXPES(3) = 0x18000000;		\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D15
+ */
+#define __gpio_as_nor_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;	\
+	REG_GPIO_PXPES(0) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x7041ffff;	\
+	REG_GPIO_PXSELC(1) = 0x7041ffff;	\
+	REG_GPIO_PXPES(1) = 0x7041ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x00060000;	\
+	REG_GPIO_PXSELS(1) = 0x00060000;	\
+	REG_GPIO_PXPES(1) = 0x00060000;		\
+	REG_GPIO_PXFUNS(2) = 0x08000000;	\
+	REG_GPIO_PXSELC(2) = 0x08000000;	\
+	REG_GPIO_PXPES(2) = 0x08000000;		\
+	REG_GPIO_PXFUNS(2) = 0x00c00000;	\
+	REG_GPIO_PXSELS(2) = 0x00c00000;	\
+	REG_GPIO_PXPES(2) = 0x00c00000;		\
+	REG_GPIO_PXFUNS(3) = 0x18000000;	\
+	REG_GPIO_PXSELS(3) = 0x18000000;	\
+	REG_GPIO_PXPES(3) = 0x18000000;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART_RxD0
+ */
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x06000000;	\
+	REG_GPIO_PXSELS(3) = 0x06000000;	\
+	REG_GPIO_PXPES(3) = 0x06000000;		\
+} while (0)
+
+#define __gpio_jtag_to_uart0()			\
+do {						\
+	REG_GPIO_PXSELS(2) = 0x80000000;	\
+} while (0)
+
+/*
+ * UART0_CTS, UART0_RTS
+ */
+#define __gpio_as_ctsrts()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xc0000000;	\
+	REG_GPIO_PXSELS(3) = 0xc0000000;	\
+	REG_GPIO_PXTRGC(3) = 0xc0000000;	\
+	REG_GPIO_PXPES(3) = 0xc0000000;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD1
+ */
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xc0000000;	\
+	REG_GPIO_PXSELC(3) = 0xc0000000;	\
+	REG_GPIO_PXTRGS(3) = 0xc0000000;	\
+	REG_GPIO_PXPES(3) = 0xc0000000;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D15, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x003cffff;	\
+	REG_GPIO_PXSELC(2) = 0x003cffff;	\
+	REG_GPIO_PXPES(2) = 0x003cffff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D17, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x003fffff;	\
+	REG_GPIO_PXSELC(2) = 0x003fffff;	\
+	REG_GPIO_PXPES(2) = 0x003fffff;		\
+} while (0)
+
+
+/* LCD_D0~LCD_D7, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001800ff;	\
+	REG_GPIO_PXSELC(2) = 0x001800ff;	\
+} while (0)
+
+/* LCD_D0~LCD_D7, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_9bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001801ff;	\
+	REG_GPIO_PXSELC(2) = 0x001801ff;	\
+} while (0)
+
+/* LCD_D0~LCD_D15, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x0018ffff;	\
+	REG_GPIO_PXSELC(2) = 0x0018ffff;	\
+} while (0)
+
+/* LCD_D0~LCD_D17, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001bffff;	\
+	REG_GPIO_PXSELC(2) = 0x001bffff;	\
+} while (0)
+
+
+/*
+ * CIM_D0~CIM_D7, CIM_MCLK, CIM_PCLK, CIM_VSYNC, CIM_HSYNC
+ */
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x0003c0ff;	\
+	REG_GPIO_PXSELC(3) = 0x0003c0ff;	\
+	REG_GPIO_PXPES(3) = 0x0003c0ff;		\
+} while (0)
+
+/*
+ * SDATA_OUT, SDATA_IN, BIT_CLK, SYNC, SCLK_RESET
+ */
+#define __gpio_as_aic()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x007c0000;	\
+	REG_GPIO_PXSELS(3) = 0x007c0000;	\
+	REG_GPIO_PXPES(3) = 0x007c0000;		\
+} while (0)
+
+/*
+ * MSC_CMD, MSC_CLK, MSC_D0 ~ MSC_D3
+ */
+#define __gpio_as_msc()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x00003f00;	\
+	REG_GPIO_PXSELC(3) = 0x00003f00;	\
+	REG_GPIO_PXPES(3) = 0x00003f00;		\
+} while (0)
+
+/*
+ * SSI_CS0, SSI_CLK, SSI_DT, SSI_DR
+ */
+#define __gpio_as_ssi()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003c0000;	\
+	REG_GPIO_PXSELC(3) = 0x003c0000;	\
+	REG_GPIO_PXPES(3) = 0x003c0000;		\
+} while (0)
+
+/*
+ * I2C_SCK, I2C_SDA
+ */
+#define __gpio_as_i2c()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x01800000;	\
+	REG_GPIO_PXSELS(3) = 0x01800000;	\
+	REG_GPIO_PXPES(3) = 0x01800000;		\
+} while (0)
+
+/*
+ * PWM0
+ */
+#define __gpio_as_pwm0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x00800000;	\
+	REG_GPIO_PXSELC(3) = 0x00800000;	\
+	REG_GPIO_PXPES(3) = 0x00800000;		\
+} while (0)
+
+/*
+ * PWM1
+ */
+#define __gpio_as_pwm1()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x01000000;	\
+	REG_GPIO_PXSELC(3) = 0x01000000;	\
+	REG_GPIO_PXPES(3) = 0x01000000;		\
+} while (0)
+
+/*
+ * PWM2
+ */
+#define __gpio_as_pwm2()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x02000000;	\
+	REG_GPIO_PXSELC(3) = 0x02000000;	\
+	REG_GPIO_PXPES(3) = 0x02000000;		\
+} while (0)
+
+/*
+ * PWM3
+ */
+#define __gpio_as_pwm3()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x04000000;	\
+	REG_GPIO_PXSELC(3) = 0x04000000;	\
+	REG_GPIO_PXPES(3) = 0x04000000;		\
+} while (0)
+
+/*
+ * PWM4
+ */
+#define __gpio_as_pwm4()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x08000000;	\
+	REG_GPIO_PXSELC(3) = 0x08000000;	\
+	REG_GPIO_PXPES(3) = 0x08000000;		\
+} while (0)
+
+/*
+ * PWM5
+ */
+#define __gpio_as_pwm5()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x10000000;	\
+	REG_GPIO_PXSELC(3) = 0x10000000;	\
+	REG_GPIO_PXPES(3) = 0x10000000;		\
+} while (0)
+
+/*
+ * PWM6
+ */
+#define __gpio_as_pwm6()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x40000000;	\
+	REG_GPIO_PXSELC(3) = 0x40000000;	\
+	REG_GPIO_PXPES(3) = 0x40000000;		\
+} while (0)
+
+/*
+ * PWM7
+ */
+#define __gpio_as_pwm7()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x80000000;	\
+	REG_GPIO_PXSELC(3) = 0x80000000;	\
+	REG_GPIO_PXPES(3) = 0x80000000;		\
+} while (0)
+
+/*
+ * n = 0 ~ 7
+ */
+#define __gpio_as_pwm(n)	__gpio_as_pwm##n()
+
+//-------------------------------------------
+// GPIO or Interrupt Mode
+
+#define __gpio_get_port(p)	(REG_GPIO_PXPIN(p))
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRS(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRC(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_pin(n)			\
+({						\
+	unsigned int p, o, v;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (__gpio_get_port(p) & (1 << o))	\
+		v = 1;				\
+	else					\
+		v = 0;				\
+	v;					\
+})
+
+#define __gpio_as_irq_high_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_low_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_rise_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_fall_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_irq()			\
+({						\
+	unsigned int p, i, tmp, v = 0;		\
+	for (p = 3; p >= 0; p--) {		\
+		tmp = REG_GPIO_PXFLG(p);	\
+		for (i = 0; i < 32; i++)	\
+			if (tmp & (1 << i))	\
+				v = (32*p + i);	\
+	}					\
+	v;					\
+})
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_PXFLG((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPEC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPES(p) = (1 << o);		\
+} while (0)
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_get_pllm() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLM_MASK) >> CPM_CPPCR_PLLM_BIT)
+#define __cpm_get_plln() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLN_MASK) >> CPM_CPPCR_PLLN_BIT)
+#define __cpm_get_pllod() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLOD_MASK) >> CPM_CPPCR_PLLOD_BIT)
+
+#define __cpm_get_cdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_CDIV_MASK) >> CPM_CPCCR_CDIV_BIT)
+#define __cpm_get_hdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_HDIV_MASK) >> CPM_CPCCR_HDIV_BIT)
+#define __cpm_get_pdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_PDIV_MASK) >> CPM_CPCCR_PDIV_BIT)
+#define __cpm_get_mdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT)
+#define __cpm_get_ldiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_LDIV_MASK) >> CPM_CPCCR_LDIV_BIT)
+#define __cpm_get_udiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_UDIV_MASK) >> CPM_CPCCR_UDIV_BIT)
+#define __cpm_get_i2sdiv() \
+	((REG_CPM_I2SCDR & CPM_I2SCDR_I2SDIV_MASK) >> CPM_I2SCDR_I2SDIV_BIT)
+#define __cpm_get_pixdiv() \
+	((REG_CPM_LPCDR & CPM_LPCDR_PIXDIV_MASK) >> CPM_LPCDR_PIXDIV_BIT)
+#define __cpm_get_mscdiv() \
+	((REG_CPM_MSCCDR & CPM_MSCCDR_MSCDIV_MASK) >> CPM_MSCCDR_MSCDIV_BIT)
+
+#define __cpm_set_cdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_CDIV_MASK) | ((v) << (CPM_CPCCR_CDIV_BIT)))
+#define __cpm_set_hdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_HDIV_MASK) | ((v) << (CPM_CPCCR_HDIV_BIT)))
+#define __cpm_set_pdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_PDIV_MASK) | ((v) << (CPM_CPCCR_PDIV_BIT)))
+#define __cpm_set_mdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_MDIV_MASK) | ((v) << (CPM_CPCCR_MDIV_BIT)))
+#define __cpm_set_ldiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_LDIV_MASK) | ((v) << (CPM_CPCCR_LDIV_BIT)))
+#define __cpm_set_udiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_UDIV_MASK) | ((v) << (CPM_CPCCR_UDIV_BIT)))
+#define __cpm_set_i2sdiv(v) \
+	(REG_CPM_I2SCDR = (REG_CPM_I2SCDR & ~CPM_I2SCDR_I2SDIV_MASK) | ((v) << (CPM_I2SCDR_I2SDIV_BIT)))
+#define __cpm_set_pixdiv(v) \
+	(REG_CPM_LPCDR = (REG_CPM_LPCDR & ~CPM_LPCDR_PIXDIV_MASK) | ((v) << (CPM_LPCDR_PIXDIV_BIT)))
+#define __cpm_set_mscdiv(v) \
+	(REG_CPM_MSCCDR = (REG_CPM_MSCCDR & ~CPM_MSCCDR_MSCDIV_MASK) | ((v) << (CPM_MSCCDR_MSCDIV_BIT)))
+
+#define __cpm_select_i2sclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_I2CS)
+#define __cpm_select_i2sclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_I2CS)
+#define __cpm_enable_cko()		(REG_CPM_CPCCR |= CPM_CPCCR_CLKOEN)
+#define __cpm_select_usbclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_UCS)
+#define __cpm_select_usbclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_UCS)
+#define __cpm_enable_pll_change()	(REG_CPM_CPCCR |= CPM_CPCCR_CE)
+#define __cpm_pllout_direct()		(REG_CPM_CPCCR |= CPM_CPCCR_PCS)
+#define __cpm_pllout_div2()		(REG_CPM_CPCCR &= ~CPM_CPCCR_PCS)
+
+#define __cpm_pll_is_on()		(REG_CPM_CPPCR & CPM_CPPCR_PLLS)
+#define __cpm_pll_bypass()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLBP)
+#define __cpm_pll_enable()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLEN)
+
+#define __cpm_get_cclk_doze_duty() \
+	((REG_CPM_LCR & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT)
+#define __cpm_set_cclk_doze_duty(v) \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_DOZE_DUTY_MASK) | ((v) << (CPM_LCR_DOZE_DUTY_BIT)))
+
+#define __cpm_doze_mode()		(REG_CPM_LCR |= CPM_LCR_DOZE_ON)
+#define __cpm_idle_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_IDLE)
+#define __cpm_sleep_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_SLEEP)
+
+#define __cpm_stop_all() 	(REG_CPM_CLKGR = 0x7fff)
+#define __cpm_stop_uart1()	(REG_CPM_CLKGR |= CPM_CLKGR_UART1)
+#define __cpm_stop_uhc()	(REG_CPM_CLKGR |= CPM_CLKGR_UHC)
+#define __cpm_stop_ipu()	(REG_CPM_CLKGR |= CPM_CLKGR_IPU)
+#define __cpm_stop_dmac()	(REG_CPM_CLKGR |= CPM_CLKGR_DMAC)
+#define __cpm_stop_udc()	(REG_CPM_CLKGR |= CPM_CLKGR_UDC)
+#define __cpm_stop_lcd()	(REG_CPM_CLKGR |= CPM_CLKGR_LCD)
+#define __cpm_stop_cim()	(REG_CPM_CLKGR |= CPM_CLKGR_CIM)
+#define __cpm_stop_sadc()	(REG_CPM_CLKGR |= CPM_CLKGR_SADC)
+#define __cpm_stop_msc()	(REG_CPM_CLKGR |= CPM_CLKGR_MSC)
+#define __cpm_stop_aic1()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC1)
+#define __cpm_stop_aic2()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC2)
+#define __cpm_stop_ssi()	(REG_CPM_CLKGR |= CPM_CLKGR_SSI)
+#define __cpm_stop_i2c()	(REG_CPM_CLKGR |= CPM_CLKGR_I2C)
+#define __cpm_stop_rtc()	(REG_CPM_CLKGR |= CPM_CLKGR_RTC)
+#define __cpm_stop_tcu()	(REG_CPM_CLKGR |= CPM_CLKGR_TCU)
+#define __cpm_stop_uart0()	(REG_CPM_CLKGR |= CPM_CLKGR_UART0)
+
+#define __cpm_start_all() 	(REG_CPM_CLKGR = 0x0)
+#define __cpm_start_uart1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART1)
+#define __cpm_start_uhc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UHC)
+#define __cpm_start_ipu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IPU)
+#define __cpm_start_dmac()	(REG_CPM_CLKGR &= ~CPM_CLKGR_DMAC)
+#define __cpm_start_udc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UDC)
+#define __cpm_start_lcd()	(REG_CPM_CLKGR &= ~CPM_CLKGR_LCD)
+#define __cpm_start_cim()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIM)
+#define __cpm_start_sadc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SADC)
+#define __cpm_start_msc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_MSC)
+#define __cpm_start_aic1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC1)
+#define __cpm_start_aic2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC2)
+#define __cpm_start_ssi()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SSI)
+#define __cpm_start_i2c()	(REG_CPM_CLKGR &= ~CPM_CLKGR_I2C)
+#define __cpm_start_rtc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_RTC)
+#define __cpm_start_tcu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_TCU)
+#define __cpm_start_uart0()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART0)
+
+#define __cpm_get_o1st() \
+	((REG_CPM_SCR & CPM_SCR_O1ST_MASK) >> CPM_SCR_O1ST_BIT)
+#define __cpm_set_o1st(v) \
+	(REG_CPM_SCR = (REG_CPM_SCR & ~CPM_SCR_O1ST_MASK) | ((v) << (CPM_SCR_O1ST_BIT)))
+#define __cpm_suspend_usbphy()		(REG_CPM_SCR |= CPM_SCR_USBPHY_SUSPEND)
+#define __cpm_enable_osc_in_sleep()	(REG_CPM_SCR |= CPM_SCR_OSC_ENABLE)
+
+
+#ifdef CFG_EXTAL
+#define JZ_EXTAL		CFG_EXTAL
+#else
+#define JZ_EXTAL		3686400
+#endif
+#define JZ_EXTAL2		32768 /* RTC clock */
+
+/* PLL output frequency */
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned long m, n, no, pllout;
+	unsigned long cppcr = REG_CPM_CPPCR;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if ((cppcr & CPM_CPPCR_PLLEN) && !(cppcr & CPM_CPPCR_PLLBP)) {
+		m = __cpm_get_pllm() + 2;
+		n = __cpm_get_plln() + 2;
+		no = od[__cpm_get_pllod()];
+		pllout = ((JZ_EXTAL) / (n * no)) * m;
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+/* PLL output frequency for MSC/I2S/LCD/USB */
+static __inline__ unsigned int __cpm_get_pllout2(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_PCS)
+		return __cpm_get_pllout();
+	else
+		return __cpm_get_pllout()/2;
+}
+
+/* CPU core clock */
+static __inline__ unsigned int __cpm_get_cclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_cdiv()];
+}
+
+/* AHB system bus clock */
+static __inline__ unsigned int __cpm_get_hclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_hdiv()];
+}
+
+/* Memory bus clock */
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_mdiv()];
+}
+
+/* APB peripheral bus clock */
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_pdiv()];
+}
+
+/* LCDC module clock */
+static __inline__ unsigned int __cpm_get_lcdclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_ldiv() + 1);
+}
+
+/* LCD pixel clock */
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_pixdiv() + 1);
+}
+
+/* I2S clock */
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_I2CS) {
+		return __cpm_get_pllout2() / (__cpm_get_i2sdiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* USB clock */
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_UCS) {
+		return __cpm_get_pllout2() / (__cpm_get_udiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* MSC clock */
+static __inline__ unsigned int __cpm_get_mscclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_mscdiv() + 1);
+}
+
+/* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+static __inline__ unsigned int __cpm_get_extalclk(void)
+{
+	return JZ_EXTAL;
+}
+
+/* RTC clock for CPM,INTC,RTC,TCU,WDT */
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+/*
+ * Output 24MHz for SD and 16MHz for MMC.
+ */
+static inline void __cpm_select_msc_clk(int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	if (sd) {
+		div = pllout2 / 24000000;
+	}
+	else {
+		div = pllout2 / 16000000;
+	}
+
+	REG_CPM_MSCCDR = div - 1;
+}
+
+/***************************************************************************
+ * TCU
+ ***************************************************************************/
+// where 'n' is the TCU channel
+#define __tcu_select_extalclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_EXT_EN)
+#define __tcu_select_rtcclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_RTC_EN)
+#define __tcu_select_pclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_PCK_EN)
+
+#define __tcu_select_clk_div1(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1)
+#define __tcu_select_clk_div4(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE4)
+#define __tcu_select_clk_div16(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE16)
+#define __tcu_select_clk_div64(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE64)
+#define __tcu_select_clk_div256(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE256)
+#define __tcu_select_clk_div1024(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1024)
+
+#define __tcu_enable_pwm_output(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_EN )
+#define __tcu_disable_pwm_output(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_EN )
+
+#define __tcu_init_pwm_output_high(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_INITL_HIGH )
+#define __tcu_init_pwm_output_low(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_INITL_HIGH )
+
+#define __tcu_set_pwm_output_shutdown_graceful(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_SD )
+#define __tcu_set_pwm_output_shutdown_abrupt(n)		( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_SD )
+
+#define __tcu_start_counter(n)		( REG_TCU_TESR |= (1 << (n)) )
+#define __tcu_stop_counter(n)		( REG_TCU_TECR |= (1 << (n)) )
+
+#define __tcu_half_match_flag(n)	( REG_TCU_TFR & (1 << ((n) + 16)) )
+#define __tcu_full_match_flag(n)	( REG_TCU_TFR & (1 << (n)) )
+#define __tcu_set_half_match_flag(n)	( REG_TCU_TFSR = (1 << ((n) + 16)) )
+#define __tcu_set_full_match_flag(n)	( REG_TCU_TFSR = (1 << (n)) )
+#define __tcu_clear_half_match_flag(n)	( REG_TCU_TFCR = (1 << ((n) + 16)) )
+#define __tcu_clear_full_match_flag(n)	( REG_TCU_TFCR = (1 << (n)) )
+#define __tcu_mask_half_match_irq(n)	( REG_TCU_TMSR = (1 << ((n) + 16)) )
+#define __tcu_mask_full_match_irq(n)	( REG_TCU_TMSR = (1 << (n)) )
+#define __tcu_unmask_half_match_irq(n)	( REG_TCU_TMCR = (1 << ((n) + 16)) )
+#define __tcu_unmask_full_match_irq(n)	( REG_TCU_TMCR = (1 << (n)) )
+
+#define __tcu_wdt_clock_stopped()	( REG_TCU_TSR & TCU_TSSR_WDTSC )
+#define __tcu_timer_clock_stopped(n)	( REG_TCU_TSR & (1 << (n)) )
+
+#define __tcu_start_wdt_clock()		( REG_TCU_TSCR = TCU_TSSR_WDTSC )
+#define __tcu_start_timer_clock(n)	( REG_TCU_TSCR = (1 << (n)) )
+
+#define __tcu_stop_wdt_clock()		( REG_TCU_TSSR = TCU_TSSR_WDTSC )
+#define __tcu_stop_timer_clock(n)	( REG_TCU_TSSR = (1 << (n)) )
+
+#define __tcu_get_count(n)		( REG_TCU_TCNT((n)) )
+#define __tcu_set_count(n,v)		( REG_TCU_TCNT((n)) = (v) )
+#define __tcu_set_full_data(n,v)	( REG_TCU_TDFR((n)) = (v) )
+#define __tcu_set_half_data(n,v)	( REG_TCU_TDHR((n)) = (v) )
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+#define __wdt_start()			( REG_WDT_TCER |= WDT_TCER_TCEN )
+#define __wdt_stop()			( REG_WDT_TCER &= ~WDT_TCER_TCEN )
+#define __wdt_set_count(v)		( REG_WDT_TCNT = (v) )
+#define __wdt_set_data(v)		( REG_WDT_TDR = (v) )
+
+#define __wdt_select_extalclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_EXT_EN)
+#define __wdt_select_rtcclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_RTC_EN)
+#define __wdt_select_pclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_PCK_EN)
+
+#define __wdt_select_clk_div1() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1)
+#define __wdt_select_clk_div4() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE4)
+#define __wdt_select_clk_div16() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE16)
+#define __wdt_select_clk_div64() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE64)
+#define __wdt_select_clk_div256() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE256)
+#define __wdt_select_clk_div1024() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1024)
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable()			( REG8(UART0_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable()		( REG8(UART0_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq()	( REG8(UART0_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq()	( REG8(UART0_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq() \
+  ( REG8(UART0_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq() \
+  ( REG8(UART0_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback()  	( REG8(UART0_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback() 	( REG8(UART0_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1()		( REG8(UART0_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(devclk, baud)				\
+  do {								\
+	REG8(UART0_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART0_DLLR) = (devclk / 16 / baud) & 0xff;		\
+	REG8(UART0_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART0_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error()		( (REG8(UART0_LSR) & UARTLSR_PER) != 0 )
+#define __uart_clear_errors() \
+  ( REG8(UART0_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty()	( (REG8(UART0_LSR) & UARTLSR_TDRQ) != 0 )
+#define __uart_transmit_end()		( (REG8(UART0_LSR) & UARTLSR_TEMT) != 0 )
+#define __uart_transmit_char(ch)	( REG8(UART0_TDR) = (ch) )
+#define __uart_receive_fifo_full()	( (REG8(UART0_LSR) & UARTLSR_DR) != 0 )
+#define __uart_receive_ready()		( (REG8(UART0_LSR) & UARTLSR_DR) != 0 )
+#define __uart_receive_char()		REG8(UART0_RDR)
+#define __uart_disable_irda()		( REG8(UART0_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(UART0_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* n is the DMA channel (0 - 5) */
+
+#define __dmac_enable_module() \
+  ( REG_DMAC_DMACR |= DMAC_DMACR_DMAE | DMAC_DMACR_PR_RR )
+#define __dmac_disable_module() \
+  ( REG_DMAC_DMACR &= ~DMAC_DMACR_DMAE )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(p) 				\
+do {							\
+	REG_DMAC_DMACR &= ~DMAC_DMACR_PR_MASK;		\
+	REG_DMAC_DMACR |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error() ( REG_DMAC_DMACR & DMAC_DMACR_HLT )
+#define __dmac_test_addr_error() ( REG_DMAC_DMACR & DMAC_DMACR_AR )
+
+#define __dmac_enable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_NDES )
+#define __dmac_disable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_NDES )
+
+#define __dmac_enable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_EN )
+#define __dmac_disable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_EN )
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR((n)) & DMAC_DCCSR_EN )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCMD((n)) |= DMAC_DCMD_TIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_TT )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_AR )
+#define __dmac_channel_count_terminated_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_CT )
+#define __dmac_channel_descriptor_invalid_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_INV )
+
+#define __dmac_channel_clear_transmit_halt(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT )
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TT )
+#define __dmac_channel_clear_address_error(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR )
+#define __dmac_channel_clear_count_terminated(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_CT )
+#define __dmac_channel_clear_descriptor_invalid(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_INV )
+
+#define __dmac_channel_set_single_mode(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TM )
+#define __dmac_channel_set_block_mode(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_TM )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_8BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BYTE;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BYTE;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_RDIL_MASK;		\
+	REG_DMAC_DCMD((n) |= ((v) << DMAC_DCMD_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DAI )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_DAI )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SAI )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_SAI )
+
+#define __dmac_channel_set_doorbell(n) \
+  (  REG_DMAC_DMADBSR = (1 << (n)) )
+
+#define __dmac_channel_irq_detected(n)  ( REG_DMAC_DMAIPR & (1 << (n)) )
+#define __dmac_channel_ack_irq(n)       ( REG_DMAC_DMAIPR &= ~(1 << (n)) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i = 0; i < MAX_DMA_NUM; i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+#define __aic_reset_status()          ( REG_AIC_FR & AIC_FR_RST )
+
+#define __aic_reset()                                   \
+do {                                                    \
+        REG_AIC_FR |= AIC_FR_RST;                       \
+} while(0)
+
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()   ( REG_AIC_CR |= AIC_CR_M2S )
+#define __aic_disable_mono2stereo()  ( REG_AIC_CR &= ~AIC_CR_M2S )
+#define __aic_enable_byteswap()      ( REG_AIC_CR |= AIC_CR_ENDSW )
+#define __aic_disable_byteswap()     ( REG_AIC_CR &= ~AIC_CR_ENDSW )
+#define __aic_enable_unsignadj()     ( REG_AIC_CR |= AIC_CR_AVSTSU )
+#define __aic_disable_unsignadj()    ( REG_AIC_CR &= ~AIC_CR_AVSTSU )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+ } while (0)
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_msbjustified()   ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+/*#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )*/
+
+#define __i2s_set_oss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+#define __i2s_set_iss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+
+#define __i2s_stop_bitclk()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_bitclk()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+#define __ac97_slot_error_detected()     ( REG_AIC_ACSR & AIC_ACSR_SLTERR )
+#define __ac97_clear_slot_error()        ( REG_AIC_ACSR &= ~AIC_ACSR_SLTERR )
+
+#define __i2s_is_busy()         ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+#define __aic_internal_codec()  ( REG_AIC_FR |= AIC_FR_ICDC ) 
+#define __aic_external_codec()  ( REG_AIC_FR &= ~AIC_FR_ICDC )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+ } while (0)
+
+
+/***************************************************************************
+ * ICDC
+ ***************************************************************************/
+#define __i2s_internal_codec()         __aic_internal_codec()
+#define __i2s_external_codec()         __aic_external_codec()
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) )
+
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+
+#define __msc_start_op() \
+  ( REG_MSC_STRPCL = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(to) 	( REG_MSC_RESTO = to )
+#define __msc_set_rdto(to) 	( REG_MSC_RDTO = to )
+#define __msc_set_cmd(cmd) 	( REG_MSC_CMD = cmd )
+#define __msc_set_arg(arg) 	( REG_MSC_ARG = arg )
+#define __msc_set_nob(nob) 	( REG_MSC_NOB = nob )
+#define __msc_get_nob() 	( REG_MSC_NOB )
+#define __msc_set_blklen(len) 	( REG_MSC_BLKLEN = len )
+#define __msc_set_cmdat(cmdat) 	( REG_MSC_CMDAT = cmdat )
+#define __msc_set_cmdat_ioabort() 	( REG_MSC_CMDAT |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init() 	( REG_MSC_CMDAT |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy() 	( REG_MSC_CMDAT |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream() ( REG_MSC_CMDAT |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block() ( REG_MSC_CMDAT &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write() ( REG_MSC_CMDAT |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(r) 				\
+do { 								\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat() \
+  REG_MSC_CMDAT &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask() 		( REG_MSC_IMASK )
+#define __msc_mask_all_intrs() 		( REG_MSC_IMASK = 0xff )
+#define __msc_unmask_all_intrs() 	( REG_MSC_IMASK = 0x00 )
+#define __msc_mask_rd() 		( REG_MSC_IMASK |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd() 		( REG_MSC_IMASK &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr() 		( REG_MSC_IMASK |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr() 		( REG_MSC_IMASK &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres() 		( REG_MSC_IMASK |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres() 	( REG_MSC_IMASK &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone() 	( REG_MSC_IMASK |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone() 	( REG_MSC_IMASK &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone() 		( REG_MSC_IMASK |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone() 		( REG_MSC_IMASK &= ~MSC_IMASK_PRG_DONE )
+
+/* n=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n) 	\
+do { 				\
+	REG_MSC_CLKRT = n;	\
+} while(0)
+
+#define __msc_get_ireg() 		( REG_MSC_IREG )
+#define __msc_ireg_rd() 		( REG_MSC_IREG & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr() 		( REG_MSC_IREG & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res() 	( REG_MSC_IREG & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done() 	( REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done() 		( REG_MSC_IREG & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res() 	( REG_MSC_IREG = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done() ( REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done() 	( REG_MSC_IREG = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat() 		( REG_MSC_STAT )
+#define __msc_stat_not_end_cmd_res() 	( (REG_MSC_STAT & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err() \
+  ( REG_MSC_STAT & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo() 		( REG_MSC_RES )
+#define __msc_rd_rxfifo()  		( REG_MSC_RXFIFO )
+#define __msc_wr_txfifo(v)  		( REG_MSC_TXFIFO = v )
+
+#define __msc_reset() 						\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+
+/***************************************************************************
+ * SSI
+ ***************************************************************************/
+
+#define __ssi_enable()    ( REG_SSI_CR0 |= SSI_CR0_SSIE )
+#define __ssi_disable()   ( REG_SSI_CR0 &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce() ( REG_SSI_CR0 &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode() ( REG_SSI_ITR &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2() 		\
+do { 					\
+	REG_SSI_CR0 |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 &= ~SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_select_gpc() 		\
+do { 					\
+	REG_SSI_CR0 &= ~SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 |= SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_loopback()  ( REG_SSI_CR0 |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback() ( REG_SSI_CR0 &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive()   ( REG_SSI_CR0 &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive()  ( REG_SSI_CR0 |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive() 	\
+  ( REG_SSI_CR0 |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo()   ( REG_SSI_CR0 |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo()   ( REG_SSI_CR0 |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo() \
+  ( REG_SSI_CR0 |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit() ( REG_SSI_CR1 &= ~SSI_CR1_UNFIN )
+
+#define __ssi_spi_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SPI; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN); 	\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SSP; 			\
+} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format() 				\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_MW1; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+	REG_SSI_CR0 &= ~SSI_CR0_RFINE; 				\
+} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+ /* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	| SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	\
+
+#define __ssi_spi_set_misc(frmhl,endian,flen,mcom,pha,pol)	\
+do { 								\
+	REG_SSI_CR1 &= ~SSICR1_MISC_MASK; 			\
+	REG_SSI_CR1 |= ((frmhl) << 30) | ((endian) << 25) | 	\
+		 (((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+	         ((pha) << 1) | (pol); 				\
+} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb() ( REG_SSI_CR1 &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb() ( REG_SSI_CR1 |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n) \
+    REG_SSI_CR1 = (REG_SSI_CR1 & ~SSI_CR1_FLEN_MASK) | (((n) - 2) << 4) 
+
+/* n = 1 - 16 */
+#define __ssi_set_microwire_command_length(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##n##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_PHA) | (n&0x1)) )
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_POL) | (n&0x1)) )
+
+/* n = ix8 */
+#define __ssi_set_tx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_TTRG_MASK; 	\
+	REG_SSI_CR1 |= SSI_CR1_TTRG_##n; 	\
+} while (0)
+
+/* n = ix8 */
+#define __ssi_set_rx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_RTRG_MASK; 	\
+	REG_SSI_CR1 |= SSI_CR1_RTRG_##n; 	\
+} while (0)
+
+#define __ssi_get_txfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_clear_errors() \
+    ( REG_SSI_SR &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_transfer_end()	( REG_SSI_SR & SSI_SR_END )
+#define __ssi_is_busy()		( REG_SSI_SR & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full()	( REG_SSI_SR & SSI_SR_TFF )
+#define __ssi_rxfifo_empty()	( REG_SSI_SR & SSI_SR_RFE )
+#define __ssi_rxfifo_noempty()	( REG_SSI_SR & SSI_SR_RFHF )
+
+#define __ssi_set_clk(dev_clk, ssi_clk) \
+  ( REG_SSI_GR = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data()    REG_SSI_DR
+#define __ssi_transmit_data(v)  ( REG_SSI_DR = (v) )
+
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+  ( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+  ( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_PACK_MASK; 		\
+    REG_CIM_CFG |= (CIM_CFG_PACK_##n); 		\
+} while (0)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CPM; 		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CIM; 		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_GCM; 		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_NGCM; 		\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+    REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;			\
+    REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+
+#define __cim_enable_sof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_stop_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_FRC_##n; 		\
+} while (0)
+
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n; 	\
+} while (0)
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dam_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+#define __lcd_as_smart_lcd() 		( REG_LCD_CFG |= (1<<LCD_CFG_LCDPIN_BIT) )
+#define __lcd_as_general_lcd() 		( REG_LCD_CFG &= ~(1<<LCD_CFG_LCDPIN_BIT) )
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+#define __lcd_panel_white()		( REG_LCD_CFG |= LCD_CFG_WHITE )
+#define __lcd_panel_black()		( REG_LCD_CFG &= ~LCD_CFG_WHITE )
+
+/* n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_CFG &= ~LCD_CFG_PDW_MASK; 	\
+	REG_LCD_CFG |= LCD_CFG_PDW_n##;		\
+} while (0)
+
+/* m=LCD_CFG_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_CFG &= ~LCD_CFG_MODE_MASK;	\
+	REG_LCD_CFG |= (m);			\
+} while(0)
+
+/* n = 0-255 */
+#define __lcd_disable_ac_bias()		( REG_LCD_IO = 0xff )
+#define __lcd_set_ac_bias(n) 			\
+do {						\
+	REG_LCD_IO &= ~LCD_IO_ACB_MASK;		\
+	REG_LCD_IO |= ((n) << LCD_IO_ACB_BIT);	\
+} while(0)
+
+#define __lcd_io_set_dir()		( REG_LCD_IO |= LCD_IO_DIR )
+#define __lcd_io_clr_dir()		( REG_LCD_IO &= ~LCD_IO_DIR )
+
+#define __lcd_io_set_dep()		( REG_LCD_IO |= LCD_IO_DEP )
+#define __lcd_io_clr_dep()		( REG_LCD_IO &= ~LCD_IO_DEP )
+
+#define __lcd_io_set_vsp()		( REG_LCD_IO |= LCD_IO_VSP )
+#define __lcd_io_clr_vsp()		( REG_LCD_IO &= ~LCD_IO_VSP )
+
+#define __lcd_io_set_hsp()		( REG_LCD_IO |= LCD_IO_HSP )
+#define __lcd_io_clr_hsp()		( REG_LCD_IO &= ~LCD_IO_HSP )
+
+#define __lcd_io_set_pcp()		( REG_LCD_IO |= LCD_IO_PCP )
+#define __lcd_io_clr_pcp()		( REG_LCD_IO &= ~LCD_IO_PCP )
+
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+/***************************************************************************
+ * RTC ops
+ ***************************************************************************/
+
+#define __rtc_write_ready()  ( REG_RTC_RCR & RTC_RCR_WRDY )
+#define __rtc_enabled()      \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_RTCE ; \
+}while(0)                           \
+
+#define __rtc_disabled()         \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_RTCE; \
+}while(0)
+#define __rtc_enable_alarm()       \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_AE; \
+}while(0)
+
+#define __rtc_disable_alarm()    \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AE; \
+}while(0)
+
+#define __rtc_enable_alarm_irq()  \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_AIE; \
+}while(0)
+
+#define __rtc_disable_alarm_irq() \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AIE; \
+}while(0)
+#define __rtc_enable_Hz_irq()      \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_HZIE;  \
+}while(0)
+
+#define __rtc_disable_Hz_irq()     \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_HZIE; \
+}while(0)
+#define __rtc_get_1Hz_flag()     \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ((REG_RTC_RCR >> RTC_RCR_HZ) & 0x1); \
+}while(0)
+#define __rtc_clear_1Hz_flag()      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_HZ;   \
+}while(0)
+#define __rtc_get_alarm_flag()       \
+do{                                  \
+       while(!__rtc_write_ready());  \
+      ((REG_RTC_RCR >> RTC_RCR_AF) & 0x1) \
+while(0)
+#define __rtc_clear_alarm_flag()    \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AF;   \
+}while(0)
+#define  __rtc_get_second()        \
+do{                                \
+       while(!__rtc_write_ready());\
+	   REG_RTC_RSR;                \
+}while(0)
+ 
+#define __rtc_set_second(v)         \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RSR = v;              \
+}while(0)
+
+#define  __rtc_get_alarm_second()  \
+do{                                \
+      while(!__rtc_write_ready()); \
+	  REG_RTC_RSAR;                \
+}while(0)
+
+	  
+#define __rtc_set_alarm_second(v)   \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RSAR = v;             \
+}while(0)
+
+#define __rtc_RGR_is_locked()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR >> RTC_RGR_LOCK;  \
+}while(0)
+#define __rtc_lock_RGR()            \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR |= RTC_RGR_LOCK;  \
+}while(0)
+
+#define __rtc_unlock_RGR()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR &= ~RTC_RGR_LOCK; \
+}while(0)
+
+#define __rtc_get_adjc_val()       \
+do{                                \
+      while(!__rtc_write_ready());  \
+      ( (REG_RTC_RGR & RTC_RGR_ADJC_MASK) >> RTC_RGR_ADJC_BIT ); \
+}while(0)
+#define __rtc_set_adjc_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_ADJC_MASK) | (v << RTC_RGR_ADJC_BIT) )) \
+}while(0)
+
+#define __rtc_get_nc1Hz_val()       \
+      while(!__rtc_write_ready());  \
+      ( (REG_RTC_RGR & RTC_RGR_NC1HZ_MASK) >> RTC_RGR_NC1HZ_BIT )
+      
+#define __rtc_set_nc1Hz_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_NC1HZ_MASK) | (v << RTC_RGR_NC1HZ_BIT) )) \
+}while(0)
+#define __rtc_power_down()          \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HCR |= RTC_HCR_PD;    \
+}while(0)
+
+#define __rtc_get_hwfcr_val()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HWFCR & RTC_HWFCR_MASK;  \
+}while(0)
+#define __rtc_set_hwfcr_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HWFCR = (v) & RTC_HWFCR_MASK;  \
+}while(0)
+
+#define __rtc_get_hrcr_val()      \
+do{                               \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HRCR & RTC_HRCR_MASK ); \
+}while(0)
+#define __rtc_set_hrcr_val(v)        \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HRCR = (v) & RTC_HRCR_MASK );  \
+}while(0)
+
+#define __rtc_enable_alarm_wakeup()      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWCR |= RTC_HWCR_EALM );  \
+}while(0)
+
+#define __rtc_disable_alarm_wakeup()     \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWCR &= ~RTC_HWCR_EALM );  \
+}while(0)
+
+#define __rtc_status_hib_reset_occur()    \
+do{                                       \
+      while(!__rtc_write_ready());        \
+    ( (REG_RTC_HWRSR >> RTC_HWRSR_HR) & 0x1 ); \
+}while(0)
+#define __rtc_status_ppr_reset_occur()     \
+do{                                        \
+      while(!__rtc_write_ready());        \
+   ( (REG_RTC_HWRSR >> RTC_HWRSR_PPR) & 0x1 ); \
+}while(0)
+#define __rtc_status_wakeup_pin_waken_up() \
+do{                                        \
+      while(!__rtc_write_ready());        \
+   ( (REG_RTC_HWRSR >> RTC_HWRSR_PIN) & 0x1 ); \
+}while(0)
+#define __rtc_status_alarm_waken_up()      \
+do{                                       \
+      while(!__rtc_write_ready());        \
+  ( (REG_RTC_HWRSR >> RTC_HWRSR_ALM) & 0x1 ); \
+}while(0)
+#define __rtc_clear_hib_stat_all()  \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWRSR = 0 );        \
+}while(0)
+
+#define __rtc_get_scratch_pattern() \
+      while(!__rtc_write_ready());  \
+		  (REG_RTC_HSPR)
+#define __rtc_set_scratch_pattern(n) 		\
+do{                                 \
+      while(!__rtc_write_ready());  \
+      (REG_RTC_HSPR = n );        \
+}while(0)
+
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __JZ4740_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz4750d.h u-boot-1.1.6/include/asm-mips/jz4750d.h
--- /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz4750d.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/asm-mips/jz4750d.h	2009-01-05 17:48:37.000000000 +0800
@@ -0,0 +1,5317 @@
+/*
+ * Include file for Ingenic Semiconductor's JZ4750 CPU.
+ */
+#ifndef __JZ4750_H__
+#define __JZ4750_H__
+
+#ifndef __ASSEMBLY__
+#define UCOS_CSP 0
+
+#if UCOS_CSP
+#define __KERNEL__
+#include <bsp.h>
+#include <types.h>
+
+#include <sysdefs.h>
+#include <cacheops.h>
+#define KSEG0 KSEG0BASE
+#else
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+#endif
+
+#define cache_unroll(base,op)	        	\
+	__asm__ __volatile__("	         	\
+		.set noreorder;		        \
+		.set mips3;		        \
+		cache %1, (%0);	                \
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+static inline void jz_flush_dcache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_DCACHE_SIZE;
+	while (start < end) {
+		cache_unroll(start,Index_Writeback_Inv_D);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+static inline void jz_flush_icache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_ICACHE_SIZE;
+	while(start < end) {
+		cache_unroll(start,Index_Invalidate_I);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+/* cpu pipeline flush */
+static inline void jz_sync(void)
+{
+	__asm__ volatile ("sync");
+}
+
+static inline void jz_writeb(u32 address, u8 value)
+{
+	*((volatile u8 *)address) = value;
+}
+
+static inline void jz_writew(u32 address, u16 value)
+{
+	*((volatile u16 *)address) = value;
+}
+
+static inline void jz_writel(u32 address, u32 value)
+{
+	*((volatile u32 *)address) = value;
+}
+
+static inline u8 jz_readb(u32 address)
+{
+	return *((volatile u8 *)address);
+}
+
+static inline u16 jz_readw(u32 address)
+{
+	return *((volatile u16 *)address);
+}
+
+static inline u32 jz_readl(u32 address)
+{
+	return *((volatile u32 *)address);
+}
+
+#define REG8(addr)	*((volatile u8 *)(addr))
+#define REG16(addr)	*((volatile u16 *)(addr))
+#define REG32(addr)	*((volatile u32 *)(addr))
+
+#else
+
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+
+#endif /* !ASSEMBLY */
+
+//----------------------------------------------------------------------
+// Boot ROM Specification
+//
+
+/* NOR Boot config */
+#define JZ4750_NORBOOT_8BIT	0x00000000	/* 8-bit data bus flash */
+#define JZ4750_NORBOOT_16BIT	0x10101010	/* 16-bit data bus flash */
+#define JZ4750_NORBOOT_32BIT	0x20202020	/* 32-bit data bus flash */
+
+/* NAND Boot config */
+#define JZ4750_NANDBOOT_B8R3	0xffffffff	/* 8-bit bus & 3 row cycles */
+#define JZ4750_NANDBOOT_B8R2	0xf0f0f0f0	/* 8-bit bus & 2 row cycles */
+#define JZ4750_NANDBOOT_B16R3	0x0f0f0f0f	/* 16-bit bus & 3 row cycles */
+#define JZ4750_NANDBOOT_B16R2	0x00000000	/* 16-bit bus & 2 row cycles */
+
+
+//----------------------------------------------------------------------
+// Register Definitions
+//
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	TCU_BASE	0xB0002000
+#define	WDT_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	ICDC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	UART2_BASE	0xB0032000
+#define	UART3_BASE	0xB0033000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SADC_BASE	0xB0070000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	SLCD_BASE	0xB3050000
+#define	CIM_BASE	0xB3060000
+#define	BCH_BASE        0xB30D0000
+#define	ETH_BASE	0xB3100000
+
+
+/*************************************************************************
+ * INTC (Interrupt Controller)
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+// 1st-level interrupts
+#define IRQ_ETH		0
+#define IRQ_I2C		5
+#define IRQ_RTC		6
+#define IRQ_UART2	7
+#define IRQ_UART1	8
+#define IRQ_UART0	9
+#define IRQ_AIC 	10
+#define IRQ_GPIO5	11
+#define IRQ_GPIO4	12
+#define IRQ_GPIO3	13
+#define IRQ_GPIO2	14
+#define IRQ_GPIO1	15
+#define IRQ_GPIO0	16
+#define IRQ_BCH		17
+#define IRQ_SADC	18
+#define IRQ_CIM		19
+#define IRQ_TSSI	20
+#define IRQ_TCU2	21
+#define IRQ_TCU1	22
+#define IRQ_TCU0	23
+#define IRQ_MSC1	24
+#define IRQ_MSC0	25
+#define IRQ_SSI   	26
+#define IRQ_UDC		27
+#define IRQ_DMAC1	28
+#define IRQ_DMAC0	29
+#define IRQ_IPU		30
+#define IRQ_LCD		31
+
+// 2nd-level interrupts
+#define IRQ_DMA_0	32  /* 32 to 37 for DMAC channel 0 to 5 */
+#define IRQ_GPIO_0	48  /* 48 to 175 for GPIO pin 0 to 127 */
+
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00) /* RTC Control Register */
+#define RTC_RSR		(RTC_BASE + 0x04) /* RTC Second Register */
+#define RTC_RSAR	(RTC_BASE + 0x08) /* RTC Second Alarm Register */
+#define RTC_RGR		(RTC_BASE + 0x0c) /* RTC Regulator Register */
+
+#define RTC_HCR		(RTC_BASE + 0x20) /* Hibernate Control Register */
+#define RTC_HWFCR	(RTC_BASE + 0x24) /* Hibernate Wakeup Filter Counter Reg */
+#define RTC_HRCR	(RTC_BASE + 0x28) /* Hibernate Reset Counter Register */
+#define RTC_HWCR	(RTC_BASE + 0x2c) /* Hibernate Wakeup Control Register */
+#define RTC_HWRSR	(RTC_BASE + 0x30) /* Hibernate Wakeup Status Register */
+#define RTC_HSPR	(RTC_BASE + 0x34) /* Hibernate Scratch Pattern Register */
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+#define REG_RTC_HCR	REG32(RTC_HCR)
+#define REG_RTC_HWFCR	REG32(RTC_HWFCR)
+#define REG_RTC_HRCR	REG32(RTC_HRCR)
+#define REG_RTC_HWCR	REG32(RTC_HWCR)
+#define REG_RTC_HWRSR	REG32(RTC_HWRSR)
+#define REG_RTC_HSPR	REG32(RTC_HSPR)
+
+/* RTC Control Register */
+#define RTC_RCR_WRDY	(1 << 7)  /* Write Ready Flag */
+#define RTC_RCR_HZ	(1 << 6)  /* 1Hz Flag */
+#define RTC_RCR_HZIE	(1 << 5)  /* 1Hz Interrupt Enable */
+#define RTC_RCR_AF	(1 << 4)  /* Alarm Flag */
+#define RTC_RCR_AIE	(1 << 3)  /* Alarm Interrupt Enable */
+#define RTC_RCR_AE	(1 << 2)  /* Alarm Enable */
+#define RTC_RCR_RTCE	(1 << 0)  /* RTC Enable */
+
+/* RTC Regulator Register */
+#define RTC_RGR_LOCK		(1 << 31) /* Lock Bit */
+#define RTC_RGR_ADJC_BIT	16
+#define RTC_RGR_ADJC_MASK	(0x3ff << RTC_RGR_ADJC_BIT)
+#define RTC_RGR_NC1HZ_BIT	0
+#define RTC_RGR_NC1HZ_MASK	(0xffff << RTC_RGR_NC1HZ_BIT)
+
+/* Hibernate Control Register */
+#define RTC_HCR_PD		(1 << 0)  /* Power Down */
+
+/* Hibernate Wakeup Filter Counter Register */
+#define RTC_HWFCR_BIT		5
+#define RTC_HWFCR_MASK		(0x7ff << RTC_HWFCR_BIT)
+
+/* Hibernate Reset Counter Register */
+#define RTC_HRCR_BIT		5
+#define RTC_HRCR_MASK		(0x7f << RTC_HRCR_BIT)
+
+/* Hibernate Wakeup Control Register */
+#define RTC_HWCR_EALM		(1 << 0)  /* RTC alarm wakeup enable */
+
+/* Hibernate Wakeup Status Register */
+#define RTC_HWRSR_HR		(1 << 5)  /* Hibernate reset */
+#define RTC_HWRSR_PPR		(1 << 4)  /* PPR reset */
+#define RTC_HWRSR_PIN		(1 << 1)  /* Wakeup pin status bit */
+#define RTC_HWRSR_ALM		(1 << 0)  /* RTC alarm status bit */
+
+
+/*************************************************************************
+ * CPM (Clock reset and Power control Management)
+ *************************************************************************/
+#define CPM_CPCCR	(CPM_BASE+0x00)
+#define CPM_CPPCR	(CPM_BASE+0x10)
+#define CPM_CPPSR	(CPM_BASE+0x14) /* PLL Switch and Status Register */
+#define CPM_I2SCDR	(CPM_BASE+0x60)
+#define CPM_LPCDR	(CPM_BASE+0x64)
+#define CPM_MSCCDR(n)	(CPM_BASE+0x10*(n)+0x68) /* MSC0(n=0) or MSC1(n=1) device clock divider Register */
+#define CPM_UHCCDR	(CPM_BASE+0x6C)
+#define CPM_SSICDR	(CPM_BASE+0x74)
+#define CPM_PCMCDR	(CPM_BASE+0x7C) /* PCM device clock divider Register */
+
+#define CPM_LCR		(CPM_BASE+0x04)
+#define CPM_CLKGR	(CPM_BASE+0x20)
+#define CPM_OPCR	(CPM_BASE+0x24) /* Oscillator and Power Control Register */
+
+#define CPM_RSR		(CPM_BASE+0x08)
+
+#define REG_CPM_CPCCR   	REG32(CPM_CPCCR)
+#define REG_CPM_CPPCR    	REG32(CPM_CPPCR)
+#define REG_CPM_CPPSR	        REG32(CPM_CPPSR)
+#define REG_CPM_I2SCDR  	REG32(CPM_I2SCDR)
+#define REG_CPM_LPCDR   	REG32(CPM_LPCDR)
+#define REG_CPM_MSCCDR(n)	REG32(CPM_MSCCDR(n))
+#define REG_CPM_UHCCDR   	REG32(CPM_UHCCDR)
+#define REG_CPM_SSICDR  	REG32(CPM_SSICDR)
+#define REG_CPM_PCMCDR          REG32(CPM_PCMCDR)
+
+#define REG_CPM_LCR	REG32(CPM_LCR)
+#define REG_CPM_CLKGR	REG32(CPM_CLKGR)
+#define REG_CPM_OPCR	REG32(CPM_OPCR)
+
+#define REG_CPM_RSR	REG32(CPM_RSR)
+
+/* Clock Control Register */
+#define CPM_CPCCR_I2CS		(1 << 31)
+#define CPM_CPCCR_ECS   	(1 << 30) /* Select the between EXCLK and EXCLK/2 output */
+#define CPM_CPCCR_UCS		(1 << 29)
+#define CPM_CPCCR_UDIV_BIT	23
+#define CPM_CPCCR_UDIV_MASK	(0x3f << CPM_CPCCR_UDIV_BIT)
+#define CPM_CPCCR_CE		(1 << 22)
+#define CPM_CPCCR_PCS		(1 << 21)
+#define CPM_CPCCR_LDIV_BIT	16
+#define CPM_CPCCR_LDIV_MASK	(0x1f << CPM_CPCCR_LDIV_BIT)
+#define CPM_CPCCR_MDIV_BIT	12
+#define CPM_CPCCR_MDIV_MASK	(0x0f << CPM_CPCCR_MDIV_BIT)
+#define CPM_CPCCR_PDIV_BIT	8
+#define CPM_CPCCR_PDIV_MASK	(0x0f << CPM_CPCCR_PDIV_BIT)
+#define CPM_CPCCR_HDIV_BIT	4
+#define CPM_CPCCR_HDIV_MASK	(0x0f << CPM_CPCCR_HDIV_BIT)
+#define CPM_CPCCR_CDIV_BIT	0
+#define CPM_CPCCR_CDIV_MASK	(0x0f << CPM_CPCCR_CDIV_BIT)
+
+/* PLL Switch and Status Register */
+#define CPM_CPPSR_PLLOFF        31
+#define CPM_CPPSR_PLLBP         30
+#define CPM_CPPSR_PLLON         29
+#define CPM_CPPSR_PS            28 /* Indicate whether the PLL parameters' change has finished */
+#define CPM_CPPSR_FS            27 /* Indicate whether the main clock's change has finished */
+#define CPM_CPPSR_CS            26 /* Indicate whether the clock switch has finished */
+#define CPM_CPPSR_PM            1  /* Clock switch mode */
+#define CPM_CPPSR_FM            0  /* Clock frequency change mode */
+
+/* I2S Clock Divider Register */
+#define CPM_I2SCDR_I2SDIV_BIT	0
+#define CPM_I2SCDR_I2SDIV_MASK	(0x1ff << CPM_I2SCDR_I2SDIV_BIT)
+
+/* LCD Pixel Clock Divider Register */
+#define CPM_LPCDR_LSCS	        31 /* TV encoder Source Pixel Clock Selection */
+#define CPM_LPCDR_LPCS	        30 /* LCD Panel pix clock Selection */
+#define CPM_LPCDR_LTCS	        29 /* LCD TV Encoder or Panel pix clock Selection */
+#define CPM_LPCDR_PIXDIV_BIT	0
+#define CPM_LPCDR_PIXDIV_MASK	(0x7ff << CPM_LPCDR_PIXDIV_BIT)
+
+/* MSC Clock Divider Register */
+#define CPM_MSCCDR_MSCDIV_BIT	0
+#define CPM_MSCCDR_MSCDIV_MASK	(0x1f << CPM_MSCCDR_MSCDIV_BIT)
+
+/* UHC Clock Divider Register */
+#define CPM_UHCCDR_UHCDIV_BIT	0
+#define CPM_UHCCDR_UHCDIV_MASK	(0xf << CPM_UHCCDR_UHCDIV_BIT)
+
+/* SSI Clock Divider Register */
+#define CPM_SSICDR_SSIDIV_BIT	0
+#define CPM_SSICDR_SSIDIV_MASK	(0xf << CPM_SSICDR_SSIDIV_BIT)
+
+/* PCM device clock divider Register */
+#define CPM_PCMCDR_PCMS         31 /* PCM source clock Selection */
+#define CPM_PCMCDR_PCMCD_BIT    0
+#define CPM_PCMCDR_PCMCD_MASK   (0x1ff << CPM_PCMCDR_PCMCD_BIT)
+
+/* PLL Control Register */
+#define CPM_CPPCR_PLLM_BIT	23
+#define CPM_CPPCR_PLLM_MASK	(0x1ff << CPM_CPPCR_PLLM_BIT)
+#define CPM_CPPCR_PLLN_BIT	18
+#define CPM_CPPCR_PLLN_MASK	(0x1f << CPM_CPPCR_PLLN_BIT)
+#define CPM_CPPCR_PLLOD_BIT	16
+#define CPM_CPPCR_PLLOD_MASK	(0x03 << CPM_CPPCR_PLLOD_BIT)
+#define CPM_CPPCR_PLLS		(1 << 10) /* obsolete, replaced by CPM_CPPSR_PLLON */
+#define CPM_CPPCR_PLLBP		(1 << 9)
+#define CPM_CPPCR_PLLEN		(1 << 8)
+#define CPM_CPPCR_PLLST_BIT	0
+#define CPM_CPPCR_PLLST_MASK	(0xff << CPM_CPPCR_PLLST_BIT)
+
+/* Low Power Control Register */
+#define CPM_LCR_DOZE_DUTY_BIT 	3
+#define CPM_LCR_DOZE_DUTY_MASK 	(0x1f << CPM_LCR_DOZE_DUTY_BIT)
+#define CPM_LCR_DOZE_ON		(1 << 2)
+#define CPM_LCR_LPM_BIT		0
+#define CPM_LCR_LPM_MASK	(0x3 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_IDLE	(0x0 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_SLEEP	(0x1 << CPM_LCR_LPM_BIT)
+
+/* Clock Gate Register */
+#define CPM_CLKGR_CIMRAM	(1 << 28)
+#define CPM_CLKGR_IDCT  	(1 << 27)
+#define CPM_CLKGR_DB    	(1 << 26)
+#define CPM_CLKGR_ME    	(1 << 25)
+#define CPM_CLKGR_MC    	(1 << 24)
+#define CPM_CLKGR_TVE    	(1 << 23)
+#define CPM_CLKGR_TSSI    	(1 << 22)
+#define CPM_CLKGR_OWI    	(1 << 21)
+#define CPM_CLKGR_PCM    	(1 << 20)
+#define CPM_CLKGR_MSC1    	(1 << 19)
+#define CPM_CLKGR_SSI0    	(1 << 18)
+#define CPM_CLKGR_UART3    	(1 << 17)
+#define CPM_CLKGR_UART2    	(1 << 16)
+#define CPM_CLKGR_UART1		(1 << 15)
+#define CPM_CLKGR_UHC		(1 << 14)
+#define CPM_CLKGR_IPU		(1 << 13)
+#define CPM_CLKGR_DMAC		(1 << 12)
+#define CPM_CLKGR_UDC		(1 << 11)
+#define CPM_CLKGR_LCD		(1 << 10)
+#define CPM_CLKGR_CIM		(1 << 9)
+#define CPM_CLKGR_SADC		(1 << 8)
+#define CPM_CLKGR_MSC0		(1 << 7)
+#define CPM_CLKGR_AIC1		(1 << 6)
+#define CPM_CLKGR_AIC2		(1 << 5)
+#define CPM_CLKGR_SSI1		(1 << 4)
+#define CPM_CLKGR_I2C		(1 << 3)
+#define CPM_CLKGR_RTC		(1 << 2)
+#define CPM_CLKGR_TCU		(1 << 1)
+#define CPM_CLKGR_UART0		(1 << 0)
+
+/* Oscillator and Power Control Register */
+#define CPM_OPCR_O1ST_BIT	8
+#define CPM_OPCR_O1ST_MASK	(0xff << CPM_SCR_O1ST_BIT)
+#define CPM_OPCR_UHCPHY_DISABLE	(1 << 7)
+#define CPM_OPCR_UDCPHY_ENABLE	(1 << 6)
+#define CPM_OPCR_OSC_ENABLE	(1 << 4)
+#define CPM_OPCR_ERCS           (1 << 2) /* EXCLK/512 clock and RTCLK clock selection */
+#define CPM_OPCR_MOSE           (1 << 1) /* Main Oscillator Enable */
+#define CPM_OPCR_MCS            (1 << 0) /* Main clock source select register */
+
+/* Reset Status Register */
+#define CPM_RSR_HR		(1 << 2)
+#define CPM_RSR_WR		(1 << 1)
+#define CPM_RSR_PR		(1 << 0)
+
+
+/*************************************************************************
+ * TCU (Timer Counter Unit)
+ *************************************************************************/
+#define TCU_TSR		(TCU_BASE + 0x1C) /* Timer Stop Register */
+#define TCU_TSSR	(TCU_BASE + 0x2C) /* Timer Stop Set Register */
+#define TCU_TSCR	(TCU_BASE + 0x3C) /* Timer Stop Clear Register */
+#define TCU_TER		(TCU_BASE + 0x10) /* Timer Counter Enable Register */
+#define TCU_TESR	(TCU_BASE + 0x14) /* Timer Counter Enable Set Register */
+#define TCU_TECR	(TCU_BASE + 0x18) /* Timer Counter Enable Clear Register */
+#define TCU_TFR		(TCU_BASE + 0x20) /* Timer Flag Register */
+#define TCU_TFSR	(TCU_BASE + 0x24) /* Timer Flag Set Register */
+#define TCU_TFCR	(TCU_BASE + 0x28) /* Timer Flag Clear Register */
+#define TCU_TMR		(TCU_BASE + 0x30) /* Timer Mask Register */
+#define TCU_TMSR	(TCU_BASE + 0x34) /* Timer Mask Set Register */
+#define TCU_TMCR	(TCU_BASE + 0x38) /* Timer Mask Clear Register */
+#define TCU_TDFR0	(TCU_BASE + 0x40) /* Timer Data Full Register */
+#define TCU_TDHR0	(TCU_BASE + 0x44) /* Timer Data Half Register */
+#define TCU_TCNT0	(TCU_BASE + 0x48) /* Timer Counter Register */
+#define TCU_TCSR0	(TCU_BASE + 0x4C) /* Timer Control Register */
+#define TCU_TDFR1	(TCU_BASE + 0x50)
+#define TCU_TDHR1	(TCU_BASE + 0x54)
+#define TCU_TCNT1	(TCU_BASE + 0x58)
+#define TCU_TCSR1	(TCU_BASE + 0x5C)
+#define TCU_TDFR2	(TCU_BASE + 0x60)
+#define TCU_TDHR2	(TCU_BASE + 0x64)
+#define TCU_TCNT2	(TCU_BASE + 0x68)
+#define TCU_TCSR2	(TCU_BASE + 0x6C)
+#define TCU_TDFR3	(TCU_BASE + 0x70)
+#define TCU_TDHR3	(TCU_BASE + 0x74)
+#define TCU_TCNT3	(TCU_BASE + 0x78)
+#define TCU_TCSR3	(TCU_BASE + 0x7C)
+#define TCU_TDFR4	(TCU_BASE + 0x80)
+#define TCU_TDHR4	(TCU_BASE + 0x84)
+#define TCU_TCNT4	(TCU_BASE + 0x88)
+#define TCU_TCSR4	(TCU_BASE + 0x8C)
+#define TCU_TDFR5	(TCU_BASE + 0x90)
+#define TCU_TDHR5	(TCU_BASE + 0x94)
+#define TCU_TCNT5	(TCU_BASE + 0x98)
+#define TCU_TCSR5	(TCU_BASE + 0x9C)
+
+#define REG_TCU_TSR	REG32(TCU_TSR)
+#define REG_TCU_TSSR	REG32(TCU_TSSR)
+#define REG_TCU_TSCR	REG32(TCU_TSCR)
+#define REG_TCU_TER	REG8(TCU_TER)
+#define REG_TCU_TESR	REG8(TCU_TESR)
+#define REG_TCU_TECR	REG8(TCU_TECR)
+#define REG_TCU_TFR	REG32(TCU_TFR)
+#define REG_TCU_TFSR	REG32(TCU_TFSR)
+#define REG_TCU_TFCR	REG32(TCU_TFCR)
+#define REG_TCU_TMR	REG32(TCU_TMR)
+#define REG_TCU_TMSR	REG32(TCU_TMSR)
+#define REG_TCU_TMCR	REG32(TCU_TMCR)
+#define REG_TCU_TDFR0	REG16(TCU_TDFR0)
+#define REG_TCU_TDHR0	REG16(TCU_TDHR0)
+#define REG_TCU_TCNT0	REG16(TCU_TCNT0)
+#define REG_TCU_TCSR0	REG16(TCU_TCSR0)
+#define REG_TCU_TDFR1	REG16(TCU_TDFR1)
+#define REG_TCU_TDHR1	REG16(TCU_TDHR1)
+#define REG_TCU_TCNT1	REG16(TCU_TCNT1)
+#define REG_TCU_TCSR1	REG16(TCU_TCSR1)
+#define REG_TCU_TDFR2	REG16(TCU_TDFR2)
+#define REG_TCU_TDHR2	REG16(TCU_TDHR2)
+#define REG_TCU_TCNT2	REG16(TCU_TCNT2)
+#define REG_TCU_TCSR2	REG16(TCU_TCSR2)
+#define REG_TCU_TDFR3	REG16(TCU_TDFR3)
+#define REG_TCU_TDHR3	REG16(TCU_TDHR3)
+#define REG_TCU_TCNT3	REG16(TCU_TCNT3)
+#define REG_TCU_TCSR3	REG16(TCU_TCSR3)
+#define REG_TCU_TDFR4	REG16(TCU_TDFR4)
+#define REG_TCU_TDHR4	REG16(TCU_TDHR4)
+#define REG_TCU_TCNT4	REG16(TCU_TCNT4)
+#define REG_TCU_TCSR4	REG16(TCU_TCSR4)
+
+// n = 0,1,2,3,4,5
+#define TCU_TDFR(n)	(TCU_BASE + (0x40 + (n)*0x10)) /* Timer Data Full Reg */
+#define TCU_TDHR(n)	(TCU_BASE + (0x44 + (n)*0x10)) /* Timer Data Half Reg */
+#define TCU_TCNT(n)	(TCU_BASE + (0x48 + (n)*0x10)) /* Timer Counter Reg */
+#define TCU_TCSR(n)	(TCU_BASE + (0x4C + (n)*0x10)) /* Timer Control Reg */
+
+#define REG_TCU_TDFR(n)	REG16(TCU_TDFR((n)))
+#define REG_TCU_TDHR(n)	REG16(TCU_TDHR((n)))
+#define REG_TCU_TCNT(n)	REG16(TCU_TCNT((n)))
+#define REG_TCU_TCSR(n)	REG16(TCU_TCSR((n)))
+
+// Register definitions
+#define TCU_TCSR_PWM_SD		(1 << 9)
+#define TCU_TCSR_PWM_INITL_HIGH	(1 << 8)
+#define TCU_TCSR_PWM_EN		(1 << 7)
+#define TCU_TCSR_PRESCALE_BIT	3
+#define TCU_TCSR_PRESCALE_MASK	(0x7 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1	(0x0 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE4	(0x1 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE16	(0x2 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE64	(0x3 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE256	(0x4 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1024	(0x5 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_EXT_EN		(1 << 2)
+#define TCU_TCSR_RTC_EN		(1 << 1)
+#define TCU_TCSR_PCK_EN		(1 << 0)
+
+#define TCU_TER_TCEN5		(1 << 5)
+#define TCU_TER_TCEN4		(1 << 4)
+#define TCU_TER_TCEN3		(1 << 3)
+#define TCU_TER_TCEN2		(1 << 2)
+#define TCU_TER_TCEN1		(1 << 1)
+#define TCU_TER_TCEN0		(1 << 0)
+
+#define TCU_TESR_TCST5		(1 << 5)
+#define TCU_TESR_TCST4		(1 << 4)
+#define TCU_TESR_TCST3		(1 << 3)
+#define TCU_TESR_TCST2		(1 << 2)
+#define TCU_TESR_TCST1		(1 << 1)
+#define TCU_TESR_TCST0		(1 << 0)
+
+#define TCU_TECR_TCCL5		(1 << 5)
+#define TCU_TECR_TCCL4		(1 << 4)
+#define TCU_TECR_TCCL3		(1 << 3)
+#define TCU_TECR_TCCL2		(1 << 2)
+#define TCU_TECR_TCCL1		(1 << 1)
+#define TCU_TECR_TCCL0		(1 << 0)
+
+#define TCU_TFR_HFLAG5		(1 << 21)
+#define TCU_TFR_HFLAG4		(1 << 20)
+#define TCU_TFR_HFLAG3		(1 << 19)
+#define TCU_TFR_HFLAG2		(1 << 18)
+#define TCU_TFR_HFLAG1		(1 << 17)
+#define TCU_TFR_HFLAG0		(1 << 16)
+#define TCU_TFR_FFLAG5		(1 << 5)
+#define TCU_TFR_FFLAG4		(1 << 4)
+#define TCU_TFR_FFLAG3		(1 << 3)
+#define TCU_TFR_FFLAG2		(1 << 2)
+#define TCU_TFR_FFLAG1		(1 << 1)
+#define TCU_TFR_FFLAG0		(1 << 0)
+
+#define TCU_TFSR_HFLAG5		(1 << 21)
+#define TCU_TFSR_HFLAG4		(1 << 20)
+#define TCU_TFSR_HFLAG3		(1 << 19)
+#define TCU_TFSR_HFLAG2		(1 << 18)
+#define TCU_TFSR_HFLAG1		(1 << 17)
+#define TCU_TFSR_HFLAG0		(1 << 16)
+#define TCU_TFSR_FFLAG5		(1 << 5)
+#define TCU_TFSR_FFLAG4		(1 << 4)
+#define TCU_TFSR_FFLAG3		(1 << 3)
+#define TCU_TFSR_FFLAG2		(1 << 2)
+#define TCU_TFSR_FFLAG1		(1 << 1)
+#define TCU_TFSR_FFLAG0		(1 << 0)
+
+#define TCU_TFCR_HFLAG5		(1 << 21)
+#define TCU_TFCR_HFLAG4		(1 << 20)
+#define TCU_TFCR_HFLAG3		(1 << 19)
+#define TCU_TFCR_HFLAG2		(1 << 18)
+#define TCU_TFCR_HFLAG1		(1 << 17)
+#define TCU_TFCR_HFLAG0		(1 << 16)
+#define TCU_TFCR_FFLAG5		(1 << 5)
+#define TCU_TFCR_FFLAG4		(1 << 4)
+#define TCU_TFCR_FFLAG3		(1 << 3)
+#define TCU_TFCR_FFLAG2		(1 << 2)
+#define TCU_TFCR_FFLAG1		(1 << 1)
+#define TCU_TFCR_FFLAG0		(1 << 0)
+
+#define TCU_TMR_HMASK5		(1 << 21)
+#define TCU_TMR_HMASK4		(1 << 20)
+#define TCU_TMR_HMASK3		(1 << 19)
+#define TCU_TMR_HMASK2		(1 << 18)
+#define TCU_TMR_HMASK1		(1 << 17)
+#define TCU_TMR_HMASK0		(1 << 16)
+#define TCU_TMR_FMASK5		(1 << 5)
+#define TCU_TMR_FMASK4		(1 << 4)
+#define TCU_TMR_FMASK3		(1 << 3)
+#define TCU_TMR_FMASK2		(1 << 2)
+#define TCU_TMR_FMASK1		(1 << 1)
+#define TCU_TMR_FMASK0		(1 << 0)
+
+#define TCU_TMSR_HMST5		(1 << 21)
+#define TCU_TMSR_HMST4		(1 << 20)
+#define TCU_TMSR_HMST3		(1 << 19)
+#define TCU_TMSR_HMST2		(1 << 18)
+#define TCU_TMSR_HMST1		(1 << 17)
+#define TCU_TMSR_HMST0		(1 << 16)
+#define TCU_TMSR_FMST5		(1 << 5)
+#define TCU_TMSR_FMST4		(1 << 4)
+#define TCU_TMSR_FMST3		(1 << 3)
+#define TCU_TMSR_FMST2		(1 << 2)
+#define TCU_TMSR_FMST1		(1 << 1)
+#define TCU_TMSR_FMST0		(1 << 0)
+
+#define TCU_TMCR_HMCL5		(1 << 21)
+#define TCU_TMCR_HMCL4		(1 << 20)
+#define TCU_TMCR_HMCL3		(1 << 19)
+#define TCU_TMCR_HMCL2		(1 << 18)
+#define TCU_TMCR_HMCL1		(1 << 17)
+#define TCU_TMCR_HMCL0		(1 << 16)
+#define TCU_TMCR_FMCL5		(1 << 5)
+#define TCU_TMCR_FMCL4		(1 << 4)
+#define TCU_TMCR_FMCL3		(1 << 3)
+#define TCU_TMCR_FMCL2		(1 << 2)
+#define TCU_TMCR_FMCL1		(1 << 1)
+#define TCU_TMCR_FMCL0		(1 << 0)
+
+#define TCU_TSR_WDTS		(1 << 16)
+#define TCU_TSR_STOP5		(1 << 5)
+#define TCU_TSR_STOP4		(1 << 4)
+#define TCU_TSR_STOP3		(1 << 3)
+#define TCU_TSR_STOP2		(1 << 2)
+#define TCU_TSR_STOP1		(1 << 1)
+#define TCU_TSR_STOP0		(1 << 0)
+
+#define TCU_TSSR_WDTSS		(1 << 16)
+#define TCU_TSSR_STPS5		(1 << 5)
+#define TCU_TSSR_STPS4		(1 << 4)
+#define TCU_TSSR_STPS3		(1 << 3)
+#define TCU_TSSR_STPS2		(1 << 2)
+#define TCU_TSSR_STPS1		(1 << 1)
+#define TCU_TSSR_STPS0		(1 << 0)
+
+#define TCU_TSSR_WDTSC		(1 << 16)
+#define TCU_TSSR_STPC5		(1 << 5)
+#define TCU_TSSR_STPC4		(1 << 4)
+#define TCU_TSSR_STPC3		(1 << 3)
+#define TCU_TSSR_STPC2		(1 << 2)
+#define TCU_TSSR_STPC1		(1 << 1)
+#define TCU_TSSR_STPC0		(1 << 0)
+
+
+/*************************************************************************
+ * WDT (WatchDog Timer)
+ *************************************************************************/
+#define WDT_TDR		(WDT_BASE + 0x00)
+#define WDT_TCER	(WDT_BASE + 0x04)
+#define WDT_TCNT	(WDT_BASE + 0x08)
+#define WDT_TCSR	(WDT_BASE + 0x0C)
+
+#define REG_WDT_TDR	REG16(WDT_TDR)
+#define REG_WDT_TCER	REG8(WDT_TCER)
+#define REG_WDT_TCNT	REG16(WDT_TCNT)
+#define REG_WDT_TCSR	REG16(WDT_TCSR)
+
+// Register definition
+#define WDT_TCSR_PRESCALE_BIT	3
+#define WDT_TCSR_PRESCALE_MASK	(0x7 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1	(0x0 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE4	(0x1 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE16	(0x2 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE64	(0x3 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE256	(0x4 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1024	(0x5 << WDT_TCSR_PRESCALE_BIT)
+#define WDT_TCSR_EXT_EN		(1 << 2)
+#define WDT_TCSR_RTC_EN		(1 << 1)
+#define WDT_TCSR_PCK_EN		(1 << 0)
+
+#define WDT_TCER_TCEN		(1 << 0)
+
+
+/*************************************************************************
+ * DMAC (DMA Controller)
+ *************************************************************************/
+
+#define MAX_DMA_NUM	12  /* max 12 channels */
+#define HALF_DMA_NUM	6   /* the number of one dma controller's channels */
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define DMAC_DSAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x00 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA source address */
+#define DMAC_DTAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x04 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA target address */
+#define DMAC_DTCR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x08 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA transfer count */
+#define DMAC_DRSR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x0c + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA request source */
+#define DMAC_DCCSR(n) (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x10 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA control/status */
+#define DMAC_DCMD(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x14 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA command */
+#define DMAC_DDA(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x18 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA descriptor address */
+#define DMAC_DSD(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0xc0 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x04)) /* DMA Stride Address */
+
+#define DMAC_DMACR(m)	(DMAC_BASE + 0x0300 + 0x100 * m)              /* DMA control register */
+#define DMAC_DMAIPR(m)	(DMAC_BASE + 0x0304 + 0x100 * m)              /* DMA interrupt pending */
+#define DMAC_DMADBR(m)	(DMAC_BASE + 0x0308 + 0x100 * m)              /* DMA doorbell */
+#define DMAC_DMADBSR(m)	(DMAC_BASE + 0x030C + 0x100 * m)              /* DMA doorbell set */
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DTAR(n)	REG32(DMAC_DTAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DCMD(n)	REG32(DMAC_DCMD((n)))
+#define REG_DMAC_DDA(n)		REG32(DMAC_DDA((n)))
+#define REG_DMAC_DSD(n)         REG32(DMAC_DSD(n))
+#define REG_DMAC_DMACR(m)	REG32(DMAC_DMACR(m))
+#define REG_DMAC_DMAIPR(m)	REG32(DMAC_DMAIPR(m))
+#define REG_DMAC_DMADBR(m)	REG32(DMAC_DMADBR(m))
+#define REG_DMAC_DMADBSR(m)	REG32(DMAC_DMADBSR(m))
+
+// DMA request source register
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x1f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_EXT	(0 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_NAND	(1 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_ENC	(2 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_DEC	(3 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO	(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TSSIIN	(9 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3OUT	(14 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3IN	(15 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2OUT	(16 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2IN	(17 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1OUT	(18 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1IN	(19 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT	(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN	(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0OUT	(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0IN	(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT	(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN	(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0OUT	(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0IN	(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TCU	(28 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SADC	(29 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1OUT	(30 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1IN	(31 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1OUT	(32 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1IN	(33 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMOUT	(34 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMIN	(35 << DMAC_DRSR_RS_BIT)
+
+// DMA channel control/status register
+#define DMAC_DCCSR_NDES		(1 << 31) /* descriptor (0) or not (1) ? */
+#define DMAC_DCCSR_DES8    	(1 << 30) /* Descriptor 8 Word */
+#define DMAC_DCCSR_DES4    	(0 << 30) /* Descriptor 4 Word */
+#define DMAC_DCCSR_CDOA_BIT	16        /* copy of DMA offset address */
+#define DMAC_DCCSR_CDOA_MASK	(0xff << DMAC_DCCSR_CDOA_BIT)
+#define DMAC_DCCSR_BERR		(1 << 7)  /* BCH error within this transfer, Only for channel 0 */
+#define DMAC_DCCSR_INV		(1 << 6)  /* descriptor invalid */
+#define DMAC_DCCSR_AR		(1 << 4)  /* address error */
+#define DMAC_DCCSR_TT		(1 << 3)  /* transfer terminated */
+#define DMAC_DCCSR_HLT		(1 << 2)  /* DMA halted */
+#define DMAC_DCCSR_CT		(1 << 1)  /* count terminated */
+#define DMAC_DCCSR_EN		(1 << 0)  /* channel enable bit */
+
+// DMA channel command register 
+#define DMAC_DCMD_EACKS_LOW  	(1 << 31) /* External DACK Output Level Select, active low */
+#define DMAC_DCMD_EACKS_HIGH  	(0 << 31) /* External DACK Output Level Select, active high */
+#define DMAC_DCMD_EACKM_WRITE 	(1 << 30) /* External DACK Output Mode Select, output in write cycle */
+#define DMAC_DCMD_EACKM_READ 	(0 << 30) /* External DACK Output Mode Select, output in read cycle */
+#define DMAC_DCMD_ERDM_BIT      28        /* External DREQ Detection Mode Select */
+#define DMAC_DCMD_ERDM_MASK     (0x03 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_LOW    (0 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_FALL   (1 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_HIGH   (2 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_RISE   (3 << DMAC_DCMD_ERDM_BIT)
+#define DMAC_DCMD_BLAST		(1 << 25) /* BCH last */
+#define DMAC_DCMD_SAI		(1 << 23) /* source address increment */
+#define DMAC_DCMD_DAI		(1 << 22) /* dest address increment */
+#define DMAC_DCMD_RDIL_BIT	16        /* request detection interval length */
+#define DMAC_DCMD_RDIL_MASK	(0x0f << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_IGN	(0 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_2	(1 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_4	(2 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_8	(3 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_12	(4 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_16	(5 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_20	(6 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_24	(7 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_28	(8 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_32	(9 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_48	(10 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_60	(11 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_64	(12 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_124	(13 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_128	(14 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_200	(15 << DMAC_DCMD_RDIL_BIT)
+#define DMAC_DCMD_SWDH_BIT	14  /* source port width */
+#define DMAC_DCMD_SWDH_MASK	(0x03 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_32	(0 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_8	(1 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_16	(2 << DMAC_DCMD_SWDH_BIT)
+#define DMAC_DCMD_DWDH_BIT	12  /* dest port width */
+#define DMAC_DCMD_DWDH_MASK	(0x03 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_32	(0 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_8	(1 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_16	(2 << DMAC_DCMD_DWDH_BIT)
+#define DMAC_DCMD_DS_BIT	8  /* transfer data size of a data unit */
+#define DMAC_DCMD_DS_MASK	(0x07 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BIT	(0 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_8BIT	(1 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BIT	(2 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BYTE	(3 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BYTE	(4 << DMAC_DCMD_DS_BIT)
+#define DMAC_DCMD_STDE   	(1 << 5) /* Stride Disable/Enable */
+#define DMAC_DCMD_DES_V		(1 << 4)  /* descriptor valid flag */
+#define DMAC_DCMD_DES_VM	(1 << 3)  /* descriptor valid mask: 1:support V-bit */
+#define DMAC_DCMD_DES_VIE	(1 << 2)  /* DMA valid error interrupt enable */
+#define DMAC_DCMD_TIE		(1 << 1)  /* DMA transfer interrupt enable */
+#define DMAC_DCMD_LINK		(1 << 0)  /* descriptor link enable */
+
+// DMA descriptor address register
+#define DMAC_DDA_BASE_BIT	12  /* descriptor base address */
+#define DMAC_DDA_BASE_MASK	(0x0fffff << DMAC_DDA_BASE_BIT)
+#define DMAC_DDA_OFFSET_BIT	4   /* descriptor offset address */
+#define DMAC_DDA_OFFSET_MASK	(0x0ff << DMAC_DDA_OFFSET_BIT)
+
+// DMA stride address register
+#define DMAC_DSD_TSD_BIT        16  /* target stride address */
+#define DMAC_DSD_TSD_MASK      	(0xffff << DMAC_DSD_TSD_BIT)
+#define DMAC_DSD_SSD_BIT        0  /* source stride address */
+#define DMAC_DSD_SSD_MASK      	(0xffff << DMAC_DSD_SSD_BIT)
+
+// DMA control register
+#define DMAC_DMACR_FMSC		(1 << 31)  /* MSC Fast DMA mode */
+#define DMAC_DMACR_FSSI		(1 << 30)  /* SSI Fast DMA mode */
+#define DMAC_DMACR_FTSSI	(1 << 29)  /* TSSI Fast DMA mode */
+#define DMAC_DMACR_FUART	(1 << 28)  /* UART Fast DMA mode */
+#define DMAC_DMACR_FAIC		(1 << 27)  /* AIC Fast DMA mode */
+#define DMAC_DMACR_PR_BIT	8  /* channel priority mode */
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_012345	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_120345	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_230145	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_340125	(3 << DMAC_DMACR_PR_BIT)
+#define DMAC_DMACR_HLT		(1 << 3)  /* DMA halt flag */
+#define DMAC_DMACR_AR		(1 << 2)  /* address error flag */
+#define DMAC_DMACR_DMAE		(1 << 0)  /* DMA enable bit */
+
+// DMA doorbell register
+#define DMAC_DMADBR_DB5		(1 << 5)  /* doorbell for channel 5 */
+#define DMAC_DMADBR_DB4		(1 << 4)  /* doorbell for channel 4 */
+#define DMAC_DMADBR_DB3		(1 << 3)  /* doorbell for channel 3 */
+#define DMAC_DMADBR_DB2		(1 << 2)  /* doorbell for channel 2 */
+#define DMAC_DMADBR_DB1		(1 << 1)  /* doorbell for channel 1 */
+#define DMAC_DMADBR_DB0		(1 << 0)  /* doorbell for channel 0 */
+
+// DMA doorbell set register
+#define DMAC_DMADBSR_DBS5	(1 << 5)  /* enable doorbell for channel 5 */
+#define DMAC_DMADBSR_DBS4	(1 << 4)  /* enable doorbell for channel 4 */
+#define DMAC_DMADBSR_DBS3	(1 << 3)  /* enable doorbell for channel 3 */
+#define DMAC_DMADBSR_DBS2	(1 << 2)  /* enable doorbell for channel 2 */
+#define DMAC_DMADBSR_DBS1	(1 << 1)  /* enable doorbell for channel 1 */
+#define DMAC_DMADBSR_DBS0	(1 << 0)  /* enable doorbell for channel 0 */
+
+// DMA interrupt pending register
+#define DMAC_DMAIPR_CIRQ5	(1 << 5)  /* irq pending status for channel 5 */
+#define DMAC_DMAIPR_CIRQ4	(1 << 4)  /* irq pending status for channel 4 */
+#define DMAC_DMAIPR_CIRQ3	(1 << 3)  /* irq pending status for channel 3 */
+#define DMAC_DMAIPR_CIRQ2	(1 << 2)  /* irq pending status for channel 2 */
+#define DMAC_DMAIPR_CIRQ1	(1 << 1)  /* irq pending status for channel 1 */
+#define DMAC_DMAIPR_CIRQ0	(1 << 0)  /* irq pending status for channel 0 */
+
+
+/*************************************************************************
+ * GPIO (General-Purpose I/O Ports)
+ *************************************************************************/
+#define MAX_GPIO_NUM	192
+
+//n = 0,1,2,3,4,5
+#define GPIO_PXPIN(n)	(GPIO_BASE + (0x00 + (n)*0x100)) /* PIN Level Register */
+#define GPIO_PXDAT(n)	(GPIO_BASE + (0x10 + (n)*0x100)) /* Port Data Register */
+#define GPIO_PXDATS(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Data Set Register */
+#define GPIO_PXDATC(n)	(GPIO_BASE + (0x18 + (n)*0x100)) /* Port Data Clear Register */
+#define GPIO_PXIM(n)	(GPIO_BASE + (0x20 + (n)*0x100)) /* Interrupt Mask Register */
+#define GPIO_PXIMS(n)	(GPIO_BASE + (0x24 + (n)*0x100)) /* Interrupt Mask Set Reg */
+#define GPIO_PXIMC(n)	(GPIO_BASE + (0x28 + (n)*0x100)) /* Interrupt Mask Clear Reg */
+#define GPIO_PXPE(n)	(GPIO_BASE + (0x30 + (n)*0x100)) /* Pull Disable Register */
+#define GPIO_PXPES(n)	(GPIO_BASE + (0x34 + (n)*0x100)) /* Pull Disable Set Reg. */
+#define GPIO_PXPEC(n)	(GPIO_BASE + (0x38 + (n)*0x100)) /* Pull Disable Clear Reg. */
+#define GPIO_PXFUN(n)	(GPIO_BASE + (0x40 + (n)*0x100)) /* Function Register */
+#define GPIO_PXFUNS(n)	(GPIO_BASE + (0x44 + (n)*0x100)) /* Function Set Register */
+#define GPIO_PXFUNC(n)	(GPIO_BASE + (0x48 + (n)*0x100)) /* Function Clear Register */
+#define GPIO_PXSEL(n)	(GPIO_BASE + (0x50 + (n)*0x100)) /* Select Register */
+#define GPIO_PXSELS(n)	(GPIO_BASE + (0x54 + (n)*0x100)) /* Select Set Register */
+#define GPIO_PXSELC(n)	(GPIO_BASE + (0x58 + (n)*0x100)) /* Select Clear Register */
+#define GPIO_PXDIR(n)	(GPIO_BASE + (0x60 + (n)*0x100)) /* Direction Register */
+#define GPIO_PXDIRS(n)	(GPIO_BASE + (0x64 + (n)*0x100)) /* Direction Set Register */
+#define GPIO_PXDIRC(n)	(GPIO_BASE + (0x68 + (n)*0x100)) /* Direction Clear Register */
+#define GPIO_PXTRG(n)	(GPIO_BASE + (0x70 + (n)*0x100)) /* Trigger Register */
+#define GPIO_PXTRGS(n)	(GPIO_BASE + (0x74 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXTRGC(n)	(GPIO_BASE + (0x78 + (n)*0x100)) /* Trigger Clear Register */
+#define GPIO_PXFLG(n)	(GPIO_BASE + (0x80 + (n)*0x100)) /* Port Flag Register */
+#define GPIO_PXFLGC(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Flag clear Register */
+
+#define REG_GPIO_PXPIN(n)	REG32(GPIO_PXPIN((n)))  /* PIN level */
+#define REG_GPIO_PXDAT(n)	REG32(GPIO_PXDAT((n)))  /* 1: interrupt pending */
+#define REG_GPIO_PXDATS(n)	REG32(GPIO_PXDATS((n)))
+#define REG_GPIO_PXDATC(n)	REG32(GPIO_PXDATC((n)))
+#define REG_GPIO_PXIM(n)	REG32(GPIO_PXIM((n)))   /* 1: mask pin interrupt */
+#define REG_GPIO_PXIMS(n)	REG32(GPIO_PXIMS((n)))
+#define REG_GPIO_PXIMC(n)	REG32(GPIO_PXIMC((n)))
+#define REG_GPIO_PXPE(n)	REG32(GPIO_PXPE((n)))   /* 1: disable pull up/down */
+#define REG_GPIO_PXPES(n)	REG32(GPIO_PXPES((n)))
+#define REG_GPIO_PXPEC(n)	REG32(GPIO_PXPEC((n)))
+#define REG_GPIO_PXFUN(n)	REG32(GPIO_PXFUN((n)))  /* 0:GPIO/INTR, 1:FUNC */
+#define REG_GPIO_PXFUNS(n)	REG32(GPIO_PXFUNS((n)))
+#define REG_GPIO_PXFUNC(n)	REG32(GPIO_PXFUNC((n)))
+#define REG_GPIO_PXSEL(n)	REG32(GPIO_PXSEL((n))) /* 0:GPIO/Fun0,1:intr/fun1*/
+#define REG_GPIO_PXSELS(n)	REG32(GPIO_PXSELS((n)))
+#define REG_GPIO_PXSELC(n)	REG32(GPIO_PXSELC((n)))
+#define REG_GPIO_PXDIR(n)	REG32(GPIO_PXDIR((n))) /* 0:input/low-level-trig/falling-edge-trig, 1:output/high-level-trig/rising-edge-trig */
+#define REG_GPIO_PXDIRS(n)	REG32(GPIO_PXDIRS((n)))
+#define REG_GPIO_PXDIRC(n)	REG32(GPIO_PXDIRC((n)))
+#define REG_GPIO_PXTRG(n)	REG32(GPIO_PXTRG((n))) /* 0:Level-trigger/Fun0, 1:Edge-trigger/Fun1 */
+#define REG_GPIO_PXTRGS(n)	REG32(GPIO_PXTRGS((n)))
+#define REG_GPIO_PXTRGC(n)	REG32(GPIO_PXTRGC((n)))
+#define REG_GPIO_PXFLG(n)	REG32(GPIO_PXFLG((n))) /* interrupt flag */
+#define REG_GPIO_PXFLGC(n)	REG32(GPIO_PXFLGC((n))) /* interrupt flag */
+
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* Register Offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+#define OFF_UMR		(0x24)	/* RW 8b H'00, UART M Register */
+#define OFF_UACR	(0x28)	/* RW 8b H'00, UART Add Cycle Register */
+
+/* Register Address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+#define UART0_UMR	(UART0_BASE + OFF_UMR)
+#define UART0_UACR	(UART0_BASE + OFF_UACR)
+
+/*
+ * Define macros for UART_IER
+ * UART Interrupt Enable Register
+ */
+#define UART_IER_RIE	(1 << 0)	/* 0: receive fifo "full" interrupt disable */
+#define UART_IER_TIE	(1 << 1)	/* 0: transmit fifo "empty" interrupt disable */
+#define UART_IER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UART_IER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UART_IER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UART_ISR
+ * UART Interrupt Status Register
+ */
+#define UART_ISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UART_ISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UART_ISR_IID_MSI		(0 << 1)	/* Modem status interrupt */
+#define UART_ISR_IID_THRI	(1 << 1)	/* Transmitter holding register empty */
+#define UART_ISR_IID_RDI		(2 << 1)	/* Receiver data interrupt */
+#define UART_ISR_IID_RLSI	(3 << 1)	/* Receiver line status interrupt */
+#define UART_ISR_FFMS	(3 << 6)	/* FIFO mode select, set when UART_FCR.FE is set to 1 */
+#define UART_ISR_FFMS_NO_FIFO	(0 << 6)
+#define UART_ISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UART_FCR
+ * UART FIFO Control Register
+ */
+#define UART_FCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UART_FCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UART_FCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UART_FCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UART_FCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UART_FCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UART_FCR_RTRG_1	(0 << 6)
+#define UART_FCR_RTRG_4	(1 << 6)
+#define UART_FCR_RTRG_8	(2 << 6)
+#define UART_FCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UART_LCR
+ * UART Line Control Register
+ */
+#define UART_LCR_WLEN	(3 << 0)	/* word length */
+#define UART_LCR_WLEN_5	(0 << 0)
+#define UART_LCR_WLEN_6	(1 << 0)
+#define UART_LCR_WLEN_7	(2 << 0)
+#define UART_LCR_WLEN_8	(3 << 0)
+#define UART_LCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_1	(0 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_2	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+
+#define UART_LCR_PE	(1 << 3)	/* 0: parity disable */
+#define UART_LCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UART_LCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UART_LCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UART_LCR_DLAB	(1 << 7)	/* 0: access UART_RDR/TDR/IER  1: access UART_DLLR/DLHR */
+
+/*
+ * Define macros for UART_LSR
+ * UART Line Status Register
+ */
+#define UART_LSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UART_LSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UART_LSR_PER	(1 << 2)	/* 0: no parity error */
+#define UART_LSR_FER	(1 << 3)	/* 0; no framing error */
+#define UART_LSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UART_LSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UART_LSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UART_LSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UART_MCR
+ * UART Modem Control Register
+ */
+#define UART_MCR_DTR	(1 << 0)	/* 0: DTR_ ouput high */
+#define UART_MCR_RTS	(1 << 1)	/* 0: RTS_ output high */
+#define UART_MCR_OUT1	(1 << 2)	/* 0: UART_MSR.RI is set to 0 and RI_ input high */
+#define UART_MCR_OUT2	(1 << 3)	/* 0: UART_MSR.DCD is set to 0 and DCD_ input high */
+#define UART_MCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UART_MCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UART_MSR
+ * UART Modem Status Register
+ */
+#define UART_MSR_DCTS	(1 << 0)	/* 0: no change on CTS_ pin since last read of UART_MSR */
+#define UART_MSR_DDSR	(1 << 1)	/* 0: no change on DSR_ pin since last read of UART_MSR */
+#define UART_MSR_DRI	(1 << 2)	/* 0: no change on RI_ pin since last read of UART_MSR */
+#define UART_MSR_DDCD	(1 << 3)	/* 0: no change on DCD_ pin since last read of UART_MSR */
+#define UART_MSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+#define UART_MSR_DSR	(1 << 5)	/* 0: DSR_ pin is high */
+#define UART_MSR_RI	(1 << 6)	/* 0: RI_ pin is high */
+#define UART_MSR_DCD	(1 << 7)	/* 0: DCD_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)	/* 0: transmitter is in UART mode  1: IrDA mode */
+#define SIRCR_RSIRE	(1 << 1)	/* 0: receiver is in UART mode  1: IrDA mode */
+#define SIRCR_TPWS	(1 << 2)	/* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TXPL	(1 << 3)	/* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RXPL	(1 << 4)	/* 0: decoder interprets positive pulse as 0 */
+
+
+/*************************************************************************
+ * AIC (AC97/I2S Controller)
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12        /* Receive FIFO Threshold */
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8         /* Transmit FIFO Threshold */
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_ICDC		(1 << 5)  /* External(0) or Internal CODEC(1) */
+#define	AIC_FR_AUSEL		(1 << 4)  /* AC97(0) or I2S/MSB-justified(1) */
+#define	AIC_FR_RST		(1 << 3)  /* AIC registers reset */
+#define	AIC_FR_BCKD		(1 << 2)  /* I2S BIT_CLK direction, 0:input,1:output */
+#define	AIC_FR_SYNCD		(1 << 1)  /* I2S SYNC direction, 0:input,1:output */
+#define	AIC_FR_ENB		(1 << 0)  /* AIC enable bit */
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_OSS_BIT		19  /* Output Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_OSS_MASK		(0x7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0x0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(0x1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(0x2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(0x3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(0x4 << AIC_CR_OSS_BIT)
+#define	AIC_CR_ISS_BIT		16  /* Input Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_ISS_MASK		(0x7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0x0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(0x1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(0x2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(0x3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(0x4 << AIC_CR_ISS_BIT)
+#define	AIC_CR_RDMS		(1 << 15)  /* Receive DMA enable */
+#define	AIC_CR_TDMS		(1 << 14)  /* Transmit DMA enable */
+#define	AIC_CR_M2S		(1 << 11)  /* Mono to Stereo enable */
+#define	AIC_CR_ENDSW		(1 << 10)  /* Endian switch enable */
+#define	AIC_CR_AVSTSU		(1 << 9)   /* Signed <-> Unsigned toggle enable */
+#define	AIC_CR_FLUSH		(1 << 8)   /* Flush FIFO */
+#define	AIC_CR_EROR		(1 << 6)   /* Enable ROR interrupt */
+#define	AIC_CR_ETUR		(1 << 5)   /* Enable TUR interrupt */
+#define	AIC_CR_ERFS		(1 << 4)   /* Enable RFS interrupt */
+#define	AIC_CR_ETFS		(1 << 3)   /* Enable TFS interrupt */
+#define	AIC_CR_ENLBF		(1 << 2)   /* Enable Loopback Function */
+#define	AIC_CR_ERPL		(1 << 1)   /* Enable Playback Function */
+#define	AIC_CR_EREC		(1 << 0)   /* Enable Record Function */
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16          /* Receive Valid Slots */
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit, PCM Left */
+#define	AIC_ACCR1_XS_BIT	0          /* Transmit Valid Slots */
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit, PCM Left */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18) /* Enable RSTO interrupt */
+#define	AIC_ACCR2_ESADR		(1 << 17) /* Enable SADR interrupt */
+#define	AIC_ACCR2_ECADT		(1 << 16) /* Enable CADT interrupt */
+#define	AIC_ACCR2_OASS_BIT	8  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)  /* SDATA_OUT output value */
+#define	AIC_ACCR2_SR		(1 << 2)  /* RESET# pin level */
+#define	AIC_ACCR2_SS		(1 << 1)  /* SYNC pin level */
+#define	AIC_ACCR2_SA		(1 << 0)  /* SYNC and SDATA_OUT alternation */
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12) /* Stop BIT_CLK for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_BIT	1  /* Input/Output Sample Size for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0) /* 0:I2S, 1:MSB-justified */
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24  /* Receive FIFO Level */
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8   /* Transmit FIFO level */
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6) /* Receive FIFO Overrun */
+#define	AIC_SR_TUR		(1 << 5) /* Transmit FIFO Underrun */
+#define	AIC_SR_RFS		(1 << 4) /* Receive FIFO Service Request */
+#define	AIC_SR_TFS		(1 << 3) /* Transmit FIFO Service Request */
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_SLTERR		(1 << 21) /* Slot Error Flag */
+#define	AIC_ACSR_CRDY		(1 << 20) /* External CODEC Ready Flag */
+#define	AIC_ACSR_CLPM		(1 << 19) /* External CODEC low power mode flag */
+#define	AIC_ACSR_RSTO		(1 << 18) /* External CODEC regs read status timeout */
+#define	AIC_ACSR_SADR		(1 << 17) /* External CODEC regs status addr and data received */
+#define	AIC_ACSR_CADT		(1 << 16) /* Command Address and Data Transmitted */
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)  /* AIC Busy in I2S/MSB-justified format */
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+/*************************************************************************
+ * ICDC (Internal CODEC)
+ *************************************************************************/
+#define	ICDC_CR			(ICDC_BASE + 0x0400)  /* ICDC Control Register */
+#define	ICDC_APWAIT		(ICDC_BASE + 0x0404)  /* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APPRE		(ICDC_BASE + 0x0408)  /* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APHPEN		(ICDC_BASE + 0x040C)  /* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APSR		(ICDC_BASE + 0x0410)  /* Anti-Pop Status Register */
+#define ICDC_CDCCR1             (ICDC_BASE + 0x0080)
+#define ICDC_CDCCR2             (ICDC_BASE + 0x0084)
+
+#define	REG_ICDC_CR		REG32(ICDC_CR)
+#define	REG_ICDC_APWAIT		REG32(ICDC_APWAIT)
+#define	REG_ICDC_APPRE		REG32(ICDC_APPRE)
+#define	REG_ICDC_APHPEN		REG32(ICDC_APHPEN)
+#define	REG_ICDC_APSR		REG32(ICDC_APSR)
+#define REG_ICDC_CDCCR1         REG32(ICDC_CDCCR1)
+#define REG_ICDC_CDCCR2         REG32(ICDC_CDCCR2)
+
+/* ICDC Control Register */
+#define	ICDC_CR_LINVOL_BIT	24 /* LINE Input Volume Gain: GAIN=LINVOL*1.5-34.5 */
+#define	ICDC_CR_LINVOL_MASK	(0x1f << ICDC_CR_LINVOL_BIT)
+#define	ICDC_CR_ASRATE_BIT	20 /* Audio Sample Rate */
+#define	ICDC_CR_ASRATE_MASK	(0x0f << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_8000	(0x0 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_11025	(0x1 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_12000	(0x2 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_16000	(0x3 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_22050	(0x4 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_24000	(0x5 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_32000	(0x6 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_44100	(0x7 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_48000	(0x8 << ICDC_CR_ASRATE_BIT)
+#define	ICDC_CR_MICBG_BIT	18 /* MIC Boost Gain */
+#define	ICDC_CR_MICBG_MASK	(0x3 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_0DB	(0x0 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_6DB	(0x1 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_12DB	(0x2 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_20DB	(0x3 << ICDC_CR_MICBG_BIT)
+#define	ICDC_CR_HPVOL_BIT	16 /* Headphone Volume Gain */
+#define	ICDC_CR_HPVOL_MASK	(0x3 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_0DB	(0x0 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_2DB	(0x1 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_4DB	(0x2 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_6DB	(0x3 << ICDC_CR_HPVOL_BIT)
+#define ICDC_CR_ELINEIN		(1 << 13) /* Enable LINE Input */
+#define ICDC_CR_EMIC		(1 << 12) /* Enable MIC Input */
+#define ICDC_CR_SW1ON		(1 << 11) /* Switch 1 in CODEC is on */
+#define ICDC_CR_EADC		(1 << 10) /* Enable ADC */
+#define ICDC_CR_SW2ON		(1 << 9)  /* Switch 2 in CODEC is on */
+#define ICDC_CR_EDAC		(1 << 8)  /* Enable DAC */
+#define ICDC_CR_HPMUTE		(1 << 5)  /* Headphone Mute */
+#define ICDC_CR_HPTON		(1 << 4)  /* Headphone Amplifier Trun On */
+#define ICDC_CR_HPTOFF		(1 << 3)  /* Headphone Amplifier Trun Off */
+#define ICDC_CR_TAAP		(1 << 2)  /* Turn Around of the Anti-Pop Procedure */
+#define ICDC_CR_EAP		(1 << 1)  /* Enable Anti-Pop Procedure */
+#define ICDC_CR_SUSPD		(1 << 0)  /* CODEC Suspend */
+
+/* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APWAIT_WAITSN_BIT	0
+#define	ICDC_APWAIT_WAITSN_MASK	(0x7ff << ICDC_APWAIT_WAITSN_BIT)
+
+/* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APPRE_PRESN_BIT	0
+#define	ICDC_APPRE_PRESN_MASK	(0x1ff << ICDC_APPRE_PRESN_BIT)
+
+/* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APHPEN_HPENSN_BIT	0
+#define	ICDC_APHPEN_HPENSN_MASK	(0x3fff << ICDC_APHPEN_HPENSN_BIT)
+
+/* Anti-Pop Status Register */
+#define	ICDC_SR_HPST_BIT	14  /* Headphone Amplifier State */
+#define	ICDC_SR_HPST_MASK	(0x7 << ICDC_SR_HPST_BIT)
+#define ICDC_SR_HPST_HP_OFF	 (0x0 << ICDC_SR_HPST_BIT) /* HP amplifier is off */
+#define ICDC_SR_HPST_TON_WAIT	 (0x1 << ICDC_SR_HPST_BIT) /* wait state in turn-on */
+  #define ICDC_SR_HPST_TON_PRE	 (0x2 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-on */
+#define ICDC_SR_HPST_TON_HPEN	 (0x3 << ICDC_SR_HPST_BIT) /* HP enable state in turn-on */
+  #define ICDC_SR_HPST_TOFF_HPEN (0x4 << ICDC_SR_HPST_BIT) /* HP enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_PRE  (0x5 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_WAIT (0x6 << ICDC_SR_HPST_BIT) /* wait state in turn-off */
+  #define ICDC_SR_HPST_HP_ON	 (0x7 << ICDC_SR_HPST_BIT) /* HP amplifier is on */
+#define	ICDC_SR_SNCNT_BIT	0  /* Sample Number Counter */
+#define	ICDC_SR_SNCNT_MASK	(0x3fff << ICDC_SR_SNCNT_BIT)
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+/*************************************************************************
+ * SSI (Synchronous Serial Interface)
+ *************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define	SSI_DR(n)		(SSI_BASE + 0x000 + (n)*0x2000)
+#define	SSI_CR0(n)		(SSI_BASE + 0x004 + (n)*0x2000)
+#define	SSI_CR1(n)		(SSI_BASE + 0x008 + (n)*0x2000)
+#define	SSI_SR(n)		(SSI_BASE + 0x00C + (n)*0x2000)
+#define	SSI_ITR(n)		(SSI_BASE + 0x010 + (n)*0x2000)
+#define	SSI_ICR(n)		(SSI_BASE + 0x014 + (n)*0x2000)
+#define	SSI_GR(n)		(SSI_BASE + 0x018 + (n)*0x2000)
+
+#define	REG_SSI_DR(n)		REG32(SSI_DR(n))
+#define	REG_SSI_CR0(n)		REG16(SSI_CR0(n))
+#define	REG_SSI_CR1(n)		REG32(SSI_CR1(n))
+#define	REG_SSI_SR(n)		REG32(SSI_SR(n))
+#define	REG_SSI_ITR(n)		REG16(SSI_ITR(n))
+#define	REG_SSI_ICR(n)		REG8(SSI_ICR(n))
+#define	REG_SSI_GR(n)		REG16(SSI_GR(n))
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+#define SSI_MAX_FIFO_ENTRIES 	128 /* 128 txfifo and 128 rxfifo */
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_EACLRUN		(1 << 7) /* hardware auto clear underrun when TxFifo no empty */
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_TTRG_BIT	16 /* SSI1 TX trigger */
+#define SSI_CR1_TTRG_MASK	(0xf << SSI1_CR1_TTRG_BIT) 
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_RTRG_BIT	8 /* SSI RX trigger */
+#define SSI_CR1_RTRG_MASK	(0xf << SSI1_CR1_RTRG_BIT)
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	16
+#define SSI_SR_TFIFONUM_MASK	(0xff << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0xff << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+
+/*************************************************************************
+ * MSC
+ *************************************************************************/
+#define	MSC_STRPCL		(MSC_BASE + 0x000)
+#define	MSC_STAT		(MSC_BASE + 0x004)
+#define	MSC_CLKRT		(MSC_BASE + 0x008)
+#define	MSC_CMDAT		(MSC_BASE + 0x00C)
+#define	MSC_RESTO		(MSC_BASE + 0x010)
+#define	MSC_RDTO		(MSC_BASE + 0x014)
+#define	MSC_BLKLEN		(MSC_BASE + 0x018)
+#define	MSC_NOB			(MSC_BASE + 0x01C)
+#define	MSC_SNOB		(MSC_BASE + 0x020)
+#define	MSC_IMASK		(MSC_BASE + 0x024)
+#define	MSC_IREG		(MSC_BASE + 0x028)
+#define	MSC_CMD			(MSC_BASE + 0x02C)
+#define	MSC_ARG			(MSC_BASE + 0x030)
+#define	MSC_RES			(MSC_BASE + 0x034)
+#define	MSC_RXFIFO		(MSC_BASE + 0x038)
+#define	MSC_TXFIFO		(MSC_BASE + 0x03C)
+
+#define	REG_MSC_STRPCL		REG16(MSC_STRPCL)
+#define	REG_MSC_STAT		REG32(MSC_STAT)
+#define	REG_MSC_CLKRT		REG16(MSC_CLKRT)
+#define	REG_MSC_CMDAT		REG32(MSC_CMDAT)
+#define	REG_MSC_RESTO		REG16(MSC_RESTO)
+#define	REG_MSC_RDTO		REG16(MSC_RDTO)
+#define	REG_MSC_BLKLEN		REG16(MSC_BLKLEN)
+#define	REG_MSC_NOB		REG16(MSC_NOB)
+#define	REG_MSC_SNOB		REG16(MSC_SNOB)
+#define	REG_MSC_IMASK		REG16(MSC_IMASK)
+#define	REG_MSC_IREG		REG16(MSC_IREG)
+#define	REG_MSC_CMD		REG8(MSC_CMD)
+#define	REG_MSC_ARG		REG32(MSC_ARG)
+#define	REG_MSC_RES		REG16(MSC_RES)
+#define	REG_MSC_RXFIFO		REG32(MSC_RXFIFO)
+#define	REG_MSC_TXFIFO		REG32(MSC_TXFIFO)
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	  (0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	  (0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	  (0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	  (0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	  (0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	  (0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	  (0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	  (0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+
+#define	MSC_CMDAT_IO_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define CMDAT_BUS_WIDTH1	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define CMDAT_BUS_WIDTH4	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT)
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE  (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+
+/*************************************************************************
+ * EMC (External Memory Controller)
+ *************************************************************************/
+#define EMC_BCR		(EMC_BASE + 0x0)  /* BCR */
+
+#define EMC_SMCR0	(EMC_BASE + 0x10)  /* Static Memory Control Register 0 */
+#define EMC_SMCR1	(EMC_BASE + 0x14)  /* Static Memory Control Register 1 */
+#define EMC_SMCR2	(EMC_BASE + 0x18)  /* Static Memory Control Register 2 */
+#define EMC_SMCR3	(EMC_BASE + 0x1c)  /* Static Memory Control Register 3 */
+#define EMC_SMCR4	(EMC_BASE + 0x20)  /* Static Memory Control Register 4 */
+#define EMC_SACR0	(EMC_BASE + 0x30)  /* Static Memory Bank 0 Addr Config Reg */
+#define EMC_SACR1	(EMC_BASE + 0x34)  /* Static Memory Bank 1 Addr Config Reg */
+#define EMC_SACR2	(EMC_BASE + 0x38)  /* Static Memory Bank 2 Addr Config Reg */
+#define EMC_SACR3	(EMC_BASE + 0x3c)  /* Static Memory Bank 3 Addr Config Reg */
+#define EMC_SACR4	(EMC_BASE + 0x40)  /* Static Memory Bank 4 Addr Config Reg */
+
+#define EMC_NFCSR	(EMC_BASE + 0x050) /* NAND Flash Control/Status Register */
+
+#define EMC_DMCR	(EMC_BASE + 0x80)  /* DRAM Control Register */
+#define EMC_RTCSR	(EMC_BASE + 0x84)  /* Refresh Time Control/Status Register */
+#define EMC_RTCNT	(EMC_BASE + 0x88)  /* Refresh Timer Counter */
+#define EMC_RTCOR	(EMC_BASE + 0x8c)  /* Refresh Time Constant Register */
+#define EMC_DMAR0	(EMC_BASE + 0x90)  /* SDRAM Bank 0 Addr Config Register */
+#define EMC_DMAR1	(EMC_BASE + 0x94)  /* SDRAM Bank 1 Addr Config Register */
+#define EMC_SDMR0	(EMC_BASE + 0x8000) /* Mode Register of SDRAM bank 0 */
+
+#define REG_EMC_BCR	REG32(EMC_BCR)
+
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR0	REG32(EMC_DMAR0)
+#define REG_EMC_DMAR1	REG32(EMC_DMAR1)
+
+/* Bus Control Register */
+#define EMC_BCR_BT_SEL_BIT      30
+#define EMC_BCR_BT_SEL_MASK     (0x3 << EMC_BCR_BT_SEL_BIT)
+#define EMC_BCR_PK_SEL          (1 << 24)
+#define EMC_BCR_BSR_MASK          (1 << 2)  /* Nand and SDRAM Bus Share Select: 0, share; 1, unshare */
+  #define EMC_BCR_BSR_SHARE       (0 << 2)
+  #define EMC_BCR_BSR_UNSHARE     (1 << 2)
+#define EMC_BCR_BRE             (1 << 1)
+#define EMC_BCR_ENDIAN          (1 << 0)
+
+/* Static Memory Control Register */
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+/* Static Memory Bank Addr Config Reg */
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+/* NAND Flash Control/Status Register */
+#define EMC_NFCSR_NFCE4		(1 << 7) /* NAND Flash Enable */
+#define EMC_NFCSR_NFE4		(1 << 6) /* NAND Flash FCE# Assertion Enable */
+#define EMC_NFCSR_NFCE3		(1 << 5)
+#define EMC_NFCSR_NFE3		(1 << 4)
+#define EMC_NFCSR_NFCE2		(1 << 3)
+#define EMC_NFCSR_NFE2		(1 << 2)
+#define EMC_NFCSR_NFCE1		(1 << 1)
+#define EMC_NFCSR_NFE1		(1 << 0)
+
+/* DRAM Control Register */
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_MBSEL_BIT	16
+  #define EMC_DMCR_MBSEL_B0	(0 << 16)
+  #define EMC_DMCR_MBSEL_B1	(1 << 16)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+/* Refresh Time Control/Status Register */
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+/* SDRAM Bank Address Configuration Register */
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+/* Mode Register of SDRAM bank 0 */
+#define EMC_SDMR_BM		(1 << 9) /* Write Burst Mode */
+#define EMC_SDMR_OM_BIT		7        /* Operating Mode */
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4        /* CAS Latency */
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3        /* Burst Type */
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT) /* Sequential */
+  #define EMC_SDMR_BT_INT	(1 << EMC_SDMR_BT_BIT) /* Interleave */
+#define EMC_SDMR_BL_BIT		0        /* Burst Length */
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+/* Extended Mode Register of Mobile SDRAM*/
+#define EMC_SDMR_SET_BA1		(1 << 14)	/*BA1*/
+#define EMC_SDMR_SET_BA0		(1 << 13)	/*BA0*/
+
+#define EMC_SDMR_DS_BIT		5	/* Driver strength */
+#define EMC_SDMR_DS_MASK	(3 << EMC_SDMR_DS_BIT)
+  #define EMC_SDMR_DS_FULL	(0 << EMC_SDMR_DS_BIT)	/*Full*/
+  #define EMC_SDMR_DS_HALF	(1 << EMC_SDMR_DS_BIT)	/*1/2 Strength*/
+  #define EMC_SDMR_DS_QUTR	(2 << EMC_SDMR_DS_BIT)	/*1/4 Strength*/
+
+#define EMC_SDMR_PRSR_BIT	0	/* Partial Array Self Refresh */
+#define EMC_SDMR_PRSR_MASK	(7 << EMC_SDMR_PRSR_BIT)
+  #define EMC_SDMR_PRSR_ALL	(0 << EMC_SDMR_PRSR_BIT) /*All Banks*/
+  #define EMC_SDMR_PRSR_HALF_TL	(1 << EMC_SDMR_PRSR_BIT) /*Half of Total Bank*/
+  #define EMC_SDMR_PRSR_QUTR_TL	(2 << EMC_SDMR_PRSR_BIT) /*Quarter of Total Bank*/
+  #define EMC_SDMR_PRSR_HALF_B0	(5 << EMC_SDMR_PRSR_BIT) /*Half of Bank0*/
+  #define EMC_SDMR_PRSR_QUTR_B0	(6 << EMC_SDMR_PRSR_BIT) /*Quarter of Bank0*/
+
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_MASK_BIT	0
+
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+#define EMC_DMAR0_BASE		(0x20 << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR1_BASE_64M	(0x24 << EMC_DMAR_BASE_BIT) /*when bank0 is 64M*/
+#define EMC_DMAR1_BASE_128M	(0x28 << EMC_DMAR_BASE_BIT) /*when bank0 is 128M*/
+
+#define EMC_DMAR_MASK_64_64	(0xfc << EMC_DMAR_MASK_BIT)  /*mask for two 64M SDRAM*/
+#define EMC_DMAR_MASK_128_128	(0xf8 << EMC_DMAR_MASK_BIT)  /*mask for two 128M SDRAM*/
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+
+/* CIM Configuration Register  (CIM_CFG) */
+
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14)
+#define	CIM_CFG_HSP		(1 << 13)
+#define	CIM_CFG_PCP		(1 << 12)
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+  #define CIM_CFG_DSM_NGCM	  (3 << CIM_CFG_DSM_BIT) /* Non-Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+
+#define	CIM_CTRL_MCLKDIV_BIT	24
+#define	CIM_CTRL_MCLKDIV_MASK	(0xff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+#define	CIM_CTRL_VDDM		(1 << 13)
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_RXF_TRIG_BIT	4
+#define	CIM_CTRL_RXF_TRIG_MASK	(0x7 << CIM_CTRL_RXF_TRIG_BIT)
+  #define CIM_CTRL_RXF_TRIG_4	  (0 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 4 */
+  #define CIM_CTRL_RXF_TRIG_8	  (1 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 8 */
+  #define CIM_CTRL_RXF_TRIG_12	  (2 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 12 */
+  #define CIM_CTRL_RXF_TRIG_16	  (3 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 16 */
+  #define CIM_CTRL_RXF_TRIG_20	  (4 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 20 */
+  #define CIM_CTRL_RXF_TRIG_24	  (5 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 24 */
+  #define CIM_CTRL_RXF_TRIG_28	  (6 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 28 */
+  #define CIM_CTRL_RXF_TRIG_32	  (7 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 32 */
+#define	CIM_CTRL_DMA_EN		(1 << 2)
+#define	CIM_CTRL_RXF_RST	(1 << 1)
+#define	CIM_CTRL_ENA		(1 << 0)
+
+/* CIM State Register  (CIM_STATE) */
+
+#define	CIM_STATE_DMA_SOF	(1 << 6)
+#define	CIM_STATE_DMA_EOF	(1 << 5)
+#define	CIM_STATE_DMA_STOP	(1 << 4)
+#define	CIM_STATE_RXF_OF	(1 << 3)
+#define	CIM_STATE_RXF_TRIG	(1 << 2)
+#define	CIM_STATE_RXF_EMPTY	(1 << 1)
+#define	CIM_STATE_VDD		(1 << 0)
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31)
+#define	CIM_CMD_EOFINT		(1 << 30)
+#define	CIM_CMD_STOP		(1 << 28)
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+
+/*************************************************************************
+ * SADC (Smart A/D Controller)
+ *************************************************************************/
+
+#define SADC_ENA	(SADC_BASE + 0x00)  /* ADC Enable Register */
+#define SADC_CFG	(SADC_BASE + 0x04)  /* ADC Configure Register */
+#define SADC_CTRL	(SADC_BASE + 0x08)  /* ADC Control Register */
+#define SADC_STATE	(SADC_BASE + 0x0C)  /* ADC Status Register*/
+#define SADC_SAMETIME	(SADC_BASE + 0x10)  /* ADC Same Point Time Register */
+#define SADC_WAITTIME	(SADC_BASE + 0x14)  /* ADC Wait Time Register */
+#define SADC_TSDAT	(SADC_BASE + 0x18)  /* ADC Touch Screen Data Register */
+#define SADC_BATDAT	(SADC_BASE + 0x1C)  /* ADC PBAT Data Register */
+#define SADC_SADDAT	(SADC_BASE + 0x20)  /* ADC SADCIN Data Register */
+
+#define REG_SADC_ENA		REG8(SADC_ENA)
+#define REG_SADC_CFG		REG32(SADC_CFG)
+#define REG_SADC_CTRL		REG8(SADC_CTRL)
+#define REG_SADC_STATE		REG8(SADC_STATE)
+#define REG_SADC_SAMETIME	REG16(SADC_SAMETIME)
+#define REG_SADC_WAITTIME	REG16(SADC_WAITTIME)
+#define REG_SADC_TSDAT		REG32(SADC_TSDAT)
+#define REG_SADC_BATDAT		REG16(SADC_BATDAT)
+#define REG_SADC_SADDAT		REG16(SADC_SADDAT)
+
+/* ADC Enable Register */
+#define SADC_ENA_ADEN		(1 << 7)  /* Touch Screen Enable */
+#define SADC_ENA_TSEN		(1 << 2)  /* Touch Screen Enable */
+#define SADC_ENA_PBATEN		(1 << 1)  /* PBAT Enable */
+#define SADC_ENA_SADCINEN	(1 << 0)  /* SADCIN Enable */
+
+/* ADC Configure Register */
+#define SADC_CFG_CLKOUT_NUM_BIT	16
+#define SADC_CFG_CLKOUT_NUM_MASK (0x7 << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_TS_DMA		(1 << 15)  /* Touch Screen DMA Enable */
+#define SADC_CFG_XYZ_BIT	13  /* XYZ selection */
+#define SADC_CFG_XYZ_MASK	(0x3 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XY		(0 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ		(1 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ1Z2	(2 << SADC_CFG_XYZ_BIT)
+#define SADC_CFG_SNUM_BIT	10  /* Sample Number */
+#define SADC_CFG_SNUM_MASK	(0x7 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_1	(0x0 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_2	(0x1 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_3	(0x2 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_4	(0x3 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_5	(0x4 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_6	(0x5 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_8	(0x6 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_9	(0x7 << SADC_CFG_SNUM_BIT)
+#define SADC_CFG_CLKDIV_BIT	5  /* AD Converter frequency clock divider */
+#define SADC_CFG_CLKDIV_MASK	(0x1f << SADC_CFG_CLKDIV_BIT)
+#define SADC_CFG_PBAT_HIGH	(0 << 4)  /* PBAT >= 2.5V */
+#define SADC_CFG_PBAT_LOW	(1 << 4)  /* PBAT < 2.5V */
+#define SADC_CFG_CMD_BIT	0  /* ADC Command */
+#define SADC_CFG_CMD_MASK	(0xf << SADC_CFG_CMD_BIT)
+  #define SADC_CFG_CMD_X_SE	(0x0 << SADC_CFG_CMD_BIT) /* X Single-End */
+  #define SADC_CFG_CMD_Y_SE	(0x1 << SADC_CFG_CMD_BIT) /* Y Single-End */
+  #define SADC_CFG_CMD_X_DIFF	(0x2 << SADC_CFG_CMD_BIT) /* X Differential */
+  #define SADC_CFG_CMD_Y_DIFF	(0x3 << SADC_CFG_CMD_BIT) /* Y Differential */
+  #define SADC_CFG_CMD_Z1_DIFF	(0x4 << SADC_CFG_CMD_BIT) /* Z1 Differential */
+  #define SADC_CFG_CMD_Z2_DIFF	(0x5 << SADC_CFG_CMD_BIT) /* Z2 Differential */
+  #define SADC_CFG_CMD_Z3_DIFF	(0x6 << SADC_CFG_CMD_BIT) /* Z3 Differential */
+  #define SADC_CFG_CMD_Z4_DIFF	(0x7 << SADC_CFG_CMD_BIT) /* Z4 Differential */
+  #define SADC_CFG_CMD_TP_SE	(0x8 << SADC_CFG_CMD_BIT) /* Touch Pressure */
+  #define SADC_CFG_CMD_PBATH_SE	(0x9 << SADC_CFG_CMD_BIT) /* PBAT >= 2.5V */
+  #define SADC_CFG_CMD_PBATL_SE	(0xa << SADC_CFG_CMD_BIT) /* PBAT < 2.5V */
+  #define SADC_CFG_CMD_SADCIN_SE (0xb << SADC_CFG_CMD_BIT) /* Measure SADCIN */
+  #define SADC_CFG_CMD_INT_PEN	(0xc << SADC_CFG_CMD_BIT) /* INT_PEN Enable */
+
+/* ADC Control Register */
+#define SADC_CTRL_PENDM		(1 << 4)  /* Pen Down Interrupt Mask */
+#define SADC_CTRL_PENUM		(1 << 3)  /* Pen Up Interrupt Mask */
+#define SADC_CTRL_TSRDYM	(1 << 2)  /* Touch Screen Data Ready Interrupt Mask */
+#define SADC_CTRL_PBATRDYM	(1 << 1)  /* PBAT Data Ready Interrupt Mask */
+#define SADC_CTRL_SRDYM		(1 << 0)  /* SADCIN Data Ready Interrupt Mask */
+
+/* ADC Status Register */
+#define SADC_STATE_TSBUSY	(1 << 7)  /* TS A/D is working */
+#define SADC_STATE_PBATBUSY	(1 << 6)  /* PBAT A/D is working */
+#define SADC_STATE_SBUSY	(1 << 5)  /* SADCIN A/D is working */
+#define SADC_STATE_PEND		(1 << 4)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PENU		(1 << 3)  /* Pen Up Interrupt Flag */
+#define SADC_STATE_TSRDY	(1 << 2)  /* Touch Screen Data Ready Interrupt Flag */
+#define SADC_STATE_PBATRDY	(1 << 1)  /* PBAT Data Ready Interrupt Flag */
+#define SADC_STATE_SRDY		(1 << 0)  /* SADCIN Data Ready Interrupt Flag */
+
+/* ADC Touch Screen Data Register */
+#define SADC_TSDAT_DATA0_BIT	0
+#define SADC_TSDAT_DATA0_MASK	(0xfff << SADC_TSDAT_DATA0_BIT)
+#define SADC_TSDAT_TYPE0	(1 << 15)
+#define SADC_TSDAT_DATA1_BIT	16
+#define SADC_TSDAT_DATA1_MASK	(0xfff << SADC_TSDAT_DATA1_BIT)
+#define SADC_TSDAT_TYPE1	(1 << 31)
+
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+
+#define SLCD_CFG	(SLCD_BASE + 0xA0)  /* SLCD Configure Register */
+#define SLCD_CTRL	(SLCD_BASE + 0xA4)  /* SLCD Control Register */
+#define SLCD_STATE	(SLCD_BASE + 0xA8)  /* SLCD Status Register */
+#define SLCD_DATA	(SLCD_BASE + 0xAC)  /* SLCD Data Register */
+
+#define REG_SLCD_CFG	REG32(SLCD_CFG)
+#define REG_SLCD_CTRL	REG8(SLCD_CTRL)
+#define REG_SLCD_STATE	REG8(SLCD_STATE)
+#define REG_SLCD_DATA	REG32(SLCD_DATA)
+
+/* SLCD Configure Register */
+#define SLCD_CFG_BURST_BIT	14
+#define SLCD_CFG_BURST_MASK	(0x3 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_4_WORD	(0 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_8_WORD	(1 << SLCD_CFG_BURST_BIT)
+#define SLCD_CFG_DWIDTH_BIT	10
+#define SLCD_CFG_DWIDTH_MASK	(0x7 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_18	(0 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_16	(1 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x3	(2 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x2	(3 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_9_x2	(4 << SLCD_CFG_DWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_16BIT	(0 << 8)
+#define SLCD_CFG_CWIDTH_8BIT	(1 << 8)
+#define SLCD_CFG_CS_ACTIVE_LOW	(0 << 4)
+#define SLCD_CFG_CS_ACTIVE_HIGH	(1 << 4)
+#define SLCD_CFG_RS_CMD_LOW	(0 << 3)
+#define SLCD_CFG_RS_CMD_HIGH	(1 << 3)
+#define SLCD_CFG_CLK_ACTIVE_FALLING	(0 << 1)
+#define SLCD_CFG_CLK_ACTIVE_RISING	(1 << 1)
+#define SLCD_CFG_TYPE_PARALLEL	(0 << 0)
+#define SLCD_CFG_TYPE_SERIAL	(1 << 0)
+
+/* SLCD Control Register */
+#define SLCD_CTRL_DMA_EN	(1 << 0)
+
+/* SLCD Status Register */
+#define SLCD_STATE_BUSY		(1 << 0)
+
+/* SLCD Data Register */
+#define SLCD_DATA_RS_DATA	(0 << 31)
+#define SLCD_DATA_RS_COMMAND	(1 << 31)
+
+/*************************************************************************
+ * LCD (LCD Controller)
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00) /* LCD Configure Register */
+#define LCD_CTRL	(LCD_BASE + 0x30) /* LCD Control Register */
+#define LCD_STATE	(LCD_BASE + 0x34) /* LCD Status Register */
+
+#define LCD_OSDC	(LCD_BASE + 0x100) /* LCD OSD Configure Register */
+#define LCD_OSDCTRL	(LCD_BASE + 0x104) /* LCD OSD Control Register */
+#define LCD_OSDS	(LCD_BASE + 0x108) /* LCD OSD Status Register */
+#define LCD_BGC		(LCD_BASE + 0x10C) /* LCD Background Color Register */
+#define LCD_KEY0	(LCD_BASE + 0x110) /* LCD Foreground Color Key Register 0 */
+#define LCD_KEY1	(LCD_BASE + 0x114) /* LCD Foreground Color Key Register 1 */
+#define LCD_ALPHA	(LCD_BASE + 0x118) /* LCD ALPHA Register */
+#define LCD_IPUR	(LCD_BASE + 0x11C) /* LCD IPU Restart Register */
+
+#define LCD_VAT		(LCD_BASE + 0x0c) /* Virtual Area Setting Register */
+#define LCD_DAH		(LCD_BASE + 0x10) /* Display Area Horizontal Start/End Point */
+#define LCD_DAV		(LCD_BASE + 0x14) /* Display Area Vertical Start/End Point */
+
+#define LCD_XYP0	(LCD_BASE + 0x120) /* Foreground 0 XY Position Register */
+#define LCD_XYP1	(LCD_BASE + 0x124) /* Foreground 1 XY Position Register */
+#define LCD_SIZE0	(LCD_BASE + 0x128) /* Foreground 0 Size Register */
+#define LCD_SIZE1	(LCD_BASE + 0x12C) /* Foreground 1 Size Register */
+#define LCD_RGBC	(LCD_BASE + 0x90) /* RGB Controll Register */
+
+#define LCD_VSYNC	(LCD_BASE + 0x04) /* Vertical Synchronize Register */
+#define LCD_HSYNC	(LCD_BASE + 0x08) /* Horizontal Synchronize Register */
+#define LCD_PS		(LCD_BASE + 0x18) /* PS Signal Setting */
+#define LCD_CLS		(LCD_BASE + 0x1c) /* CLS Signal Setting */
+#define LCD_SPL		(LCD_BASE + 0x20) /* SPL Signal Setting */
+#define LCD_REV		(LCD_BASE + 0x24) /* REV Signal Setting */
+#define LCD_IID		(LCD_BASE + 0x38) /* Interrupt ID Register */
+#define LCD_DA0		(LCD_BASE + 0x40) /* Descriptor Address Register 0 */
+#define LCD_SA0		(LCD_BASE + 0x44) /* Source Address Register 0 */
+#define LCD_FID0	(LCD_BASE + 0x48) /* Frame ID Register 0 */
+#define LCD_CMD0	(LCD_BASE + 0x4c) /* DMA Command Register 0 */
+#define LCD_DA1		(LCD_BASE + 0x50) /* Descriptor Address Register 1 */
+#define LCD_SA1		(LCD_BASE + 0x54) /* Source Address Register 1 */
+#define LCD_FID1	(LCD_BASE + 0x58) /* Frame ID Register 1 */
+#define LCD_CMD1	(LCD_BASE + 0x5c) /* DMA Command Register 1 */
+
+#define LCD_OFFS0	(LCD_BASE + 0x60) /* DMA Offsize Register 0 */
+#define LCD_PW0		(LCD_BASE + 0x64) /* DMA Page Width Register 0 */
+#define LCD_CNUM0	(LCD_BASE + 0x68) /* DMA Command Counter Register 0 */
+#define LCD_DESSIZE0	(LCD_BASE + 0x6C) /* Foreground Size in Descriptor 0 Register*/
+#define LCD_OFFS1	(LCD_BASE + 0x70) /* DMA Offsize Register 1 */
+#define LCD_PW1		(LCD_BASE + 0x74) /* DMA Page Width Register 1 */
+#define LCD_CNUM1	(LCD_BASE + 0x78) /* DMA Command Counter Register 1 */
+#define LCD_DESSIZE1	(LCD_BASE + 0x7C) /* Foreground Size in Descriptor 1 Register*/
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+
+#define REG_LCD_OSDC	REG16(LCD_OSDC)
+#define REG_LCD_OSDCTRL	REG16(LCD_OSDCTRL)
+#define REG_LCD_OSDS	REG16(LCD_OSDS)
+#define REG_LCD_BGC	REG32(LCD_BGC)
+#define REG_LCD_KEY0	REG32(LCD_KEY0)
+#define REG_LCD_KEY1	REG32(LCD_KEY1)
+#define REG_LCD_ALPHA	REG8(LCD_ALPHA)
+#define REG_LCD_IPUR	REG32(LCD_IPUR)
+
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+
+#define REG_LCD_XYP0	REG32(LCD_XYP0)
+#define REG_LCD_XYP1	REG32(LCD_XYP1)
+#define REG_LCD_SIZE0	REG32(LCD_SIZE0)
+#define REG_LCD_SIZE1	REG32(LCD_SIZE1)
+#define REG_LCD_RGBC	REG16(LCD_RGBC)
+
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+#define REG_LCD_OFFS0	REG32(LCD_OFFS0)
+#define REG_LCD_PW0	REG32(LCD_PW0)
+#define REG_LCD_CNUM0	REG32(LCD_CNUM0)
+#define REG_LCD_DESSIZE0	REG32(LCD_DESSIZE0)
+#define REG_LCD_OFFS1	REG32(LCD_OFFS1)
+#define REG_LCD_PW1	REG32(LCD_PW1)
+#define REG_LCD_CNUM1	REG32(LCD_CNUM1)
+#define REG_LCD_DESSIZE1	REG32(LCD_DESSIZE1)
+
+/* LCD Configure Register */
+#define LCD_CFG_LCDPIN_BIT	31  /* LCD pins selection */
+#define LCD_CFG_LCDPIN_MASK	(0x1 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_LCD	(0x0 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_SLCD	(0x1 << LCD_CFG_LCDPIN_BIT)
+#define LCD_CFG_FUHOLD		(1 << 29) /* hold pixel clock when outFIFO underrun */
+#define LCD_CFG_NEWDES		(1 << 28) /* use new descripter. old: 4words, new:8words */
+#define LCD_CFG_PALBP		(1 << 27) /* bypass data format and alpha blending */
+#define LCD_CFG_TVEN		(1 << 26) /* indicate the terminal is lcd or tv */
+#define LCD_CFG_RECOVER		(1 << 25) /* Auto recover when output fifo underrun */
+#define LCD_CFG_DITHER		(1 << 24) /* Dither function */
+#define LCD_CFG_PSM		(1 << 23) /* PS signal mode */
+#define LCD_CFG_CLSM		(1 << 22) /* CLS signal mode */
+#define LCD_CFG_SPLM		(1 << 21) /* SPL signal mode */
+#define LCD_CFG_REVM		(1 << 20) /* REV signal mode */
+#define LCD_CFG_HSYNM		(1 << 19) /* HSYNC signal mode */
+#define LCD_CFG_PCLKM		(1 << 18) /* PCLK signal mode */
+#define LCD_CFG_INVDAT		(1 << 17) /* Inverse output data */
+#define LCD_CFG_SYNDIR_IN	(1 << 16) /* VSYNC&HSYNC direction */
+#define LCD_CFG_PSP		(1 << 15) /* PS pin reset state */
+#define LCD_CFG_CLSP		(1 << 14) /* CLS pin reset state */
+#define LCD_CFG_SPLP		(1 << 13) /* SPL pin reset state */
+#define LCD_CFG_REVP		(1 << 12) /* REV pin reset state */
+#define LCD_CFG_HSP		(1 << 11) /* HSYNC pority:0-active high,1-active low */
+#define LCD_CFG_PCP		(1 << 10) /* PCLK pority:0-rising,1-falling */
+#define LCD_CFG_DEP		(1 << 9)  /* DE pority:0-active high,1-active low */
+#define LCD_CFG_VSP		(1 << 8)  /* VSYNC pority:0-rising,1-falling */
+#define MODE_TFT_18BIT          (1 << 7)  /* 18bit TFT */
+#define LCD_CFG_PDW_BIT		4  /* STN pins utilization */
+#define LCD_CFG_PDW_MASK	(0x3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_PDW_1		(0 << LCD_CFG_PDW_BIT) /* LCD_D[0] */
+  #define LCD_CFG_PDW_2		(1 << LCD_CFG_PDW_BIT) /* LCD_D[0:1] */
+  #define LCD_CFG_PDW_4		(2 << LCD_CFG_PDW_BIT) /* LCD_D[0:3]/LCD_D[8:11] */
+  #define LCD_CFG_PDW_8		(3 << LCD_CFG_PDW_BIT) /* LCD_D[0:7]/LCD_D[8:15] */
+#define LCD_CFG_MODE_BIT	0  /* Display Device Mode Select */
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_CFG_MODE_BIT) /* 16,18 bit TFT */
+  #define LCD_CFG_MODE_SPECIAL_TFT_1	(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_2	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_3	(3 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(5 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SERIAL_TFT	(12 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_LCM  		(13 << LCD_CFG_MODE_BIT)
+  /* JZ47XX defines */
+  #define LCD_CFG_MODE_SHARP_HR		(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_CASIO_TFT	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SAMSUNG_ALPHA	(3 << LCD_CFG_MODE_BIT)
+
+/* LCD Control Register */
+#define LCD_CTRL_BST_BIT	28  /* Burst Length Selection */
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT) /* 4-word */
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT) /* 8-word */
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT) /* 16-word */
+  #define LCD_CTRL_BST_32	(3 << LCD_CTRL_BST_BIT) /* 32-word */
+#define LCD_CTRL_RGB565		(0 << 27) /* RGB565 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_RGB555		(1 << 27) /* RGB555 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_OFUP		(1 << 26) /* Output FIFO underrun protection enable */
+#define LCD_CTRL_FRC_BIT	24  /* STN FRC Algorithm Selection */
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT) /* 16 grayscale */
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT) /* 4 grayscale */
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT) /* 2 grayscale */
+#define LCD_CTRL_PDD_BIT	16  /* Load Palette Delay Counter */
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13) /* EOF interrupt mask */
+#define LCD_CTRL_SOFM		(1 << 12) /* SOF interrupt mask */
+#define LCD_CTRL_OFUM		(1 << 11) /* Output FIFO underrun interrupt mask */
+#define LCD_CTRL_IFUM0		(1 << 10) /* Input FIFO 0 underrun interrupt mask */
+#define LCD_CTRL_IFUM1		(1 << 9)  /* Input FIFO 1 underrun interrupt mask */
+#define LCD_CTRL_LDDM		(1 << 8)  /* LCD disable done interrupt mask */
+#define LCD_CTRL_QDM		(1 << 7)  /* LCD quick disable done interrupt mask */
+#define LCD_CTRL_BEDN		(1 << 6)  /* Endian selection */
+#define LCD_CTRL_PEDN		(1 << 5)  /* Endian in byte:0-msb first, 1-lsb first */
+#define LCD_CTRL_DIS		(1 << 4)  /* Disable indicate bit */
+#define LCD_CTRL_ENA		(1 << 3)  /* LCD enable bit */
+#define LCD_CTRL_BPP_BIT	0  /* Bits Per Pixel */
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT) /* 1 bpp */
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT) /* 2 bpp */
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT) /* 4 bpp */
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT) /* 8 bpp */
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT) /* 15/16 bpp */
+  #define LCD_CTRL_BPP_18_24	(5 << LCD_CTRL_BPP_BIT) /* 18/24/32 bpp */
+
+/* LCD Status Register */
+#define LCD_STATE_QD		(1 << 7) /* Quick Disable Done */
+#define LCD_STATE_EOF		(1 << 5) /* EOF Flag */
+#define LCD_STATE_SOF		(1 << 4) /* SOF Flag */
+#define LCD_STATE_OFU		(1 << 3) /* Output FIFO Underrun */
+#define LCD_STATE_IFU0		(1 << 2) /* Input FIFO 0 Underrun */
+#define LCD_STATE_IFU1		(1 << 1) /* Input FIFO 1 Underrun */
+#define LCD_STATE_LDD		(1 << 0) /* LCD Disabled */
+
+/* OSD Configure Register */
+#define LCD_OSDC_SOFM1		(1 << 15) /* Start of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_EOFM1		(1 << 14) /* End of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_REM1		(1 << 13) /* Real end of frame mask for foreground 1 */
+#define LCD_OSDC_SOFM0		(1 << 11) /* Start of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_EOFM0		(1 << 10) /* End of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_REM0		(1 << 9) /* Real end of frame mask for foreground 0 */
+#define LCD_OSDC_REMB		(1 << 7) /* Real end of frame mask for background */
+#define LCD_OSDC_F1EN		(1 << 4) /* enable foreground 1 */
+#define LCD_OSDC_F0EN		(1 << 3) /* enable foreground 0 */
+#define LCD_OSDC_ALPHAEN		(1 << 2) /* enable alpha blending */
+#define LCD_OSDC_ALPHAMD		(1 << 1) /* alpha blending mode */
+#define LCD_OSDC_OSDEN		(1 << 0) /* OSD mode enable */
+
+/* OSD Controll Register */
+#define LCD_OSDCTRL_IPU		(1 << 15) /* input data from IPU */
+#define LCD_OSDCTRL_RGB565	(0 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_RGB555	(1 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_CHANGES	(1 << 3) /* Change size flag */
+#define LCD_OSDCTRL_OSDBPP_BIT	0 	 /* Bits Per Pixel of OSD Channel 1 */
+#define LCD_OSDCTRL_OSDBPP_MASK	(0x3<<LCD_OSDCTRL_OSDBPP_BIT) 	 /* Bits Per Pixel of OSD Channel 1's MASK */
+  #define LCD_OSDCTRL_OSDBPP_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_15_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_18_24	(5 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 18,24 bit*/
+
+/* OSD State Register */
+#define LCD_OSDS_SOF1		(1 << 15) /* Start of frame flag for foreground 1 */
+#define LCD_OSDS_EOF1		(1 << 14) /* End of frame flag for foreground 1 */
+#define LCD_OSDS_SOF0		(1 << 11) /* Start of frame flag for foreground 0 */
+#define LCD_OSDS_EOF0		(1 << 10) /* End of frame flag for foreground 0 */
+#define LCD_OSDS_READY		(1 << 0)  /* Read for accept the change */
+
+/* Background Color Register */
+#define LCD_BGC_RED_OFFSET	(1 << 16)  /* Red color offset */
+#define LCD_BGC_RED_MASK	(0xFF<<LCD_BGC_RED_OFFSET)
+#define LCD_BGC_GREEN_OFFSET	(1 << 8)   /* Green color offset */
+#define LCD_BGC_GREEN_MASK	(0xFF<<LCD_BGC_GREEN_OFFSET)
+#define LCD_BGC_BLUE_OFFSET	(1 << 0)   /* Blue color offset */
+#define LCD_BGC_BLUE_MASK	(0xFF<<LCD_BGC_BLUE_OFFSET)
+
+/* Foreground Color Key Register 0,1(foreground 0, foreground 1) */
+#define LCD_KEY_KEYEN		(1 << 31)   /* enable color key */
+#define LCD_KEY_KEYMD		(1 << 30)   /* color key mode */
+#define LCD_KEY_RED_OFFSET	(1 << 16)  /* Red color offset */
+#define LCD_KEY_RED_MASK	(0xFF<<LCD_KEY_RED_OFFSET)
+#define LCD_KEY_GREEN_OFFSET	(1 << 8)   /* Green color offset */
+#define LCD_KEY_GREEN_MASK	(0xFF<<LCD_KEY_GREEN_OFFSET)
+#define LCD_KEY_BLUE_OFFSET	(1 << 0)   /* Blue color offset */
+#define LCD_KEY_BLUE_MASK	(0xFF<<LCD_KEY_BLUE_OFFSET)
+
+/* IPU Restart Register */
+#define LCD_IPUR_IPUREN		(1 << 31)   /* IPU restart function enable*/
+
+/* RGB Control Register */
+#define LCD_RGBC_RGBDM		(1 << 15)   /* enable RGB Dummy data */
+#define LCD_RGBC_DMM		(1 << 14)   /* RGB Dummy mode */
+#define LCD_RGBC_YCC		(1 << 8)    /* RGB to YCC */
+#define LCD_RGBC_ODDRGB_BIT	4	/* odd line serial RGB data arrangement */
+#define LCD_RGBC_ODDRGB_MASK	(0x7<<LCD_RGBC_ODDRGB_BIT)
+  #define LCD_RGBC_ODD_RGB	0
+  #define LCD_RGBC_ODD_RBG	1
+  #define LCD_RGBC_ODD_GRB	2
+  #define LCD_RGBC_ODD_GBR	3
+  #define LCD_RGBC_ODD_BRG	4
+  #define LCD_RGBC_ODD_BGR	5
+#define LCD_RGBC_EVENRGB_BIT	0	/* even line serial RGB data arrangement */
+#define LCD_RGBC_EVENRGB_MASK	(0x7<<LCD_RGBC_EVENRGB_BIT)
+  #define LCD_RGBC_EVEN_RGB	0
+  #define LCD_RGBC_EVEN_RBG	1
+  #define LCD_RGBC_EVEN_GRB	2
+  #define LCD_RGBC_EVEN_GBR	3
+  #define LCD_RGBC_EVEN_BRG	4
+  #define LCD_RGBC_EVEN_BGR	5
+
+/* Vertical Synchronize Register */
+#define LCD_VSYNC_VPS_BIT	16  /* VSYNC pulse start in line clock, fixed to 0 */
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0   /* VSYNC pulse end in line clock */
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+/* Horizontal Synchronize Register */
+#define LCD_HSYNC_HPS_BIT	16  /* HSYNC pulse start position in dot clock */
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0   /* HSYNC pulse end position in dot clock */
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+/* Virtual Area Setting Register */
+#define LCD_VAT_HT_BIT		16  /* Horizontal Total size in dot clock */
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0   /* Vertical Total size in dot clock */
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+/* Display Area Horizontal Start/End Point Register */
+#define LCD_DAH_HDS_BIT		16  /* Horizontal display area start in dot clock */
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0   /* Horizontal display area end in dot clock */
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+/* Display Area Vertical Start/End Point Register */
+#define LCD_DAV_VDS_BIT		16  /* Vertical display area start in line clock */
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0   /* Vertical display area end in line clock */
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+/* Foreground XY Position Register */
+#define LCD_XYP_YPOS_BIT	16  /* Y position bit of foreground 0 or 1 */
+#define LCD_XYP_YPOS_MASK	(0xffff << LCD_XYP_YPOS_BIT)
+#define LCD_XYP_XPOS_BIT	0   /* X position bit of foreground 0 or 1 */
+#define LCD_XYP_XPOS_MASK	(0xffff << LCD_XYP_XPOS_BIT)
+
+/* PS Signal Setting */
+#define LCD_PS_PSS_BIT		16  /* PS signal start position in dot clock */
+#define LCD_PS_PSS_MASK		(0xffff << LCD_PS_PSS_BIT)
+#define LCD_PS_PSE_BIT		0   /* PS signal end position in dot clock */
+#define LCD_PS_PSE_MASK		(0xffff << LCD_PS_PSE_BIT)
+
+/* CLS Signal Setting */
+#define LCD_CLS_CLSS_BIT	16  /* CLS signal start position in dot clock */
+#define LCD_CLS_CLSS_MASK	(0xffff << LCD_CLS_CLSS_BIT)
+#define LCD_CLS_CLSE_BIT	0   /* CLS signal end position in dot clock */
+#define LCD_CLS_CLSE_MASK	(0xffff << LCD_CLS_CLSE_BIT)
+
+/* SPL Signal Setting */
+#define LCD_SPL_SPLS_BIT	16  /* SPL signal start position in dot clock */
+#define LCD_SPL_SPLS_MASK	(0xffff << LCD_SPL_SPLS_BIT)
+#define LCD_SPL_SPLE_BIT	0   /* SPL signal end position in dot clock */
+#define LCD_SPL_SPLE_MASK	(0xffff << LCD_SPL_SPLE_BIT)
+
+/* REV Signal Setting */
+#define LCD_REV_REVS_BIT	16  /* REV signal start position in dot clock */
+#define LCD_REV_REVS_MASK	(0xffff << LCD_REV_REVS_BIT)
+
+/* DMA Command Register */
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_CMD		(1 << 29) /* indicate command in slcd mode */
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+/* DMA Offsize Register 0,1 */
+
+/* DMA Page Width Register 0,1 */
+
+/* DMA Command Counter Register 0,1 */
+
+/* Foreground 0,1 Size Register */
+#define LCD_DESSIZE_HEIGHT_BIT	16  /* height of foreground 1 */
+#define LCD_DESSIZE_HEIGHT_MASK	(0xffff << LCD_DESSIZE_HEIGHT_BIT)
+#define LCD_DESSIZE_WIDTH_BIT	0  /* width of foreground 1 */
+#define LCD_DESSIZE_WIDTH_MASK	(0xffff << LCD_DESSIZE_WIDTH_BIT)
+
+/*************************************************************************
+ * USB Device
+ *************************************************************************/
+#define USB_BASE  UDC_BASE
+
+#define USB_REG_FADDR		(USB_BASE + 0x00) /* Function Address 8-bit */
+#define USB_REG_POWER		(USB_BASE + 0x01) /* Power Managemetn 8-bit */
+#define USB_REG_INTRIN		(USB_BASE + 0x02) /* Interrupt IN 16-bit */
+#define USB_REG_INTROUT		(USB_BASE + 0x04) /* Interrupt OUT 16-bit */
+#define USB_REG_INTRINE		(USB_BASE + 0x06) /* Intr IN enable 16-bit */
+#define USB_REG_INTROUTE	(USB_BASE + 0x08) /* Intr OUT enable 16-bit */
+#define USB_REG_INTRUSB		(USB_BASE + 0x0a) /* Interrupt USB 8-bit */
+#define USB_REG_INTRUSBE	(USB_BASE + 0x0b) /* Interrupt USB Enable 8-bit */
+#define USB_REG_FRAME		(USB_BASE + 0x0c) /* Frame number 16-bit */
+#define USB_REG_INDEX		(USB_BASE + 0x0e) /* Index register 8-bit */
+#define USB_REG_TESTMODE	(USB_BASE + 0x0f) /* USB test mode 8-bit */
+
+#define USB_REG_CSR0		(USB_BASE + 0x12) /* EP0 CSR 8-bit */
+#define USB_REG_INMAXP		(USB_BASE + 0x10) /* EP1-2 IN Max Pkt Size 16-bit */
+#define USB_REG_INCSR		(USB_BASE + 0x12) /* EP1-2 IN CSR LSB 8/16bit */
+#define USB_REG_INCSRH		(USB_BASE + 0x13) /* EP1-2 IN CSR MSB 8-bit */
+#define USB_REG_OUTMAXP		(USB_BASE + 0x14) /* EP1 OUT Max Pkt Size 16-bit */
+#define USB_REG_OUTCSR		(USB_BASE + 0x16) /* EP1 OUT CSR LSB 8/16bit */
+#define USB_REG_OUTCSRH		(USB_BASE + 0x17) /* EP1 OUT CSR MSB 8-bit */
+#define USB_REG_OUTCOUNT	(USB_BASE + 0x18) /* bytes in EP0/1 OUT FIFO 16-bit */
+
+#define USB_FIFO_EP0		(USB_BASE + 0x20)
+#define USB_FIFO_EP1		(USB_BASE + 0x24)
+#define USB_FIFO_EP2		(USB_BASE + 0x28)
+
+#define USB_REG_EPINFO		(USB_BASE + 0x78) /* Endpoint information */
+#define USB_REG_RAMINFO		(USB_BASE + 0x79) /* RAM information */
+
+#define USB_REG_INTR		(USB_BASE + 0x200) /* DMA pending interrupts */
+#define USB_REG_CNTL1		(USB_BASE + 0x204) /* DMA channel 1 control */
+#define USB_REG_ADDR1		(USB_BASE + 0x208) /* DMA channel 1 AHB memory addr */
+#define USB_REG_COUNT1		(USB_BASE + 0x20c) /* DMA channel 1 byte count */
+#define USB_REG_CNTL2		(USB_BASE + 0x214) /* DMA channel 2 control */
+#define USB_REG_ADDR2		(USB_BASE + 0x218) /* DMA channel 2 AHB memory addr */
+#define USB_REG_COUNT2		(USB_BASE + 0x21c) /* DMA channel 2 byte count */
+
+
+/* Power register bit masks */
+#define USB_POWER_SUSPENDM	0x01
+#define USB_POWER_RESUME	0x04
+#define USB_POWER_HSMODE	0x10
+#define USB_POWER_HSENAB	0x20
+#define USB_POWER_SOFTCONN	0x40
+
+/* Interrupt register bit masks */
+#define USB_INTR_SUSPEND	0x01
+#define USB_INTR_RESUME		0x02
+#define USB_INTR_RESET		0x04
+
+#define USB_INTR_EP0		0x0001
+#define USB_INTR_INEP1		0x0002
+#define USB_INTR_INEP2		0x0004
+#define USB_INTR_OUTEP1		0x0002
+
+/* CSR0 bit masks */
+#define USB_CSR0_OUTPKTRDY	0x01
+#define USB_CSR0_INPKTRDY	0x02
+#define USB_CSR0_SENTSTALL	0x04
+#define USB_CSR0_DATAEND	0x08
+#define USB_CSR0_SETUPEND	0x10
+#define USB_CSR0_SENDSTALL	0x20
+#define USB_CSR0_SVDOUTPKTRDY	0x40
+#define USB_CSR0_SVDSETUPEND	0x80
+
+/* Endpoint CSR register bits */
+#define USB_INCSRH_AUTOSET	0x80
+#define USB_INCSRH_ISO		0x40
+#define USB_INCSRH_MODE		0x20
+#define USB_INCSRH_DMAREQENAB	0x10
+#define USB_INCSRH_DMAREQMODE	0x04
+#define USB_INCSR_CDT		0x40
+#define USB_INCSR_SENTSTALL	0x20
+#define USB_INCSR_SENDSTALL	0x10
+#define USB_INCSR_FF		0x08
+#define USB_INCSR_UNDERRUN	0x04
+#define USB_INCSR_FFNOTEMPT	0x02
+#define USB_INCSR_INPKTRDY	0x01
+#define USB_OUTCSRH_AUTOCLR	0x80
+#define USB_OUTCSRH_ISO		0x40
+#define USB_OUTCSRH_DMAREQENAB	0x20
+#define USB_OUTCSRH_DNYT	0x10
+#define USB_OUTCSRH_DMAREQMODE	0x08
+#define USB_OUTCSR_CDT		0x80
+#define USB_OUTCSR_SENTSTALL	0x40
+#define USB_OUTCSR_SENDSTALL	0x20
+#define USB_OUTCSR_FF		0x10
+#define USB_OUTCSR_DATAERR	0x08
+#define USB_OUTCSR_OVERRUN	0x04
+#define USB_OUTCSR_FFFULL	0x02
+#define USB_OUTCSR_OUTPKTRDY	0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK		0x01
+#define USB_TEST_J		0x02
+#define USB_TEST_K		0x04
+#define USB_TEST_PACKET		0x08
+
+/* DMA control bits */
+#define USB_CNTL_ENA		0x01
+#define USB_CNTL_DIR_IN		0x02
+#define USB_CNTL_MODE_1		0x04
+#define USB_CNTL_INTR_EN	0x08
+#define USB_CNTL_EP(n)		((n) << 4)
+#define USB_CNTL_BURST_0	(0 << 9)
+#define USB_CNTL_BURST_4	(1 << 9)
+#define USB_CNTL_BURST_8	(2 << 9)
+#define USB_CNTL_BURST_16	(3 << 9)
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define	BCH_CR         	(BCH_BASE + 0x00) /* BCH Control register */
+#define	BCH_CRS       	(BCH_BASE + 0x04) /* BCH Control Set register */
+#define	BCH_CRC       	(BCH_BASE + 0x08) /* BCH Control Clear register */
+#define	BCH_CNT    	(BCH_BASE + 0x0C) /* BCH ENC/DEC Count register */
+#define	BCH_DR     	(BCH_BASE + 0x10) /* BCH data register */
+#define	BCH_PAR0    	(BCH_BASE + 0x14) /* BCH Parity 0 register */
+#define	BCH_PAR1    	(BCH_BASE + 0x18) /* BCH Parity 1 register */
+#define	BCH_PAR2    	(BCH_BASE + 0x1C) /* BCH Parity 2 register */
+#define	BCH_PAR3    	(BCH_BASE + 0x20) /* BCH Parity 3 register */
+#define	BCH_INTS    	(BCH_BASE + 0x24) /* BCH Interrupt Status register */
+#define	BCH_ERR0        (BCH_BASE + 0x28) /* BCH Error Report 0 register */
+#define	BCH_ERR1        (BCH_BASE + 0x2C) /* BCH Error Report 1 register */
+#define	BCH_ERR2        (BCH_BASE + 0x30) /* BCH Error Report 2 register */
+#define	BCH_ERR3        (BCH_BASE + 0x34) /* BCH Error Report 3 register */
+#define	BCH_INTE        (BCH_BASE + 0x38) /* BCH Interrupt Enable register */
+#define	BCH_INTES       (BCH_BASE + 0x3C) /* BCH Interrupt Set register */
+#define	BCH_INTEC       (BCH_BASE + 0x40) /* BCH Interrupt Clear register */
+
+#define	REG_BCH_CR      REG32(BCH_CR)
+#define	REG_BCH_CRS     REG32(BCH_CRS)
+#define	REG_BCH_CRC     REG32(BCH_CRC)
+#define	REG_BCH_CNT     REG32(BCH_CNT)
+#define	REG_BCH_DR      REG8(BCH_DR)
+#define	REG_BCH_PAR0    REG32(BCH_PAR0)
+#define	REG_BCH_PAR1    REG32(BCH_PAR1)
+#define	REG_BCH_PAR2    REG32(BCH_PAR2)
+#define	REG_BCH_PAR3    REG32(BCH_PAR3)
+#define	REG_BCH_INTS    REG32(BCH_INTS)
+#define	REG_BCH_ERR0    REG32(BCH_ERR0)
+#define	REG_BCH_ERR1    REG32(BCH_ERR1)
+#define	REG_BCH_ERR2    REG32(BCH_ERR2)
+#define	REG_BCH_ERR3    REG32(BCH_ERR3)
+#define	REG_BCH_INTE    REG32(BCH_INTE)
+#define	REG_BCH_INTEC   REG32(BCH_INTEC)
+#define	REG_BCH_INTES   REG32(BCH_INTES)
+
+/* BCH Control Register*/
+#define	BCH_CR_DMAE              (1 << 4)  /* BCH DMA Enable */
+#define	BCH_CR_ENCE              (1 << 3)  /* BCH Encoding Select */
+#define	BCH_CR_DECE              (0 << 3)  /* BCH Decoding Select */
+#define	BCH_CR_BSEL8             (1 << 2)  /* 8 Bit BCH Select */
+#define	BCH_CR_BSEL4             (0 << 2)  /* 4 Bit BCH Select */
+#define	BCH_CR_BRST              (1 << 1)  /* BCH Reset */
+#define	BCH_CR_BCHE              (1 << 0)  /* BCH Enable */
+
+/* BCH Interrupt Status Register */
+#define	BCH_INTS_ERRC_BIT        28
+#define	BCH_INTS_ERRC_MASK       (0xf << BCH_INTS_ERRC_BIT)
+#define	BCH_INTS_ALL0            (1 << 5)
+#define	BCH_INTS_ALLf            (1 << 4)
+#define	BCH_INTS_DECF            (1 << 3)
+#define	BCH_INTS_ENCF            (1 << 2)
+#define	BCH_INTS_UNCOR           (1 << 1)
+#define	BCH_INTS_ERR             (1 << 0)
+
+/* BCH ENC/DEC Count Register */
+#define BCH_CNT_DEC_BIT          16
+#define BCH_CNT_DEC_MASK         (0x3ff << BCH_CNT_DEC_BIT)
+#define BCH_CNT_ENC_BIT          0
+#define BCH_CNT_ENC_MASK         (0x3ff << BCH_CNT_ENC_BIT)
+
+/* BCH Error Report Register */
+#define BCH_ERR_INDEX_ODD_BIT    16
+#define BCH_ERR_INDEX_ODD_MASK   (0x1fff << BCH_ERR_INDEX_ODD_BIT)
+#define BCH_ERR_INDEX_EVEN_BIT   0
+#define BCH_ERR_INDEX_EVEN_MASK  (0x1fff << BCH_ERR_INDEX_EVEN_BIT)
+
+
+//----------------------------------------------------------------------
+//
+// Module Operation Definitions
+//
+//----------------------------------------------------------------------
+#ifndef __ASSEMBLY__
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+//------------------------------------------------------
+// GPIO Pins Description
+//
+// PORT 0:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		D0		-
+//	1		D1		-
+//	2		D2		-
+//	3		D3		-
+//	4		D4		-
+//	5		D5		-
+//	6		D6		-
+//	7		D7		-
+//	8		D8		-
+//	9		D9		-
+//	10		D10		-
+//	11		D11		-
+//	12		D12		-
+//	13		D13		-
+//	14		D14		-
+//	15		D15		-
+//	16		D16		-
+//	17		D17		-
+//	18		D18		-
+//	19		D19		-
+//	20		D20		-
+//	21		D21		-
+//	22		D22		-
+//	23		D23		-
+//	24		D24		-
+//	25		D25		-
+//	26		D26		-
+//	27		D27		-
+//	28		D28		-
+//	29		D29		-
+//	30		D30		-
+//	31		D31		-
+//
+//------------------------------------------------------
+// PORT 1:
+//
+// PIN/BIT N		FUNC0		FUNC1	       FUNC2         NOTE
+//	0		A0		-              -
+//	1		A1		-              -
+//	2		A2		-              -
+//	3		A3		-              -
+//	4		A4		-              -
+//	5		A5		-              -
+//	6		A6		-              -
+//	7		A7		-              -
+//	8		A8		-              -
+//	9		A9		-              -
+//	10		A10		-              -
+//	11		A11		-              -
+//	12		A12		-              -
+//	13		A13		-              -
+//	14		A14		-              -
+//	15		A15/CLE		CL(unshare)    MSC0_CLK
+//	16		DCS0#		-              -
+//	17		RAS#		-              -
+//	18		CAS#		-              -
+//	19		SDWE#/BUFD#	-              -
+//	20		WE0#		-              -
+//	21		WE1#		-              -
+//	22		WE2#		-              -
+//	23		WE3#		-              -
+//	24		CKO		-	       -              Note1
+//	25		CKE		-              -
+//	26		SSI_CLK	        MSC1_CLK       -
+//	27		SSI_DT		MSC1_D1        -
+//	28		SSI_DR		MSC1_D0        -
+//	29		SSI_CE0#	MSC1_CMD       -
+//	30		SSI_GPC	        MSC1_D2        -
+//	31		SSI_CE1#	MSC1_D3        -
+//
+// Note1: BIT24: it is CKO when chip is reset
+//
+//------------------------------------------------------
+// PORT 2:
+//
+// PIN/BIT N		FUNC0		FUNC1		FUNC2         NOTE
+//	0		SD0		A20             -
+//	1		SD1		A21             -
+//	2		SD2		A22             -
+//	3		SD3		A23             -
+//	4		SD4		A24             -
+//	5		SD5		A25             -
+//	6		SD6		-               -
+//	7		SD7		-               -
+//	8		SD8		TSDI0           -
+//	9		SD9		TSDI1           -
+//	10		SD10		TSDI2           -
+//	11		SD11		TSDI3           -
+//	12		SD12		TSDI4           -
+//	13		SD13		TSDI5           -
+//	14		SD14		TSDI6           -
+//	15		SD15		TSDI7           -
+//	16		A16/ALE		AL(unshare)     MSC0_CMD
+//	17		A17             MSC0_D3         -
+//	18		A18             DREQ            -
+//	19		A19             DACK            -
+//	20		WAIT#		-		-             Note2
+//	21		CS1#		-               - 
+//	22		CS2#		-               -
+//	23		CS3#		-               -
+//	24		CS4#		-               -
+//	25		RD#		-               -
+//	26		WR#		-               -
+//	27		FRB#		-		-             Note3
+//	28		FRE#		MSC0_D0         -
+//	29		FWE#		MSC0_D1         -
+//	30		-       	-		-             Note4
+//	31		-       	-		-             Note5
+//
+// Note2: BIT20: it is WIAT# pin when chip is reset
+//
+// Note3: BIT27: when NAND is used, it should connect to NANF FRB#.
+//
+// Note4: BIT30: it is BOOT_SEL0 which would be set as input without pulling when chip is reset.
+//
+// Note5: BIT31: it is BOOT_SEL1 which would be set as input without pulling when chip is reset.
+//
+//------------------------------------------------------
+// PORT 3:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		LCD_B2		-
+//	1		LCD_B3		-
+//	2		LCD_B4		-
+//	3		LCD_B5		-
+//	4		LCD_B6		-
+//	5		LCD_B7		-
+//	6		LCD_G2		-
+//	7		LCD_G3		-
+//	8		LCD_G4		-
+//	9		LCD_G5		-
+//	10		LCD_G6		-
+//	11		LCD_G7		-
+//	12		LCD_R2		-
+//	13		LCD_R3		-
+//	14		LCD_R4		-
+//	15		LCD_R5		-
+//	16		LCD_R6		-
+//	17		LCD_R7		-
+//	18		LCD_PCLK	-
+//	19		LCD_HSYNC	-
+//	20		LCD_VSYNC	-
+//	21		LCD_DE		-
+//	22		LCD_CLS		LCD_R1
+//	23		LCD_SPL		LCD_G0
+//	24		LCD_PS		LCD_G1
+//	25		LCD_REV		LCD_B1
+//	26		LCD_B0   	-
+//	27		LCD_R0		-
+//	28		UART0_RXD	TSCLK
+//	29		UART0_TXD	TSSTR
+//	30		UART0_CTS	TSFRM
+//	31		UART0_RTS	TSFAIL
+//
+//------------------------------------------------------
+// PORT 4:
+//
+// PIN/BIT N		FUNC0		FUNC1	       FUNC2         NOTE
+//	0		CIM_D0		TSDI0          -
+//	1		CIM_D1		TSDI1          -
+//	2		CIM_D2		TSDI2          -
+//	3		CIM_D3		TSDI3          -
+//	4		CIM_D4		TSDI4          -
+//	5		CIM_D5		TSDI5          -
+//	6		CIM_D6		TSDI6          -
+//	7		CIM_D7		TSDI7          -
+//	8		CIM_MCLK	TSFAIL         -
+//	9		CIM_PCLK	TSCLK          -
+//	10		CIM_VSYNC	TSSTR          -
+//	11		CIM_HSYNC	TSFRM          -
+//	12		I2C_SDA		-              -
+//	13		I2C_SCK		-              -
+//	18		SDATO           -              -
+//	19		SDATI           -              -
+//	20		PWM0		-              -
+//	22		PWM2		SYNC           -
+//	23		PWM3		UART1_RxD      BCLK
+//	24		PWM4		-              -
+//	25		PWM5		UART1_TxD      SCLK_RSTN
+//	28		DCS1#		-              -
+//	29		-        	-              -              Note6
+//	30		WKUP		-	       -              Note7
+//	31		-		-	       -              Note8
+//
+// Note6: BIT29: it is BOOT_SEL2 which would be set as input without pulling when chip is reset.
+// Note7: BIT30: it is only used as input and interrupt, and with no pull-up and pull-down
+// Note8: BIT31: it is used to select the function of UART or JTAG set by PESEL[31]
+//        PESEL[31] = 0, select JTAG function
+//        PESEL[31] = 1, select UART function
+//
+//------------------------------------------------------
+// PORT 5:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	10		SSI_CLK		-
+//	11	        SSI_DT		PWM1
+//	12		SSI_DR		-
+//	13		SSI_CE0#	-
+//	14		SSI_GPC 	-
+//	15		SSI_CE2#	-
+//
+//////////////////////////////////////////////////////////
+
+/*----------------------------------------------------------------
+ * p is the port number (0,1,2,3,4,5)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-127), regardless of the port
+ */
+
+//----------------------------------------------------------------
+// Function Pins Mode
+
+#define is_share_mode() ((REG_EMC_BCR & EMC_BCR_BSR_MASK) == EMC_BCR_BSR_SHARE)
+
+#define __gpio_as_func0(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func1(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func2(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_32bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ * !!!!DCS1#
+ */
+#define __gpio_as_sdram_x2_32bit()		\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+	REG_GPIO_PXFUNS(4) = 0x10000000;	\
+	REG_GPIO_PXSELC(4) = 0x10000000;	\
+	REG_GPIO_PXPES(4) = 0x10000000;		\
+} while (0)
+/*
+ * D0 ~ D15, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;	\
+	REG_GPIO_PXPES(0) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD
+ */
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x30000000;	\
+	REG_GPIO_PXSELC(3) = 0x30000000;	\
+	REG_GPIO_PXPES(3) = 0x30000000;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD, UART0_CTS, UART0_RTS
+ */
+#define __gpio_as_uart0_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xf0000000;	\
+	REG_GPIO_PXSELC(3) = 0xf0000000;	\
+	REG_GPIO_PXPES(3) = 0xf0000000;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD
+ */
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x02800000;	\
+	REG_GPIO_PXSELC(4) = 0x02800000;	\
+	REG_GPIO_PXPES(4) = 0x02800000;		\
+} while (0)
+
+/*
+ * UART2_TxD, UART2_RxD, UART2_CTS, UART2_RTS using JTAG pins
+ */
+#define __gpio_as_uart2()			\
+do {						\
+	REG_GPIO_PXSELS(4) = 0x80000000;	\
+} while (0)
+
+/*
+ * D0 ~ D7, CS1#, CLE, ALE, FRE#, FWE#, FRB#, RDWE#/BUFD#
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nand_8bit(n)						\
+do {		              						\
+	if (!is_share_mode()) {						\
+		/* unshare mode */					\
+		REG_GPIO_PXFUNS(2) = 0x000000ff; /* SD0~SD7 */		\
+		REG_GPIO_PXSELS(2) = 0x000000ff;			\
+		REG_GPIO_PXPES(2) = 0x000000ff;				\
+		REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(SA3) */		\
+		REG_GPIO_PXSELS(1) = 0x00008000;			\
+		REG_GPIO_PXPES(1) = 0x00008000;				\
+		REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(SA4) */		\
+		REG_GPIO_PXSELS(2) = 0x00010000;			\
+		REG_GPIO_PXPES(2) = 0x00010000;				\
+	} else {							\
+		/* 32/16-bit data bus */				\
+		REG_GPIO_PXFUNS(0) = 0x000000ff; /* D0~D7 */		\
+		REG_GPIO_PXSELC(0) = 0x000000ff;			\
+		REG_GPIO_PXPES(0) = 0x000000ff;				\
+		REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(A15) */		\
+		REG_GPIO_PXSELC(1) = 0x00008000;			\
+		REG_GPIO_PXPES(1) = 0x00008000;				\
+		REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(A16) */		\
+		REG_GPIO_PXSELC(2) = 0x00010000;			\
+		REG_GPIO_PXPES(2) = 0x00010000;				\
+	}								\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+        REG_GPIO_PXFUNS(1) = 0x00080000; /* RDWE#/BUFD# */		\
+        REG_GPIO_PXSELC(1) = 0x00080000;				\
+	REG_GPIO_PXPES(1) = 0x00080000;					\
+	REG_GPIO_PXFUNS(2) = 0x30000000; /* FRE#, FWE# */		\
+	REG_GPIO_PXSELC(2) = 0x30000000;				\
+	REG_GPIO_PXPES(2) = 0x30000000;					\
+	REG_GPIO_PXFUNC(2) = 0x08000000; /* FRB#(input) */		\
+	REG_GPIO_PXSELC(2) = 0x08000000;				\
+	REG_GPIO_PXDIRC(2) = 0x08000000;				\
+	REG_GPIO_PXPES(2) = 0x08000000;					\
+} while (0)
+
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D7
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nor_8bit(n)						\
+do {								        \
+	/* 32/16-bit data bus */					\
+	REG_GPIO_PXFUNS(0) = 0x000000ff;				\
+	REG_GPIO_PXSELC(0) = 0x000000ff;				\
+	REG_GPIO_PXPES(0) = 0x000000ff;					\
+									\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff; /* A0~A15 */			\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;				\
+	REG_GPIO_PXPES(1) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(2) = 0x06110007; /* RD#, WR#, WAIT#, A20~A22 */	\
+	REG_GPIO_PXSELC(2) = 0x06110007;				\
+	REG_GPIO_PXPES(2) = 0x06110007;					\
+	REG_GPIO_PXFUNS(2) = 0x000e0000; /* A17~A19 */	        	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;				\
+	REG_GPIO_PXPES(2) = 0x000e0000;					\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D15
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nor_16bit(n)						\
+do {	               							\
+	/* 32/16-bit data normal order */				\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;				\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;				\
+	REG_GPIO_PXPES(0) = 0x0000ffff;					\
+									\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff; /* A0~A15 */			\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;				\
+	REG_GPIO_PXPES(1) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(2) = 0x06110007; /* RD#, WR#, WAIT#, A20~A22 */	\
+	REG_GPIO_PXSELC(2) = 0x06110007;				\
+	REG_GPIO_PXPES(2) = 0x06110007;					\
+	REG_GPIO_PXFUNS(2) = 0x000e0000; /* A17~A19 */	        	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;				\
+	REG_GPIO_PXPES(2) = 0x000e0000;					\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D7, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003c00ff;	\
+	REG_GPIO_PXTRGC(3) = 0x003c00ff;	\
+	REG_GPIO_PXSELC(3) = 0x003c00ff;	\
+	REG_GPIO_PXPES(3) = 0x003c00ff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D15, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003cffff;	\
+	REG_GPIO_PXTRGC(3) = 0x003cffff;	\
+	REG_GPIO_PXSELC(3) = 0x003cffff;	\
+	REG_GPIO_PXPES(3) = 0x003cffff;		\
+} while (0)
+
+/*
+ * LCD_R2~LCD_R7, LCD_G2~LCD_G7, LCD_B2~LCD_B7,
+ * LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003fffff;	\
+	REG_GPIO_PXTRGC(3) = 0x003fffff;	\
+	REG_GPIO_PXSELC(3) = 0x003fffff;	\
+	REG_GPIO_PXPES(3) = 0x003fffff;		\
+} while (0)
+
+/*
+ * LCD_R0~LCD_R7, LCD_G0~LCD_G7, LCD_B0~LCD_B7,
+ * LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_24bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x0fffffff;	\
+	REG_GPIO_PXTRGC(3) = 0x0fffffff;	\
+	REG_GPIO_PXSELC(3) = 0x0c3fffff;	\
+	REG_GPIO_PXSELS(3) = 0x03c00000;	\
+	REG_GPIO_PXPES(3) = 0x0fffffff;		\
+} while (0)
+
+/*
+ *  LCD_CLS, LCD_SPL, LCD_PS, LCD_REV
+ */
+#define __gpio_as_lcd_special()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x03C00000;	\
+	REG_GPIO_PXSELC(3) = 0x03C00000;	\
+	REG_GPIO_PXPES(3)  = 0x03C00000;	\
+} while (0)
+
+/*
+ * CIM_D0~CIM_D7, CIM_MCLK, CIM_PCLK, CIM_VSYNC, CIM_HSYNC
+ */
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00000fff;	\
+	REG_GPIO_PXSELC(4) = 0x00000fff;	\
+	REG_GPIO_PXPES(4)  = 0x00000fff;	\
+} while (0)
+
+/* 
+ * SDATO, SDATI, BCLK, SYNC, SCLK_RSTN(gpio sepc) or
+ * SDATA_OUT, SDATA_IN, BIT_CLK, SYNC, SCLK_RESET(aic spec)
+ */
+#define __gpio_as_aic()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x16c00000;	\
+	REG_GPIO_PXTRGC(4) = 0x02c00000;	\
+	REG_GPIO_PXTRGS(4) = 0x14000000;	\
+	REG_GPIO_PXSELC(4) = 0x14c00000;	\
+	REG_GPIO_PXSELS(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4)  = 0x16c00000;	\
+} while (0)
+
+/*
+ * MSC0_CMD, MSC0_CLK, MSC0_D0 ~ MSC0_D3
+ */
+#define __gpio_as_msc0_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0x00008000;	\
+	REG_GPIO_PXTRGS(1) = 0x00008000;	\
+	REG_GPIO_PXSELC(1) = 0x00008000;	\
+	REG_GPIO_PXPES(1)  = 0x00008000;	\
+	REG_GPIO_PXFUNS(2) = 0x38030000;	\
+	REG_GPIO_PXTRGS(2) = 0x00010000;	\
+	REG_GPIO_PXTRGC(2) = 0x38020000;	\
+	REG_GPIO_PXSELC(2) = 0x08010000;	\
+	REG_GPIO_PXSELS(2) = 0x30020000;	\
+	REG_GPIO_PXPES(2)  = 0x38030000;	\
+} while (0)
+
+/*
+ * MSC1_CMD, MSC1_CLK, MSC1_D0 ~ MSC1_D3
+ */
+#define __gpio_as_msc1_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0xfc000000;	\
+	REG_GPIO_PXTRGC(1) = 0xfc000000;	\
+	REG_GPIO_PXSELC(1) = 0xfc000000;	\
+	REG_GPIO_PXPES(1)  = 0xfc000000;	\
+} while (0)
+
+#define __gpio_as_msc 	__gpio_as_msc0_4bit /* default as msc0 4bit */
+#define __gpio_as_msc0 	__gpio_as_msc0_4bit /* msc0 default as 4bit */
+#define __gpio_as_msc1 	__gpio_as_msc1_4bit /* msc1 only support 4bit */
+
+/*
+ * SSI_CE0, SSI_CE1, SSI_GPC, SSI_CLK, SSI_DT, SSI_DR
+ */
+#define __gpio_as_ssi()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0xfc000000;	\
+	REG_GPIO_PXTRGC(1) = 0xfc000000;	\
+	REG_GPIO_PXSELC(1) = 0xfc000000;	\
+	REG_GPIO_PXPES(1)  = 0xfc000000;	\
+} while (0)
+
+/*
+ * SSI_CE0, SSI_CE2, SSI_GPC, SSI_CLK, SSI_DT, SSI1_DR
+ */
+#define __gpio_as_ssi_1()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x0000fc00;	\
+	REG_GPIO_PXTRGC(5) = 0x0000fc00;	\
+	REG_GPIO_PXSELC(5) = 0x0000fc00;	\
+	REG_GPIO_PXPES(5)  = 0x0000fc00;	\
+} while (0)
+
+/*
+ * I2C_SCK, I2C_SDA
+ */
+#define __gpio_as_i2c()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00003000;	\
+	REG_GPIO_PXSELC(4) = 0x00003000;	\
+	REG_GPIO_PXPES(4)  = 0x00003000;	\
+} while (0)
+
+/*
+ * PWM0
+ */
+#define __gpio_as_pwm0()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00100000;	\
+	REG_GPIO_PXSELC(4) = 0x00100000;	\
+	REG_GPIO_PXPES(4) = 0x00100000;		\
+} while (0)
+
+/*
+ * PWM1
+ */
+#define __gpio_as_pwm1()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000800;	\
+	REG_GPIO_PXSELC(5) = 0x00000800;	\
+	REG_GPIO_PXPES(5) = 0x00000800;		\
+} while (0)
+
+/*
+ * PWM2
+ */
+#define __gpio_as_pwm2()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00400000;	\
+	REG_GPIO_PXSELC(4) = 0x00400000;	\
+	REG_GPIO_PXPES(4) = 0x00400000;		\
+} while (0)
+
+/*
+ * PWM3
+ */
+#define __gpio_as_pwm3()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00800000;	\
+	REG_GPIO_PXSELC(4) = 0x00800000;	\
+	REG_GPIO_PXPES(4) = 0x00800000;		\
+} while (0)
+
+/*
+ * PWM4
+ */
+#define __gpio_as_pwm4()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x01000000;	\
+	REG_GPIO_PXSELC(4) = 0x01000000;	\
+	REG_GPIO_PXPES(4) = 0x01000000;		\
+} while (0)
+
+/*
+ * PWM5
+ */
+#define __gpio_as_pwm5()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x02000000;	\
+	REG_GPIO_PXSELC(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4) = 0x02000000;		\
+} while (0)
+
+/*
+ * n = 0 ~ 5
+ */
+#define __gpio_as_pwm(n)	__gpio_as_pwm##n()
+
+//-------------------------------------------
+// GPIO or Interrupt Mode
+
+#define __gpio_get_port(p)	(REG_GPIO_PXPIN(p))
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRS(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRC(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_pin(n)			\
+({						\
+	unsigned int p, o, v;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (__gpio_get_port(p) & (1 << o))	\
+		v = 1;				\
+	else					\
+		v = 0;				\
+	v;					\
+})
+
+#define __gpio_as_irq_high_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_low_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_rise_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_fall_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_irq()			\
+({						\
+	unsigned int p, i, tmp, v = 0;		\
+	for (p = 3; p >= 0; p--) {		\
+		tmp = REG_GPIO_PXFLG(p);	\
+		for (i = 0; i < 32; i++)	\
+			if (tmp & (1 << i))	\
+				v = (32*p + i);	\
+	}					\
+	v;					\
+})
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_PXFLG((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPEC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPES(p) = (1 << o);		\
+} while (0)
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_get_pllm() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLM_MASK) >> CPM_CPPCR_PLLM_BIT)
+#define __cpm_get_plln() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLN_MASK) >> CPM_CPPCR_PLLN_BIT)
+#define __cpm_get_pllod() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLOD_MASK) >> CPM_CPPCR_PLLOD_BIT)
+
+#define __cpm_get_cdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_CDIV_MASK) >> CPM_CPCCR_CDIV_BIT)
+#define __cpm_get_hdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_HDIV_MASK) >> CPM_CPCCR_HDIV_BIT)
+#define __cpm_get_pdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_PDIV_MASK) >> CPM_CPCCR_PDIV_BIT)
+#define __cpm_get_mdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT)
+#define __cpm_get_ldiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_LDIV_MASK) >> CPM_CPCCR_LDIV_BIT)
+#define __cpm_get_udiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_UDIV_MASK) >> CPM_CPCCR_UDIV_BIT)
+#define __cpm_get_i2sdiv() \
+	((REG_CPM_I2SCDR & CPM_I2SCDR_I2SDIV_MASK) >> CPM_I2SCDR_I2SDIV_BIT)
+#define __cpm_get_pixdiv() \
+	((REG_CPM_LPCDR & CPM_LPCDR_PIXDIV_MASK) >> CPM_LPCDR_PIXDIV_BIT)
+#define __cpm_get_mscdiv(n) \
+	((REG_CPM_MSCCDR(n) & CPM_MSCCDR_MSCDIV_MASK) >> CPM_MSCCDR_MSCDIV_BIT)
+#define __cpm_get_uhcdiv() \
+	((REG_CPM_UHCCDR & CPM_UHCCDR_UHCDIV_MASK) >> CPM_UHCCDR_UHCDIV_BIT)
+#define __cpm_get_ssidiv() \
+	((REG_CPM_SSICCDR & CPM_SSICDR_SSICDIV_MASK) >> CPM_SSICDR_SSIDIV_BIT)
+#define __cpm_get_pcmdiv(v) \
+	((REG_CPM_PCMCDR & CPM_PCMCDR_PCMCD_MASK) >> CPM_PCMCDR_PCMCD_BIT)
+
+#define __cpm_set_cdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_CDIV_MASK) | ((v) << (CPM_CPCCR_CDIV_BIT)))
+#define __cpm_set_hdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_HDIV_MASK) | ((v) << (CPM_CPCCR_HDIV_BIT)))
+#define __cpm_set_pdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_PDIV_MASK) | ((v) << (CPM_CPCCR_PDIV_BIT)))
+#define __cpm_set_mdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_MDIV_MASK) | ((v) << (CPM_CPCCR_MDIV_BIT)))
+#define __cpm_set_ldiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_LDIV_MASK) | ((v) << (CPM_CPCCR_LDIV_BIT)))
+#define __cpm_set_udiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_UDIV_MASK) | ((v) << (CPM_CPCCR_UDIV_BIT)))
+#define __cpm_set_i2sdiv(v) \
+	(REG_CPM_I2SCDR = (REG_CPM_I2SCDR & ~CPM_I2SCDR_I2SDIV_MASK) | ((v) << (CPM_I2SCDR_I2SDIV_BIT)))
+#define __cpm_set_pixdiv(v) \
+	(REG_CPM_LPCDR = (REG_CPM_LPCDR & ~CPM_LPCDR_PIXDIV_MASK) | ((v) << (CPM_LPCDR_PIXDIV_BIT)))
+#define __cpm_set_mscdiv(n, v) \
+	(REG_CPM_MSCCDR(n) = (REG_CPM_MSCCDR(n) & ~CPM_MSCCDR_MSCDIV_MASK) | ((v) << (CPM_MSCCDR_MSCDIV_BIT)))
+#define __cpm_set_uhcdiv(v) \
+	(REG_CPM_UHCCDR = (REG_CPM_UHCCDR & ~CPM_UHCCDR_UHCDIV_MASK) | ((v) << (CPM_UHCCDR_UHCDIV_BIT)))
+#define __cpm_set_ssidiv(v) \
+	(REG_CPM_SSICDR = (REG_CPM_SSICDR & ~CPM_SSICDR_SSIDIV_MASK) | ((v) << (CPM_SSICDR_SSIDIV_BIT)))
+#define __cpm_set_pcmdiv(v) \
+	(REG_CPM_PCMCDR = (REG_CPM_PCMCDR & ~CPM_PCMCDR_PCMCD_MASK) | ((v) << (CPM_PCMCDR_PCMCD_BIT)))
+
+#define __cpm_select_pcmclk_pll() 	(REG_CPM_PCMCDR |= CPM_PCMCDR_PCMS)
+#define __cpm_select_pcmclk_exclk() 	(REG_CPM_PCMCDR &= ~CPM_PCMCDR_PCMS)
+#define __cpm_select_pixclk_ext()	(REG_CPM_LPCDR |= CPM_LPCDR_LPCS)
+#define __cpm_select_pixclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LPCS)
+#define __cpm_select_tveclk_exclk()	(REG_CPM_LPCDR |= CPM_CPCCR_LSCS)
+#define __cpm_select_tveclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LSCS)
+#define __cpm_select_pixclk_lcd()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LTCS)
+#define __cpm_select_pixclk_tve()	(REG_CPM_LPCDR |= CPM_LPCDR_LTCS)
+#define __cpm_select_i2sclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_I2CS)
+#define __cpm_select_i2sclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_I2CS)
+#define __cpm_select_usbclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_UCS)
+#define __cpm_select_usbclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_UCS)
+
+#define __cpm_enable_cko()
+#define __cpm_exclk_direct()		(REG_CPM_CPCCR &= ~CPM_CPCCR_ECS)
+#define __cpm_exclk_div2()             	(REG_CPM_CPCCR |= CPM_CPCCR_ECS)
+#define __cpm_enable_pll_change()	(REG_CPM_CPCCR |= CPM_CPCCR_CE)
+#define __cpm_pllout_direct()		(REG_CPM_CPCCR |= CPM_CPCCR_PCS)
+#define __cpm_pllout_div2()		(REG_CPM_CPCCR &= ~CPM_CPCCR_PCS)
+#define __cpm_pll_enable()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLEN)
+
+#define __cpm_pll_is_off()		(REG_CPM_CPPSR & CPM_CPPSR_PLLOFF)
+#define __cpm_pll_is_on()		(REG_CPM_CPPSR & CPM_CPPSR_PLLON)
+#define __cpm_pll_bypass()		(REG_CPM_CPPSR |= CPM_CPPSR_PLLBP)
+
+#define __cpm_get_cclk_doze_duty() \
+	((REG_CPM_LCR & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT)
+#define __cpm_set_cclk_doze_duty(v) \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_DOZE_DUTY_MASK) | ((v) << (CPM_LCR_DOZE_DUTY_BIT)))
+
+#define __cpm_doze_mode()		(REG_CPM_LCR |= CPM_LCR_DOZE_ON)
+#define __cpm_idle_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_IDLE)
+#define __cpm_sleep_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_SLEEP)
+
+#define __cpm_stop_all() 	(REG_CPM_CLKGR = 0x1fffffff)
+#define __cpm_stop_cimram()	(REG_CPM_CLKGR |= CPM_CLKGR_CIMRAM)
+#define __cpm_stop_idct()	(REG_CPM_CLKGR |= CPM_CLKGR_IDCT)
+#define __cpm_stop_db()	        (REG_CPM_CLKGR |= CPM_CLKGR_DB)
+#define __cpm_stop_me()	        (REG_CPM_CLKGR |= CPM_CLKGR_ME)
+#define __cpm_stop_mc()	        (REG_CPM_CLKGR |= CPM_CLKGR_MC)
+#define __cpm_stop_tve()        (REG_CPM_CLKGR |= CPM_CLKGR_TVE)
+#define __cpm_stop_tssi()       (REG_CPM_CLKGR |= CPM_CLKGR_TSSI)
+#define __cpm_stop_owi()        (REG_CPM_CLKGR |= CPM_CLKGR_OWI)
+#define __cpm_stop_pcm()        (REG_CPM_CLKGR |= CPM_CLKGR_PCM)
+#define __cpm_stop_uart3()	(REG_CPM_CLKGR |= CPM_CLKGR_UART3)
+#define __cpm_stop_uart2()	(REG_CPM_CLKGR |= CPM_CLKGR_UART2)
+#define __cpm_stop_uart1()	(REG_CPM_CLKGR |= CPM_CLKGR_UART1)
+#define __cpm_stop_uhc()	(REG_CPM_CLKGR |= CPM_CLKGR_UHC)
+#define __cpm_stop_ipu()	(REG_CPM_CLKGR |= CPM_CLKGR_IPU)
+#define __cpm_stop_dmac()	(REG_CPM_CLKGR |= CPM_CLKGR_DMAC)
+#define __cpm_stop_udc()	(REG_CPM_CLKGR |= CPM_CLKGR_UDC)
+#define __cpm_stop_lcd()	(REG_CPM_CLKGR |= CPM_CLKGR_LCD)
+#define __cpm_stop_cim()	(REG_CPM_CLKGR |= CPM_CLKGR_CIM)
+#define __cpm_stop_sadc()	(REG_CPM_CLKGR |= CPM_CLKGR_SADC)
+#define __cpm_stop_msc(n)	(REG_CPM_CLKGR |= CPM_CLKGR_MSC##n)
+#define __cpm_stop_aic1()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC1)
+#define __cpm_stop_aic2()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC2)
+#define __cpm_stop_ssi(n)	(REG_CPM_CLKGR |= CPM_CLKGR_SSI##n)
+#define __cpm_stop_i2c()	(REG_CPM_CLKGR |= CPM_CLKGR_I2C)
+#define __cpm_stop_rtc()	(REG_CPM_CLKGR |= CPM_CLKGR_RTC)
+#define __cpm_stop_tcu()	(REG_CPM_CLKGR |= CPM_CLKGR_TCU)
+#define __cpm_stop_uart0()	(REG_CPM_CLKGR |= CPM_CLKGR_UART0)
+
+#define __cpm_start_all() 	(REG_CPM_CLKGR = 0x0)
+#define __cpm_start_cimram()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIMRAM)
+#define __cpm_start_idct()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IDCT)
+#define __cpm_start_db()        (REG_CPM_CLKGR &= ~CPM_CLKGR_DB)
+#define __cpm_start_me()        (REG_CPM_CLKGR &= ~CPM_CLKGR_ME)
+#define __cpm_start_mc()        (REG_CPM_CLKGR &= ~CPM_CLKGR_MC)
+#define __cpm_start_tve()        (REG_CPM_CLKGR &= ~CPM_CLKGR_TVE)
+#define __cpm_start_tssi()       (REG_CPM_CLKGR &= ~CPM_CLKGR_TSSI)
+#define __cpm_start_owi()        (REG_CPM_CLKGR &= ~CPM_CLKGR_OWI)
+#define __cpm_start_pcm()        (REG_CPM_CLKGR &= ~CPM_CLKGR_PCM)
+#define __cpm_start_uart3()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART3)
+#define __cpm_start_uart2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART2)
+#define __cpm_start_uart1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART1)
+#define __cpm_start_uhc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UHC)
+#define __cpm_start_ipu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IPU)
+#define __cpm_start_dmac()	(REG_CPM_CLKGR &= ~CPM_CLKGR_DMAC)
+#define __cpm_start_udc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UDC)
+#define __cpm_start_lcd()	(REG_CPM_CLKGR &= ~CPM_CLKGR_LCD)
+#define __cpm_start_cim()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIM)
+#define __cpm_start_sadc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SADC)
+#define __cpm_start_msc(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_MSC##n)
+#define __cpm_start_aic1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC1)
+#define __cpm_start_aic2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC2)
+#define __cpm_start_ssi(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_SSI##n)
+#define __cpm_start_i2c()	(REG_CPM_CLKGR &= ~CPM_CLKGR_I2C)
+#define __cpm_start_rtc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_RTC)
+#define __cpm_start_tcu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_TCU)
+#define __cpm_start_uart0()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART0)
+
+#define __cpm_get_o1st() \
+	((REG_CPM_OPCR & CPM_OPCR_O1ST_MASK) >> CPM_OPCR_O1ST_BIT)
+#define __cpm_set_o1st(v) \
+	(REG_CPM_OPCR = (REG_CPM_OPCR & ~CPM_OPCR_O1ST_MASK) | ((v) << (CPM_OPCR_O1ST_BIT)))
+#define __cpm_suspend_uhcphy()		(REG_CPM_OPCR |= CPM_OPCR_UHCPHY_SUSPEND)
+#define __cpm_suspend_udcphy()		(REG_CPM_OPCR &= ~CPM_OPCR_UDCPHY_ENABLE)
+#define __cpm_enable_osc_in_sleep()	(REG_CPM_OPCR |= CPM_OPCR_OSC_ENABLE)
+#define __cpm_select_rtcclk_rtc()	(REG_CPM_OPCR |= CPM_OPCR_ERCS)
+#define __cpm_select_rtcclk_exclk()	(REG_CPM_OPCR &= ~CPM_OPCR_ERCS)
+
+
+#ifdef CFG_EXTAL
+#define JZ_EXTAL		CFG_EXTAL
+#else
+#define JZ_EXTAL		3686400
+#endif
+#define JZ_EXTAL2		32768 /* RTC clock */
+
+/* PLL output frequency */
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned long m, n, no, pllout;
+	unsigned long cppcr = REG_CPM_CPPCR;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if ((cppcr & CPM_CPPCR_PLLEN) && !(cppcr & CPM_CPPCR_PLLBP)) {
+		m = __cpm_get_pllm() + 2;
+		n = __cpm_get_plln() + 2;
+		no = od[__cpm_get_pllod()];
+		pllout = ((JZ_EXTAL) / (n * no)) * m;
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+/* PLL output frequency for MSC/I2S/LCD/USB */
+static __inline__ unsigned int __cpm_get_pllout2(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_PCS)
+		return __cpm_get_pllout();
+	else
+		return __cpm_get_pllout()/2;
+}
+
+/* CPU core clock */
+static __inline__ unsigned int __cpm_get_cclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_cdiv()];
+}
+
+/* AHB system bus clock */
+static __inline__ unsigned int __cpm_get_hclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_hdiv()];
+}
+
+/* Memory bus clock */
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_mdiv()];
+}
+
+/* APB peripheral bus clock */
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_pdiv()];
+}
+
+/* LCDC module clock */
+static __inline__ unsigned int __cpm_get_lcdclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_ldiv() + 1);
+}
+
+/* LCD pixel clock */
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_pixdiv() + 1);
+}
+
+/* I2S clock */
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_I2CS) {
+		return __cpm_get_pllout2() / (__cpm_get_i2sdiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* USB clock */
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_UCS) {
+		return __cpm_get_pllout2() / (__cpm_get_udiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+static __inline__ unsigned int __cpm_get_extalclk(void)
+{
+	return JZ_EXTAL;
+}
+
+/* RTC clock for CPM,INTC,RTC,TCU,WDT */
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+/*
+ * Output 24MHz for SD and 16MHz for MMC.
+ */
+static inline void __cpm_select_msc_clk(int n, int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	if (sd) {
+		div = pllout2 / 24000000;
+	}
+	else {
+		div = pllout2 / 16000000;
+	}
+
+	REG_CPM_MSCCDR(n) = div - 1;
+	REG_CPM_CPCCR |= CPM_CPCCR_CE;
+}
+
+/***************************************************************************
+ * TCU
+ ***************************************************************************/
+// where 'n' is the TCU channel
+#define __tcu_select_extalclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_EXT_EN)
+#define __tcu_select_rtcclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_RTC_EN)
+#define __tcu_select_pclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_PCK_EN)
+
+#define __tcu_select_clk_div1(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1)
+#define __tcu_select_clk_div4(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE4)
+#define __tcu_select_clk_div16(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE16)
+#define __tcu_select_clk_div64(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE64)
+#define __tcu_select_clk_div256(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE256)
+#define __tcu_select_clk_div1024(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1024)
+
+#define __tcu_enable_pwm_output(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_EN )
+#define __tcu_disable_pwm_output(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_EN )
+
+#define __tcu_init_pwm_output_high(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_INITL_HIGH )
+#define __tcu_init_pwm_output_low(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_INITL_HIGH )
+
+#define __tcu_set_pwm_output_shutdown_graceful(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_SD )
+#define __tcu_set_pwm_output_shutdown_abrupt(n)		( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_SD )
+
+#define __tcu_start_counter(n)		( REG_TCU_TESR |= (1 << (n)) )
+#define __tcu_stop_counter(n)		( REG_TCU_TECR |= (1 << (n)) )
+
+#define __tcu_half_match_flag(n)	( REG_TCU_TFR & (1 << ((n) + 16)) )
+#define __tcu_full_match_flag(n)	( REG_TCU_TFR & (1 << (n)) )
+#define __tcu_set_half_match_flag(n)	( REG_TCU_TFSR = (1 << ((n) + 16)) )
+#define __tcu_set_full_match_flag(n)	( REG_TCU_TFSR = (1 << (n)) )
+#define __tcu_clear_half_match_flag(n)	( REG_TCU_TFCR = (1 << ((n) + 16)) )
+#define __tcu_clear_full_match_flag(n)	( REG_TCU_TFCR = (1 << (n)) )
+#define __tcu_mask_half_match_irq(n)	( REG_TCU_TMSR = (1 << ((n) + 16)) )
+#define __tcu_mask_full_match_irq(n)	( REG_TCU_TMSR = (1 << (n)) )
+#define __tcu_unmask_half_match_irq(n)	( REG_TCU_TMCR = (1 << ((n) + 16)) )
+#define __tcu_unmask_full_match_irq(n)	( REG_TCU_TMCR = (1 << (n)) )
+
+#define __tcu_wdt_clock_stopped()	( REG_TCU_TSR & TCU_TSSR_WDTSC )
+#define __tcu_timer_clock_stopped(n)	( REG_TCU_TSR & (1 << (n)) )
+
+#define __tcu_start_wdt_clock()		( REG_TCU_TSCR = TCU_TSSR_WDTSC )
+#define __tcu_start_timer_clock(n)	( REG_TCU_TSCR = (1 << (n)) )
+
+#define __tcu_stop_wdt_clock()		( REG_TCU_TSSR = TCU_TSSR_WDTSC )
+#define __tcu_stop_timer_clock(n)	( REG_TCU_TSSR = (1 << (n)) )
+
+#define __tcu_get_count(n)		( REG_TCU_TCNT((n)) )
+#define __tcu_set_count(n,v)		( REG_TCU_TCNT((n)) = (v) )
+#define __tcu_set_full_data(n,v)	( REG_TCU_TDFR((n)) = (v) )
+#define __tcu_set_half_data(n,v)	( REG_TCU_TDHR((n)) = (v) )
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+#define __wdt_start()			( REG_WDT_TCER |= WDT_TCER_TCEN )
+#define __wdt_stop()			( REG_WDT_TCER &= ~WDT_TCER_TCEN )
+#define __wdt_set_count(v)		( REG_WDT_TCNT = (v) )
+#define __wdt_set_data(v)		( REG_WDT_TDR = (v) )
+
+#define __wdt_select_extalclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_EXT_EN)
+#define __wdt_select_rtcclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_RTC_EN)
+#define __wdt_select_pclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_PCK_EN)
+
+#define __wdt_select_clk_div1() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1)
+#define __wdt_select_clk_div4() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE4)
+#define __wdt_select_clk_div16() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE16)
+#define __wdt_select_clk_div64() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE64)
+#define __wdt_select_clk_div256() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE256)
+#define __wdt_select_clk_div1024() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1024)
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable()			( REG8(UART0_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable()		( REG8(UART0_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq()	( REG8(UART0_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq()	( REG8(UART0_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq() \
+  ( REG8(UART0_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq() \
+  ( REG8(UART0_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback()  	( REG8(UART0_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback() 	( REG8(UART0_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1()		( REG8(UART0_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(devclk, baud)				\
+  do {								\
+	REG8(UART0_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART0_DLLR) = (devclk / 16 / baud) & 0xff;		\
+	REG8(UART0_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART0_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error()		( (REG8(UART0_LSR) & UARTLSR_PER) != 0 )
+#define __uart_clear_errors() \
+  ( REG8(UART0_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty()	( (REG8(UART0_LSR) & UARTLSR_TDRQ) != 0 )
+#define __uart_transmit_end()		( (REG8(UART0_LSR) & UARTLSR_TEMT) != 0 )
+#define __uart_transmit_char(ch)	( REG8(UART0_TDR) = (ch) )
+#define __uart_receive_fifo_full()	( (REG8(UART0_LSR) & UARTLSR_DR) != 0 )
+#define __uart_receive_ready()		( (REG8(UART0_LSR) & UARTLSR_DR) != 0 )
+#define __uart_receive_char()		REG8(UART0_RDR)
+#define __uart_disable_irda()		( REG8(UART0_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(UART0_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define __dmac_enable_module(m) \
+	( REG_DMAC_DMACR(m) |= DMAC_DMACR_DMAE | DMAC_DMACR_PR_012345 )
+#define __dmac_disable_module(m) \
+	( REG_DMAC_DMACR(m) &= ~DMAC_DMACR_DMAE )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(m,p)			\
+do {							\
+	REG_DMAC_DMACR(m) &= ~DMAC_DMACR_PR_MASK;	\
+	REG_DMAC_DMACR(m) |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_HLT )
+#define __dmac_test_addr_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_AR )
+
+#define __dmac_enable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_NDES )
+#define __dmac_disable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_NDES )
+
+#define __dmac_enable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_EN )
+#define __dmac_disable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_EN )
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR((n)) & DMAC_DCCSR_EN )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCMD((n)) |= DMAC_DCMD_TIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_TT )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_AR )
+#define __dmac_channel_count_terminated_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_CT )
+#define __dmac_channel_descriptor_invalid_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_INV )
+
+#define __dmac_channel_clear_transmit_halt(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT )
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TT )
+#define __dmac_channel_clear_address_error(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR )
+#define __dmac_channel_clear_count_terminated(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_CT )
+#define __dmac_channel_clear_descriptor_invalid(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_INV )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_8BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BYTE;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BYTE;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_RDIL_MASK;		\
+	REG_DMAC_DCMD((n) |= ((v) << DMAC_DCMD_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DAI )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_DAI )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SAI )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_SAI )
+
+#define __dmac_channel_set_doorbell(m,n)	\
+	(  REG_DMAC_DMADBSR(m) = (1 << (n)) )
+
+#define __dmac_channel_irq_detected(m,n)  ( REG_DMAC_DMAIPR(m) & (1 << (n)) )
+#define __dmac_channel_ack_irq(m,n)       ( REG_DMAC_DMAIPR(m) &= ~(1 << (n)) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i = 0; i < MAX_DMA_NUM; i++)
+		if (__dmac_channel_irq_detected(i/HALF_DMA_NUM, i-i/HALF_DMA_NUM*HALF_DMA_NUM))
+			return i;
+	return -1;
+}
+
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+#define __aic_reset_status()          ( REG_AIC_FR & AIC_FR_RST )
+
+#define __aic_reset()                                   \
+do {                                                    \
+        REG_AIC_FR |= AIC_FR_RST;                       \
+} while(0)
+
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()   ( REG_AIC_CR |= AIC_CR_M2S )
+#define __aic_disable_mono2stereo()  ( REG_AIC_CR &= ~AIC_CR_M2S )
+#define __aic_enable_byteswap()      ( REG_AIC_CR |= AIC_CR_ENDSW )
+#define __aic_disable_byteswap()     ( REG_AIC_CR &= ~AIC_CR_ENDSW )
+#define __aic_enable_unsignadj()     ( REG_AIC_CR |= AIC_CR_AVSTSU )
+#define __aic_disable_unsignadj()    ( REG_AIC_CR &= ~AIC_CR_AVSTSU )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+ } while (0)
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_msbjustified()   ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+/*#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )*/
+
+#define __i2s_set_oss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+#define __i2s_set_iss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+
+#define __i2s_stop_bitclk()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_bitclk()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+#define __ac97_slot_error_detected()     ( REG_AIC_ACSR & AIC_ACSR_SLTERR )
+#define __ac97_clear_slot_error()        ( REG_AIC_ACSR &= ~AIC_ACSR_SLTERR )
+
+#define __i2s_is_busy()         ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+#define __aic_internal_codec()  ( REG_AIC_FR |= AIC_FR_ICDC ) 
+#define __aic_external_codec()  ( REG_AIC_FR &= ~AIC_FR_ICDC )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+ } while (0)
+
+
+/***************************************************************************
+ * ICDC
+ ***************************************************************************/
+#define __i2s_internal_codec()         __aic_internal_codec()
+#define __i2s_external_codec()         __aic_external_codec()
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) )
+
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+
+#define __msc_start_op() \
+  ( REG_MSC_STRPCL = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(to) 	( REG_MSC_RESTO = to )
+#define __msc_set_rdto(to) 	( REG_MSC_RDTO = to )
+#define __msc_set_cmd(cmd) 	( REG_MSC_CMD = cmd )
+#define __msc_set_arg(arg) 	( REG_MSC_ARG = arg )
+#define __msc_set_nob(nob) 	( REG_MSC_NOB = nob )
+#define __msc_get_nob() 	( REG_MSC_NOB )
+#define __msc_set_blklen(len) 	( REG_MSC_BLKLEN = len )
+#define __msc_set_cmdat(cmdat) 	( REG_MSC_CMDAT = cmdat )
+#define __msc_set_cmdat_ioabort() 	( REG_MSC_CMDAT |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init() 	( REG_MSC_CMDAT |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy() 	( REG_MSC_CMDAT |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream() ( REG_MSC_CMDAT |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block() ( REG_MSC_CMDAT &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write() ( REG_MSC_CMDAT |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(r) 				\
+do { 								\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat() \
+  REG_MSC_CMDAT &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask() 		( REG_MSC_IMASK )
+#define __msc_mask_all_intrs() 		( REG_MSC_IMASK = 0xff )
+#define __msc_unmask_all_intrs() 	( REG_MSC_IMASK = 0x00 )
+#define __msc_mask_rd() 		( REG_MSC_IMASK |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd() 		( REG_MSC_IMASK &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr() 		( REG_MSC_IMASK |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr() 		( REG_MSC_IMASK &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres() 		( REG_MSC_IMASK |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres() 	( REG_MSC_IMASK &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone() 	( REG_MSC_IMASK |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone() 	( REG_MSC_IMASK &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone() 		( REG_MSC_IMASK |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone() 		( REG_MSC_IMASK &= ~MSC_IMASK_PRG_DONE )
+
+/* n=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n) 	\
+do { 				\
+	REG_MSC_CLKRT = n;	\
+} while(0)
+
+#define __msc_get_ireg() 		( REG_MSC_IREG )
+#define __msc_ireg_rd() 		( REG_MSC_IREG & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr() 		( REG_MSC_IREG & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res() 	( REG_MSC_IREG & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done() 	( REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done() 		( REG_MSC_IREG & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res() 	( REG_MSC_IREG = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done() ( REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done() 	( REG_MSC_IREG = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat() 		( REG_MSC_STAT )
+#define __msc_stat_not_end_cmd_res() 	( (REG_MSC_STAT & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err() \
+  ( REG_MSC_STAT & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo() 		( REG_MSC_RES )
+#define __msc_rd_rxfifo()  		( REG_MSC_RXFIFO )
+#define __msc_wr_txfifo(v)  		( REG_MSC_TXFIFO = v )
+
+#define __msc_reset() 						\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+
+/***************************************************************************
+ * SSI (Synchronous Serial Interface)
+ ***************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define __ssi_enable(n) 	( REG_SSI_CR0(n) |= SSI_CR0_SSIE )
+#define __ssi_disable(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode(n) ( REG_SSI_ITR(n) &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2(n) 		\
+do { 					\
+	REG_SSI_CR0(n) |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1(n) &= ~SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_select_gpc(n) 			\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_FSEL;	\
+	REG_SSI_CR1(n) |= SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_underrun_auto_clear(n) 		\
+do { 						\
+	REG_SSI_CR0(n) |= SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_underrun_clear_manually(n) 	\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_txfifo_half_empty_intr(n)  \
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE )
+#define __ssi_disable_txfifo_half_empty_intr(n)	\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TIE )
+#define __ssi_enable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_TEIE )
+#define __ssi_disable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TEIE )
+#define __ssi_enable_rxfifo_half_full_intr(n)	\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE )
+#define __ssi_disable_rxfifo_half_full_intr(n)  \
+	( REG_SSI_CR0(n) &= ~SSI_CR0_RIE )
+#define __ssi_enable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_REIE )
+#define __ssi_disable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_REIE )
+
+#define __ssi_enable_loopback(n)  ( REG_SSI_CR0(n) |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback(n) ( REG_SSI_CR0(n) &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive(n)   ( REG_SSI_CR0(n) &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive(n)  ( REG_SSI_CR0(n) |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive(n)					\
+	( REG_SSI_CR0(n) |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit(n) 	( REG_SSI_CR1(n) &= ~SSI_CR1_UNFIN )
+#define __ssi_wait_transmit(n) 		( REG_SSI_CR1(n) |= SSI_CR1_UNFIN )
+#define __ssi_use_busy_wait_mode(n) 	__ssi_wait_transmit(n)
+#define __ssi_unset_busy_wait_mode(n) 	__ssi_finish_transmit(n)
+
+#define __ssi_spi_format(n)						\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SPI;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+	} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format(n)						\
+	do { 								\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN);	\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SSP;			\
+	} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format(n)					\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_MW1;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+		REG_SSI_CR0(n) &= ~SSI_CR0_RFINE;			\
+	} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+/* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	  | SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	
+
+#define __ssi_spi_set_misc(n,frmhl,endian,flen,mcom,pha,pol)		\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSICR1_MISC_MASK;			\
+		REG_SSI_CR1(n) |= ((frmhl) << 30) | ((endian) << 25) | 	\
+			(((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+			((pha) << 1) | (pol); 				\
+	} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb(n) ( REG_SSI_CR1(n) &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb(n) ( REG_SSI_CR1(n) |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n, m)					\
+	REG_SSI_CR1(n) = (REG_SSI_CR1(n) & ~SSI_CR1_FLEN_MASK) | (((m) - 2) << 4) 
+
+/* m = 1 - 16 */
+#define __ssi_set_microwire_command_length(n,m)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##m##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n, m)					\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_PHA) | (((m)&0x1)<< 1)))
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n, p)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_POL) | ((p)&0x1)) )
+
+/* SSI tx trigger, m = i x 8 */
+#define __ssi_set_tx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_TTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_TTRG_BIT;	\
+	} while (0)
+
+/* SSI rx trigger, m = i x 8 */
+#define __ssi_set_rx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_RTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_RTRG_BIT;	\
+	} while (0)
+
+#define __ssi_get_txfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_transfer_end(n)		( REG_SSI_SR(n) & SSI_SR_END )
+#define __ssi_is_busy(n)		( REG_SSI_SR(n) & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full(n)		( REG_SSI_SR(n) & SSI_SR_TFF )
+#define __ssi_rxfifo_empty(n)		( REG_SSI_SR(n) & SSI_SR_RFE )
+#define __ssi_rxfifo_half_full(n)	( REG_SSI_SR(n) & SSI_SR_RFHF )
+#define __ssi_txfifo_half_empty(n)	( REG_SSI_SR(n) & SSI_SR_TFHE )
+#define __ssi_underrun(n)		( REG_SSI_SR(n) & SSI_SR_UNDR )
+#define __ssi_overrun(n)		( REG_SSI_SR(n) & SSI_SR_OVER )
+#define __ssi_clear_underrun(n)		( REG_SSI_SR(n) = ~SSI_SR_UNDR )
+#define __ssi_clear_overrun(n)		( REG_SSI_SR(n) = ~SSI_SR_OVER )
+#define __ssi_clear_errors(n)		( REG_SSI_SR(n) &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_set_clk(n, dev_clk, ssi_clk)			\
+	( REG_SSI_GR(n) = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data(n) 		REG_SSI_DR(n)
+#define __ssi_transmit_data(n, v) 	(REG_SSI_DR(n) = (v))
+
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+  ( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+  ( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_PACK_MASK; 		\
+    REG_CIM_CFG |= (CIM_CFG_PACK_##n); 		\
+} while (0)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CPM; 		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CIM; 		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_GCM; 		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_NGCM; 		\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+    REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;			\
+    REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+
+#define __cim_enable_sof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_stop_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_FRC_##n; 		\
+} while (0)
+
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n; 	\
+} while (0)
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dam_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+#define __lcd_as_smart_lcd() 		( REG_LCD_CFG |= (1<<LCD_CFG_LCDPIN_BIT) )
+#define __lcd_as_general_lcd() 		( REG_LCD_CFG &= ~(1<<LCD_CFG_LCDPIN_BIT) )
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+#define __lcd_panel_white()		( REG_LCD_CFG |= LCD_CFG_WHITE )
+#define __lcd_panel_black()		( REG_LCD_CFG &= ~LCD_CFG_WHITE )
+
+/* n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_CFG &= ~LCD_CFG_PDW_MASK; 	\
+	REG_LCD_CFG |= LCD_CFG_PDW_n##;		\
+} while (0)
+
+/* m=LCD_CFG_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_CFG &= ~LCD_CFG_MODE_MASK;	\
+	REG_LCD_CFG |= (m);			\
+} while(0)
+
+/* n = 0-255 */
+#define __lcd_disable_ac_bias()		( REG_LCD_IO = 0xff )
+#define __lcd_set_ac_bias(n) 			\
+do {						\
+	REG_LCD_IO &= ~LCD_IO_ACB_MASK;		\
+	REG_LCD_IO |= ((n) << LCD_IO_ACB_BIT);	\
+} while(0)
+
+#define __lcd_io_set_dir()		( REG_LCD_IO |= LCD_IO_DIR )
+#define __lcd_io_clr_dir()		( REG_LCD_IO &= ~LCD_IO_DIR )
+
+#define __lcd_io_set_dep()		( REG_LCD_IO |= LCD_IO_DEP )
+#define __lcd_io_clr_dep()		( REG_LCD_IO &= ~LCD_IO_DEP )
+
+#define __lcd_io_set_vsp()		( REG_LCD_IO |= LCD_IO_VSP )
+#define __lcd_io_clr_vsp()		( REG_LCD_IO &= ~LCD_IO_VSP )
+
+#define __lcd_io_set_hsp()		( REG_LCD_IO |= LCD_IO_HSP )
+#define __lcd_io_clr_hsp()		( REG_LCD_IO &= ~LCD_IO_HSP )
+
+#define __lcd_io_set_pcp()		( REG_LCD_IO |= LCD_IO_PCP )
+#define __lcd_io_clr_pcp()		( REG_LCD_IO &= ~LCD_IO_PCP )
+
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+/***************************************************************************
+ * RTC ops
+ ***************************************************************************/
+
+#define __rtc_write_ready()  ( REG_RTC_RCR & RTC_RCR_WRDY )
+#define __rtc_enabled()      \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_RTCE ; \
+}while(0)                           \
+
+#define __rtc_disabled()         \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_RTCE; \
+}while(0)
+#define __rtc_enable_alarm()       \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_AE; \
+}while(0)
+
+#define __rtc_disable_alarm()    \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AE; \
+}while(0)
+
+#define __rtc_enable_alarm_irq()  \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_AIE; \
+}while(0)
+
+#define __rtc_disable_alarm_irq() \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AIE; \
+}while(0)
+#define __rtc_enable_Hz_irq()      \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_HZIE;  \
+}while(0)
+
+#define __rtc_disable_Hz_irq()     \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_HZIE; \
+}while(0)
+#define __rtc_get_1Hz_flag()     \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ((REG_RTC_RCR >> RTC_RCR_HZ) & 0x1); \
+}while(0)
+#define __rtc_clear_1Hz_flag()      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_HZ;   \
+}while(0)
+#define __rtc_get_alarm_flag()       \
+do{                                  \
+       while(!__rtc_write_ready());  \
+      ((REG_RTC_RCR >> RTC_RCR_AF) & 0x1) \
+while(0)
+#define __rtc_clear_alarm_flag()    \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AF;   \
+}while(0)
+#define  __rtc_get_second()        \
+do{                                \
+       while(!__rtc_write_ready());\
+	   REG_RTC_RSR;                \
+}while(0)
+ 
+#define __rtc_set_second(v)         \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RSR = v;              \
+}while(0)
+
+#define  __rtc_get_alarm_second()  \
+do{                                \
+      while(!__rtc_write_ready()); \
+	  REG_RTC_RSAR;                \
+}while(0)
+
+	  
+#define __rtc_set_alarm_second(v)   \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RSAR = v;             \
+}while(0)
+
+#define __rtc_RGR_is_locked()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR >> RTC_RGR_LOCK;  \
+}while(0)
+#define __rtc_lock_RGR()            \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR |= RTC_RGR_LOCK;  \
+}while(0)
+
+#define __rtc_unlock_RGR()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR &= ~RTC_RGR_LOCK; \
+}while(0)
+
+#define __rtc_get_adjc_val()       \
+do{                                \
+      while(!__rtc_write_ready());  \
+      ( (REG_RTC_RGR & RTC_RGR_ADJC_MASK) >> RTC_RGR_ADJC_BIT ); \
+}while(0)
+#define __rtc_set_adjc_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_ADJC_MASK) | (v << RTC_RGR_ADJC_BIT) )) \
+}while(0)
+
+#define __rtc_get_nc1Hz_val()       \
+      while(!__rtc_write_ready());  \
+      ( (REG_RTC_RGR & RTC_RGR_NC1HZ_MASK) >> RTC_RGR_NC1HZ_BIT )
+      
+#define __rtc_set_nc1Hz_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_NC1HZ_MASK) | (v << RTC_RGR_NC1HZ_BIT) )) \
+}while(0)
+#define __rtc_power_down()          \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HCR |= RTC_HCR_PD;    \
+}while(0)
+
+#define __rtc_get_hwfcr_val()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HWFCR & RTC_HWFCR_MASK;  \
+}while(0)
+#define __rtc_set_hwfcr_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HWFCR = (v) & RTC_HWFCR_MASK;  \
+}while(0)
+
+#define __rtc_get_hrcr_val()      \
+do{                               \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HRCR & RTC_HRCR_MASK ); \
+}while(0)
+#define __rtc_set_hrcr_val(v)        \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HRCR = (v) & RTC_HRCR_MASK );  \
+}while(0)
+
+#define __rtc_enable_alarm_wakeup()      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWCR |= RTC_HWCR_EALM );  \
+}while(0)
+
+#define __rtc_disable_alarm_wakeup()     \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWCR &= ~RTC_HWCR_EALM );  \
+}while(0)
+
+#define __rtc_status_hib_reset_occur()    \
+do{                                       \
+      while(!__rtc_write_ready());        \
+    ( (REG_RTC_HWRSR >> RTC_HWRSR_HR) & 0x1 ); \
+}while(0)
+#define __rtc_status_ppr_reset_occur()     \
+do{                                        \
+      while(!__rtc_write_ready());        \
+   ( (REG_RTC_HWRSR >> RTC_HWRSR_PPR) & 0x1 ); \
+}while(0)
+#define __rtc_status_wakeup_pin_waken_up() \
+do{                                        \
+      while(!__rtc_write_ready());        \
+   ( (REG_RTC_HWRSR >> RTC_HWRSR_PIN) & 0x1 ); \
+}while(0)
+#define __rtc_status_alarm_waken_up()      \
+do{                                       \
+      while(!__rtc_write_ready());        \
+  ( (REG_RTC_HWRSR >> RTC_HWRSR_ALM) & 0x1 ); \
+}while(0)
+#define __rtc_clear_hib_stat_all()  \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWRSR = 0 );        \
+}while(0)
+
+#define __rtc_get_scratch_pattern() \
+      while(!__rtc_write_ready());  \
+		  (REG_RTC_HSPR)
+#define __rtc_set_scratch_pattern(n) 		\
+do{                                 \
+      while(!__rtc_write_ready());  \
+      (REG_RTC_HSPR = n );        \
+}while(0)
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define __ecc_encoding_4bit()                                   \
+do {				   		        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BCHE;  \
+	REG_BCH_CRC = BCH_CR_BSEL8;				\
+} while(0)
+#define __ecc_decoding_4bit()                           \
+do {                                                    \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BCHE;	\
+	REG_BCH_CRC = BCH_CR_ENCE | BCH_CR_BSEL8;	\
+} while(0)
+#define __ecc_encoding_8bit()                                                   \
+do {				   		                        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;   \
+} while(0)
+#define __ecc_decoding_8bit()                                        \
+do {                                                                 \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;	     \
+	REG_BCH_CRC = BCH_CR_ENCE;	                             \
+} while(0)
+#define __ecc_dma_enable()        ( REG_BCH_CRS = BCH_CR_DMAE )
+#define __ecc_disable()           ( REG_BCH_CRC = BCH_CR_BCHE )
+#define __ecc_encode_sync()       while (!(REG_BCH_INTS & BCH_INTS_ENCF))
+#define __ecc_decode_sync()       while (!(REG_BCH_INTS & BCH_INTS_DECF))
+#define __ecc_cnt_dec(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_DEC_MASK << BCH_CNT_DEC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_DEC_BIT;                        \
+} while(0)
+#define __ecc_cnt_enc(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_ENC_MASK << BCH_CNT_ENC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_ENC_BIT;                        \
+} while(0)
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __JZ4750_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz4750.h u-boot-1.1.6/include/asm-mips/jz4750.h
--- /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz4750.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/asm-mips/jz4750.h	2008-12-17 18:09:53.000000000 +0800
@@ -0,0 +1,5355 @@
+/*
+ * Include file for Ingenic Semiconductor's JZ4750 CPU.
+ */
+#ifndef __JZ4750_H__
+#define __JZ4750_H__
+
+#ifndef __ASSEMBLY__
+#define UCOS_CSP 0
+
+#if UCOS_CSP
+#define __KERNEL__
+#include <bsp.h>
+#include <types.h>
+
+#include <sysdefs.h>
+#include <cacheops.h>
+#define KSEG0 KSEG0BASE
+#else
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+#endif
+
+#define cache_unroll(base,op)	        	\
+	__asm__ __volatile__("	         	\
+		.set noreorder;		        \
+		.set mips3;		        \
+		cache %1, (%0);	                \
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+static inline void jz_flush_dcache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_DCACHE_SIZE;
+	while (start < end) {
+		cache_unroll(start,Index_Writeback_Inv_D);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+static inline void jz_flush_icache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_ICACHE_SIZE;
+	while(start < end) {
+		cache_unroll(start,Index_Invalidate_I);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+/* cpu pipeline flush */
+static inline void jz_sync(void)
+{
+	__asm__ volatile ("sync");
+}
+
+static inline void jz_writeb(u32 address, u8 value)
+{
+	*((volatile u8 *)address) = value;
+}
+
+static inline void jz_writew(u32 address, u16 value)
+{
+	*((volatile u16 *)address) = value;
+}
+
+static inline void jz_writel(u32 address, u32 value)
+{
+	*((volatile u32 *)address) = value;
+}
+
+static inline u8 jz_readb(u32 address)
+{
+	return *((volatile u8 *)address);
+}
+
+static inline u16 jz_readw(u32 address)
+{
+	return *((volatile u16 *)address);
+}
+
+static inline u32 jz_readl(u32 address)
+{
+	return *((volatile u32 *)address);
+}
+
+#define REG8(addr)	*((volatile u8 *)(addr))
+#define REG16(addr)	*((volatile u16 *)(addr))
+#define REG32(addr)	*((volatile u32 *)(addr))
+
+#else
+
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+
+#endif /* !ASSEMBLY */
+
+//----------------------------------------------------------------------
+// Boot ROM Specification
+//
+
+/* NOR Boot config */
+#define JZ4750_NORBOOT_8BIT	0x00000000	/* 8-bit data bus flash */
+#define JZ4750_NORBOOT_16BIT	0x10101010	/* 16-bit data bus flash */
+#define JZ4750_NORBOOT_32BIT	0x20202020	/* 32-bit data bus flash */
+
+/* NAND Boot config */
+#define JZ4750_NANDBOOT_B8R3	0xffffffff	/* 8-bit bus & 3 row cycles */
+#define JZ4750_NANDBOOT_B8R2	0xf0f0f0f0	/* 8-bit bus & 2 row cycles */
+#define JZ4750_NANDBOOT_B16R3	0x0f0f0f0f	/* 16-bit bus & 3 row cycles */
+#define JZ4750_NANDBOOT_B16R2	0x00000000	/* 16-bit bus & 2 row cycles */
+
+
+//----------------------------------------------------------------------
+// Register Definitions
+//
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	TCU_BASE	0xB0002000
+#define	WDT_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	ICDC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	UART2_BASE	0xB0032000
+#define	UART3_BASE	0xB0033000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SADC_BASE	0xB0070000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	SLCD_BASE	0xB3050000
+#define	CIM_BASE	0xB3060000
+#define	BCH_BASE        0xB30D0000
+#define	ETH_BASE	0xB3100000
+
+
+/*************************************************************************
+ * INTC (Interrupt Controller)
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+// 1st-level interrupts
+#define IRQ_OWI		0
+#define IRQ_I2C		1
+#define IRQ_TSSI	2
+#define IRQ_UART3	3
+#define IRQ_UART2	4
+#define IRQ_UART1	5
+#define IRQ_UART0	6
+#define IRQ_PCM		7
+#define IRQ_AIC		8
+#define IRQ_RTC		9
+#define IRQ_SADC	10
+#define IRQ_SSI1	11
+#define IRQ_SSI0	12
+#define IRQ_MSC1	13
+#define IRQ_MSC0	14
+#define IRQ_ETH		15
+#define IRQ_BCH		16
+#define IRQ_UHC		17
+#define IRQ_CIM		18
+#define IRQ_UDC		19
+#define IRQ_DMAC	20
+#define IRQ_TCU2	21
+#define IRQ_TCU1	22
+#define IRQ_TCU0	23
+#define IRQ_GPIO5	24
+#define IRQ_GPIO4	25
+#define IRQ_GPIO3	26
+#define IRQ_GPIO2	27
+#define IRQ_GPIO1	28
+#define IRQ_GPIO0	29
+#define IRQ_IPU		30
+#define IRQ_LCD		31
+
+// 2nd-level interrupts
+#define IRQ_DMA_0	32  /* 32 to 37 for DMAC channel 0 to 5 */
+#define IRQ_GPIO_0	48  /* 48 to 175 for GPIO pin 0 to 127 */
+
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00) /* RTC Control Register */
+#define RTC_RSR		(RTC_BASE + 0x04) /* RTC Second Register */
+#define RTC_RSAR	(RTC_BASE + 0x08) /* RTC Second Alarm Register */
+#define RTC_RGR		(RTC_BASE + 0x0c) /* RTC Regulator Register */
+
+#define RTC_HCR		(RTC_BASE + 0x20) /* Hibernate Control Register */
+#define RTC_HWFCR	(RTC_BASE + 0x24) /* Hibernate Wakeup Filter Counter Reg */
+#define RTC_HRCR	(RTC_BASE + 0x28) /* Hibernate Reset Counter Register */
+#define RTC_HWCR	(RTC_BASE + 0x2c) /* Hibernate Wakeup Control Register */
+#define RTC_HWRSR	(RTC_BASE + 0x30) /* Hibernate Wakeup Status Register */
+#define RTC_HSPR	(RTC_BASE + 0x34) /* Hibernate Scratch Pattern Register */
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+#define REG_RTC_HCR	REG32(RTC_HCR)
+#define REG_RTC_HWFCR	REG32(RTC_HWFCR)
+#define REG_RTC_HRCR	REG32(RTC_HRCR)
+#define REG_RTC_HWCR	REG32(RTC_HWCR)
+#define REG_RTC_HWRSR	REG32(RTC_HWRSR)
+#define REG_RTC_HSPR	REG32(RTC_HSPR)
+
+/* RTC Control Register */
+#define RTC_RCR_WRDY	(1 << 7)  /* Write Ready Flag */
+#define RTC_RCR_HZ	(1 << 6)  /* 1Hz Flag */
+#define RTC_RCR_HZIE	(1 << 5)  /* 1Hz Interrupt Enable */
+#define RTC_RCR_AF	(1 << 4)  /* Alarm Flag */
+#define RTC_RCR_AIE	(1 << 3)  /* Alarm Interrupt Enable */
+#define RTC_RCR_AE	(1 << 2)  /* Alarm Enable */
+#define RTC_RCR_RTCE	(1 << 0)  /* RTC Enable */
+
+/* RTC Regulator Register */
+#define RTC_RGR_LOCK		(1 << 31) /* Lock Bit */
+#define RTC_RGR_ADJC_BIT	16
+#define RTC_RGR_ADJC_MASK	(0x3ff << RTC_RGR_ADJC_BIT)
+#define RTC_RGR_NC1HZ_BIT	0
+#define RTC_RGR_NC1HZ_MASK	(0xffff << RTC_RGR_NC1HZ_BIT)
+
+/* Hibernate Control Register */
+#define RTC_HCR_PD		(1 << 0)  /* Power Down */
+
+/* Hibernate Wakeup Filter Counter Register */
+#define RTC_HWFCR_BIT		5
+#define RTC_HWFCR_MASK		(0x7ff << RTC_HWFCR_BIT)
+
+/* Hibernate Reset Counter Register */
+#define RTC_HRCR_BIT		5
+#define RTC_HRCR_MASK		(0x7f << RTC_HRCR_BIT)
+
+/* Hibernate Wakeup Control Register */
+#define RTC_HWCR_EALM		(1 << 0)  /* RTC alarm wakeup enable */
+
+/* Hibernate Wakeup Status Register */
+#define RTC_HWRSR_HR		(1 << 5)  /* Hibernate reset */
+#define RTC_HWRSR_PPR		(1 << 4)  /* PPR reset */
+#define RTC_HWRSR_PIN		(1 << 1)  /* Wakeup pin status bit */
+#define RTC_HWRSR_ALM		(1 << 0)  /* RTC alarm status bit */
+
+
+/*************************************************************************
+ * CPM (Clock reset and Power control Management)
+ *************************************************************************/
+#define CPM_CPCCR	(CPM_BASE+0x00)
+#define CPM_CPPCR	(CPM_BASE+0x10)
+#define CPM_CPPSR	(CPM_BASE+0x14) /* PLL Switch and Status Register */
+#define CPM_I2SCDR	(CPM_BASE+0x60)
+#define CPM_LPCDR	(CPM_BASE+0x64)
+#define CPM_MSCCDR(n)	(CPM_BASE+0x10*(n)+0x68) /* MSC0(n=0) or MSC1(n=1) device clock divider Register */
+#define CPM_UHCCDR	(CPM_BASE+0x6C)
+#define CPM_SSICDR	(CPM_BASE+0x74)
+#define CPM_PCMCDR	(CPM_BASE+0x7C) /* PCM device clock divider Register */
+
+#define CPM_LCR		(CPM_BASE+0x04)
+#define CPM_CLKGR	(CPM_BASE+0x20)
+#define CPM_OPCR	(CPM_BASE+0x24) /* Oscillator and Power Control Register */
+
+#define CPM_RSR		(CPM_BASE+0x08)
+
+#define REG_CPM_CPCCR   	REG32(CPM_CPCCR)
+#define REG_CPM_CPPCR    	REG32(CPM_CPPCR)
+#define REG_CPM_CPPSR	        REG32(CPM_CPPSR)
+#define REG_CPM_I2SCDR  	REG32(CPM_I2SCDR)
+#define REG_CPM_LPCDR   	REG32(CPM_LPCDR)
+#define REG_CPM_MSCCDR(n)	REG32(CPM_MSCCDR(n))
+#define REG_CPM_UHCCDR   	REG32(CPM_UHCCDR)
+#define REG_CPM_SSICDR  	REG32(CPM_SSICDR)
+#define REG_CPM_PCMCDR          REG32(CPM_PCMCDR)
+
+#define REG_CPM_LCR	REG32(CPM_LCR)
+#define REG_CPM_CLKGR	REG32(CPM_CLKGR)
+#define REG_CPM_OPCR	REG32(CPM_OPCR)
+
+#define REG_CPM_RSR	REG32(CPM_RSR)
+
+/* Clock Control Register */
+#define CPM_CPCCR_I2CS		(1 << 31)
+#define CPM_CPCCR_ECS   	(1 << 30) /* Select the between EXCLK and EXCLK/2 output */
+#define CPM_CPCCR_UCS		(1 << 29)
+#define CPM_CPCCR_UDIV_BIT	23
+#define CPM_CPCCR_UDIV_MASK	(0x3f << CPM_CPCCR_UDIV_BIT)
+#define CPM_CPCCR_CE		(1 << 22)
+#define CPM_CPCCR_PCS		(1 << 21)
+#define CPM_CPCCR_LDIV_BIT	16
+#define CPM_CPCCR_LDIV_MASK	(0x1f << CPM_CPCCR_LDIV_BIT)
+#define CPM_CPCCR_MDIV_BIT	12
+#define CPM_CPCCR_MDIV_MASK	(0x0f << CPM_CPCCR_MDIV_BIT)
+#define CPM_CPCCR_PDIV_BIT	8
+#define CPM_CPCCR_PDIV_MASK	(0x0f << CPM_CPCCR_PDIV_BIT)
+#define CPM_CPCCR_HDIV_BIT	4
+#define CPM_CPCCR_HDIV_MASK	(0x0f << CPM_CPCCR_HDIV_BIT)
+#define CPM_CPCCR_CDIV_BIT	0
+#define CPM_CPCCR_CDIV_MASK	(0x0f << CPM_CPCCR_CDIV_BIT)
+
+/* PLL Switch and Status Register */
+#define CPM_CPPSR_PLLOFF        31
+#define CPM_CPPSR_PLLBP         30
+#define CPM_CPPSR_PLLON         29
+#define CPM_CPPSR_PS            28 /* Indicate whether the PLL parameters' change has finished */
+#define CPM_CPPSR_FS            27 /* Indicate whether the main clock's change has finished */
+#define CPM_CPPSR_CS            26 /* Indicate whether the clock switch has finished */
+#define CPM_CPPSR_PM            1  /* Clock switch mode */
+#define CPM_CPPSR_FM            0  /* Clock frequency change mode */
+
+/* I2S Clock Divider Register */
+#define CPM_I2SCDR_I2SDIV_BIT	0
+#define CPM_I2SCDR_I2SDIV_MASK	(0x1ff << CPM_I2SCDR_I2SDIV_BIT)
+
+/* LCD Pixel Clock Divider Register */
+#define CPM_LPCDR_LSCS	        31 /* TV encoder Source Pixel Clock Selection */
+#define CPM_LPCDR_LPCS	        30 /* LCD Panel pix clock Selection */
+#define CPM_LPCDR_LTCS	        29 /* LCD TV Encoder or Panel pix clock Selection */
+#define CPM_LPCDR_PIXDIV_BIT	0
+#define CPM_LPCDR_PIXDIV_MASK	(0x7ff << CPM_LPCDR_PIXDIV_BIT)
+
+/* MSC Clock Divider Register */
+#define CPM_MSCCDR_MSCDIV_BIT	0
+#define CPM_MSCCDR_MSCDIV_MASK	(0x1f << CPM_MSCCDR_MSCDIV_BIT)
+
+/* UHC Clock Divider Register */
+#define CPM_UHCCDR_UHCDIV_BIT	0
+#define CPM_UHCCDR_UHCDIV_MASK	(0xf << CPM_UHCCDR_UHCDIV_BIT)
+
+/* SSI Clock Divider Register */
+#define CPM_SSICDR_SSIDIV_BIT	0
+#define CPM_SSICDR_SSIDIV_MASK	(0xf << CPM_SSICDR_SSIDIV_BIT)
+
+/* PCM device clock divider Register */
+#define CPM_PCMCDR_PCMS         31 /* PCM source clock Selection */
+#define CPM_PCMCDR_PCMCD_BIT    0
+#define CPM_PCMCDR_PCMCD_MASK   (0x1ff << CPM_PCMCDR_PCMCD_BIT)
+
+/* PLL Control Register */
+#define CPM_CPPCR_PLLM_BIT	23
+#define CPM_CPPCR_PLLM_MASK	(0x1ff << CPM_CPPCR_PLLM_BIT)
+#define CPM_CPPCR_PLLN_BIT	18
+#define CPM_CPPCR_PLLN_MASK	(0x1f << CPM_CPPCR_PLLN_BIT)
+#define CPM_CPPCR_PLLOD_BIT	16
+#define CPM_CPPCR_PLLOD_MASK	(0x03 << CPM_CPPCR_PLLOD_BIT)
+#define CPM_CPPCR_PLLS		(1 << 10) /* obsolete, replaced by CPM_CPPSR_PLLON */
+#define CPM_CPPCR_PLLBP		(1 << 9)
+#define CPM_CPPCR_PLLEN		(1 << 8)
+#define CPM_CPPCR_PLLST_BIT	0
+#define CPM_CPPCR_PLLST_MASK	(0xff << CPM_CPPCR_PLLST_BIT)
+
+/* Low Power Control Register */
+#define CPM_LCR_DOZE_DUTY_BIT 	3
+#define CPM_LCR_DOZE_DUTY_MASK 	(0x1f << CPM_LCR_DOZE_DUTY_BIT)
+#define CPM_LCR_DOZE_ON		(1 << 2)
+#define CPM_LCR_LPM_BIT		0
+#define CPM_LCR_LPM_MASK	(0x3 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_IDLE	(0x0 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_SLEEP	(0x1 << CPM_LCR_LPM_BIT)
+
+/* Clock Gate Register */
+#define CPM_CLKGR_CIMRAM	(1 << 28)
+#define CPM_CLKGR_IDCT  	(1 << 27)
+#define CPM_CLKGR_DB    	(1 << 26)
+#define CPM_CLKGR_ME    	(1 << 25)
+#define CPM_CLKGR_MC    	(1 << 24)
+#define CPM_CLKGR_TVE    	(1 << 23)
+#define CPM_CLKGR_TSSI    	(1 << 22)
+#define CPM_CLKGR_OWI    	(1 << 21)
+#define CPM_CLKGR_PCM    	(1 << 20)
+#define CPM_CLKGR_MSC1    	(1 << 19)
+#define CPM_CLKGR_SSI0    	(1 << 18)
+#define CPM_CLKGR_UART3    	(1 << 17)
+#define CPM_CLKGR_UART2    	(1 << 16)
+#define CPM_CLKGR_UART1		(1 << 15)
+#define CPM_CLKGR_UHC		(1 << 14)
+#define CPM_CLKGR_IPU		(1 << 13)
+#define CPM_CLKGR_DMAC		(1 << 12)
+#define CPM_CLKGR_UDC		(1 << 11)
+#define CPM_CLKGR_LCD		(1 << 10)
+#define CPM_CLKGR_CIM		(1 << 9)
+#define CPM_CLKGR_SADC		(1 << 8)
+#define CPM_CLKGR_MSC0		(1 << 7)
+#define CPM_CLKGR_AIC1		(1 << 6)
+#define CPM_CLKGR_AIC2		(1 << 5)
+#define CPM_CLKGR_SSI1		(1 << 4)
+#define CPM_CLKGR_I2C		(1 << 3)
+#define CPM_CLKGR_RTC		(1 << 2)
+#define CPM_CLKGR_TCU		(1 << 1)
+#define CPM_CLKGR_UART0		(1 << 0)
+
+/* Oscillator and Power Control Register */
+#define CPM_OPCR_O1ST_BIT	8
+#define CPM_OPCR_O1ST_MASK	(0xff << CPM_SCR_O1ST_BIT)
+#define CPM_OPCR_UHCPHY_DISABLE	(1 << 7)
+#define CPM_OPCR_UDCPHY_ENABLE	(1 << 6)
+#define CPM_OPCR_OSC_ENABLE	(1 << 4)
+#define CPM_OPCR_ERCS           (1 << 2) /* EXCLK/512 clock and RTCLK clock selection */
+#define CPM_OPCR_MOSE           (1 << 1) /* Main Oscillator Enable */
+#define CPM_OPCR_MCS            (1 << 0) /* Main clock source select register */
+
+/* Reset Status Register */
+#define CPM_RSR_HR		(1 << 2)
+#define CPM_RSR_WR		(1 << 1)
+#define CPM_RSR_PR		(1 << 0)
+
+
+/*************************************************************************
+ * TCU (Timer Counter Unit)
+ *************************************************************************/
+#define TCU_TSR		(TCU_BASE + 0x1C) /* Timer Stop Register */
+#define TCU_TSSR	(TCU_BASE + 0x2C) /* Timer Stop Set Register */
+#define TCU_TSCR	(TCU_BASE + 0x3C) /* Timer Stop Clear Register */
+#define TCU_TER		(TCU_BASE + 0x10) /* Timer Counter Enable Register */
+#define TCU_TESR	(TCU_BASE + 0x14) /* Timer Counter Enable Set Register */
+#define TCU_TECR	(TCU_BASE + 0x18) /* Timer Counter Enable Clear Register */
+#define TCU_TFR		(TCU_BASE + 0x20) /* Timer Flag Register */
+#define TCU_TFSR	(TCU_BASE + 0x24) /* Timer Flag Set Register */
+#define TCU_TFCR	(TCU_BASE + 0x28) /* Timer Flag Clear Register */
+#define TCU_TMR		(TCU_BASE + 0x30) /* Timer Mask Register */
+#define TCU_TMSR	(TCU_BASE + 0x34) /* Timer Mask Set Register */
+#define TCU_TMCR	(TCU_BASE + 0x38) /* Timer Mask Clear Register */
+#define TCU_TDFR0	(TCU_BASE + 0x40) /* Timer Data Full Register */
+#define TCU_TDHR0	(TCU_BASE + 0x44) /* Timer Data Half Register */
+#define TCU_TCNT0	(TCU_BASE + 0x48) /* Timer Counter Register */
+#define TCU_TCSR0	(TCU_BASE + 0x4C) /* Timer Control Register */
+#define TCU_TDFR1	(TCU_BASE + 0x50)
+#define TCU_TDHR1	(TCU_BASE + 0x54)
+#define TCU_TCNT1	(TCU_BASE + 0x58)
+#define TCU_TCSR1	(TCU_BASE + 0x5C)
+#define TCU_TDFR2	(TCU_BASE + 0x60)
+#define TCU_TDHR2	(TCU_BASE + 0x64)
+#define TCU_TCNT2	(TCU_BASE + 0x68)
+#define TCU_TCSR2	(TCU_BASE + 0x6C)
+#define TCU_TDFR3	(TCU_BASE + 0x70)
+#define TCU_TDHR3	(TCU_BASE + 0x74)
+#define TCU_TCNT3	(TCU_BASE + 0x78)
+#define TCU_TCSR3	(TCU_BASE + 0x7C)
+#define TCU_TDFR4	(TCU_BASE + 0x80)
+#define TCU_TDHR4	(TCU_BASE + 0x84)
+#define TCU_TCNT4	(TCU_BASE + 0x88)
+#define TCU_TCSR4	(TCU_BASE + 0x8C)
+#define TCU_TDFR5	(TCU_BASE + 0x90)
+#define TCU_TDHR5	(TCU_BASE + 0x94)
+#define TCU_TCNT5	(TCU_BASE + 0x98)
+#define TCU_TCSR5	(TCU_BASE + 0x9C)
+
+#define REG_TCU_TSR	REG32(TCU_TSR)
+#define REG_TCU_TSSR	REG32(TCU_TSSR)
+#define REG_TCU_TSCR	REG32(TCU_TSCR)
+#define REG_TCU_TER	REG8(TCU_TER)
+#define REG_TCU_TESR	REG8(TCU_TESR)
+#define REG_TCU_TECR	REG8(TCU_TECR)
+#define REG_TCU_TFR	REG32(TCU_TFR)
+#define REG_TCU_TFSR	REG32(TCU_TFSR)
+#define REG_TCU_TFCR	REG32(TCU_TFCR)
+#define REG_TCU_TMR	REG32(TCU_TMR)
+#define REG_TCU_TMSR	REG32(TCU_TMSR)
+#define REG_TCU_TMCR	REG32(TCU_TMCR)
+#define REG_TCU_TDFR0	REG16(TCU_TDFR0)
+#define REG_TCU_TDHR0	REG16(TCU_TDHR0)
+#define REG_TCU_TCNT0	REG16(TCU_TCNT0)
+#define REG_TCU_TCSR0	REG16(TCU_TCSR0)
+#define REG_TCU_TDFR1	REG16(TCU_TDFR1)
+#define REG_TCU_TDHR1	REG16(TCU_TDHR1)
+#define REG_TCU_TCNT1	REG16(TCU_TCNT1)
+#define REG_TCU_TCSR1	REG16(TCU_TCSR1)
+#define REG_TCU_TDFR2	REG16(TCU_TDFR2)
+#define REG_TCU_TDHR2	REG16(TCU_TDHR2)
+#define REG_TCU_TCNT2	REG16(TCU_TCNT2)
+#define REG_TCU_TCSR2	REG16(TCU_TCSR2)
+#define REG_TCU_TDFR3	REG16(TCU_TDFR3)
+#define REG_TCU_TDHR3	REG16(TCU_TDHR3)
+#define REG_TCU_TCNT3	REG16(TCU_TCNT3)
+#define REG_TCU_TCSR3	REG16(TCU_TCSR3)
+#define REG_TCU_TDFR4	REG16(TCU_TDFR4)
+#define REG_TCU_TDHR4	REG16(TCU_TDHR4)
+#define REG_TCU_TCNT4	REG16(TCU_TCNT4)
+#define REG_TCU_TCSR4	REG16(TCU_TCSR4)
+
+// n = 0,1,2,3,4,5
+#define TCU_TDFR(n)	(TCU_BASE + (0x40 + (n)*0x10)) /* Timer Data Full Reg */
+#define TCU_TDHR(n)	(TCU_BASE + (0x44 + (n)*0x10)) /* Timer Data Half Reg */
+#define TCU_TCNT(n)	(TCU_BASE + (0x48 + (n)*0x10)) /* Timer Counter Reg */
+#define TCU_TCSR(n)	(TCU_BASE + (0x4C + (n)*0x10)) /* Timer Control Reg */
+
+#define REG_TCU_TDFR(n)	REG16(TCU_TDFR((n)))
+#define REG_TCU_TDHR(n)	REG16(TCU_TDHR((n)))
+#define REG_TCU_TCNT(n)	REG16(TCU_TCNT((n)))
+#define REG_TCU_TCSR(n)	REG16(TCU_TCSR((n)))
+
+// Register definitions
+#define TCU_TCSR_PWM_SD		(1 << 9)
+#define TCU_TCSR_PWM_INITL_HIGH	(1 << 8)
+#define TCU_TCSR_PWM_EN		(1 << 7)
+#define TCU_TCSR_PRESCALE_BIT	3
+#define TCU_TCSR_PRESCALE_MASK	(0x7 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1	(0x0 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE4	(0x1 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE16	(0x2 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE64	(0x3 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE256	(0x4 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1024	(0x5 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_EXT_EN		(1 << 2)
+#define TCU_TCSR_RTC_EN		(1 << 1)
+#define TCU_TCSR_PCK_EN		(1 << 0)
+
+#define TCU_TER_TCEN5		(1 << 5)
+#define TCU_TER_TCEN4		(1 << 4)
+#define TCU_TER_TCEN3		(1 << 3)
+#define TCU_TER_TCEN2		(1 << 2)
+#define TCU_TER_TCEN1		(1 << 1)
+#define TCU_TER_TCEN0		(1 << 0)
+
+#define TCU_TESR_TCST5		(1 << 5)
+#define TCU_TESR_TCST4		(1 << 4)
+#define TCU_TESR_TCST3		(1 << 3)
+#define TCU_TESR_TCST2		(1 << 2)
+#define TCU_TESR_TCST1		(1 << 1)
+#define TCU_TESR_TCST0		(1 << 0)
+
+#define TCU_TECR_TCCL5		(1 << 5)
+#define TCU_TECR_TCCL4		(1 << 4)
+#define TCU_TECR_TCCL3		(1 << 3)
+#define TCU_TECR_TCCL2		(1 << 2)
+#define TCU_TECR_TCCL1		(1 << 1)
+#define TCU_TECR_TCCL0		(1 << 0)
+
+#define TCU_TFR_HFLAG5		(1 << 21)
+#define TCU_TFR_HFLAG4		(1 << 20)
+#define TCU_TFR_HFLAG3		(1 << 19)
+#define TCU_TFR_HFLAG2		(1 << 18)
+#define TCU_TFR_HFLAG1		(1 << 17)
+#define TCU_TFR_HFLAG0		(1 << 16)
+#define TCU_TFR_FFLAG5		(1 << 5)
+#define TCU_TFR_FFLAG4		(1 << 4)
+#define TCU_TFR_FFLAG3		(1 << 3)
+#define TCU_TFR_FFLAG2		(1 << 2)
+#define TCU_TFR_FFLAG1		(1 << 1)
+#define TCU_TFR_FFLAG0		(1 << 0)
+
+#define TCU_TFSR_HFLAG5		(1 << 21)
+#define TCU_TFSR_HFLAG4		(1 << 20)
+#define TCU_TFSR_HFLAG3		(1 << 19)
+#define TCU_TFSR_HFLAG2		(1 << 18)
+#define TCU_TFSR_HFLAG1		(1 << 17)
+#define TCU_TFSR_HFLAG0		(1 << 16)
+#define TCU_TFSR_FFLAG5		(1 << 5)
+#define TCU_TFSR_FFLAG4		(1 << 4)
+#define TCU_TFSR_FFLAG3		(1 << 3)
+#define TCU_TFSR_FFLAG2		(1 << 2)
+#define TCU_TFSR_FFLAG1		(1 << 1)
+#define TCU_TFSR_FFLAG0		(1 << 0)
+
+#define TCU_TFCR_HFLAG5		(1 << 21)
+#define TCU_TFCR_HFLAG4		(1 << 20)
+#define TCU_TFCR_HFLAG3		(1 << 19)
+#define TCU_TFCR_HFLAG2		(1 << 18)
+#define TCU_TFCR_HFLAG1		(1 << 17)
+#define TCU_TFCR_HFLAG0		(1 << 16)
+#define TCU_TFCR_FFLAG5		(1 << 5)
+#define TCU_TFCR_FFLAG4		(1 << 4)
+#define TCU_TFCR_FFLAG3		(1 << 3)
+#define TCU_TFCR_FFLAG2		(1 << 2)
+#define TCU_TFCR_FFLAG1		(1 << 1)
+#define TCU_TFCR_FFLAG0		(1 << 0)
+
+#define TCU_TMR_HMASK5		(1 << 21)
+#define TCU_TMR_HMASK4		(1 << 20)
+#define TCU_TMR_HMASK3		(1 << 19)
+#define TCU_TMR_HMASK2		(1 << 18)
+#define TCU_TMR_HMASK1		(1 << 17)
+#define TCU_TMR_HMASK0		(1 << 16)
+#define TCU_TMR_FMASK5		(1 << 5)
+#define TCU_TMR_FMASK4		(1 << 4)
+#define TCU_TMR_FMASK3		(1 << 3)
+#define TCU_TMR_FMASK2		(1 << 2)
+#define TCU_TMR_FMASK1		(1 << 1)
+#define TCU_TMR_FMASK0		(1 << 0)
+
+#define TCU_TMSR_HMST5		(1 << 21)
+#define TCU_TMSR_HMST4		(1 << 20)
+#define TCU_TMSR_HMST3		(1 << 19)
+#define TCU_TMSR_HMST2		(1 << 18)
+#define TCU_TMSR_HMST1		(1 << 17)
+#define TCU_TMSR_HMST0		(1 << 16)
+#define TCU_TMSR_FMST5		(1 << 5)
+#define TCU_TMSR_FMST4		(1 << 4)
+#define TCU_TMSR_FMST3		(1 << 3)
+#define TCU_TMSR_FMST2		(1 << 2)
+#define TCU_TMSR_FMST1		(1 << 1)
+#define TCU_TMSR_FMST0		(1 << 0)
+
+#define TCU_TMCR_HMCL5		(1 << 21)
+#define TCU_TMCR_HMCL4		(1 << 20)
+#define TCU_TMCR_HMCL3		(1 << 19)
+#define TCU_TMCR_HMCL2		(1 << 18)
+#define TCU_TMCR_HMCL1		(1 << 17)
+#define TCU_TMCR_HMCL0		(1 << 16)
+#define TCU_TMCR_FMCL5		(1 << 5)
+#define TCU_TMCR_FMCL4		(1 << 4)
+#define TCU_TMCR_FMCL3		(1 << 3)
+#define TCU_TMCR_FMCL2		(1 << 2)
+#define TCU_TMCR_FMCL1		(1 << 1)
+#define TCU_TMCR_FMCL0		(1 << 0)
+
+#define TCU_TSR_WDTS		(1 << 16)
+#define TCU_TSR_STOP5		(1 << 5)
+#define TCU_TSR_STOP4		(1 << 4)
+#define TCU_TSR_STOP3		(1 << 3)
+#define TCU_TSR_STOP2		(1 << 2)
+#define TCU_TSR_STOP1		(1 << 1)
+#define TCU_TSR_STOP0		(1 << 0)
+
+#define TCU_TSSR_WDTSS		(1 << 16)
+#define TCU_TSSR_STPS5		(1 << 5)
+#define TCU_TSSR_STPS4		(1 << 4)
+#define TCU_TSSR_STPS3		(1 << 3)
+#define TCU_TSSR_STPS2		(1 << 2)
+#define TCU_TSSR_STPS1		(1 << 1)
+#define TCU_TSSR_STPS0		(1 << 0)
+
+#define TCU_TSSR_WDTSC		(1 << 16)
+#define TCU_TSSR_STPC5		(1 << 5)
+#define TCU_TSSR_STPC4		(1 << 4)
+#define TCU_TSSR_STPC3		(1 << 3)
+#define TCU_TSSR_STPC2		(1 << 2)
+#define TCU_TSSR_STPC1		(1 << 1)
+#define TCU_TSSR_STPC0		(1 << 0)
+
+
+/*************************************************************************
+ * WDT (WatchDog Timer)
+ *************************************************************************/
+#define WDT_TDR		(WDT_BASE + 0x00)
+#define WDT_TCER	(WDT_BASE + 0x04)
+#define WDT_TCNT	(WDT_BASE + 0x08)
+#define WDT_TCSR	(WDT_BASE + 0x0C)
+
+#define REG_WDT_TDR	REG16(WDT_TDR)
+#define REG_WDT_TCER	REG8(WDT_TCER)
+#define REG_WDT_TCNT	REG16(WDT_TCNT)
+#define REG_WDT_TCSR	REG16(WDT_TCSR)
+
+// Register definition
+#define WDT_TCSR_PRESCALE_BIT	3
+#define WDT_TCSR_PRESCALE_MASK	(0x7 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1	(0x0 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE4	(0x1 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE16	(0x2 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE64	(0x3 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE256	(0x4 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1024	(0x5 << WDT_TCSR_PRESCALE_BIT)
+#define WDT_TCSR_EXT_EN		(1 << 2)
+#define WDT_TCSR_RTC_EN		(1 << 1)
+#define WDT_TCSR_PCK_EN		(1 << 0)
+
+#define WDT_TCER_TCEN		(1 << 0)
+
+
+/*************************************************************************
+ * DMAC (DMA Controller)
+ *************************************************************************/
+
+#define MAX_DMA_NUM	12  /* max 12 channels */
+#define HALF_DMA_NUM	6   /* the number of one dma controller's channels */
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define DMAC_DSAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x00 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA source address */
+#define DMAC_DTAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x04 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA target address */
+#define DMAC_DTCR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x08 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA transfer count */
+#define DMAC_DRSR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x0c + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA request source */
+#define DMAC_DCCSR(n) (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x10 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA control/status */
+#define DMAC_DCMD(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x14 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA command */
+#define DMAC_DDA(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x18 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA descriptor address */
+#define DMAC_DSD(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0xc0 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x04)) /* DMA Stride Address */
+
+#define DMAC_DMACR(m)	(DMAC_BASE + 0x0300 + 0x100 * m)              /* DMA control register */
+#define DMAC_DMAIPR(m)	(DMAC_BASE + 0x0304 + 0x100 * m)              /* DMA interrupt pending */
+#define DMAC_DMADBR(m)	(DMAC_BASE + 0x0308 + 0x100 * m)              /* DMA doorbell */
+#define DMAC_DMADBSR(m)	(DMAC_BASE + 0x030C + 0x100 * m)              /* DMA doorbell set */
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DTAR(n)	REG32(DMAC_DTAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DCMD(n)	REG32(DMAC_DCMD((n)))
+#define REG_DMAC_DDA(n)		REG32(DMAC_DDA((n)))
+#define REG_DMAC_DSD(n)         REG32(DMAC_DSD(n))
+#define REG_DMAC_DMACR(m)	REG32(DMAC_DMACR(m))
+#define REG_DMAC_DMAIPR(m)	REG32(DMAC_DMAIPR(m))
+#define REG_DMAC_DMADBR(m)	REG32(DMAC_DMADBR(m))
+#define REG_DMAC_DMADBSR(m)	REG32(DMAC_DMADBSR(m))
+
+// DMA request source register
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x1f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_EXT	(0 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_NAND	(1 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_ENC	(2 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_DEC	(3 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO	(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TSSIIN	(9 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3OUT	(14 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3IN	(15 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2OUT	(16 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2IN	(17 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1OUT	(18 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1IN	(19 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT	(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN	(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0OUT	(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0IN	(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT	(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN	(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0OUT	(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0IN	(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TCU	(28 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SADC	(29 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1OUT	(30 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1IN	(31 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1OUT	(32 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1IN	(33 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMOUT	(34 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMIN	(35 << DMAC_DRSR_RS_BIT)
+
+// DMA channel control/status register
+#define DMAC_DCCSR_NDES		(1 << 31) /* descriptor (0) or not (1) ? */
+#define DMAC_DCCSR_DES8    	(1 << 30) /* Descriptor 8 Word */
+#define DMAC_DCCSR_DES4    	(0 << 30) /* Descriptor 4 Word */
+#define DMAC_DCCSR_CDOA_BIT	16        /* copy of DMA offset address */
+#define DMAC_DCCSR_CDOA_MASK	(0xff << DMAC_DCCSR_CDOA_BIT)
+#define DMAC_DCCSR_BERR		(1 << 7)  /* BCH error within this transfer, Only for channel 0 */
+#define DMAC_DCCSR_INV		(1 << 6)  /* descriptor invalid */
+#define DMAC_DCCSR_AR		(1 << 4)  /* address error */
+#define DMAC_DCCSR_TT		(1 << 3)  /* transfer terminated */
+#define DMAC_DCCSR_HLT		(1 << 2)  /* DMA halted */
+#define DMAC_DCCSR_CT		(1 << 1)  /* count terminated */
+#define DMAC_DCCSR_EN		(1 << 0)  /* channel enable bit */
+
+// DMA channel command register 
+#define DMAC_DCMD_EACKS_LOW  	(1 << 31) /* External DACK Output Level Select, active low */
+#define DMAC_DCMD_EACKS_HIGH  	(0 << 31) /* External DACK Output Level Select, active high */
+#define DMAC_DCMD_EACKM_WRITE 	(1 << 30) /* External DACK Output Mode Select, output in write cycle */
+#define DMAC_DCMD_EACKM_READ 	(0 << 30) /* External DACK Output Mode Select, output in read cycle */
+#define DMAC_DCMD_ERDM_BIT      28        /* External DREQ Detection Mode Select */
+#define DMAC_DCMD_ERDM_MASK     (0x03 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_LOW    (0 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_FALL   (1 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_HIGH   (2 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_RISE   (3 << DMAC_DCMD_ERDM_BIT)
+#define DMAC_DCMD_BLAST		(1 << 25) /* BCH last */
+#define DMAC_DCMD_SAI		(1 << 23) /* source address increment */
+#define DMAC_DCMD_DAI		(1 << 22) /* dest address increment */
+#define DMAC_DCMD_RDIL_BIT	16        /* request detection interval length */
+#define DMAC_DCMD_RDIL_MASK	(0x0f << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_IGN	(0 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_2	(1 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_4	(2 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_8	(3 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_12	(4 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_16	(5 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_20	(6 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_24	(7 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_28	(8 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_32	(9 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_48	(10 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_60	(11 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_64	(12 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_124	(13 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_128	(14 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_200	(15 << DMAC_DCMD_RDIL_BIT)
+#define DMAC_DCMD_SWDH_BIT	14  /* source port width */
+#define DMAC_DCMD_SWDH_MASK	(0x03 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_32	(0 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_8	(1 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_16	(2 << DMAC_DCMD_SWDH_BIT)
+#define DMAC_DCMD_DWDH_BIT	12  /* dest port width */
+#define DMAC_DCMD_DWDH_MASK	(0x03 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_32	(0 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_8	(1 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_16	(2 << DMAC_DCMD_DWDH_BIT)
+#define DMAC_DCMD_DS_BIT	8  /* transfer data size of a data unit */
+#define DMAC_DCMD_DS_MASK	(0x07 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BIT	(0 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_8BIT	(1 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BIT	(2 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BYTE	(3 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BYTE	(4 << DMAC_DCMD_DS_BIT)
+#define DMAC_DCMD_STDE   	(1 << 5) /* Stride Disable/Enable */
+#define DMAC_DCMD_DES_V		(1 << 4)  /* descriptor valid flag */
+#define DMAC_DCMD_DES_VM	(1 << 3)  /* descriptor valid mask: 1:support V-bit */
+#define DMAC_DCMD_DES_VIE	(1 << 2)  /* DMA valid error interrupt enable */
+#define DMAC_DCMD_TIE		(1 << 1)  /* DMA transfer interrupt enable */
+#define DMAC_DCMD_LINK		(1 << 0)  /* descriptor link enable */
+
+// DMA descriptor address register
+#define DMAC_DDA_BASE_BIT	12  /* descriptor base address */
+#define DMAC_DDA_BASE_MASK	(0x0fffff << DMAC_DDA_BASE_BIT)
+#define DMAC_DDA_OFFSET_BIT	4   /* descriptor offset address */
+#define DMAC_DDA_OFFSET_MASK	(0x0ff << DMAC_DDA_OFFSET_BIT)
+
+// DMA stride address register
+#define DMAC_DSD_TSD_BIT        16  /* target stride address */
+#define DMAC_DSD_TSD_MASK      	(0xffff << DMAC_DSD_TSD_BIT)
+#define DMAC_DSD_SSD_BIT        0  /* source stride address */
+#define DMAC_DSD_SSD_MASK      	(0xffff << DMAC_DSD_SSD_BIT)
+
+// DMA control register
+#define DMAC_DMACR_FMSC		(1 << 31)  /* MSC Fast DMA mode */
+#define DMAC_DMACR_FSSI		(1 << 30)  /* SSI Fast DMA mode */
+#define DMAC_DMACR_FTSSI	(1 << 29)  /* TSSI Fast DMA mode */
+#define DMAC_DMACR_FUART	(1 << 28)  /* UART Fast DMA mode */
+#define DMAC_DMACR_FAIC		(1 << 27)  /* AIC Fast DMA mode */
+#define DMAC_DMACR_PR_BIT	8  /* channel priority mode */
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_012345	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_120345	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_230145	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_340125	(3 << DMAC_DMACR_PR_BIT)
+#define DMAC_DMACR_HLT		(1 << 3)  /* DMA halt flag */
+#define DMAC_DMACR_AR		(1 << 2)  /* address error flag */
+#define DMAC_DMACR_DMAE		(1 << 0)  /* DMA enable bit */
+
+// DMA doorbell register
+#define DMAC_DMADBR_DB5		(1 << 5)  /* doorbell for channel 5 */
+#define DMAC_DMADBR_DB4		(1 << 4)  /* doorbell for channel 4 */
+#define DMAC_DMADBR_DB3		(1 << 3)  /* doorbell for channel 3 */
+#define DMAC_DMADBR_DB2		(1 << 2)  /* doorbell for channel 2 */
+#define DMAC_DMADBR_DB1		(1 << 1)  /* doorbell for channel 1 */
+#define DMAC_DMADBR_DB0		(1 << 0)  /* doorbell for channel 0 */
+
+// DMA doorbell set register
+#define DMAC_DMADBSR_DBS5	(1 << 5)  /* enable doorbell for channel 5 */
+#define DMAC_DMADBSR_DBS4	(1 << 4)  /* enable doorbell for channel 4 */
+#define DMAC_DMADBSR_DBS3	(1 << 3)  /* enable doorbell for channel 3 */
+#define DMAC_DMADBSR_DBS2	(1 << 2)  /* enable doorbell for channel 2 */
+#define DMAC_DMADBSR_DBS1	(1 << 1)  /* enable doorbell for channel 1 */
+#define DMAC_DMADBSR_DBS0	(1 << 0)  /* enable doorbell for channel 0 */
+
+// DMA interrupt pending register
+#define DMAC_DMAIPR_CIRQ5	(1 << 5)  /* irq pending status for channel 5 */
+#define DMAC_DMAIPR_CIRQ4	(1 << 4)  /* irq pending status for channel 4 */
+#define DMAC_DMAIPR_CIRQ3	(1 << 3)  /* irq pending status for channel 3 */
+#define DMAC_DMAIPR_CIRQ2	(1 << 2)  /* irq pending status for channel 2 */
+#define DMAC_DMAIPR_CIRQ1	(1 << 1)  /* irq pending status for channel 1 */
+#define DMAC_DMAIPR_CIRQ0	(1 << 0)  /* irq pending status for channel 0 */
+
+
+/*************************************************************************
+ * GPIO (General-Purpose I/O Ports)
+ *************************************************************************/
+#define MAX_GPIO_NUM	192
+
+//n = 0,1,2,3,4,5
+#define GPIO_PXPIN(n)	(GPIO_BASE + (0x00 + (n)*0x100)) /* PIN Level Register */
+#define GPIO_PXDAT(n)	(GPIO_BASE + (0x10 + (n)*0x100)) /* Port Data Register */
+#define GPIO_PXDATS(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Data Set Register */
+#define GPIO_PXDATC(n)	(GPIO_BASE + (0x18 + (n)*0x100)) /* Port Data Clear Register */
+#define GPIO_PXIM(n)	(GPIO_BASE + (0x20 + (n)*0x100)) /* Interrupt Mask Register */
+#define GPIO_PXIMS(n)	(GPIO_BASE + (0x24 + (n)*0x100)) /* Interrupt Mask Set Reg */
+#define GPIO_PXIMC(n)	(GPIO_BASE + (0x28 + (n)*0x100)) /* Interrupt Mask Clear Reg */
+#define GPIO_PXPE(n)	(GPIO_BASE + (0x30 + (n)*0x100)) /* Pull Disable Register */
+#define GPIO_PXPES(n)	(GPIO_BASE + (0x34 + (n)*0x100)) /* Pull Disable Set Reg. */
+#define GPIO_PXPEC(n)	(GPIO_BASE + (0x38 + (n)*0x100)) /* Pull Disable Clear Reg. */
+#define GPIO_PXFUN(n)	(GPIO_BASE + (0x40 + (n)*0x100)) /* Function Register */
+#define GPIO_PXFUNS(n)	(GPIO_BASE + (0x44 + (n)*0x100)) /* Function Set Register */
+#define GPIO_PXFUNC(n)	(GPIO_BASE + (0x48 + (n)*0x100)) /* Function Clear Register */
+#define GPIO_PXSEL(n)	(GPIO_BASE + (0x50 + (n)*0x100)) /* Select Register */
+#define GPIO_PXSELS(n)	(GPIO_BASE + (0x54 + (n)*0x100)) /* Select Set Register */
+#define GPIO_PXSELC(n)	(GPIO_BASE + (0x58 + (n)*0x100)) /* Select Clear Register */
+#define GPIO_PXDIR(n)	(GPIO_BASE + (0x60 + (n)*0x100)) /* Direction Register */
+#define GPIO_PXDIRS(n)	(GPIO_BASE + (0x64 + (n)*0x100)) /* Direction Set Register */
+#define GPIO_PXDIRC(n)	(GPIO_BASE + (0x68 + (n)*0x100)) /* Direction Clear Register */
+#define GPIO_PXTRG(n)	(GPIO_BASE + (0x70 + (n)*0x100)) /* Trigger Register */
+#define GPIO_PXTRGS(n)	(GPIO_BASE + (0x74 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXTRGC(n)	(GPIO_BASE + (0x78 + (n)*0x100)) /* Trigger Clear Register */
+#define GPIO_PXFLG(n)	(GPIO_BASE + (0x80 + (n)*0x100)) /* Port Flag Register */
+#define GPIO_PXFLGC(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Flag clear Register */
+
+#define REG_GPIO_PXPIN(n)	REG32(GPIO_PXPIN((n)))  /* PIN level */
+#define REG_GPIO_PXDAT(n)	REG32(GPIO_PXDAT((n)))  /* 1: interrupt pending */
+#define REG_GPIO_PXDATS(n)	REG32(GPIO_PXDATS((n)))
+#define REG_GPIO_PXDATC(n)	REG32(GPIO_PXDATC((n)))
+#define REG_GPIO_PXIM(n)	REG32(GPIO_PXIM((n)))   /* 1: mask pin interrupt */
+#define REG_GPIO_PXIMS(n)	REG32(GPIO_PXIMS((n)))
+#define REG_GPIO_PXIMC(n)	REG32(GPIO_PXIMC((n)))
+#define REG_GPIO_PXPE(n)	REG32(GPIO_PXPE((n)))   /* 1: disable pull up/down */
+#define REG_GPIO_PXPES(n)	REG32(GPIO_PXPES((n)))
+#define REG_GPIO_PXPEC(n)	REG32(GPIO_PXPEC((n)))
+#define REG_GPIO_PXFUN(n)	REG32(GPIO_PXFUN((n)))  /* 0:GPIO/INTR, 1:FUNC */
+#define REG_GPIO_PXFUNS(n)	REG32(GPIO_PXFUNS((n)))
+#define REG_GPIO_PXFUNC(n)	REG32(GPIO_PXFUNC((n)))
+#define REG_GPIO_PXSEL(n)	REG32(GPIO_PXSEL((n))) /* 0:GPIO/Fun0,1:intr/fun1*/
+#define REG_GPIO_PXSELS(n)	REG32(GPIO_PXSELS((n)))
+#define REG_GPIO_PXSELC(n)	REG32(GPIO_PXSELC((n)))
+#define REG_GPIO_PXDIR(n)	REG32(GPIO_PXDIR((n))) /* 0:input/low-level-trig/falling-edge-trig, 1:output/high-level-trig/rising-edge-trig */
+#define REG_GPIO_PXDIRS(n)	REG32(GPIO_PXDIRS((n)))
+#define REG_GPIO_PXDIRC(n)	REG32(GPIO_PXDIRC((n)))
+#define REG_GPIO_PXTRG(n)	REG32(GPIO_PXTRG((n))) /* 0:Level-trigger/Fun0, 1:Edge-trigger/Fun1 */
+#define REG_GPIO_PXTRGS(n)	REG32(GPIO_PXTRGS((n)))
+#define REG_GPIO_PXTRGC(n)	REG32(GPIO_PXTRGC((n)))
+#define REG_GPIO_PXFLG(n)	REG32(GPIO_PXFLG((n))) /* interrupt flag */
+#define REG_GPIO_PXFLGC(n)	REG32(GPIO_PXFLGC((n))) /* interrupt flag */
+
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* Register Offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+#define OFF_UMR		(0x24)	/* RW 8b H'00, UART M Register */
+#define OFF_UACR	(0x28)	/* RW 8b H'00, UART Add Cycle Register */
+
+/* Register Address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+#define UART0_UMR	(UART0_BASE + OFF_UMR)
+#define UART0_UACR	(UART0_BASE + OFF_UACR)
+
+/*
+ * Define macros for UART_IER
+ * UART Interrupt Enable Register
+ */
+#define UART_IER_RIE	(1 << 0)	/* 0: receive fifo "full" interrupt disable */
+#define UART_IER_TIE	(1 << 1)	/* 0: transmit fifo "empty" interrupt disable */
+#define UART_IER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UART_IER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UART_IER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UART_ISR
+ * UART Interrupt Status Register
+ */
+#define UART_ISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UART_ISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UART_ISR_IID_MSI		(0 << 1)	/* Modem status interrupt */
+#define UART_ISR_IID_THRI	(1 << 1)	/* Transmitter holding register empty */
+#define UART_ISR_IID_RDI		(2 << 1)	/* Receiver data interrupt */
+#define UART_ISR_IID_RLSI	(3 << 1)	/* Receiver line status interrupt */
+#define UART_ISR_FFMS	(3 << 6)	/* FIFO mode select, set when UART_FCR.FE is set to 1 */
+#define UART_ISR_FFMS_NO_FIFO	(0 << 6)
+#define UART_ISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UART_FCR
+ * UART FIFO Control Register
+ */
+#define UART_FCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UART_FCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UART_FCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UART_FCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UART_FCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UART_FCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UART_FCR_RTRG_1	(0 << 6)
+#define UART_FCR_RTRG_4	(1 << 6)
+#define UART_FCR_RTRG_8	(2 << 6)
+#define UART_FCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UART_LCR
+ * UART Line Control Register
+ */
+#define UART_LCR_WLEN	(3 << 0)	/* word length */
+#define UART_LCR_WLEN_5	(0 << 0)
+#define UART_LCR_WLEN_6	(1 << 0)
+#define UART_LCR_WLEN_7	(2 << 0)
+#define UART_LCR_WLEN_8	(3 << 0)
+#define UART_LCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_1	(0 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_2	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+
+#define UART_LCR_PE	(1 << 3)	/* 0: parity disable */
+#define UART_LCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UART_LCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UART_LCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UART_LCR_DLAB	(1 << 7)	/* 0: access UART_RDR/TDR/IER  1: access UART_DLLR/DLHR */
+
+/*
+ * Define macros for UART_LSR
+ * UART Line Status Register
+ */
+#define UART_LSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UART_LSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UART_LSR_PER	(1 << 2)	/* 0: no parity error */
+#define UART_LSR_FER	(1 << 3)	/* 0; no framing error */
+#define UART_LSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UART_LSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UART_LSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UART_LSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UART_MCR
+ * UART Modem Control Register
+ */
+#define UART_MCR_DTR	(1 << 0)	/* 0: DTR_ ouput high */
+#define UART_MCR_RTS	(1 << 1)	/* 0: RTS_ output high */
+#define UART_MCR_OUT1	(1 << 2)	/* 0: UART_MSR.RI is set to 0 and RI_ input high */
+#define UART_MCR_OUT2	(1 << 3)	/* 0: UART_MSR.DCD is set to 0 and DCD_ input high */
+#define UART_MCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UART_MCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UART_MSR
+ * UART Modem Status Register
+ */
+#define UART_MSR_DCTS	(1 << 0)	/* 0: no change on CTS_ pin since last read of UART_MSR */
+#define UART_MSR_DDSR	(1 << 1)	/* 0: no change on DSR_ pin since last read of UART_MSR */
+#define UART_MSR_DRI	(1 << 2)	/* 0: no change on RI_ pin since last read of UART_MSR */
+#define UART_MSR_DDCD	(1 << 3)	/* 0: no change on DCD_ pin since last read of UART_MSR */
+#define UART_MSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+#define UART_MSR_DSR	(1 << 5)	/* 0: DSR_ pin is high */
+#define UART_MSR_RI	(1 << 6)	/* 0: RI_ pin is high */
+#define UART_MSR_DCD	(1 << 7)	/* 0: DCD_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)	/* 0: transmitter is in UART mode  1: IrDA mode */
+#define SIRCR_RSIRE	(1 << 1)	/* 0: receiver is in UART mode  1: IrDA mode */
+#define SIRCR_TPWS	(1 << 2)	/* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TXPL	(1 << 3)	/* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RXPL	(1 << 4)	/* 0: decoder interprets positive pulse as 0 */
+
+
+/*************************************************************************
+ * AIC (AC97/I2S Controller)
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12        /* Receive FIFO Threshold */
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8         /* Transmit FIFO Threshold */
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_ICDC		(1 << 5)  /* External(0) or Internal CODEC(1) */
+#define	AIC_FR_AUSEL		(1 << 4)  /* AC97(0) or I2S/MSB-justified(1) */
+#define	AIC_FR_RST		(1 << 3)  /* AIC registers reset */
+#define	AIC_FR_BCKD		(1 << 2)  /* I2S BIT_CLK direction, 0:input,1:output */
+#define	AIC_FR_SYNCD		(1 << 1)  /* I2S SYNC direction, 0:input,1:output */
+#define	AIC_FR_ENB		(1 << 0)  /* AIC enable bit */
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_OSS_BIT		19  /* Output Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_OSS_MASK		(0x7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0x0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(0x1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(0x2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(0x3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(0x4 << AIC_CR_OSS_BIT)
+#define	AIC_CR_ISS_BIT		16  /* Input Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_ISS_MASK		(0x7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0x0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(0x1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(0x2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(0x3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(0x4 << AIC_CR_ISS_BIT)
+#define	AIC_CR_RDMS		(1 << 15)  /* Receive DMA enable */
+#define	AIC_CR_TDMS		(1 << 14)  /* Transmit DMA enable */
+#define	AIC_CR_M2S		(1 << 11)  /* Mono to Stereo enable */
+#define	AIC_CR_ENDSW		(1 << 10)  /* Endian switch enable */
+#define	AIC_CR_AVSTSU		(1 << 9)   /* Signed <-> Unsigned toggle enable */
+#define	AIC_CR_FLUSH		(1 << 8)   /* Flush FIFO */
+#define	AIC_CR_EROR		(1 << 6)   /* Enable ROR interrupt */
+#define	AIC_CR_ETUR		(1 << 5)   /* Enable TUR interrupt */
+#define	AIC_CR_ERFS		(1 << 4)   /* Enable RFS interrupt */
+#define	AIC_CR_ETFS		(1 << 3)   /* Enable TFS interrupt */
+#define	AIC_CR_ENLBF		(1 << 2)   /* Enable Loopback Function */
+#define	AIC_CR_ERPL		(1 << 1)   /* Enable Playback Function */
+#define	AIC_CR_EREC		(1 << 0)   /* Enable Record Function */
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16          /* Receive Valid Slots */
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit, PCM Left */
+#define	AIC_ACCR1_XS_BIT	0          /* Transmit Valid Slots */
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit, PCM Left */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18) /* Enable RSTO interrupt */
+#define	AIC_ACCR2_ESADR		(1 << 17) /* Enable SADR interrupt */
+#define	AIC_ACCR2_ECADT		(1 << 16) /* Enable CADT interrupt */
+#define	AIC_ACCR2_OASS_BIT	8  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)  /* SDATA_OUT output value */
+#define	AIC_ACCR2_SR		(1 << 2)  /* RESET# pin level */
+#define	AIC_ACCR2_SS		(1 << 1)  /* SYNC pin level */
+#define	AIC_ACCR2_SA		(1 << 0)  /* SYNC and SDATA_OUT alternation */
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12) /* Stop BIT_CLK for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_BIT	1  /* Input/Output Sample Size for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0) /* 0:I2S, 1:MSB-justified */
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24  /* Receive FIFO Level */
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8   /* Transmit FIFO level */
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6) /* Receive FIFO Overrun */
+#define	AIC_SR_TUR		(1 << 5) /* Transmit FIFO Underrun */
+#define	AIC_SR_RFS		(1 << 4) /* Receive FIFO Service Request */
+#define	AIC_SR_TFS		(1 << 3) /* Transmit FIFO Service Request */
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_SLTERR		(1 << 21) /* Slot Error Flag */
+#define	AIC_ACSR_CRDY		(1 << 20) /* External CODEC Ready Flag */
+#define	AIC_ACSR_CLPM		(1 << 19) /* External CODEC low power mode flag */
+#define	AIC_ACSR_RSTO		(1 << 18) /* External CODEC regs read status timeout */
+#define	AIC_ACSR_SADR		(1 << 17) /* External CODEC regs status addr and data received */
+#define	AIC_ACSR_CADT		(1 << 16) /* Command Address and Data Transmitted */
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)  /* AIC Busy in I2S/MSB-justified format */
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+/*************************************************************************
+ * ICDC (Internal CODEC)
+ *************************************************************************/
+#define	ICDC_CR			(ICDC_BASE + 0x0400)  /* ICDC Control Register */
+#define	ICDC_APWAIT		(ICDC_BASE + 0x0404)  /* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APPRE		(ICDC_BASE + 0x0408)  /* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APHPEN		(ICDC_BASE + 0x040C)  /* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APSR		(ICDC_BASE + 0x0410)  /* Anti-Pop Status Register */
+#define ICDC_CDCCR1             (ICDC_BASE + 0x0080)
+#define ICDC_CDCCR2             (ICDC_BASE + 0x0084)
+
+#define	REG_ICDC_CR		REG32(ICDC_CR)
+#define	REG_ICDC_APWAIT		REG32(ICDC_APWAIT)
+#define	REG_ICDC_APPRE		REG32(ICDC_APPRE)
+#define	REG_ICDC_APHPEN		REG32(ICDC_APHPEN)
+#define	REG_ICDC_APSR		REG32(ICDC_APSR)
+#define REG_ICDC_CDCCR1         REG32(ICDC_CDCCR1)
+#define REG_ICDC_CDCCR2         REG32(ICDC_CDCCR2)
+
+/* ICDC Control Register */
+#define	ICDC_CR_LINVOL_BIT	24 /* LINE Input Volume Gain: GAIN=LINVOL*1.5-34.5 */
+#define	ICDC_CR_LINVOL_MASK	(0x1f << ICDC_CR_LINVOL_BIT)
+#define	ICDC_CR_ASRATE_BIT	20 /* Audio Sample Rate */
+#define	ICDC_CR_ASRATE_MASK	(0x0f << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_8000	(0x0 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_11025	(0x1 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_12000	(0x2 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_16000	(0x3 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_22050	(0x4 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_24000	(0x5 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_32000	(0x6 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_44100	(0x7 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_48000	(0x8 << ICDC_CR_ASRATE_BIT)
+#define	ICDC_CR_MICBG_BIT	18 /* MIC Boost Gain */
+#define	ICDC_CR_MICBG_MASK	(0x3 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_0DB	(0x0 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_6DB	(0x1 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_12DB	(0x2 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_20DB	(0x3 << ICDC_CR_MICBG_BIT)
+#define	ICDC_CR_HPVOL_BIT	16 /* Headphone Volume Gain */
+#define	ICDC_CR_HPVOL_MASK	(0x3 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_0DB	(0x0 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_2DB	(0x1 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_4DB	(0x2 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_6DB	(0x3 << ICDC_CR_HPVOL_BIT)
+#define ICDC_CR_ELINEIN		(1 << 13) /* Enable LINE Input */
+#define ICDC_CR_EMIC		(1 << 12) /* Enable MIC Input */
+#define ICDC_CR_SW1ON		(1 << 11) /* Switch 1 in CODEC is on */
+#define ICDC_CR_EADC		(1 << 10) /* Enable ADC */
+#define ICDC_CR_SW2ON		(1 << 9)  /* Switch 2 in CODEC is on */
+#define ICDC_CR_EDAC		(1 << 8)  /* Enable DAC */
+#define ICDC_CR_HPMUTE		(1 << 5)  /* Headphone Mute */
+#define ICDC_CR_HPTON		(1 << 4)  /* Headphone Amplifier Trun On */
+#define ICDC_CR_HPTOFF		(1 << 3)  /* Headphone Amplifier Trun Off */
+#define ICDC_CR_TAAP		(1 << 2)  /* Turn Around of the Anti-Pop Procedure */
+#define ICDC_CR_EAP		(1 << 1)  /* Enable Anti-Pop Procedure */
+#define ICDC_CR_SUSPD		(1 << 0)  /* CODEC Suspend */
+
+/* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APWAIT_WAITSN_BIT	0
+#define	ICDC_APWAIT_WAITSN_MASK	(0x7ff << ICDC_APWAIT_WAITSN_BIT)
+
+/* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APPRE_PRESN_BIT	0
+#define	ICDC_APPRE_PRESN_MASK	(0x1ff << ICDC_APPRE_PRESN_BIT)
+
+/* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APHPEN_HPENSN_BIT	0
+#define	ICDC_APHPEN_HPENSN_MASK	(0x3fff << ICDC_APHPEN_HPENSN_BIT)
+
+/* Anti-Pop Status Register */
+#define	ICDC_SR_HPST_BIT	14  /* Headphone Amplifier State */
+#define	ICDC_SR_HPST_MASK	(0x7 << ICDC_SR_HPST_BIT)
+#define ICDC_SR_HPST_HP_OFF	 (0x0 << ICDC_SR_HPST_BIT) /* HP amplifier is off */
+#define ICDC_SR_HPST_TON_WAIT	 (0x1 << ICDC_SR_HPST_BIT) /* wait state in turn-on */
+  #define ICDC_SR_HPST_TON_PRE	 (0x2 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-on */
+#define ICDC_SR_HPST_TON_HPEN	 (0x3 << ICDC_SR_HPST_BIT) /* HP enable state in turn-on */
+  #define ICDC_SR_HPST_TOFF_HPEN (0x4 << ICDC_SR_HPST_BIT) /* HP enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_PRE  (0x5 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_WAIT (0x6 << ICDC_SR_HPST_BIT) /* wait state in turn-off */
+  #define ICDC_SR_HPST_HP_ON	 (0x7 << ICDC_SR_HPST_BIT) /* HP amplifier is on */
+#define	ICDC_SR_SNCNT_BIT	0  /* Sample Number Counter */
+#define	ICDC_SR_SNCNT_MASK	(0x3fff << ICDC_SR_SNCNT_BIT)
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+/*************************************************************************
+ * SSI (Synchronous Serial Interface)
+ *************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define	SSI_DR(n)		(SSI_BASE + 0x000 + (n)*0x2000)
+#define	SSI_CR0(n)		(SSI_BASE + 0x004 + (n)*0x2000)
+#define	SSI_CR1(n)		(SSI_BASE + 0x008 + (n)*0x2000)
+#define	SSI_SR(n)		(SSI_BASE + 0x00C + (n)*0x2000)
+#define	SSI_ITR(n)		(SSI_BASE + 0x010 + (n)*0x2000)
+#define	SSI_ICR(n)		(SSI_BASE + 0x014 + (n)*0x2000)
+#define	SSI_GR(n)		(SSI_BASE + 0x018 + (n)*0x2000)
+
+#define	REG_SSI_DR(n)		REG32(SSI_DR(n))
+#define	REG_SSI_CR0(n)		REG16(SSI_CR0(n))
+#define	REG_SSI_CR1(n)		REG32(SSI_CR1(n))
+#define	REG_SSI_SR(n)		REG32(SSI_SR(n))
+#define	REG_SSI_ITR(n)		REG16(SSI_ITR(n))
+#define	REG_SSI_ICR(n)		REG8(SSI_ICR(n))
+#define	REG_SSI_GR(n)		REG16(SSI_GR(n))
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+#define SSI_MAX_FIFO_ENTRIES 	128 /* 128 txfifo and 128 rxfifo */
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_EACLRUN		(1 << 7) /* hardware auto clear underrun when TxFifo no empty */
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_TTRG_BIT	16 /* SSI1 TX trigger */
+#define SSI_CR1_TTRG_MASK	(0xf << SSI1_CR1_TTRG_BIT) 
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_RTRG_BIT	8 /* SSI RX trigger */
+#define SSI_CR1_RTRG_MASK	(0xf << SSI1_CR1_RTRG_BIT)
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	16
+#define SSI_SR_TFIFONUM_MASK	(0xff << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0xff << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+
+/*************************************************************************
+ * MSC
+ *************************************************************************/
+#define	MSC_STRPCL		(MSC_BASE + 0x000)
+#define	MSC_STAT		(MSC_BASE + 0x004)
+#define	MSC_CLKRT		(MSC_BASE + 0x008)
+#define	MSC_CMDAT		(MSC_BASE + 0x00C)
+#define	MSC_RESTO		(MSC_BASE + 0x010)
+#define	MSC_RDTO		(MSC_BASE + 0x014)
+#define	MSC_BLKLEN		(MSC_BASE + 0x018)
+#define	MSC_NOB			(MSC_BASE + 0x01C)
+#define	MSC_SNOB		(MSC_BASE + 0x020)
+#define	MSC_IMASK		(MSC_BASE + 0x024)
+#define	MSC_IREG		(MSC_BASE + 0x028)
+#define	MSC_CMD			(MSC_BASE + 0x02C)
+#define	MSC_ARG			(MSC_BASE + 0x030)
+#define	MSC_RES			(MSC_BASE + 0x034)
+#define	MSC_RXFIFO		(MSC_BASE + 0x038)
+#define	MSC_TXFIFO		(MSC_BASE + 0x03C)
+
+#define	REG_MSC_STRPCL		REG16(MSC_STRPCL)
+#define	REG_MSC_STAT		REG32(MSC_STAT)
+#define	REG_MSC_CLKRT		REG16(MSC_CLKRT)
+#define	REG_MSC_CMDAT		REG32(MSC_CMDAT)
+#define	REG_MSC_RESTO		REG16(MSC_RESTO)
+#define	REG_MSC_RDTO		REG16(MSC_RDTO)
+#define	REG_MSC_BLKLEN		REG16(MSC_BLKLEN)
+#define	REG_MSC_NOB		REG16(MSC_NOB)
+#define	REG_MSC_SNOB		REG16(MSC_SNOB)
+#define	REG_MSC_IMASK		REG16(MSC_IMASK)
+#define	REG_MSC_IREG		REG16(MSC_IREG)
+#define	REG_MSC_CMD		REG8(MSC_CMD)
+#define	REG_MSC_ARG		REG32(MSC_ARG)
+#define	REG_MSC_RES		REG16(MSC_RES)
+#define	REG_MSC_RXFIFO		REG32(MSC_RXFIFO)
+#define	REG_MSC_TXFIFO		REG32(MSC_TXFIFO)
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	  (0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	  (0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	  (0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	  (0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	  (0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	  (0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	  (0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	  (0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+
+#define	MSC_CMDAT_IO_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define CMDAT_BUS_WIDTH1	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define CMDAT_BUS_WIDTH4	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT)
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE  (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+
+/*************************************************************************
+ * EMC (External Memory Controller)
+ *************************************************************************/
+#define EMC_BCR		(EMC_BASE + 0x0)  /* BCR */
+
+#define EMC_SMCR0	(EMC_BASE + 0x10)  /* Static Memory Control Register 0 */
+#define EMC_SMCR1	(EMC_BASE + 0x14)  /* Static Memory Control Register 1 */
+#define EMC_SMCR2	(EMC_BASE + 0x18)  /* Static Memory Control Register 2 */
+#define EMC_SMCR3	(EMC_BASE + 0x1c)  /* Static Memory Control Register 3 */
+#define EMC_SMCR4	(EMC_BASE + 0x20)  /* Static Memory Control Register 4 */
+#define EMC_SACR0	(EMC_BASE + 0x30)  /* Static Memory Bank 0 Addr Config Reg */
+#define EMC_SACR1	(EMC_BASE + 0x34)  /* Static Memory Bank 1 Addr Config Reg */
+#define EMC_SACR2	(EMC_BASE + 0x38)  /* Static Memory Bank 2 Addr Config Reg */
+#define EMC_SACR3	(EMC_BASE + 0x3c)  /* Static Memory Bank 3 Addr Config Reg */
+#define EMC_SACR4	(EMC_BASE + 0x40)  /* Static Memory Bank 4 Addr Config Reg */
+
+#define EMC_NFCSR	(EMC_BASE + 0x050) /* NAND Flash Control/Status Register */
+
+#define EMC_DMCR	(EMC_BASE + 0x80)  /* DRAM Control Register */
+#define EMC_RTCSR	(EMC_BASE + 0x84)  /* Refresh Time Control/Status Register */
+#define EMC_RTCNT	(EMC_BASE + 0x88)  /* Refresh Timer Counter */
+#define EMC_RTCOR	(EMC_BASE + 0x8c)  /* Refresh Time Constant Register */
+#define EMC_DMAR0	(EMC_BASE + 0x90)  /* SDRAM Bank 0 Addr Config Register */
+#define EMC_DMAR1	(EMC_BASE + 0x94)  /* SDRAM Bank 1 Addr Config Register */
+#define EMC_SDMR0	(EMC_BASE + 0x8000) /* Mode Register of SDRAM bank 0 */
+
+#define REG_EMC_BCR	REG32(EMC_BCR)
+
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR0	REG32(EMC_DMAR0)
+#define REG_EMC_DMAR1	REG32(EMC_DMAR1)
+
+/* Bus Control Register */
+#define EMC_BCR_BT_SEL_BIT      30
+#define EMC_BCR_BT_SEL_MASK     (0x3 << EMC_BCR_BT_SEL_BIT)
+#define EMC_BCR_PK_SEL          (1 << 24)
+#define EMC_BCR_BSR_MASK          (1 << 2)  /* Nand and SDRAM Bus Share Select: 0, share; 1, unshare */
+  #define EMC_BCR_BSR_SHARE       (0 << 2)
+  #define EMC_BCR_BSR_UNSHARE     (1 << 2)
+#define EMC_BCR_BRE             (1 << 1)
+#define EMC_BCR_ENDIAN          (1 << 0)
+
+/* Static Memory Control Register */
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+/* Static Memory Bank Addr Config Reg */
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+/* NAND Flash Control/Status Register */
+#define EMC_NFCSR_NFCE4		(1 << 7) /* NAND Flash Enable */
+#define EMC_NFCSR_NFE4		(1 << 6) /* NAND Flash FCE# Assertion Enable */
+#define EMC_NFCSR_NFCE3		(1 << 5)
+#define EMC_NFCSR_NFE3		(1 << 4)
+#define EMC_NFCSR_NFCE2		(1 << 3)
+#define EMC_NFCSR_NFE2		(1 << 2)
+#define EMC_NFCSR_NFCE1		(1 << 1)
+#define EMC_NFCSR_NFE1		(1 << 0)
+
+/* DRAM Control Register */
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_MBSEL_BIT	16
+  #define EMC_DMCR_MBSEL_B0	(0 << 16)
+  #define EMC_DMCR_MBSEL_B1	(1 << 16)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+/* Refresh Time Control/Status Register */
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+/* SDRAM Bank Address Configuration Register */
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+/* Mode Register of SDRAM bank 0 */
+#define EMC_SDMR_BM		(1 << 9) /* Write Burst Mode */
+#define EMC_SDMR_OM_BIT		7        /* Operating Mode */
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4        /* CAS Latency */
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3        /* Burst Type */
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT) /* Sequential */
+  #define EMC_SDMR_BT_INT	(1 << EMC_SDMR_BT_BIT) /* Interleave */
+#define EMC_SDMR_BL_BIT		0        /* Burst Length */
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+/* Extended Mode Register of Mobile SDRAM*/
+#define EMC_SDMR_SET_BA1		(1 << 14)	/*BA1*/
+#define EMC_SDMR_SET_BA0		(1 << 13)	/*BA0*/
+
+#define EMC_SDMR_DS_BIT		5	/* Driver strength */
+#define EMC_SDMR_DS_MASK	(3 << EMC_SDMR_DS_BIT)
+  #define EMC_SDMR_DS_FULL	(0 << EMC_SDMR_DS_BIT)	/*Full*/
+  #define EMC_SDMR_DS_HALF	(1 << EMC_SDMR_DS_BIT)	/*1/2 Strength*/
+  #define EMC_SDMR_DS_QUTR	(2 << EMC_SDMR_DS_BIT)	/*1/4 Strength*/
+
+#define EMC_SDMR_PRSR_BIT	0	/* Partial Array Self Refresh */
+#define EMC_SDMR_PRSR_MASK	(7 << EMC_SDMR_PRSR_BIT)
+  #define EMC_SDMR_PRSR_ALL	(0 << EMC_SDMR_PRSR_BIT) /*All Banks*/
+  #define EMC_SDMR_PRSR_HALF_TL	(1 << EMC_SDMR_PRSR_BIT) /*Half of Total Bank*/
+  #define EMC_SDMR_PRSR_QUTR_TL	(2 << EMC_SDMR_PRSR_BIT) /*Quarter of Total Bank*/
+  #define EMC_SDMR_PRSR_HALF_B0	(5 << EMC_SDMR_PRSR_BIT) /*Half of Bank0*/
+  #define EMC_SDMR_PRSR_QUTR_B0	(6 << EMC_SDMR_PRSR_BIT) /*Quarter of Bank0*/
+
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_MASK_BIT	0
+
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+#define EMC_DMAR0_BASE		(0x20 << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR1_BASE_64M	(0x24 << EMC_DMAR_BASE_BIT) /*when bank0 is 64M*/
+#define EMC_DMAR1_BASE_128M	(0x28 << EMC_DMAR_BASE_BIT) /*when bank0 is 128M*/
+
+#define EMC_DMAR_MASK_64_64	(0xfc << EMC_DMAR_MASK_BIT)  /*mask for two 64M SDRAM*/
+#define EMC_DMAR_MASK_128_128	(0xf8 << EMC_DMAR_MASK_BIT)  /*mask for two 128M SDRAM*/
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+
+/* CIM Configuration Register  (CIM_CFG) */
+
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14)
+#define	CIM_CFG_HSP		(1 << 13)
+#define	CIM_CFG_PCP		(1 << 12)
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+  #define CIM_CFG_DSM_NGCM	  (3 << CIM_CFG_DSM_BIT) /* Non-Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+
+#define	CIM_CTRL_MCLKDIV_BIT	24
+#define	CIM_CTRL_MCLKDIV_MASK	(0xff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+#define	CIM_CTRL_VDDM		(1 << 13)
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_RXF_TRIG_BIT	4
+#define	CIM_CTRL_RXF_TRIG_MASK	(0x7 << CIM_CTRL_RXF_TRIG_BIT)
+  #define CIM_CTRL_RXF_TRIG_4	  (0 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 4 */
+  #define CIM_CTRL_RXF_TRIG_8	  (1 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 8 */
+  #define CIM_CTRL_RXF_TRIG_12	  (2 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 12 */
+  #define CIM_CTRL_RXF_TRIG_16	  (3 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 16 */
+  #define CIM_CTRL_RXF_TRIG_20	  (4 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 20 */
+  #define CIM_CTRL_RXF_TRIG_24	  (5 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 24 */
+  #define CIM_CTRL_RXF_TRIG_28	  (6 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 28 */
+  #define CIM_CTRL_RXF_TRIG_32	  (7 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 32 */
+#define	CIM_CTRL_DMA_EN		(1 << 2)
+#define	CIM_CTRL_RXF_RST	(1 << 1)
+#define	CIM_CTRL_ENA		(1 << 0)
+
+/* CIM State Register  (CIM_STATE) */
+
+#define	CIM_STATE_DMA_SOF	(1 << 6)
+#define	CIM_STATE_DMA_EOF	(1 << 5)
+#define	CIM_STATE_DMA_STOP	(1 << 4)
+#define	CIM_STATE_RXF_OF	(1 << 3)
+#define	CIM_STATE_RXF_TRIG	(1 << 2)
+#define	CIM_STATE_RXF_EMPTY	(1 << 1)
+#define	CIM_STATE_VDD		(1 << 0)
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31)
+#define	CIM_CMD_EOFINT		(1 << 30)
+#define	CIM_CMD_STOP		(1 << 28)
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+
+/*************************************************************************
+ * SADC (Smart A/D Controller)
+ *************************************************************************/
+
+#define SADC_ENA	(SADC_BASE + 0x00)  /* ADC Enable Register */
+#define SADC_CFG	(SADC_BASE + 0x04)  /* ADC Configure Register */
+#define SADC_CTRL	(SADC_BASE + 0x08)  /* ADC Control Register */
+#define SADC_STATE	(SADC_BASE + 0x0C)  /* ADC Status Register*/
+#define SADC_SAMETIME	(SADC_BASE + 0x10)  /* ADC Same Point Time Register */
+#define SADC_WAITTIME	(SADC_BASE + 0x14)  /* ADC Wait Time Register */
+#define SADC_TSDAT	(SADC_BASE + 0x18)  /* ADC Touch Screen Data Register */
+#define SADC_BATDAT	(SADC_BASE + 0x1C)  /* ADC PBAT Data Register */
+#define SADC_SADDAT	(SADC_BASE + 0x20)  /* ADC SADCIN Data Register */
+
+#define REG_SADC_ENA		REG8(SADC_ENA)
+#define REG_SADC_CFG		REG32(SADC_CFG)
+#define REG_SADC_CTRL		REG8(SADC_CTRL)
+#define REG_SADC_STATE		REG8(SADC_STATE)
+#define REG_SADC_SAMETIME	REG16(SADC_SAMETIME)
+#define REG_SADC_WAITTIME	REG16(SADC_WAITTIME)
+#define REG_SADC_TSDAT		REG32(SADC_TSDAT)
+#define REG_SADC_BATDAT		REG16(SADC_BATDAT)
+#define REG_SADC_SADDAT		REG16(SADC_SADDAT)
+
+/* ADC Enable Register */
+#define SADC_ENA_ADEN		(1 << 7)  /* Touch Screen Enable */
+#define SADC_ENA_TSEN		(1 << 2)  /* Touch Screen Enable */
+#define SADC_ENA_PBATEN		(1 << 1)  /* PBAT Enable */
+#define SADC_ENA_SADCINEN	(1 << 0)  /* SADCIN Enable */
+
+/* ADC Configure Register */
+#define SADC_CFG_CLKOUT_NUM_BIT	16
+#define SADC_CFG_CLKOUT_NUM_MASK (0x7 << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_TS_DMA		(1 << 15)  /* Touch Screen DMA Enable */
+#define SADC_CFG_XYZ_BIT	13  /* XYZ selection */
+#define SADC_CFG_XYZ_MASK	(0x3 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XY		(0 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ		(1 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ1Z2	(2 << SADC_CFG_XYZ_BIT)
+#define SADC_CFG_SNUM_BIT	10  /* Sample Number */
+#define SADC_CFG_SNUM_MASK	(0x7 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_1	(0x0 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_2	(0x1 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_3	(0x2 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_4	(0x3 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_5	(0x4 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_6	(0x5 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_8	(0x6 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_9	(0x7 << SADC_CFG_SNUM_BIT)
+#define SADC_CFG_CLKDIV_BIT	5  /* AD Converter frequency clock divider */
+#define SADC_CFG_CLKDIV_MASK	(0x1f << SADC_CFG_CLKDIV_BIT)
+#define SADC_CFG_PBAT_HIGH	(0 << 4)  /* PBAT >= 2.5V */
+#define SADC_CFG_PBAT_LOW	(1 << 4)  /* PBAT < 2.5V */
+#define SADC_CFG_CMD_BIT	0  /* ADC Command */
+#define SADC_CFG_CMD_MASK	(0xf << SADC_CFG_CMD_BIT)
+  #define SADC_CFG_CMD_X_SE	(0x0 << SADC_CFG_CMD_BIT) /* X Single-End */
+  #define SADC_CFG_CMD_Y_SE	(0x1 << SADC_CFG_CMD_BIT) /* Y Single-End */
+  #define SADC_CFG_CMD_X_DIFF	(0x2 << SADC_CFG_CMD_BIT) /* X Differential */
+  #define SADC_CFG_CMD_Y_DIFF	(0x3 << SADC_CFG_CMD_BIT) /* Y Differential */
+  #define SADC_CFG_CMD_Z1_DIFF	(0x4 << SADC_CFG_CMD_BIT) /* Z1 Differential */
+  #define SADC_CFG_CMD_Z2_DIFF	(0x5 << SADC_CFG_CMD_BIT) /* Z2 Differential */
+  #define SADC_CFG_CMD_Z3_DIFF	(0x6 << SADC_CFG_CMD_BIT) /* Z3 Differential */
+  #define SADC_CFG_CMD_Z4_DIFF	(0x7 << SADC_CFG_CMD_BIT) /* Z4 Differential */
+  #define SADC_CFG_CMD_TP_SE	(0x8 << SADC_CFG_CMD_BIT) /* Touch Pressure */
+  #define SADC_CFG_CMD_PBATH_SE	(0x9 << SADC_CFG_CMD_BIT) /* PBAT >= 2.5V */
+  #define SADC_CFG_CMD_PBATL_SE	(0xa << SADC_CFG_CMD_BIT) /* PBAT < 2.5V */
+  #define SADC_CFG_CMD_SADCIN_SE (0xb << SADC_CFG_CMD_BIT) /* Measure SADCIN */
+  #define SADC_CFG_CMD_INT_PEN	(0xc << SADC_CFG_CMD_BIT) /* INT_PEN Enable */
+
+/* ADC Control Register */
+#define SADC_CTRL_PENDM		(1 << 4)  /* Pen Down Interrupt Mask */
+#define SADC_CTRL_PENUM		(1 << 3)  /* Pen Up Interrupt Mask */
+#define SADC_CTRL_TSRDYM	(1 << 2)  /* Touch Screen Data Ready Interrupt Mask */
+#define SADC_CTRL_PBATRDYM	(1 << 1)  /* PBAT Data Ready Interrupt Mask */
+#define SADC_CTRL_SRDYM		(1 << 0)  /* SADCIN Data Ready Interrupt Mask */
+
+/* ADC Status Register */
+#define SADC_STATE_TSBUSY	(1 << 7)  /* TS A/D is working */
+#define SADC_STATE_PBATBUSY	(1 << 6)  /* PBAT A/D is working */
+#define SADC_STATE_SBUSY	(1 << 5)  /* SADCIN A/D is working */
+#define SADC_STATE_PEND		(1 << 4)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PENU		(1 << 3)  /* Pen Up Interrupt Flag */
+#define SADC_STATE_TSRDY	(1 << 2)  /* Touch Screen Data Ready Interrupt Flag */
+#define SADC_STATE_PBATRDY	(1 << 1)  /* PBAT Data Ready Interrupt Flag */
+#define SADC_STATE_SRDY		(1 << 0)  /* SADCIN Data Ready Interrupt Flag */
+
+/* ADC Touch Screen Data Register */
+#define SADC_TSDAT_DATA0_BIT	0
+#define SADC_TSDAT_DATA0_MASK	(0xfff << SADC_TSDAT_DATA0_BIT)
+#define SADC_TSDAT_TYPE0	(1 << 15)
+#define SADC_TSDAT_DATA1_BIT	16
+#define SADC_TSDAT_DATA1_MASK	(0xfff << SADC_TSDAT_DATA1_BIT)
+#define SADC_TSDAT_TYPE1	(1 << 31)
+
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+
+#define SLCD_CFG	(SLCD_BASE + 0xA0)  /* SLCD Configure Register */
+#define SLCD_CTRL	(SLCD_BASE + 0xA4)  /* SLCD Control Register */
+#define SLCD_STATE	(SLCD_BASE + 0xA8)  /* SLCD Status Register */
+#define SLCD_DATA	(SLCD_BASE + 0xAC)  /* SLCD Data Register */
+
+#define REG_SLCD_CFG	REG32(SLCD_CFG)
+#define REG_SLCD_CTRL	REG8(SLCD_CTRL)
+#define REG_SLCD_STATE	REG8(SLCD_STATE)
+#define REG_SLCD_DATA	REG32(SLCD_DATA)
+
+/* SLCD Configure Register */
+#define SLCD_CFG_BURST_BIT	14
+#define SLCD_CFG_BURST_MASK	(0x3 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_4_WORD	(0 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_8_WORD	(1 << SLCD_CFG_BURST_BIT)
+#define SLCD_CFG_DWIDTH_BIT	10
+#define SLCD_CFG_DWIDTH_MASK	(0x7 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_18	(0 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_16	(1 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x3	(2 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x2	(3 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_9_x2	(4 << SLCD_CFG_DWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_16BIT	(0 << 8)
+#define SLCD_CFG_CWIDTH_8BIT	(1 << 8)
+#define SLCD_CFG_CS_ACTIVE_LOW	(0 << 4)
+#define SLCD_CFG_CS_ACTIVE_HIGH	(1 << 4)
+#define SLCD_CFG_RS_CMD_LOW	(0 << 3)
+#define SLCD_CFG_RS_CMD_HIGH	(1 << 3)
+#define SLCD_CFG_CLK_ACTIVE_FALLING	(0 << 1)
+#define SLCD_CFG_CLK_ACTIVE_RISING	(1 << 1)
+#define SLCD_CFG_TYPE_PARALLEL	(0 << 0)
+#define SLCD_CFG_TYPE_SERIAL	(1 << 0)
+
+/* SLCD Control Register */
+#define SLCD_CTRL_DMA_EN	(1 << 0)
+
+/* SLCD Status Register */
+#define SLCD_STATE_BUSY		(1 << 0)
+
+/* SLCD Data Register */
+#define SLCD_DATA_RS_DATA	(0 << 31)
+#define SLCD_DATA_RS_COMMAND	(1 << 31)
+
+/*************************************************************************
+ * LCD (LCD Controller)
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00) /* LCD Configure Register */
+#define LCD_CTRL	(LCD_BASE + 0x30) /* LCD Control Register */
+#define LCD_STATE	(LCD_BASE + 0x34) /* LCD Status Register */
+
+#define LCD_OSDC	(LCD_BASE + 0x100) /* LCD OSD Configure Register */
+#define LCD_OSDCTRL	(LCD_BASE + 0x104) /* LCD OSD Control Register */
+#define LCD_OSDS	(LCD_BASE + 0x108) /* LCD OSD Status Register */
+#define LCD_BGC		(LCD_BASE + 0x10C) /* LCD Background Color Register */
+#define LCD_KEY0	(LCD_BASE + 0x110) /* LCD Foreground Color Key Register 0 */
+#define LCD_KEY1	(LCD_BASE + 0x114) /* LCD Foreground Color Key Register 1 */
+#define LCD_ALPHA	(LCD_BASE + 0x118) /* LCD ALPHA Register */
+#define LCD_IPUR	(LCD_BASE + 0x11C) /* LCD IPU Restart Register */
+
+#define LCD_VAT		(LCD_BASE + 0x0c) /* Virtual Area Setting Register */
+#define LCD_DAH		(LCD_BASE + 0x10) /* Display Area Horizontal Start/End Point */
+#define LCD_DAV		(LCD_BASE + 0x14) /* Display Area Vertical Start/End Point */
+
+#define LCD_XYP0	(LCD_BASE + 0x120) /* Foreground 0 XY Position Register */
+#define LCD_XYP1	(LCD_BASE + 0x124) /* Foreground 1 XY Position Register */
+#define LCD_SIZE0	(LCD_BASE + 0x128) /* Foreground 0 Size Register */
+#define LCD_SIZE1	(LCD_BASE + 0x12C) /* Foreground 1 Size Register */
+#define LCD_RGBC	(LCD_BASE + 0x90) /* RGB Controll Register */
+
+#define LCD_VSYNC	(LCD_BASE + 0x04) /* Vertical Synchronize Register */
+#define LCD_HSYNC	(LCD_BASE + 0x08) /* Horizontal Synchronize Register */
+#define LCD_PS		(LCD_BASE + 0x18) /* PS Signal Setting */
+#define LCD_CLS		(LCD_BASE + 0x1c) /* CLS Signal Setting */
+#define LCD_SPL		(LCD_BASE + 0x20) /* SPL Signal Setting */
+#define LCD_REV		(LCD_BASE + 0x24) /* REV Signal Setting */
+#define LCD_IID		(LCD_BASE + 0x38) /* Interrupt ID Register */
+#define LCD_DA0		(LCD_BASE + 0x40) /* Descriptor Address Register 0 */
+#define LCD_SA0		(LCD_BASE + 0x44) /* Source Address Register 0 */
+#define LCD_FID0	(LCD_BASE + 0x48) /* Frame ID Register 0 */
+#define LCD_CMD0	(LCD_BASE + 0x4c) /* DMA Command Register 0 */
+#define LCD_DA1		(LCD_BASE + 0x50) /* Descriptor Address Register 1 */
+#define LCD_SA1		(LCD_BASE + 0x54) /* Source Address Register 1 */
+#define LCD_FID1	(LCD_BASE + 0x58) /* Frame ID Register 1 */
+#define LCD_CMD1	(LCD_BASE + 0x5c) /* DMA Command Register 1 */
+
+#define LCD_OFFS0	(LCD_BASE + 0x60) /* DMA Offsize Register 0 */
+#define LCD_PW0		(LCD_BASE + 0x64) /* DMA Page Width Register 0 */
+#define LCD_CNUM0	(LCD_BASE + 0x68) /* DMA Command Counter Register 0 */
+#define LCD_DESSIZE0	(LCD_BASE + 0x6C) /* Foreground Size in Descriptor 0 Register*/
+#define LCD_OFFS1	(LCD_BASE + 0x70) /* DMA Offsize Register 1 */
+#define LCD_PW1		(LCD_BASE + 0x74) /* DMA Page Width Register 1 */
+#define LCD_CNUM1	(LCD_BASE + 0x78) /* DMA Command Counter Register 1 */
+#define LCD_DESSIZE1	(LCD_BASE + 0x7C) /* Foreground Size in Descriptor 1 Register*/
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+
+#define REG_LCD_OSDC	REG16(LCD_OSDC)
+#define REG_LCD_OSDCTRL	REG16(LCD_OSDCTRL)
+#define REG_LCD_OSDS	REG16(LCD_OSDS)
+#define REG_LCD_BGC	REG32(LCD_BGC)
+#define REG_LCD_KEY0	REG32(LCD_KEY0)
+#define REG_LCD_KEY1	REG32(LCD_KEY1)
+#define REG_LCD_ALPHA	REG8(LCD_ALPHA)
+#define REG_LCD_IPUR	REG32(LCD_IPUR)
+
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+
+#define REG_LCD_XYP0	REG32(LCD_XYP0)
+#define REG_LCD_XYP1	REG32(LCD_XYP1)
+#define REG_LCD_SIZE0	REG32(LCD_SIZE0)
+#define REG_LCD_SIZE1	REG32(LCD_SIZE1)
+#define REG_LCD_RGBC	REG16(LCD_RGBC)
+
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+#define REG_LCD_OFFS0	REG32(LCD_OFFS0)
+#define REG_LCD_PW0	REG32(LCD_PW0)
+#define REG_LCD_CNUM0	REG32(LCD_CNUM0)
+#define REG_LCD_DESSIZE0	REG32(LCD_DESSIZE0)
+#define REG_LCD_OFFS1	REG32(LCD_OFFS1)
+#define REG_LCD_PW1	REG32(LCD_PW1)
+#define REG_LCD_CNUM1	REG32(LCD_CNUM1)
+#define REG_LCD_DESSIZE1	REG32(LCD_DESSIZE1)
+
+/* LCD Configure Register */
+#define LCD_CFG_LCDPIN_BIT	31  /* LCD pins selection */
+#define LCD_CFG_LCDPIN_MASK	(0x1 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_LCD	(0x0 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_SLCD	(0x1 << LCD_CFG_LCDPIN_BIT)
+#define LCD_CFG_FUHOLD		(1 << 29) /* hold pixel clock when outFIFO underrun */
+#define LCD_CFG_NEWDES		(1 << 28) /* use new descripter. old: 4words, new:8words */
+#define LCD_CFG_PALBP		(1 << 27) /* bypass data format and alpha blending */
+#define LCD_CFG_TVEN		(1 << 26) /* indicate the terminal is lcd or tv */
+#define LCD_CFG_RECOVER		(1 << 25) /* Auto recover when output fifo underrun */
+#define LCD_CFG_DITHER		(1 << 24) /* Dither function */
+#define LCD_CFG_PSM		(1 << 23) /* PS signal mode */
+#define LCD_CFG_CLSM		(1 << 22) /* CLS signal mode */
+#define LCD_CFG_SPLM		(1 << 21) /* SPL signal mode */
+#define LCD_CFG_REVM		(1 << 20) /* REV signal mode */
+#define LCD_CFG_HSYNM		(1 << 19) /* HSYNC signal mode */
+#define LCD_CFG_PCLKM		(1 << 18) /* PCLK signal mode */
+#define LCD_CFG_INVDAT		(1 << 17) /* Inverse output data */
+#define LCD_CFG_SYNDIR_IN	(1 << 16) /* VSYNC&HSYNC direction */
+#define LCD_CFG_PSP		(1 << 15) /* PS pin reset state */
+#define LCD_CFG_CLSP		(1 << 14) /* CLS pin reset state */
+#define LCD_CFG_SPLP		(1 << 13) /* SPL pin reset state */
+#define LCD_CFG_REVP		(1 << 12) /* REV pin reset state */
+#define LCD_CFG_HSP		(1 << 11) /* HSYNC pority:0-active high,1-active low */
+#define LCD_CFG_PCP		(1 << 10) /* PCLK pority:0-rising,1-falling */
+#define LCD_CFG_DEP		(1 << 9)  /* DE pority:0-active high,1-active low */
+#define LCD_CFG_VSP		(1 << 8)  /* VSYNC pority:0-rising,1-falling */
+#define MODE_TFT_18BIT          (1 << 7)  /* 18bit TFT */
+#define LCD_CFG_PDW_BIT		4  /* STN pins utilization */
+#define LCD_CFG_PDW_MASK	(0x3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_PDW_1		(0 << LCD_CFG_PDW_BIT) /* LCD_D[0] */
+  #define LCD_CFG_PDW_2		(1 << LCD_CFG_PDW_BIT) /* LCD_D[0:1] */
+  #define LCD_CFG_PDW_4		(2 << LCD_CFG_PDW_BIT) /* LCD_D[0:3]/LCD_D[8:11] */
+  #define LCD_CFG_PDW_8		(3 << LCD_CFG_PDW_BIT) /* LCD_D[0:7]/LCD_D[8:15] */
+#define LCD_CFG_MODE_BIT	0  /* Display Device Mode Select */
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_CFG_MODE_BIT) /* 16,18 bit TFT */
+  #define LCD_CFG_MODE_SPECIAL_TFT_1	(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_2	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_3	(3 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(5 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SERIAL_TFT	(12 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_LCM  		(13 << LCD_CFG_MODE_BIT)
+  /* JZ47XX defines */
+  #define LCD_CFG_MODE_SHARP_HR		(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_CASIO_TFT	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SAMSUNG_ALPHA	(3 << LCD_CFG_MODE_BIT)
+
+/* LCD Control Register */
+#define LCD_CTRL_BST_BIT	28  /* Burst Length Selection */
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT) /* 4-word */
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT) /* 8-word */
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT) /* 16-word */
+  #define LCD_CTRL_BST_32	(3 << LCD_CTRL_BST_BIT) /* 32-word */
+#define LCD_CTRL_RGB565		(0 << 27) /* RGB565 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_RGB555		(1 << 27) /* RGB555 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_OFUP		(1 << 26) /* Output FIFO underrun protection enable */
+#define LCD_CTRL_FRC_BIT	24  /* STN FRC Algorithm Selection */
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT) /* 16 grayscale */
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT) /* 4 grayscale */
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT) /* 2 grayscale */
+#define LCD_CTRL_PDD_BIT	16  /* Load Palette Delay Counter */
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13) /* EOF interrupt mask */
+#define LCD_CTRL_SOFM		(1 << 12) /* SOF interrupt mask */
+#define LCD_CTRL_OFUM		(1 << 11) /* Output FIFO underrun interrupt mask */
+#define LCD_CTRL_IFUM0		(1 << 10) /* Input FIFO 0 underrun interrupt mask */
+#define LCD_CTRL_IFUM1		(1 << 9)  /* Input FIFO 1 underrun interrupt mask */
+#define LCD_CTRL_LDDM		(1 << 8)  /* LCD disable done interrupt mask */
+#define LCD_CTRL_QDM		(1 << 7)  /* LCD quick disable done interrupt mask */
+#define LCD_CTRL_BEDN		(1 << 6)  /* Endian selection */
+#define LCD_CTRL_PEDN		(1 << 5)  /* Endian in byte:0-msb first, 1-lsb first */
+#define LCD_CTRL_DIS		(1 << 4)  /* Disable indicate bit */
+#define LCD_CTRL_ENA		(1 << 3)  /* LCD enable bit */
+#define LCD_CTRL_BPP_BIT	0  /* Bits Per Pixel */
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT) /* 1 bpp */
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT) /* 2 bpp */
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT) /* 4 bpp */
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT) /* 8 bpp */
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT) /* 15/16 bpp */
+  #define LCD_CTRL_BPP_18_24	(5 << LCD_CTRL_BPP_BIT) /* 18/24/32 bpp */
+
+/* LCD Status Register */
+#define LCD_STATE_QD		(1 << 7) /* Quick Disable Done */
+#define LCD_STATE_EOF		(1 << 5) /* EOF Flag */
+#define LCD_STATE_SOF		(1 << 4) /* SOF Flag */
+#define LCD_STATE_OFU		(1 << 3) /* Output FIFO Underrun */
+#define LCD_STATE_IFU0		(1 << 2) /* Input FIFO 0 Underrun */
+#define LCD_STATE_IFU1		(1 << 1) /* Input FIFO 1 Underrun */
+#define LCD_STATE_LDD		(1 << 0) /* LCD Disabled */
+
+/* OSD Configure Register */
+#define LCD_OSDC_SOFM1		(1 << 15) /* Start of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_EOFM1		(1 << 14) /* End of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_REM1		(1 << 13) /* Real end of frame mask for foreground 1 */
+#define LCD_OSDC_SOFM0		(1 << 11) /* Start of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_EOFM0		(1 << 10) /* End of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_REM0		(1 << 9) /* Real end of frame mask for foreground 0 */
+#define LCD_OSDC_REMB		(1 << 7) /* Real end of frame mask for background */
+#define LCD_OSDC_F1EN		(1 << 4) /* enable foreground 1 */
+#define LCD_OSDC_F0EN		(1 << 3) /* enable foreground 0 */
+#define LCD_OSDC_ALPHAEN		(1 << 2) /* enable alpha blending */
+#define LCD_OSDC_ALPHAMD		(1 << 1) /* alpha blending mode */
+#define LCD_OSDC_OSDEN		(1 << 0) /* OSD mode enable */
+
+/* OSD Controll Register */
+#define LCD_OSDCTRL_IPU		(1 << 15) /* input data from IPU */
+#define LCD_OSDCTRL_RGB565	(0 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_RGB555	(1 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_CHANGES	(1 << 3) /* Change size flag */
+#define LCD_OSDCTRL_OSDBPP_BIT	0 	 /* Bits Per Pixel of OSD Channel 1 */
+#define LCD_OSDCTRL_OSDBPP_MASK	(0x3<<LCD_OSDCTRL_OSDBPP_BIT) 	 /* Bits Per Pixel of OSD Channel 1's MASK */
+  #define LCD_OSDCTRL_OSDBPP_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_15_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_18_24	(5 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 18,24 bit*/
+
+/* OSD State Register */
+#define LCD_OSDS_SOF1		(1 << 15) /* Start of frame flag for foreground 1 */
+#define LCD_OSDS_EOF1		(1 << 14) /* End of frame flag for foreground 1 */
+#define LCD_OSDS_SOF0		(1 << 11) /* Start of frame flag for foreground 0 */
+#define LCD_OSDS_EOF0		(1 << 10) /* End of frame flag for foreground 0 */
+#define LCD_OSDS_READY		(1 << 0)  /* Read for accept the change */
+
+/* Background Color Register */
+#define LCD_BGC_RED_OFFSET	(1 << 16)  /* Red color offset */
+#define LCD_BGC_RED_MASK	(0xFF<<LCD_BGC_RED_OFFSET)
+#define LCD_BGC_GREEN_OFFSET	(1 << 8)   /* Green color offset */
+#define LCD_BGC_GREEN_MASK	(0xFF<<LCD_BGC_GREEN_OFFSET)
+#define LCD_BGC_BLUE_OFFSET	(1 << 0)   /* Blue color offset */
+#define LCD_BGC_BLUE_MASK	(0xFF<<LCD_BGC_BLUE_OFFSET)
+
+/* Foreground Color Key Register 0,1(foreground 0, foreground 1) */
+#define LCD_KEY_KEYEN		(1 << 31)   /* enable color key */
+#define LCD_KEY_KEYMD		(1 << 30)   /* color key mode */
+#define LCD_KEY_RED_OFFSET	(1 << 16)  /* Red color offset */
+#define LCD_KEY_RED_MASK	(0xFF<<LCD_KEY_RED_OFFSET)
+#define LCD_KEY_GREEN_OFFSET	(1 << 8)   /* Green color offset */
+#define LCD_KEY_GREEN_MASK	(0xFF<<LCD_KEY_GREEN_OFFSET)
+#define LCD_KEY_BLUE_OFFSET	(1 << 0)   /* Blue color offset */
+#define LCD_KEY_BLUE_MASK	(0xFF<<LCD_KEY_BLUE_OFFSET)
+
+/* IPU Restart Register */
+#define LCD_IPUR_IPUREN		(1 << 31)   /* IPU restart function enable*/
+
+/* RGB Control Register */
+#define LCD_RGBC_RGBDM		(1 << 15)   /* enable RGB Dummy data */
+#define LCD_RGBC_DMM		(1 << 14)   /* RGB Dummy mode */
+#define LCD_RGBC_YCC		(1 << 8)    /* RGB to YCC */
+#define LCD_RGBC_ODDRGB_BIT	4	/* odd line serial RGB data arrangement */
+#define LCD_RGBC_ODDRGB_MASK	(0x7<<LCD_RGBC_ODDRGB_BIT)
+  #define LCD_RGBC_ODD_RGB	0
+  #define LCD_RGBC_ODD_RBG	1
+  #define LCD_RGBC_ODD_GRB	2
+  #define LCD_RGBC_ODD_GBR	3
+  #define LCD_RGBC_ODD_BRG	4
+  #define LCD_RGBC_ODD_BGR	5
+#define LCD_RGBC_EVENRGB_BIT	0	/* even line serial RGB data arrangement */
+#define LCD_RGBC_EVENRGB_MASK	(0x7<<LCD_RGBC_EVENRGB_BIT)
+  #define LCD_RGBC_EVEN_RGB	0
+  #define LCD_RGBC_EVEN_RBG	1
+  #define LCD_RGBC_EVEN_GRB	2
+  #define LCD_RGBC_EVEN_GBR	3
+  #define LCD_RGBC_EVEN_BRG	4
+  #define LCD_RGBC_EVEN_BGR	5
+
+/* Vertical Synchronize Register */
+#define LCD_VSYNC_VPS_BIT	16  /* VSYNC pulse start in line clock, fixed to 0 */
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0   /* VSYNC pulse end in line clock */
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+/* Horizontal Synchronize Register */
+#define LCD_HSYNC_HPS_BIT	16  /* HSYNC pulse start position in dot clock */
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0   /* HSYNC pulse end position in dot clock */
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+/* Virtual Area Setting Register */
+#define LCD_VAT_HT_BIT		16  /* Horizontal Total size in dot clock */
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0   /* Vertical Total size in dot clock */
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+/* Display Area Horizontal Start/End Point Register */
+#define LCD_DAH_HDS_BIT		16  /* Horizontal display area start in dot clock */
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0   /* Horizontal display area end in dot clock */
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+/* Display Area Vertical Start/End Point Register */
+#define LCD_DAV_VDS_BIT		16  /* Vertical display area start in line clock */
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0   /* Vertical display area end in line clock */
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+/* Foreground XY Position Register */
+#define LCD_XYP_YPOS_BIT	16  /* Y position bit of foreground 0 or 1 */
+#define LCD_XYP_YPOS_MASK	(0xffff << LCD_XYP_YPOS_BIT)
+#define LCD_XYP_XPOS_BIT	0   /* X position bit of foreground 0 or 1 */
+#define LCD_XYP_XPOS_MASK	(0xffff << LCD_XYP_XPOS_BIT)
+
+/* PS Signal Setting */
+#define LCD_PS_PSS_BIT		16  /* PS signal start position in dot clock */
+#define LCD_PS_PSS_MASK		(0xffff << LCD_PS_PSS_BIT)
+#define LCD_PS_PSE_BIT		0   /* PS signal end position in dot clock */
+#define LCD_PS_PSE_MASK		(0xffff << LCD_PS_PSE_BIT)
+
+/* CLS Signal Setting */
+#define LCD_CLS_CLSS_BIT	16  /* CLS signal start position in dot clock */
+#define LCD_CLS_CLSS_MASK	(0xffff << LCD_CLS_CLSS_BIT)
+#define LCD_CLS_CLSE_BIT	0   /* CLS signal end position in dot clock */
+#define LCD_CLS_CLSE_MASK	(0xffff << LCD_CLS_CLSE_BIT)
+
+/* SPL Signal Setting */
+#define LCD_SPL_SPLS_BIT	16  /* SPL signal start position in dot clock */
+#define LCD_SPL_SPLS_MASK	(0xffff << LCD_SPL_SPLS_BIT)
+#define LCD_SPL_SPLE_BIT	0   /* SPL signal end position in dot clock */
+#define LCD_SPL_SPLE_MASK	(0xffff << LCD_SPL_SPLE_BIT)
+
+/* REV Signal Setting */
+#define LCD_REV_REVS_BIT	16  /* REV signal start position in dot clock */
+#define LCD_REV_REVS_MASK	(0xffff << LCD_REV_REVS_BIT)
+
+/* DMA Command Register */
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_CMD		(1 << 29) /* indicate command in slcd mode */
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+/* DMA Offsize Register 0,1 */
+
+/* DMA Page Width Register 0,1 */
+
+/* DMA Command Counter Register 0,1 */
+
+/* Foreground 0,1 Size Register */
+#define LCD_DESSIZE_HEIGHT_BIT	16  /* height of foreground 1 */
+#define LCD_DESSIZE_HEIGHT_MASK	(0xffff << LCD_DESSIZE_HEIGHT_BIT)
+#define LCD_DESSIZE_WIDTH_BIT	0  /* width of foreground 1 */
+#define LCD_DESSIZE_WIDTH_MASK	(0xffff << LCD_DESSIZE_WIDTH_BIT)
+
+/*************************************************************************
+ * USB Device
+ *************************************************************************/
+#define USB_BASE  UDC_BASE
+
+#define USB_REG_FADDR		(USB_BASE + 0x00) /* Function Address 8-bit */
+#define USB_REG_POWER		(USB_BASE + 0x01) /* Power Managemetn 8-bit */
+#define USB_REG_INTRIN		(USB_BASE + 0x02) /* Interrupt IN 16-bit */
+#define USB_REG_INTROUT		(USB_BASE + 0x04) /* Interrupt OUT 16-bit */
+#define USB_REG_INTRINE		(USB_BASE + 0x06) /* Intr IN enable 16-bit */
+#define USB_REG_INTROUTE	(USB_BASE + 0x08) /* Intr OUT enable 16-bit */
+#define USB_REG_INTRUSB		(USB_BASE + 0x0a) /* Interrupt USB 8-bit */
+#define USB_REG_INTRUSBE	(USB_BASE + 0x0b) /* Interrupt USB Enable 8-bit */
+#define USB_REG_FRAME		(USB_BASE + 0x0c) /* Frame number 16-bit */
+#define USB_REG_INDEX		(USB_BASE + 0x0e) /* Index register 8-bit */
+#define USB_REG_TESTMODE	(USB_BASE + 0x0f) /* USB test mode 8-bit */
+
+#define USB_REG_CSR0		(USB_BASE + 0x12) /* EP0 CSR 8-bit */
+#define USB_REG_INMAXP		(USB_BASE + 0x10) /* EP1-2 IN Max Pkt Size 16-bit */
+#define USB_REG_INCSR		(USB_BASE + 0x12) /* EP1-2 IN CSR LSB 8/16bit */
+#define USB_REG_INCSRH		(USB_BASE + 0x13) /* EP1-2 IN CSR MSB 8-bit */
+#define USB_REG_OUTMAXP		(USB_BASE + 0x14) /* EP1 OUT Max Pkt Size 16-bit */
+#define USB_REG_OUTCSR		(USB_BASE + 0x16) /* EP1 OUT CSR LSB 8/16bit */
+#define USB_REG_OUTCSRH		(USB_BASE + 0x17) /* EP1 OUT CSR MSB 8-bit */
+#define USB_REG_OUTCOUNT	(USB_BASE + 0x18) /* bytes in EP0/1 OUT FIFO 16-bit */
+
+#define USB_FIFO_EP0		(USB_BASE + 0x20)
+#define USB_FIFO_EP1		(USB_BASE + 0x24)
+#define USB_FIFO_EP2		(USB_BASE + 0x28)
+
+#define USB_REG_EPINFO		(USB_BASE + 0x78) /* Endpoint information */
+#define USB_REG_RAMINFO		(USB_BASE + 0x79) /* RAM information */
+
+#define USB_REG_INTR		(USB_BASE + 0x200) /* DMA pending interrupts */
+#define USB_REG_CNTL1		(USB_BASE + 0x204) /* DMA channel 1 control */
+#define USB_REG_ADDR1		(USB_BASE + 0x208) /* DMA channel 1 AHB memory addr */
+#define USB_REG_COUNT1		(USB_BASE + 0x20c) /* DMA channel 1 byte count */
+#define USB_REG_CNTL2		(USB_BASE + 0x214) /* DMA channel 2 control */
+#define USB_REG_ADDR2		(USB_BASE + 0x218) /* DMA channel 2 AHB memory addr */
+#define USB_REG_COUNT2		(USB_BASE + 0x21c) /* DMA channel 2 byte count */
+
+
+/* Power register bit masks */
+#define USB_POWER_SUSPENDM	0x01
+#define USB_POWER_RESUME	0x04
+#define USB_POWER_HSMODE	0x10
+#define USB_POWER_HSENAB	0x20
+#define USB_POWER_SOFTCONN	0x40
+
+/* Interrupt register bit masks */
+#define USB_INTR_SUSPEND	0x01
+#define USB_INTR_RESUME		0x02
+#define USB_INTR_RESET		0x04
+
+#define USB_INTR_EP0		0x0001
+#define USB_INTR_INEP1		0x0002
+#define USB_INTR_INEP2		0x0004
+#define USB_INTR_OUTEP1		0x0002
+
+/* CSR0 bit masks */
+#define USB_CSR0_OUTPKTRDY	0x01
+#define USB_CSR0_INPKTRDY	0x02
+#define USB_CSR0_SENTSTALL	0x04
+#define USB_CSR0_DATAEND	0x08
+#define USB_CSR0_SETUPEND	0x10
+#define USB_CSR0_SENDSTALL	0x20
+#define USB_CSR0_SVDOUTPKTRDY	0x40
+#define USB_CSR0_SVDSETUPEND	0x80
+
+/* Endpoint CSR register bits */
+#define USB_INCSRH_AUTOSET	0x80
+#define USB_INCSRH_ISO		0x40
+#define USB_INCSRH_MODE		0x20
+#define USB_INCSRH_DMAREQENAB	0x10
+#define USB_INCSRH_DMAREQMODE	0x04
+#define USB_INCSR_CDT		0x40
+#define USB_INCSR_SENTSTALL	0x20
+#define USB_INCSR_SENDSTALL	0x10
+#define USB_INCSR_FF		0x08
+#define USB_INCSR_UNDERRUN	0x04
+#define USB_INCSR_FFNOTEMPT	0x02
+#define USB_INCSR_INPKTRDY	0x01
+#define USB_OUTCSRH_AUTOCLR	0x80
+#define USB_OUTCSRH_ISO		0x40
+#define USB_OUTCSRH_DMAREQENAB	0x20
+#define USB_OUTCSRH_DNYT	0x10
+#define USB_OUTCSRH_DMAREQMODE	0x08
+#define USB_OUTCSR_CDT		0x80
+#define USB_OUTCSR_SENTSTALL	0x40
+#define USB_OUTCSR_SENDSTALL	0x20
+#define USB_OUTCSR_FF		0x10
+#define USB_OUTCSR_DATAERR	0x08
+#define USB_OUTCSR_OVERRUN	0x04
+#define USB_OUTCSR_FFFULL	0x02
+#define USB_OUTCSR_OUTPKTRDY	0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK		0x01
+#define USB_TEST_J		0x02
+#define USB_TEST_K		0x04
+#define USB_TEST_PACKET		0x08
+
+/* DMA control bits */
+#define USB_CNTL_ENA		0x01
+#define USB_CNTL_DIR_IN		0x02
+#define USB_CNTL_MODE_1		0x04
+#define USB_CNTL_INTR_EN	0x08
+#define USB_CNTL_EP(n)		((n) << 4)
+#define USB_CNTL_BURST_0	(0 << 9)
+#define USB_CNTL_BURST_4	(1 << 9)
+#define USB_CNTL_BURST_8	(2 << 9)
+#define USB_CNTL_BURST_16	(3 << 9)
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define	BCH_CR         	(BCH_BASE + 0x00) /* BCH Control register */
+#define	BCH_CRS       	(BCH_BASE + 0x04) /* BCH Control Set register */
+#define	BCH_CRC       	(BCH_BASE + 0x08) /* BCH Control Clear register */
+#define	BCH_CNT    	(BCH_BASE + 0x0C) /* BCH ENC/DEC Count register */
+#define	BCH_DR     	(BCH_BASE + 0x10) /* BCH data register */
+#define	BCH_PAR0    	(BCH_BASE + 0x14) /* BCH Parity 0 register */
+#define	BCH_PAR1    	(BCH_BASE + 0x18) /* BCH Parity 1 register */
+#define	BCH_PAR2    	(BCH_BASE + 0x1C) /* BCH Parity 2 register */
+#define	BCH_PAR3    	(BCH_BASE + 0x20) /* BCH Parity 3 register */
+#define	BCH_INTS    	(BCH_BASE + 0x24) /* BCH Interrupt Status register */
+#define	BCH_ERR0        (BCH_BASE + 0x28) /* BCH Error Report 0 register */
+#define	BCH_ERR1        (BCH_BASE + 0x2C) /* BCH Error Report 1 register */
+#define	BCH_ERR2        (BCH_BASE + 0x30) /* BCH Error Report 2 register */
+#define	BCH_ERR3        (BCH_BASE + 0x34) /* BCH Error Report 3 register */
+#define	BCH_INTE        (BCH_BASE + 0x38) /* BCH Interrupt Enable register */
+#define	BCH_INTES       (BCH_BASE + 0x3C) /* BCH Interrupt Set register */
+#define	BCH_INTEC       (BCH_BASE + 0x40) /* BCH Interrupt Clear register */
+
+#define	REG_BCH_CR      REG32(BCH_CR)
+#define	REG_BCH_CRS     REG32(BCH_CRS)
+#define	REG_BCH_CRC     REG32(BCH_CRC)
+#define	REG_BCH_CNT     REG32(BCH_CNT)
+#define	REG_BCH_DR      REG8(BCH_DR)
+#define	REG_BCH_PAR0    REG32(BCH_PAR0)
+#define	REG_BCH_PAR1    REG32(BCH_PAR1)
+#define	REG_BCH_PAR2    REG32(BCH_PAR2)
+#define	REG_BCH_PAR3    REG32(BCH_PAR3)
+#define	REG_BCH_INTS    REG32(BCH_INTS)
+#define	REG_BCH_ERR0    REG32(BCH_ERR0)
+#define	REG_BCH_ERR1    REG32(BCH_ERR1)
+#define	REG_BCH_ERR2    REG32(BCH_ERR2)
+#define	REG_BCH_ERR3    REG32(BCH_ERR3)
+#define	REG_BCH_INTE    REG32(BCH_INTE)
+#define	REG_BCH_INTEC   REG32(BCH_INTEC)
+#define	REG_BCH_INTES   REG32(BCH_INTES)
+
+/* BCH Control Register*/
+#define	BCH_CR_DMAE              (1 << 4)  /* BCH DMA Enable */
+#define	BCH_CR_ENCE              (1 << 3)  /* BCH Encoding Select */
+#define	BCH_CR_DECE              (0 << 3)  /* BCH Decoding Select */
+#define	BCH_CR_BSEL8             (1 << 2)  /* 8 Bit BCH Select */
+#define	BCH_CR_BSEL4             (0 << 2)  /* 4 Bit BCH Select */
+#define	BCH_CR_BRST              (1 << 1)  /* BCH Reset */
+#define	BCH_CR_BCHE              (1 << 0)  /* BCH Enable */
+
+/* BCH Interrupt Status Register */
+#define	BCH_INTS_ERRC_BIT        28
+#define	BCH_INTS_ERRC_MASK       (0xf << BCH_INTS_ERRC_BIT)
+#define	BCH_INTS_ALL0            (1 << 5)
+#define	BCH_INTS_ALLf            (1 << 4)
+#define	BCH_INTS_DECF            (1 << 3)
+#define	BCH_INTS_ENCF            (1 << 2)
+#define	BCH_INTS_UNCOR           (1 << 1)
+#define	BCH_INTS_ERR             (1 << 0)
+
+/* BCH ENC/DEC Count Register */
+#define BCH_CNT_DEC_BIT          16
+#define BCH_CNT_DEC_MASK         (0x3ff << BCH_CNT_DEC_BIT)
+#define BCH_CNT_ENC_BIT          0
+#define BCH_CNT_ENC_MASK         (0x3ff << BCH_CNT_ENC_BIT)
+
+/* BCH Error Report Register */
+#define BCH_ERR_INDEX_ODD_BIT    16
+#define BCH_ERR_INDEX_ODD_MASK   (0x1fff << BCH_ERR_INDEX_ODD_BIT)
+#define BCH_ERR_INDEX_EVEN_BIT   0
+#define BCH_ERR_INDEX_EVEN_MASK  (0x1fff << BCH_ERR_INDEX_EVEN_BIT)
+
+
+//----------------------------------------------------------------------
+//
+// Module Operation Definitions
+//
+//----------------------------------------------------------------------
+#ifndef __ASSEMBLY__
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+//------------------------------------------------------
+// GPIO Pins Description
+//
+// PORT 0:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		D0		-
+//	1		D1		-
+//	2		D2		-
+//	3		D3		-
+//	4		D4		-
+//	5		D5		-
+//	6		D6		-
+//	7		D7		-
+//	8		D8		-
+//	9		D9		-
+//	10		D10		-
+//	11		D11		-
+//	12		D12		-
+//	13		D13		-
+//	14		D14		-
+//	15		D15		-
+//	16		D16		-
+//	17		D17		-
+//	18		D18		-
+//	19		D19		-
+//	20		D20		-
+//	21		D21		-
+//	22		D22		-
+//	23		D23		-
+//	24		D24		-
+//	25		D25		-
+//	26		D26		-
+//	27		D27		-
+//	28		D28		-
+//	29		D29		-
+//	30		D30		-
+//	31		D31		-
+//
+//------------------------------------------------------
+// PORT 1:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		A0		-
+//	1		A1		-
+//	2		A2		-
+//	3		A3		-
+//	4		A4		-
+//	5		A5		-
+//	6		A6		-
+//	7		A7		-
+//	8		A8		-
+//	9		A9		-
+//	10		A10		-
+//	11		A11		-
+//	12		A12		-
+//	13		A13		-
+//	14		A14		-
+//	15		A15/CLE		SA3
+//	16		DCS0#		-
+//	17		RAS#		-
+//	18		CAS#		-
+//	19		RDWE#/BUFD#	-
+//	20		WE0#		-
+//	21		WE1#		-
+//	22		WE2#		-
+//	23		WE3#		-
+//	24		CKO		-		Note1
+//	25		CKE		-
+//	26		SSI0_CLK	-
+//	27		SSI0_DT		-
+//	28		SSI0_DR		-
+//	29		SSI0_CE0#	-
+//	30		SSI0_CE1#_GPC	-
+//	31		SSI0_CE2#	-
+//
+// Note1: BIT24: it is CKO when chip is reset
+//
+//------------------------------------------------------
+// PORT 2:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		SD0		A20
+//	1		SD1		A21
+//	2		SD2		A22
+//	3		SD3		A23
+//	4		SD4		A24
+//	5		SD5		A25
+//	6		SD6		-
+//	7		SD7		-
+//	8		SD8		TSDI0
+//	9		SD9		TSDI1
+//	10		SD10		TSDI2
+//	11		SD11		TSDI3
+//	12		SD12		TSDI4
+//	13		SD13		TSDI5
+//	14		SD14		TSDI6
+//	15		SD15		TSDI7
+//	16		A16/ALE		SA4
+//	17		SA0		A17
+//	18		SA1		A18
+//	19		SA2		A19
+//	20		WAIT#		-		Note2
+//	21		CS1#		-
+//	22		CS2#		-
+//	23		CS3#		-
+//	24		CS4#		-
+//	25		RD#		-
+//	26		WR#		-
+//	27		FRB#		-		Note3
+//	28		FRE#		-
+//	29		FWE#		-
+//	30		BOOT_SEL0	-		Note4
+//	31		BOOT_SEL1	-		Note5
+//
+// Note2: BIT20: it is WIAT# pin when chip is reset
+//
+// Note3: BIT27: when NAND is used, it should connect to NANF FRB#.
+//
+// Note4: BIT30: it is BOOT_SEL0 when chip is reset, it can used as output GPIO.
+//
+// Note5: BIT31: it is BOOT_SEL1 when chip is reset, it can used as general GPIO.
+//
+//------------------------------------------------------
+// PORT 3:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		LCD_D0		-
+//	1		LCD_D1		-
+//	2		LCD_D2		-
+//	3		LCD_D3		-
+//	4		LCD_D4		-
+//	5		LCD_D5		-
+//	6		LCD_D6		-
+//	7		LCD_D7		-
+//	8		LCD_D8		-
+//	9		LCD_D9		-
+//	10		LCD_D10		-
+//	11		LCD_D11		-
+//	12		LCD_D12		-
+//	13		LCD_D13		-
+//	14		LCD_D14		-
+//	15		LCD_D15		-
+//	16		LCD_D16		-
+//	17		LCD_D17		-
+//	18		LCD_PCLK	-
+//	19		LCD_HSYNC	-
+//	20		LCD_VSYNC	-
+//	21		LCD_DE		-
+//	22		LCD_CLS		-
+//	23		LCD_SPL		-
+//	24		LCD_PS		-
+//	25		LCD_REV		-
+//	26		SSI1_CLK	-
+//	27		SSI1_DT		-
+//	28		SSI1_DR		-
+//	29		SSI1_CE0#	-
+//	30		SSI1_CE1#	-
+//	31		-		-
+//
+//------------------------------------------------------
+// PORT 4:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		CIM_D0		-
+//	1		CIM_D1		-
+//	2		CIM_D2		-
+//	3		CIM_D3		-
+//	4		CIM_D4		-
+//	5		CIM_D5		-
+//	6		CIM_D6		-
+//	7		CIM_D7		-
+//	8		CIM_MCLK	-
+//	9		CIM_PCLK	-
+//	10		CIM_VSYNC	-
+//	11		CIM_HSYNC	-
+//	12		I2C_SDA		-
+//	13		I2C_SCK		-
+//	14		-		-
+//	15		-		-
+//	16		UART1_RxD	-
+//	17		UART1_TxD	-
+//	18		UART1_CTS	PCM_DIN
+//	19		UART1_RTS	PCM_DOUT
+//	20		PWM0		PCM_CLK
+//	21		PWM1		PCM_SYN
+//	22		PWM2		SCLK_RSTN
+//	23		PWM3		BCLK
+//	24		PWM4		SYNC
+//	25		PWM5		OWI
+//	26		SDATO		UART2_TxD
+//	27		SDATI		UART2_RxD
+//	28		DCS1#		-
+//	29		-		-
+//	30		WKUP		-		Note6
+//	31		-		-		Note7
+//
+// Note6: BIT30: it is only used as input and interrupt, and with no pull-up and pull-down
+//
+// Note7: BIT31: it is used to select the function of UART or JTAG set by PESEL[31]
+//        PESEL[31] = 0, select JTAG function
+//        PESEL[31] = 1, select UART function
+//
+//------------------------------------------------------
+// PORT 5:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		MSC0_D0		-
+//	1		MSC0_D1		-
+//	2		MSC0_D2		DREQ
+//	3		MSC0_D3		DACK
+//	4		MSC0_D4		UART0_RxD
+//	5		MSC0_D5		UART0_TxD
+//	6		MSC0_D6		UART0_CTS
+//	7		MSC0_D7		UART0_RTS
+//	8		MSC0_CLK	-
+//	9		MSC0_CMD	-
+//	10		MSC1_D0		-
+//	11		MSC1_D1		-
+//	12		MSC1_D2		-
+//	13		MSC1_D3		-
+//	14		MSC1_CLK	-
+//	15		MSC1_CMD	-
+//	16		UART3_RxD	-
+//	17		UART3_TxD	-
+//	18		UART3_CTS	-
+//	19		UART3_RTS	-
+//	20		TSCLK		-
+//	21		TSSTR		-
+//	22		TSFRM		-
+//	23		TSFAIL		-
+//	24		-		-
+//	25		-		-
+//	26		-		-
+//	27		-		-
+//	28		-		-
+//	29		-		-
+//	30		-		-
+//	31		-		-
+//
+//////////////////////////////////////////////////////////
+
+/*----------------------------------------------------------------
+ * p is the port number (0,1,2,3)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-127), regardless of the port
+ */
+
+//----------------------------------------------------------------
+// Function Pins Mode
+
+#define is_share_mode() ((REG_EMC_BCR & EMC_BCR_BSR_MASK) == EMC_BCR_BSR_SHARE)
+#define is_normal_order() (!(REG_EMC_BCR & EMC_BCR_PK_SEL))
+
+#define __gpio_as_func0(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func1(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_32bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ * !!!!DCS1#
+ */
+#define __gpio_as_sdram_x2_32bit()		\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+	REG_GPIO_PXFUNS(4) = 0x10000000;	\
+	REG_GPIO_PXSELC(4) = 0x10000000;	\
+	REG_GPIO_PXPES(4) = 0x10000000;		\
+} while (0)
+/*
+ * D0 ~ D15, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;	\
+	REG_GPIO_PXPES(0) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD
+ */
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000030;	\
+	REG_GPIO_PXSELS(5) = 0x00000030;	\
+	REG_GPIO_PXPES(5) = 0x00000030;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD, UART0_CTS, UART0_RTS
+ */
+#define __gpio_as_uart0_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x000000f0;	\
+	REG_GPIO_PXSELS(5) = 0x000000f0;	\
+	REG_GPIO_PXPES(5) = 0x000000f0;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD
+ */
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00030000;	\
+	REG_GPIO_PXSELC(4) = 0x00030000;	\
+	REG_GPIO_PXPES(4) = 0x00030000;		\
+} while (0)
+
+
+/*
+ * UART1_TxD, UART1_RxD, UART1_CTS, UART1_RTS
+ */
+#define __gpio_as_uart1_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x000f0000;	\
+	REG_GPIO_PXSELC(4) = 0x000f0000;	\
+	REG_GPIO_PXPES(4) = 0x000f0000;		\
+} while (0)
+
+/*
+ * UART2_TxD, UART2_RxD
+ */
+#define __gpio_as_uart2()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x0c000000;	\
+	REG_GPIO_PXSELS(4) = 0x0c000000;	\
+	REG_GPIO_PXPES(4) = 0x0c000000;		\
+} while (0)
+
+/*
+ * UART3_TxD, UART3_RxD
+ */
+#define __gpio_as_uart3()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00030000;	\
+	REG_GPIO_PXSELC(5) = 0x00030000;	\
+	REG_GPIO_PXPES(5) = 0x00030000;		\
+} while (0)
+
+/*
+ * UART3_TxD, UART3_RxD, UART3_CTS, UART3_RTS
+ */
+#define __gpio_as_uart3_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x000f0000;	\
+	REG_GPIO_PXSELC(5) = 0x000f0000;	\
+	REG_GPIO_PXPES(5) = 0x000f0000;		\
+} while (0)
+
+/*
+ * D0 ~ D7, CS1#, CLE, ALE, FRE#, FWE#, FRB#, RDWE#/BUFD#
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nand_8bit(n)						\
+do {		              						\
+	if (!is_share_mode()) {						\
+		/* unshare mode */					\
+		REG_GPIO_PXFUNS(2) = 0x000000ff; /* SD0~SD7 */		\
+		REG_GPIO_PXSELS(2) = 0x000000ff;			\
+		REG_GPIO_PXPES(2) = 0x000000ff;				\
+		REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(SA3) */		\
+		REG_GPIO_PXSELS(1) = 0x00008000;			\
+		REG_GPIO_PXPES(1) = 0x00008000;				\
+		REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(SA4) */		\
+		REG_GPIO_PXSELS(2) = 0x00010000;			\
+		REG_GPIO_PXPES(2) = 0x00010000;				\
+	} else {							\
+		/* share mode */					\
+		if (is_normal_order()) {	              		\
+			/* 32/16-bit data normal order */		\
+			REG_GPIO_PXFUNS(0) = 0x000000ff; /* D0~D7 */	\
+			REG_GPIO_PXSELC(0) = 0x000000ff;		\
+			REG_GPIO_PXPES(0) = 0x000000ff;			\
+		} else {						\
+			/* 16-bit data special order */			\
+			REG_GPIO_PXFUNS(0) = 0x0000ff00; /* D0~D7 */	\
+			REG_GPIO_PXSELC(0) = 0x0000ff00;		\
+			REG_GPIO_PXPES(0) = 0x0000ff00;			\
+		}							\
+		REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(A15) */		\
+		REG_GPIO_PXSELC(1) = 0x00008000;			\
+		REG_GPIO_PXPES(1) = 0x00008000;				\
+		REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(A16) */		\
+		REG_GPIO_PXSELC(2) = 0x00010000;			\
+		REG_GPIO_PXPES(2) = 0x00010000;				\
+	}								\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+        REG_GPIO_PXFUNS(1) = 0x00080000; /* RDWE#/BUFD# */		\
+        REG_GPIO_PXSELC(1) = 0x00080000;				\
+	REG_GPIO_PXPES(1) = 0x00080000;					\
+	REG_GPIO_PXFUNS(2) = 0x30000000; /* FRE#, FWE# */		\
+	REG_GPIO_PXSELC(2) = 0x30000000;				\
+	REG_GPIO_PXPES(2) = 0x30000000;					\
+	REG_GPIO_PXFUNC(2) = 0x08000000; /* FRB#(input) */		\
+	REG_GPIO_PXSELC(2) = 0x08000000;				\
+	REG_GPIO_PXDIRC(2) = 0x08000000;				\
+	REG_GPIO_PXPES(2) = 0x08000000;					\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D7
+ */
+#define __gpio_as_nor_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x000000ff;	\
+	REG_GPIO_PXSELC(0) = 0x000000ff;	\
+	REG_GPIO_PXPES(0) = 0x000000ff;		\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;	\
+	REG_GPIO_PXPES(1) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x07110007;	\
+	REG_GPIO_PXSELC(2) = 0x07110007;	\
+	REG_GPIO_PXPES(2) = 0x07110007;		\
+	REG_GPIO_PXFUNS(2) = 0x000e0000;	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;	\
+	REG_GPIO_PXPES(2) = 0x000e0000;		\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D15
+ */
+#define __gpio_as_nor_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;	\
+	REG_GPIO_PXPES(0) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;	\
+	REG_GPIO_PXPES(1) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x07110007;	\
+	REG_GPIO_PXSELC(2) = 0x07110007;	\
+	REG_GPIO_PXPES(2) = 0x07110007;		\
+	REG_GPIO_PXFUNS(2) = 0x000e0000;	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;	\
+	REG_GPIO_PXPES(2) = 0x000e0000;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D7, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003c00ff;	\
+	REG_GPIO_PXSELC(3) = 0x003c00ff;	\
+	REG_GPIO_PXPES(3) = 0x003c00ff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D15, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003cffff;	\
+	REG_GPIO_PXSELC(3) = 0x003cffff;	\
+	REG_GPIO_PXPES(3) = 0x003cffff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D17, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003fffff;	\
+	REG_GPIO_PXSELC(3) = 0x003fffff;	\
+	REG_GPIO_PXPES(3) = 0x003fffff;		\
+} while (0)
+
+/*
+ *  LCD_CLS, LCD_SPL, LCD_PS, LCD_REV
+ */
+#define __gpio_as_lcd_special()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x03C00000;	\
+	REG_GPIO_PXSELC(3) = 0x03C00000;	\
+	REG_GPIO_PXPES(3)  = 0x03C00000;	\
+} while (0)
+
+/*
+ * CIM_D0~CIM_D7, CIM_MCLK, CIM_PCLK, CIM_VSYNC, CIM_HSYNC
+ */
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00000fff;	\
+	REG_GPIO_PXSELC(4) = 0x00000fff;	\
+	REG_GPIO_PXPES(4)  = 0x00000fff;	\
+} while (0)
+
+/*
+ * SDATO, SDATI, BCLK, SYNC, SCLK_RSTN(gpio sepc) or
+ * SDATA_OUT, SDATA_IN, BIT_CLK, SYNC, SCLK_RESET(aic spec)
+ */
+#define __gpio_as_aic()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x0c000000;	\
+	REG_GPIO_PXSELS(4) = 0x0c000000;	\
+	REG_GPIO_PXPES(4)  = 0x0c000000;	\
+	REG_GPIO_PXFUNS(4) = 0x00e00000;	\
+	REG_GPIO_PXSELC(4) = 0x00e00000;	\
+	REG_GPIO_PXPES(4)  = 0x00e00000;	\
+} while (0)
+
+/*
+ * MSC0_CMD, MSC0_CLK, MSC0_D0 ~ MSC0_D3
+ */
+#define __gpio_as_msc0_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x0000030f;	\
+	REG_GPIO_PXSELC(5) = 0x0000030f;	\
+	REG_GPIO_PXPES(5)  = 0x0000030f;	\
+} while (0)
+
+/*
+ * MSC0_CMD, MSC0_CLK, MSC0_D0 ~ MSC0_D7
+ */
+#define __gpio_as_msc0_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x000003ff;	\
+	REG_GPIO_PXSELC(5) = 0x000003ff;	\
+	REG_GPIO_PXPES(5)  = 0x000003ff;	\
+} while (0)
+
+/*
+ * MSC1_CMD, MSC1_CLK, MSC1_D0 ~ MSC1_D3
+ */
+#define __gpio_as_msc1_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x0000fc00;	\
+	REG_GPIO_PXSELC(5) = 0x0000fc00;	\
+	REG_GPIO_PXPES(5)  = 0x0000fc00;	\
+} while (0)
+
+#define __gpio_as_msc 	__gpio_as_msc0_8bit /* default as msc0 8bit */
+#define __gpio_as_msc0 	__gpio_as_msc0_8bit /* msc0 default as 8bit */
+#define __gpio_as_msc1 	__gpio_as_msc1_4bit /* msc1 only support 4bit */
+
+/*
+ * SSI0_CE0, SSI0_CE1#_GPC, SSI0_CE2, SSI0_CLK, SSI0_DT, SSI0_DR
+ */
+#define __gpio_as_ssi0()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0xfc000000;	\
+	REG_GPIO_PXSELC(1) = 0xfc000000;	\
+	REG_GPIO_PXPES(1)  = 0xfc000000;	\
+} while (0)
+
+/*
+ * SSI1_CE0, SSI1_CE1, SSI1_CLK, SSI1_DT, SSI1_DR
+ */
+#define __gpio_as_ssi1()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x7c000000;	\
+	REG_GPIO_PXSELC(3) = 0x7c000000;	\
+	REG_GPIO_PXPES(3)  = 0x7c000000;	\
+} while (0)
+
+/* n = 0(SSI0), 1(SSI1) */
+#define __gpio_as_ssi(n)	 __gpio_as_ssi##n()
+
+/*
+ * I2C_SCK, I2C_SDA
+ */
+#define __gpio_as_i2c()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00003000;	\
+	REG_GPIO_PXSELC(4) = 0x00003000;	\
+	REG_GPIO_PXPES(4)  = 0x00003000;	\
+} while (0)
+
+/*
+ * PWM0
+ */
+#define __gpio_as_pwm0()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00100000;	\
+	REG_GPIO_PXSELC(4) = 0x00100000;	\
+	REG_GPIO_PXPES(4) = 0x00100000;		\
+} while (0)
+
+/*
+ * PWM1
+ */
+#define __gpio_as_pwm1()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00200000;	\
+	REG_GPIO_PXSELC(4) = 0x00200000;	\
+	REG_GPIO_PXPES(4) = 0x00200000;		\
+} while (0)
+
+/*
+ * PWM2
+ */
+#define __gpio_as_pwm2()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00400000;	\
+	REG_GPIO_PXSELC(4) = 0x00400000;	\
+	REG_GPIO_PXPES(4) = 0x00400000;		\
+} while (0)
+
+/*
+ * PWM3
+ */
+#define __gpio_as_pwm3()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00800000;	\
+	REG_GPIO_PXSELC(4) = 0x00800000;	\
+	REG_GPIO_PXPES(4) = 0x00800000;		\
+} while (0)
+
+/*
+ * PWM4
+ */
+#define __gpio_as_pwm4()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x01000000;	\
+	REG_GPIO_PXSELC(4) = 0x01000000;	\
+	REG_GPIO_PXPES(4) = 0x01000000;		\
+} while (0)
+
+/*
+ * PWM5
+ */
+#define __gpio_as_pwm5()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x02000000;	\
+	REG_GPIO_PXSELC(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4) = 0x02000000;		\
+} while (0)
+
+/*
+ * n = 0 ~ 5
+ */
+#define __gpio_as_pwm(n)	__gpio_as_pwm##n()
+
+//-------------------------------------------
+// GPIO or Interrupt Mode
+
+#define __gpio_get_port(p)	(REG_GPIO_PXPIN(p))
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRS(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRC(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_pin(n)			\
+({						\
+	unsigned int p, o, v;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (__gpio_get_port(p) & (1 << o))	\
+		v = 1;				\
+	else					\
+		v = 0;				\
+	v;					\
+})
+
+#define __gpio_as_irq_high_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_low_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_rise_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_fall_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_irq()			\
+({						\
+	unsigned int p, i, tmp, v = 0;		\
+	for (p = 3; p >= 0; p--) {		\
+		tmp = REG_GPIO_PXFLG(p);	\
+		for (i = 0; i < 32; i++)	\
+			if (tmp & (1 << i))	\
+				v = (32*p + i);	\
+	}					\
+	v;					\
+})
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_PXFLG((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPEC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPES(p) = (1 << o);		\
+} while (0)
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_get_pllm() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLM_MASK) >> CPM_CPPCR_PLLM_BIT)
+#define __cpm_get_plln() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLN_MASK) >> CPM_CPPCR_PLLN_BIT)
+#define __cpm_get_pllod() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLOD_MASK) >> CPM_CPPCR_PLLOD_BIT)
+
+#define __cpm_get_cdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_CDIV_MASK) >> CPM_CPCCR_CDIV_BIT)
+#define __cpm_get_hdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_HDIV_MASK) >> CPM_CPCCR_HDIV_BIT)
+#define __cpm_get_pdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_PDIV_MASK) >> CPM_CPCCR_PDIV_BIT)
+#define __cpm_get_mdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT)
+#define __cpm_get_ldiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_LDIV_MASK) >> CPM_CPCCR_LDIV_BIT)
+#define __cpm_get_udiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_UDIV_MASK) >> CPM_CPCCR_UDIV_BIT)
+#define __cpm_get_i2sdiv() \
+	((REG_CPM_I2SCDR & CPM_I2SCDR_I2SDIV_MASK) >> CPM_I2SCDR_I2SDIV_BIT)
+#define __cpm_get_pixdiv() \
+	((REG_CPM_LPCDR & CPM_LPCDR_PIXDIV_MASK) >> CPM_LPCDR_PIXDIV_BIT)
+#define __cpm_get_mscdiv(n) \
+	((REG_CPM_MSCCDR(n) & CPM_MSCCDR_MSCDIV_MASK) >> CPM_MSCCDR_MSCDIV_BIT)
+#define __cpm_get_uhcdiv() \
+	((REG_CPM_UHCCDR & CPM_UHCCDR_UHCDIV_MASK) >> CPM_UHCCDR_UHCDIV_BIT)
+#define __cpm_get_ssidiv() \
+	((REG_CPM_SSICCDR & CPM_SSICDR_SSICDIV_MASK) >> CPM_SSICDR_SSIDIV_BIT)
+#define __cpm_get_pcmdiv(v) \
+	((REG_CPM_PCMCDR & CPM_PCMCDR_PCMCD_MASK) >> CPM_PCMCDR_PCMCD_BIT)
+
+#define __cpm_set_cdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_CDIV_MASK) | ((v) << (CPM_CPCCR_CDIV_BIT)))
+#define __cpm_set_hdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_HDIV_MASK) | ((v) << (CPM_CPCCR_HDIV_BIT)))
+#define __cpm_set_pdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_PDIV_MASK) | ((v) << (CPM_CPCCR_PDIV_BIT)))
+#define __cpm_set_mdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_MDIV_MASK) | ((v) << (CPM_CPCCR_MDIV_BIT)))
+#define __cpm_set_ldiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_LDIV_MASK) | ((v) << (CPM_CPCCR_LDIV_BIT)))
+#define __cpm_set_udiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_UDIV_MASK) | ((v) << (CPM_CPCCR_UDIV_BIT)))
+#define __cpm_set_i2sdiv(v) \
+	(REG_CPM_I2SCDR = (REG_CPM_I2SCDR & ~CPM_I2SCDR_I2SDIV_MASK) | ((v) << (CPM_I2SCDR_I2SDIV_BIT)))
+#define __cpm_set_pixdiv(v) \
+	(REG_CPM_LPCDR = (REG_CPM_LPCDR & ~CPM_LPCDR_PIXDIV_MASK) | ((v) << (CPM_LPCDR_PIXDIV_BIT)))
+#define __cpm_set_mscdiv(n, v) \
+	(REG_CPM_MSCCDR(n) = (REG_CPM_MSCCDR(n) & ~CPM_MSCCDR_MSCDIV_MASK) | ((v) << (CPM_MSCCDR_MSCDIV_BIT)))
+#define __cpm_set_uhcdiv(v) \
+	(REG_CPM_UHCCDR = (REG_CPM_UHCCDR & ~CPM_UHCCDR_UHCDIV_MASK) | ((v) << (CPM_UHCCDR_UHCDIV_BIT)))
+#define __cpm_set_ssidiv(v) \
+	(REG_CPM_SSICDR = (REG_CPM_SSICDR & ~CPM_SSICDR_SSIDIV_MASK) | ((v) << (CPM_SSICDR_SSIDIV_BIT)))
+#define __cpm_set_pcmdiv(v) \
+	(REG_CPM_PCMCDR = (REG_CPM_PCMCDR & ~CPM_PCMCDR_PCMCD_MASK) | ((v) << (CPM_PCMCDR_PCMCD_BIT)))
+
+#define __cpm_select_pcmclk_pll() 	(REG_CPM_PCMCDR |= CPM_PCMCDR_PCMS)
+#define __cpm_select_pcmclk_exclk() 	(REG_CPM_PCMCDR &= ~CPM_PCMCDR_PCMS)
+#define __cpm_select_pixclk_ext()	(REG_CPM_LPCDR |= CPM_LPCDR_LPCS)
+#define __cpm_select_pixclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LPCS)
+#define __cpm_select_tveclk_exclk()	(REG_CPM_LPCDR |= CPM_CPCCR_LSCS)
+#define __cpm_select_tveclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LSCS)
+#define __cpm_select_pixclk_lcd()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LTCS)
+#define __cpm_select_pixclk_tve()	(REG_CPM_LPCDR |= CPM_LPCDR_LTCS)
+#define __cpm_select_i2sclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_I2CS)
+#define __cpm_select_i2sclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_I2CS)
+#define __cpm_select_usbclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_UCS)
+#define __cpm_select_usbclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_UCS)
+
+#define __cpm_enable_cko()
+#define __cpm_exclk_direct()		(REG_CPM_CPCCR &= ~CPM_CPCCR_ECS)
+#define __cpm_exclk_div2()             	(REG_CPM_CPCCR |= CPM_CPCCR_ECS)
+#define __cpm_enable_pll_change()	(REG_CPM_CPCCR |= CPM_CPCCR_CE)
+#define __cpm_pllout_direct()		(REG_CPM_CPCCR |= CPM_CPCCR_PCS)
+#define __cpm_pllout_div2()		(REG_CPM_CPCCR &= ~CPM_CPCCR_PCS)
+#define __cpm_pll_enable()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLEN)
+
+#define __cpm_pll_is_off()		(REG_CPM_CPPSR & CPM_CPPSR_PLLOFF)
+#define __cpm_pll_is_on()		(REG_CPM_CPPSR & CPM_CPPSR_PLLON)
+#define __cpm_pll_bypass()		(REG_CPM_CPPSR |= CPM_CPPSR_PLLBP)
+
+#define __cpm_get_cclk_doze_duty() \
+	((REG_CPM_LCR & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT)
+#define __cpm_set_cclk_doze_duty(v) \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_DOZE_DUTY_MASK) | ((v) << (CPM_LCR_DOZE_DUTY_BIT)))
+
+#define __cpm_doze_mode()		(REG_CPM_LCR |= CPM_LCR_DOZE_ON)
+#define __cpm_idle_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_IDLE)
+#define __cpm_sleep_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_SLEEP)
+
+#define __cpm_stop_all() 	(REG_CPM_CLKGR = 0x1fffffff)
+#define __cpm_stop_cimram()	(REG_CPM_CLKGR |= CPM_CLKGR_CIMRAM)
+#define __cpm_stop_idct()	(REG_CPM_CLKGR |= CPM_CLKGR_IDCT)
+#define __cpm_stop_db()	        (REG_CPM_CLKGR |= CPM_CLKGR_DB)
+#define __cpm_stop_me()	        (REG_CPM_CLKGR |= CPM_CLKGR_ME)
+#define __cpm_stop_mc()	        (REG_CPM_CLKGR |= CPM_CLKGR_MC)
+#define __cpm_stop_tve()        (REG_CPM_CLKGR |= CPM_CLKGR_TVE)
+#define __cpm_stop_tssi()       (REG_CPM_CLKGR |= CPM_CLKGR_TSSI)
+#define __cpm_stop_owi()        (REG_CPM_CLKGR |= CPM_CLKGR_OWI)
+#define __cpm_stop_pcm()        (REG_CPM_CLKGR |= CPM_CLKGR_PCM)
+#define __cpm_stop_uart3()	(REG_CPM_CLKGR |= CPM_CLKGR_UART3)
+#define __cpm_stop_uart2()	(REG_CPM_CLKGR |= CPM_CLKGR_UART2)
+#define __cpm_stop_uart1()	(REG_CPM_CLKGR |= CPM_CLKGR_UART1)
+#define __cpm_stop_uhc()	(REG_CPM_CLKGR |= CPM_CLKGR_UHC)
+#define __cpm_stop_ipu()	(REG_CPM_CLKGR |= CPM_CLKGR_IPU)
+#define __cpm_stop_dmac()	(REG_CPM_CLKGR |= CPM_CLKGR_DMAC)
+#define __cpm_stop_udc()	(REG_CPM_CLKGR |= CPM_CLKGR_UDC)
+#define __cpm_stop_lcd()	(REG_CPM_CLKGR |= CPM_CLKGR_LCD)
+#define __cpm_stop_cim()	(REG_CPM_CLKGR |= CPM_CLKGR_CIM)
+#define __cpm_stop_sadc()	(REG_CPM_CLKGR |= CPM_CLKGR_SADC)
+#define __cpm_stop_msc(n)	(REG_CPM_CLKGR |= CPM_CLKGR_MSC##n)
+#define __cpm_stop_aic1()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC1)
+#define __cpm_stop_aic2()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC2)
+#define __cpm_stop_ssi(n)	(REG_CPM_CLKGR |= CPM_CLKGR_SSI##n)
+#define __cpm_stop_i2c()	(REG_CPM_CLKGR |= CPM_CLKGR_I2C)
+#define __cpm_stop_rtc()	(REG_CPM_CLKGR |= CPM_CLKGR_RTC)
+#define __cpm_stop_tcu()	(REG_CPM_CLKGR |= CPM_CLKGR_TCU)
+#define __cpm_stop_uart0()	(REG_CPM_CLKGR |= CPM_CLKGR_UART0)
+
+#define __cpm_start_all() 	(REG_CPM_CLKGR = 0x0)
+#define __cpm_start_cimram()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIMRAM)
+#define __cpm_start_idct()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IDCT)
+#define __cpm_start_db()        (REG_CPM_CLKGR &= ~CPM_CLKGR_DB)
+#define __cpm_start_me()        (REG_CPM_CLKGR &= ~CPM_CLKGR_ME)
+#define __cpm_start_mc()        (REG_CPM_CLKGR &= ~CPM_CLKGR_MC)
+#define __cpm_start_tve()        (REG_CPM_CLKGR &= ~CPM_CLKGR_TVE)
+#define __cpm_start_tssi()       (REG_CPM_CLKGR &= ~CPM_CLKGR_TSSI)
+#define __cpm_start_owi()        (REG_CPM_CLKGR &= ~CPM_CLKGR_OWI)
+#define __cpm_start_pcm()        (REG_CPM_CLKGR &= ~CPM_CLKGR_PCM)
+#define __cpm_start_uart3()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART3)
+#define __cpm_start_uart2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART2)
+#define __cpm_start_uart1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART1)
+#define __cpm_start_uhc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UHC)
+#define __cpm_start_ipu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IPU)
+#define __cpm_start_dmac()	(REG_CPM_CLKGR &= ~CPM_CLKGR_DMAC)
+#define __cpm_start_udc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UDC)
+#define __cpm_start_lcd()	(REG_CPM_CLKGR &= ~CPM_CLKGR_LCD)
+#define __cpm_start_cim()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIM)
+#define __cpm_start_sadc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SADC)
+#define __cpm_start_msc(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_MSC##n)
+#define __cpm_start_aic1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC1)
+#define __cpm_start_aic2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC2)
+#define __cpm_start_ssi(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_SSI##n)
+#define __cpm_start_i2c()	(REG_CPM_CLKGR &= ~CPM_CLKGR_I2C)
+#define __cpm_start_rtc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_RTC)
+#define __cpm_start_tcu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_TCU)
+#define __cpm_start_uart0()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART0)
+
+#define __cpm_get_o1st() \
+	((REG_CPM_OPCR & CPM_OPCR_O1ST_MASK) >> CPM_OPCR_O1ST_BIT)
+#define __cpm_set_o1st(v) \
+	(REG_CPM_OPCR = (REG_CPM_OPCR & ~CPM_OPCR_O1ST_MASK) | ((v) << (CPM_OPCR_O1ST_BIT)))
+#define __cpm_suspend_uhcphy()		(REG_CPM_OPCR |= CPM_OPCR_UHCPHY_SUSPEND)
+#define __cpm_suspend_udcphy()		(REG_CPM_OPCR &= ~CPM_OPCR_UDCPHY_ENABLE)
+#define __cpm_enable_osc_in_sleep()	(REG_CPM_OPCR |= CPM_OPCR_OSC_ENABLE)
+#define __cpm_select_rtcclk_rtc()	(REG_CPM_OPCR |= CPM_OPCR_ERCS)
+#define __cpm_select_rtcclk_exclk()	(REG_CPM_OPCR &= ~CPM_OPCR_ERCS)
+
+
+#ifdef CFG_EXTAL
+#define JZ_EXTAL		CFG_EXTAL
+#else
+#define JZ_EXTAL		3686400
+#endif
+#define JZ_EXTAL2		32768 /* RTC clock */
+
+/* PLL output frequency */
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned long m, n, no, pllout;
+	unsigned long cppcr = REG_CPM_CPPCR;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if ((cppcr & CPM_CPPCR_PLLEN) && !(cppcr & CPM_CPPCR_PLLBP)) {
+		m = __cpm_get_pllm() + 2;
+		n = __cpm_get_plln() + 2;
+		no = od[__cpm_get_pllod()];
+		pllout = ((JZ_EXTAL) / (n * no)) * m;
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+/* PLL output frequency for MSC/I2S/LCD/USB */
+static __inline__ unsigned int __cpm_get_pllout2(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_PCS)
+		return __cpm_get_pllout();
+	else
+		return __cpm_get_pllout()/2;
+}
+
+/* CPU core clock */
+static __inline__ unsigned int __cpm_get_cclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_cdiv()];
+}
+
+/* AHB system bus clock */
+static __inline__ unsigned int __cpm_get_hclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_hdiv()];
+}
+
+/* Memory bus clock */
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_mdiv()];
+}
+
+/* APB peripheral bus clock */
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_pdiv()];
+}
+
+/* LCDC module clock */
+static __inline__ unsigned int __cpm_get_lcdclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_ldiv() + 1);
+}
+
+/* LCD pixel clock */
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_pixdiv() + 1);
+}
+
+/* I2S clock */
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_I2CS) {
+		return __cpm_get_pllout2() / (__cpm_get_i2sdiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* USB clock */
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_UCS) {
+		return __cpm_get_pllout2() / (__cpm_get_udiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+static __inline__ unsigned int __cpm_get_extalclk(void)
+{
+	return JZ_EXTAL;
+}
+
+/* RTC clock for CPM,INTC,RTC,TCU,WDT */
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+/*
+ * Output 24MHz for SD and 16MHz for MMC.
+ */
+static inline void __cpm_select_msc_clk(int n, int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	if (sd) {
+		div = pllout2 / 24000000;
+	}
+	else {
+		div = pllout2 / 16000000;
+	}
+
+	REG_CPM_MSCCDR(n) = div - 1;
+	REG_CPM_CPCCR |= CPM_CPCCR_CE;
+}
+
+/***************************************************************************
+ * TCU
+ ***************************************************************************/
+// where 'n' is the TCU channel
+#define __tcu_select_extalclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_EXT_EN)
+#define __tcu_select_rtcclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_RTC_EN)
+#define __tcu_select_pclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_PCK_EN)
+
+#define __tcu_select_clk_div1(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1)
+#define __tcu_select_clk_div4(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE4)
+#define __tcu_select_clk_div16(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE16)
+#define __tcu_select_clk_div64(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE64)
+#define __tcu_select_clk_div256(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE256)
+#define __tcu_select_clk_div1024(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1024)
+
+#define __tcu_enable_pwm_output(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_EN )
+#define __tcu_disable_pwm_output(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_EN )
+
+#define __tcu_init_pwm_output_high(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_INITL_HIGH )
+#define __tcu_init_pwm_output_low(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_INITL_HIGH )
+
+#define __tcu_set_pwm_output_shutdown_graceful(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_SD )
+#define __tcu_set_pwm_output_shutdown_abrupt(n)		( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_SD )
+
+#define __tcu_start_counter(n)		( REG_TCU_TESR |= (1 << (n)) )
+#define __tcu_stop_counter(n)		( REG_TCU_TECR |= (1 << (n)) )
+
+#define __tcu_half_match_flag(n)	( REG_TCU_TFR & (1 << ((n) + 16)) )
+#define __tcu_full_match_flag(n)	( REG_TCU_TFR & (1 << (n)) )
+#define __tcu_set_half_match_flag(n)	( REG_TCU_TFSR = (1 << ((n) + 16)) )
+#define __tcu_set_full_match_flag(n)	( REG_TCU_TFSR = (1 << (n)) )
+#define __tcu_clear_half_match_flag(n)	( REG_TCU_TFCR = (1 << ((n) + 16)) )
+#define __tcu_clear_full_match_flag(n)	( REG_TCU_TFCR = (1 << (n)) )
+#define __tcu_mask_half_match_irq(n)	( REG_TCU_TMSR = (1 << ((n) + 16)) )
+#define __tcu_mask_full_match_irq(n)	( REG_TCU_TMSR = (1 << (n)) )
+#define __tcu_unmask_half_match_irq(n)	( REG_TCU_TMCR = (1 << ((n) + 16)) )
+#define __tcu_unmask_full_match_irq(n)	( REG_TCU_TMCR = (1 << (n)) )
+
+#define __tcu_wdt_clock_stopped()	( REG_TCU_TSR & TCU_TSSR_WDTSC )
+#define __tcu_timer_clock_stopped(n)	( REG_TCU_TSR & (1 << (n)) )
+
+#define __tcu_start_wdt_clock()		( REG_TCU_TSCR = TCU_TSSR_WDTSC )
+#define __tcu_start_timer_clock(n)	( REG_TCU_TSCR = (1 << (n)) )
+
+#define __tcu_stop_wdt_clock()		( REG_TCU_TSSR = TCU_TSSR_WDTSC )
+#define __tcu_stop_timer_clock(n)	( REG_TCU_TSSR = (1 << (n)) )
+
+#define __tcu_get_count(n)		( REG_TCU_TCNT((n)) )
+#define __tcu_set_count(n,v)		( REG_TCU_TCNT((n)) = (v) )
+#define __tcu_set_full_data(n,v)	( REG_TCU_TDFR((n)) = (v) )
+#define __tcu_set_half_data(n,v)	( REG_TCU_TDHR((n)) = (v) )
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+#define __wdt_start()			( REG_WDT_TCER |= WDT_TCER_TCEN )
+#define __wdt_stop()			( REG_WDT_TCER &= ~WDT_TCER_TCEN )
+#define __wdt_set_count(v)		( REG_WDT_TCNT = (v) )
+#define __wdt_set_data(v)		( REG_WDT_TDR = (v) )
+
+#define __wdt_select_extalclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_EXT_EN)
+#define __wdt_select_rtcclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_RTC_EN)
+#define __wdt_select_pclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_PCK_EN)
+
+#define __wdt_select_clk_div1() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1)
+#define __wdt_select_clk_div4() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE4)
+#define __wdt_select_clk_div16() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE16)
+#define __wdt_select_clk_div64() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE64)
+#define __wdt_select_clk_div256() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE256)
+#define __wdt_select_clk_div1024() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1024)
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable()			( REG8(UART0_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable()		( REG8(UART0_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq()	( REG8(UART0_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq()	( REG8(UART0_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq() \
+  ( REG8(UART0_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq() \
+  ( REG8(UART0_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback()  	( REG8(UART0_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback() 	( REG8(UART0_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1()		( REG8(UART0_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(devclk, baud)				\
+  do {								\
+	REG8(UART0_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART0_DLLR) = (devclk / 16 / baud) & 0xff;		\
+	REG8(UART0_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART0_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error()		( (REG8(UART0_LSR) & UARTLSR_PER) != 0 )
+#define __uart_clear_errors() \
+  ( REG8(UART0_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty()	( (REG8(UART0_LSR) & UARTLSR_TDRQ) != 0 )
+#define __uart_transmit_end()		( (REG8(UART0_LSR) & UARTLSR_TEMT) != 0 )
+#define __uart_transmit_char(ch)	( REG8(UART0_TDR) = (ch) )
+#define __uart_receive_fifo_full()	( (REG8(UART0_LSR) & UARTLSR_DR) != 0 )
+#define __uart_receive_ready()		( (REG8(UART0_LSR) & UARTLSR_DR) != 0 )
+#define __uart_receive_char()		REG8(UART0_RDR)
+#define __uart_disable_irda()		( REG8(UART0_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(UART0_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define __dmac_enable_module(m) \
+	( REG_DMAC_DMACR(m) |= DMAC_DMACR_DMAE | DMAC_DMACR_PR_012345 )
+#define __dmac_disable_module(m) \
+	( REG_DMAC_DMACR(m) &= ~DMAC_DMACR_DMAE )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(m,p)			\
+do {							\
+	REG_DMAC_DMACR(m) &= ~DMAC_DMACR_PR_MASK;	\
+	REG_DMAC_DMACR(m) |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_HLT )
+#define __dmac_test_addr_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_AR )
+
+#define __dmac_enable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_NDES )
+#define __dmac_disable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_NDES )
+
+#define __dmac_enable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_EN )
+#define __dmac_disable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_EN )
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR((n)) & DMAC_DCCSR_EN )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCMD((n)) |= DMAC_DCMD_TIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_TT )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_AR )
+#define __dmac_channel_count_terminated_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_CT )
+#define __dmac_channel_descriptor_invalid_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_INV )
+
+#define __dmac_channel_clear_transmit_halt(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT )
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TT )
+#define __dmac_channel_clear_address_error(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR )
+#define __dmac_channel_clear_count_terminated(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_CT )
+#define __dmac_channel_clear_descriptor_invalid(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_INV )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_8BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BYTE;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BYTE;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_RDIL_MASK;		\
+	REG_DMAC_DCMD((n) |= ((v) << DMAC_DCMD_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DAI )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_DAI )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SAI )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_SAI )
+
+#define __dmac_channel_set_doorbell(m,n)	\
+	(  REG_DMAC_DMADBSR(m) = (1 << (n)) )
+
+#define __dmac_channel_irq_detected(m,n)  ( REG_DMAC_DMAIPR(m) & (1 << (n)) )
+#define __dmac_channel_ack_irq(m,n)       ( REG_DMAC_DMAIPR(m) &= ~(1 << (n)) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i = 0; i < MAX_DMA_NUM; i++)
+		if (__dmac_channel_irq_detected(i/HALF_DMA_NUM, i-i/HALF_DMA_NUM*HALF_DMA_NUM))
+			return i;
+	return -1;
+}
+
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+#define __aic_reset_status()          ( REG_AIC_FR & AIC_FR_RST )
+
+#define __aic_reset()                                   \
+do {                                                    \
+        REG_AIC_FR |= AIC_FR_RST;                       \
+} while(0)
+
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()   ( REG_AIC_CR |= AIC_CR_M2S )
+#define __aic_disable_mono2stereo()  ( REG_AIC_CR &= ~AIC_CR_M2S )
+#define __aic_enable_byteswap()      ( REG_AIC_CR |= AIC_CR_ENDSW )
+#define __aic_disable_byteswap()     ( REG_AIC_CR &= ~AIC_CR_ENDSW )
+#define __aic_enable_unsignadj()     ( REG_AIC_CR |= AIC_CR_AVSTSU )
+#define __aic_disable_unsignadj()    ( REG_AIC_CR &= ~AIC_CR_AVSTSU )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+ } while (0)
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_msbjustified()   ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+/*#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )*/
+
+#define __i2s_set_oss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+#define __i2s_set_iss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+
+#define __i2s_stop_bitclk()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_bitclk()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+#define __ac97_slot_error_detected()     ( REG_AIC_ACSR & AIC_ACSR_SLTERR )
+#define __ac97_clear_slot_error()        ( REG_AIC_ACSR &= ~AIC_ACSR_SLTERR )
+
+#define __i2s_is_busy()         ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+#define __aic_internal_codec()  ( REG_AIC_FR |= AIC_FR_ICDC ) 
+#define __aic_external_codec()  ( REG_AIC_FR &= ~AIC_FR_ICDC )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+ } while (0)
+
+
+/***************************************************************************
+ * ICDC
+ ***************************************************************************/
+#define __i2s_internal_codec()         __aic_internal_codec()
+#define __i2s_external_codec()         __aic_external_codec()
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) )
+
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+
+#define __msc_start_op() \
+  ( REG_MSC_STRPCL = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(to) 	( REG_MSC_RESTO = to )
+#define __msc_set_rdto(to) 	( REG_MSC_RDTO = to )
+#define __msc_set_cmd(cmd) 	( REG_MSC_CMD = cmd )
+#define __msc_set_arg(arg) 	( REG_MSC_ARG = arg )
+#define __msc_set_nob(nob) 	( REG_MSC_NOB = nob )
+#define __msc_get_nob() 	( REG_MSC_NOB )
+#define __msc_set_blklen(len) 	( REG_MSC_BLKLEN = len )
+#define __msc_set_cmdat(cmdat) 	( REG_MSC_CMDAT = cmdat )
+#define __msc_set_cmdat_ioabort() 	( REG_MSC_CMDAT |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init() 	( REG_MSC_CMDAT |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy() 	( REG_MSC_CMDAT |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream() ( REG_MSC_CMDAT |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block() ( REG_MSC_CMDAT &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write() ( REG_MSC_CMDAT |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(r) 				\
+do { 								\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat() \
+  REG_MSC_CMDAT &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask() 		( REG_MSC_IMASK )
+#define __msc_mask_all_intrs() 		( REG_MSC_IMASK = 0xff )
+#define __msc_unmask_all_intrs() 	( REG_MSC_IMASK = 0x00 )
+#define __msc_mask_rd() 		( REG_MSC_IMASK |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd() 		( REG_MSC_IMASK &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr() 		( REG_MSC_IMASK |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr() 		( REG_MSC_IMASK &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres() 		( REG_MSC_IMASK |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres() 	( REG_MSC_IMASK &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone() 	( REG_MSC_IMASK |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone() 	( REG_MSC_IMASK &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone() 		( REG_MSC_IMASK |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone() 		( REG_MSC_IMASK &= ~MSC_IMASK_PRG_DONE )
+
+/* n=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n) 	\
+do { 				\
+	REG_MSC_CLKRT = n;	\
+} while(0)
+
+#define __msc_get_ireg() 		( REG_MSC_IREG )
+#define __msc_ireg_rd() 		( REG_MSC_IREG & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr() 		( REG_MSC_IREG & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res() 	( REG_MSC_IREG & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done() 	( REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done() 		( REG_MSC_IREG & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res() 	( REG_MSC_IREG = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done() ( REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done() 	( REG_MSC_IREG = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat() 		( REG_MSC_STAT )
+#define __msc_stat_not_end_cmd_res() 	( (REG_MSC_STAT & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err() \
+  ( REG_MSC_STAT & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo() 		( REG_MSC_RES )
+#define __msc_rd_rxfifo()  		( REG_MSC_RXFIFO )
+#define __msc_wr_txfifo(v)  		( REG_MSC_TXFIFO = v )
+
+#define __msc_reset() 						\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+
+/***************************************************************************
+ * SSI (Synchronous Serial Interface)
+ ***************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define __ssi_enable(n) 	( REG_SSI_CR0(n) |= SSI_CR0_SSIE )
+#define __ssi_disable(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode(n) ( REG_SSI_ITR(n) &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2(n) 		\
+do { 					\
+	REG_SSI_CR0(n) |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1(n) &= ~SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_select_gpc(n) 			\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_FSEL;	\
+	REG_SSI_CR1(n) |= SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_underrun_auto_clear(n) 		\
+do { 						\
+	REG_SSI_CR0(n) |= SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_underrun_clear_manually(n) 	\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_txfifo_half_empty_intr(n)  \
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE )
+#define __ssi_disable_txfifo_half_empty_intr(n)	\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TIE )
+#define __ssi_enable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_TEIE )
+#define __ssi_disable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TEIE )
+#define __ssi_enable_rxfifo_half_full_intr(n)	\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE )
+#define __ssi_disable_rxfifo_half_full_intr(n)  \
+	( REG_SSI_CR0(n) &= ~SSI_CR0_RIE )
+#define __ssi_enable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_REIE )
+#define __ssi_disable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_REIE )
+
+#define __ssi_enable_loopback(n)  ( REG_SSI_CR0(n) |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback(n) ( REG_SSI_CR0(n) &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive(n)   ( REG_SSI_CR0(n) &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive(n)  ( REG_SSI_CR0(n) |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive(n)					\
+	( REG_SSI_CR0(n) |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit(n) 	( REG_SSI_CR1(n) &= ~SSI_CR1_UNFIN )
+#define __ssi_wait_transmit(n) 		( REG_SSI_CR1(n) |= SSI_CR1_UNFIN )
+#define __ssi_use_busy_wait_mode(n) 	__ssi_wait_transmit(n)
+#define __ssi_unset_busy_wait_mode(n) 	__ssi_finish_transmit(n)
+
+#define __ssi_spi_format(n)						\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SPI;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+	} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format(n)						\
+	do { 								\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN);	\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SSP;			\
+	} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format(n)					\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_MW1;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+		REG_SSI_CR0(n) &= ~SSI_CR0_RFINE;			\
+	} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+/* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	  | SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	
+
+#define __ssi_spi_set_misc(n,frmhl,endian,flen,mcom,pha,pol)		\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSICR1_MISC_MASK;			\
+		REG_SSI_CR1(n) |= ((frmhl) << 30) | ((endian) << 25) | 	\
+			(((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+			((pha) << 1) | (pol); 				\
+	} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb(n) ( REG_SSI_CR1(n) &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb(n) ( REG_SSI_CR1(n) |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n, m)					\
+	REG_SSI_CR1(n) = (REG_SSI_CR1(n) & ~SSI_CR1_FLEN_MASK) | (((m) - 2) << 4) 
+
+/* m = 1 - 16 */
+#define __ssi_set_microwire_command_length(n,m)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##m##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n, m)					\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_PHA) | (((m)&0x1)<< 1)))
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n, p)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_POL) | ((p)&0x1)) )
+
+/* SSI tx trigger, m = i x 8 */
+#define __ssi_set_tx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_TTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_TTRG_BIT;	\
+	} while (0)
+
+/* SSI rx trigger, m = i x 8 */
+#define __ssi_set_rx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_RTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_RTRG_BIT;	\
+	} while (0)
+
+#define __ssi_get_txfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_transfer_end(n)		( REG_SSI_SR(n) & SSI_SR_END )
+#define __ssi_is_busy(n)		( REG_SSI_SR(n) & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full(n)		( REG_SSI_SR(n) & SSI_SR_TFF )
+#define __ssi_rxfifo_empty(n)		( REG_SSI_SR(n) & SSI_SR_RFE )
+#define __ssi_rxfifo_half_full(n)	( REG_SSI_SR(n) & SSI_SR_RFHF )
+#define __ssi_txfifo_half_empty(n)	( REG_SSI_SR(n) & SSI_SR_TFHE )
+#define __ssi_underrun(n)		( REG_SSI_SR(n) & SSI_SR_UNDR )
+#define __ssi_overrun(n)		( REG_SSI_SR(n) & SSI_SR_OVER )
+#define __ssi_clear_underrun(n)		( REG_SSI_SR(n) = ~SSI_SR_UNDR )
+#define __ssi_clear_overrun(n)		( REG_SSI_SR(n) = ~SSI_SR_OVER )
+#define __ssi_clear_errors(n)		( REG_SSI_SR(n) &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_set_clk(n, dev_clk, ssi_clk)			\
+	( REG_SSI_GR(n) = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data(n) 		REG_SSI_DR(n)
+#define __ssi_transmit_data(n, v) 	(REG_SSI_DR(n) = (v))
+
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+  ( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+  ( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_PACK_MASK; 		\
+    REG_CIM_CFG |= (CIM_CFG_PACK_##n); 		\
+} while (0)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CPM; 		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CIM; 		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_GCM; 		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_NGCM; 		\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+    REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;			\
+    REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+
+#define __cim_enable_sof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_stop_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_FRC_##n; 		\
+} while (0)
+
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n; 	\
+} while (0)
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dam_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+#define __lcd_as_smart_lcd() 		( REG_LCD_CFG |= (1<<LCD_CFG_LCDPIN_BIT) )
+#define __lcd_as_general_lcd() 		( REG_LCD_CFG &= ~(1<<LCD_CFG_LCDPIN_BIT) )
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+#define __lcd_panel_white()		( REG_LCD_CFG |= LCD_CFG_WHITE )
+#define __lcd_panel_black()		( REG_LCD_CFG &= ~LCD_CFG_WHITE )
+
+/* n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_CFG &= ~LCD_CFG_PDW_MASK; 	\
+	REG_LCD_CFG |= LCD_CFG_PDW_n##;		\
+} while (0)
+
+/* m=LCD_CFG_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_CFG &= ~LCD_CFG_MODE_MASK;	\
+	REG_LCD_CFG |= (m);			\
+} while(0)
+
+/* n = 0-255 */
+#define __lcd_disable_ac_bias()		( REG_LCD_IO = 0xff )
+#define __lcd_set_ac_bias(n) 			\
+do {						\
+	REG_LCD_IO &= ~LCD_IO_ACB_MASK;		\
+	REG_LCD_IO |= ((n) << LCD_IO_ACB_BIT);	\
+} while(0)
+
+#define __lcd_io_set_dir()		( REG_LCD_IO |= LCD_IO_DIR )
+#define __lcd_io_clr_dir()		( REG_LCD_IO &= ~LCD_IO_DIR )
+
+#define __lcd_io_set_dep()		( REG_LCD_IO |= LCD_IO_DEP )
+#define __lcd_io_clr_dep()		( REG_LCD_IO &= ~LCD_IO_DEP )
+
+#define __lcd_io_set_vsp()		( REG_LCD_IO |= LCD_IO_VSP )
+#define __lcd_io_clr_vsp()		( REG_LCD_IO &= ~LCD_IO_VSP )
+
+#define __lcd_io_set_hsp()		( REG_LCD_IO |= LCD_IO_HSP )
+#define __lcd_io_clr_hsp()		( REG_LCD_IO &= ~LCD_IO_HSP )
+
+#define __lcd_io_set_pcp()		( REG_LCD_IO |= LCD_IO_PCP )
+#define __lcd_io_clr_pcp()		( REG_LCD_IO &= ~LCD_IO_PCP )
+
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+/***************************************************************************
+ * RTC ops
+ ***************************************************************************/
+
+#define __rtc_write_ready()  ( REG_RTC_RCR & RTC_RCR_WRDY )
+#define __rtc_enabled()      \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_RTCE ; \
+}while(0)                           \
+
+#define __rtc_disabled()         \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_RTCE; \
+}while(0)
+#define __rtc_enable_alarm()       \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_AE; \
+}while(0)
+
+#define __rtc_disable_alarm()    \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AE; \
+}while(0)
+
+#define __rtc_enable_alarm_irq()  \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_AIE; \
+}while(0)
+
+#define __rtc_disable_alarm_irq() \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AIE; \
+}while(0)
+#define __rtc_enable_Hz_irq()      \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR |= RTC_RCR_HZIE;  \
+}while(0)
+
+#define __rtc_disable_Hz_irq()     \
+do{                          \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_HZIE; \
+}while(0)
+#define __rtc_get_1Hz_flag()     \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ((REG_RTC_RCR >> RTC_RCR_HZ) & 0x1); \
+}while(0)
+#define __rtc_clear_1Hz_flag()      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_HZ;   \
+}while(0)
+#define __rtc_get_alarm_flag()       \
+do{                                  \
+       while(!__rtc_write_ready());  \
+      ((REG_RTC_RCR >> RTC_RCR_AF) & 0x1) \
+while(0)
+#define __rtc_clear_alarm_flag()    \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RCR &= ~RTC_RCR_AF;   \
+}while(0)
+#define  __rtc_get_second()        \
+do{                                \
+       while(!__rtc_write_ready());\
+	   REG_RTC_RSR;                \
+}while(0)
+ 
+#define __rtc_set_second(v)         \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RSR = v;              \
+}while(0)
+
+#define  __rtc_get_alarm_second()  \
+do{                                \
+      while(!__rtc_write_ready()); \
+	  REG_RTC_RSAR;                \
+}while(0)
+
+	  
+#define __rtc_set_alarm_second(v)   \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RSAR = v;             \
+}while(0)
+
+#define __rtc_RGR_is_locked()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR >> RTC_RGR_LOCK;  \
+}while(0)
+#define __rtc_lock_RGR()            \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR |= RTC_RGR_LOCK;  \
+}while(0)
+
+#define __rtc_unlock_RGR()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_RGR &= ~RTC_RGR_LOCK; \
+}while(0)
+
+#define __rtc_get_adjc_val()       \
+do{                                \
+      while(!__rtc_write_ready());  \
+      ( (REG_RTC_RGR & RTC_RGR_ADJC_MASK) >> RTC_RGR_ADJC_BIT ); \
+}while(0)
+#define __rtc_set_adjc_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_ADJC_MASK) | (v << RTC_RGR_ADJC_BIT) )) \
+}while(0)
+
+#define __rtc_get_nc1Hz_val()       \
+      while(!__rtc_write_ready());  \
+      ( (REG_RTC_RGR & RTC_RGR_NC1HZ_MASK) >> RTC_RGR_NC1HZ_BIT )
+      
+#define __rtc_set_nc1Hz_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_NC1HZ_MASK) | (v << RTC_RGR_NC1HZ_BIT) )) \
+}while(0)
+#define __rtc_power_down()          \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HCR |= RTC_HCR_PD;    \
+}while(0)
+
+#define __rtc_get_hwfcr_val()       \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HWFCR & RTC_HWFCR_MASK;  \
+}while(0)
+#define __rtc_set_hwfcr_val(v)      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      REG_RTC_HWFCR = (v) & RTC_HWFCR_MASK;  \
+}while(0)
+
+#define __rtc_get_hrcr_val()      \
+do{                               \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HRCR & RTC_HRCR_MASK ); \
+}while(0)
+#define __rtc_set_hrcr_val(v)        \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HRCR = (v) & RTC_HRCR_MASK );  \
+}while(0)
+
+#define __rtc_enable_alarm_wakeup()      \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWCR |= RTC_HWCR_EALM );  \
+}while(0)
+
+#define __rtc_disable_alarm_wakeup()     \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWCR &= ~RTC_HWCR_EALM );  \
+}while(0)
+
+#define __rtc_status_hib_reset_occur()    \
+do{                                       \
+      while(!__rtc_write_ready());        \
+    ( (REG_RTC_HWRSR >> RTC_HWRSR_HR) & 0x1 ); \
+}while(0)
+#define __rtc_status_ppr_reset_occur()     \
+do{                                        \
+      while(!__rtc_write_ready());        \
+   ( (REG_RTC_HWRSR >> RTC_HWRSR_PPR) & 0x1 ); \
+}while(0)
+#define __rtc_status_wakeup_pin_waken_up() \
+do{                                        \
+      while(!__rtc_write_ready());        \
+   ( (REG_RTC_HWRSR >> RTC_HWRSR_PIN) & 0x1 ); \
+}while(0)
+#define __rtc_status_alarm_waken_up()      \
+do{                                       \
+      while(!__rtc_write_ready());        \
+  ( (REG_RTC_HWRSR >> RTC_HWRSR_ALM) & 0x1 ); \
+}while(0)
+#define __rtc_clear_hib_stat_all()  \
+do{                                 \
+      while(!__rtc_write_ready());  \
+      ( REG_RTC_HWRSR = 0 );        \
+}while(0)
+
+#define __rtc_get_scratch_pattern() \
+      while(!__rtc_write_ready());  \
+		  (REG_RTC_HSPR)
+#define __rtc_set_scratch_pattern(n) 		\
+do{                                 \
+      while(!__rtc_write_ready());  \
+      (REG_RTC_HSPR = n );        \
+}while(0)
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define __ecc_encoding_4bit()                                   \
+do {				   		        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BCHE;  \
+	REG_BCH_CRC = BCH_CR_BSEL8;				\
+} while(0)
+#define __ecc_decoding_4bit()                           \
+do {                                                    \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BCHE;	\
+	REG_BCH_CRC = BCH_CR_ENCE | BCH_CR_BSEL8;	\
+} while(0)
+#define __ecc_encoding_8bit()                                                   \
+do {				   		                        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;   \
+} while(0)
+#define __ecc_decoding_8bit()                                        \
+do {                                                                 \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;	     \
+	REG_BCH_CRC = BCH_CR_ENCE;	                             \
+} while(0)
+#define __ecc_dma_enable()        ( REG_BCH_CRS = BCH_CR_DMAE )
+#define __ecc_disable()           ( REG_BCH_CRC = BCH_CR_BCHE )
+#define __ecc_encode_sync()       while (!(REG_BCH_INTS & BCH_INTS_ENCF))
+#define __ecc_decode_sync()       while (!(REG_BCH_INTS & BCH_INTS_DECF))
+#define __ecc_cnt_dec(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_DEC_MASK << BCH_CNT_DEC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_DEC_BIT;                        \
+} while(0)
+#define __ecc_cnt_enc(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_ENC_MASK << BCH_CNT_ENC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_ENC_BIT;                        \
+} while(0)
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __JZ4750_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz5730.h u-boot-1.1.6/include/asm-mips/jz5730.h
--- /develop/source/01boot/u-boot-1.1.6/include/asm-mips/jz5730.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/asm-mips/jz5730.h	2007-03-01 16:52:26.000000000 +0800
@@ -0,0 +1,3389 @@
+/*
+ * Include file for Ingenic Semiconductor's JZ5730 CPU.
+ */
+#ifndef __JZ5730_H__
+#define __JZ5730_H__
+
+#ifndef __ASSEMBLY__
+
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+
+#define cache_unroll(base,op)	        	\
+	__asm__ __volatile__("	         	\
+		.set noreorder;		        \
+		.set mips3;		        \
+		cache %1, (%0);	                \
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+static inline void jz_flush_dcache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_DCACHE_SIZE;
+	while (start < end) {
+		cache_unroll(start,Index_Writeback_Inv_D);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+static inline void jz_flush_icache(void)
+{
+	unsigned long start;
+	unsigned long end;
+
+	start = KSEG0;
+	end = start + CFG_ICACHE_SIZE;
+	while(start < end) {
+		cache_unroll(start,Index_Invalidate_I);
+		start += CFG_CACHELINE_SIZE;
+	}
+}
+
+/* cpu pipeline flush */
+static inline void jz_sync(void)
+{
+	__asm__ volatile ("sync");
+}
+
+static inline void jz_writeb(u32 address, u8 value)
+{
+	*((volatile u8 *)address) = value;
+}
+
+static inline void jz_writew(u32 address, u8 value)
+{
+	*((volatile u16 *)address) = value;
+}
+
+static inline void jz_writel(u32 address, u32 value)
+{
+	*((volatile u32 *)address) = value;
+}
+
+static inline u8 jz_readb(u32 address)
+{
+	return *((volatile u8 *)address);
+}
+
+static inline u16 jz_readw(u32 address)
+{
+	return *((volatile u16 *)address);
+}
+
+static inline u32 jz_readl(u32 address)
+{
+	return *((volatile u32 *)address);
+}
+
+#define REG8(addr)	*((volatile u8 *)(addr))
+#define REG16(addr)	*((volatile u16 *)(addr))
+#define REG32(addr)	*((volatile u32 *)(addr))
+
+#else
+
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+
+#endif /* !ASSEMBLY */
+
+#define	HARB_BASE	0xB3000000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define PCIC_BASE	0xB3070000
+#define	ETH_BASE	0xB3100000
+#define	NBM_BASE	0xB3F00000
+
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	OST_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	WDT_BASE	0xB0004000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	SCC_BASE	0xB0041000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	PWM0_BASE	0xB0050000
+#define	PWM1_BASE	0xB0051000
+#define	DES_BASE	0xB0060000
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00)
+#define RTC_RSR		(RTC_BASE + 0x04)
+#define RTC_RSAR	(RTC_BASE + 0x08)
+#define RTC_RGR		(RTC_BASE + 0x0c)
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+
+#define RTC_RCR_HZ	(1 << 6)
+#define RTC_RCR_HZIE	(1 << 5)
+#define RTC_RCR_AF	(1 << 4)
+#define RTC_RCR_AIE	(1 << 3)
+#define RTC_RCR_AE	(1 << 2)
+#define RTC_RCR_START	(1 << 0)
+
+#define RTC_RGR_LOCK		(1 << 31)
+#define RTC_RGR_ADJ_BIT		16
+#define RTC_RGR_ADJ_MASK	(0x3ff << RTC_RGR_ADJ_BIT)
+#define RTC_RGR_DIV_BIT		0
+#define RTC_REG_DIV_MASK	(0xff << RTC_RGR_DIV_BIT)
+
+
+
+/*************************************************************************
+ * PCIC
+ *************************************************************************/
+#define PCIC_CFGAR		(PCIC_BASE + 0x2c)
+#define PCIC_CFGDR		(PCIC_BASE + 0x30)
+#define PCIC_SR			(PCIC_BASE + 0x34)
+#define PCIC_IER		(PCIC_BASE + 0x38)
+#define PCIC_PTA_MEMATR		(PCIC_BASE + 0x40)
+#define PCIC_ATP_MTR0		(PCIC_BASE + 0x44)
+#define PCIC_ATP_MTR1		(PCIC_BASE + 0x48)
+#define PCIC_ATP_MTR2		(PCIC_BASE + 0x4c)
+#define PCIC_ATP_IOTR		(PCIC_BASE + 0x50)
+#define PCIC_INTACK		(PCIC_BASE + 0x54)
+
+#define PCIC_CFG_COMMAND	(PCIC_BASE + 0x100 + 0x04)
+#define PCIC_CFG_STATUS		(PCIC_BASE + 0x100 + 0x06)
+#define PCIC_CFG_MEMBASE0	(PCIC_BASE + 0x100 + 0x10)
+
+#define REG_PCIC_CFGAR		REG32(PCIC_CFGAR)
+#define REG_PCIC_CFGDR		REG32(PCIC_CFGDR)
+#define REG_PCIC_SR		REG32(PCIC_SR)
+#define REG_PCIC_IER		REG32(PCIC_IER)
+#define REG_PCIC_PTA_MEMATR	REG32(PCIC_PTA_MEMATR)
+#define REG_PCIC_ATP_MTR0	REG32(PCIC_ATP_MTR0)
+#define REG_PCIC_ATP_MTR1	REG32(PCIC_ATP_MTR1)
+#define REG_PCIC_ATP_MTR2	REG32(PCIC_ATP_MTR2)
+#define REG_PCIC_ATP_IOTR	REG32(PCIC_ATP_IOTR)
+#define REG_PCIC_INTACK		REG32(PCIC_INTACK)
+
+#define REG_PCIC_CFG_COMMAND	REG16(PCIC_CFG_COMMAND)
+#define REG_PCIC_CFG_STATUS	REG16(PCIC_CFG_STATUS)
+#define REG_PCIC_CFG_MEMBASE0	REG32(PCIC_CFG_MEMBASE0)
+
+#define PCIC_SR_INTD		(1 << 15)
+#define PCIC_SR_INTC		(1 << 14)
+#define PCIC_SR_INTB		(1 << 13)
+#define PCIC_SR_INTA		(1 << 12)
+#define PCIC_SR_APER		(1 << 11)	/* Addr parity error */
+#define PCIC_SR_DPER		(1 << 10)	/* Data parity error */
+#define PCIC_SR_MA		(1 << 9)	/* Master abort */
+#define PCIC_SR_TA		(1 << 8)	/* Target abort */
+
+#define PCIC_IER_SPLIT		(1 << 31)	/* AHB split enable */
+#define PCIC_IER_PCIA		(1 << 30)	/* PCI extern arbiter */
+#define PCIC_IER_INTD		(1 << 6)	/* INTD enable */
+#define PCIC_IER_INTC		(1 << 5)	/* INTC enable */
+#define PCIC_IER_INTB		(1 << 4)	/* INTB enable */
+#define PCIC_IER_INTA		(1 << 3)	/* INTA enable */
+#define PCIC_IER_MIE		(1 << 2)	/* mailbox intr en */
+#define PCIC_IER_IE		(1 << 1)	/* Interrupt en */
+
+#define PCIC_CFG_COMMAND_MASTER	(1 << 2)
+#define PCIC_CFG_COMMAND_MEM	(1 << 1)
+#define PCIC_CFG_COMMAND_IO	(1 << 0)
+
+#define IRQ_PCIC_0	40
+#define NUM_PCID	4
+
+#define JzSOC_PCI_IO_START	0xA0000000
+#define JzSOC_PCI_IO_END	0xA7FFFFFF
+#define JzSOC_PCI_MEM_START	0xA8000000
+#define JzSOC_PCI_MEM_END	0xAFFFFFFF
+
+#define JzSOC_PCI_VGA_TEXT_BASE	0xB0000000
+#define JzSOC_PCI_VGA_FB_BASE	0xB8000000
+
+#define JzSOC_PCI_CORE_START	0x10000000
+
+
+/*************************************************************************
+ * FIR
+ *************************************************************************/
+#define	FIR_TDR			(FIR_BASE + 0x000)
+#define	FIR_RDR			(FIR_BASE + 0x004)
+#define	FIR_TFLR		(FIR_BASE + 0x008)
+#define	FIR_AR			(FIR_BASE + 0x00C)
+#define	FIR_CR1			(FIR_BASE + 0x010)
+#define	FIR_CR2			(FIR_BASE + 0x014)
+#define	FIR_SR			(FIR_BASE + 0x018)
+
+#define	REG_FIR_TDR		REG8(FIR_TDR)
+#define	REG_FIR_RDR		REG8(FIR_RDR)
+#define REG_FIR_TFLR		REG16(FIR_TFLR)
+#define REG_FIR_AR		REG8(FIR_AR)
+#define	REG_FIR_CR1		REG8(FIR_CR1)
+#define	REG_FIR_CR2		REG16(FIR_CR2)
+#define REG_FIR_SR		REG16(FIR_SR)
+
+/* FIR Control Register 1 (FIR_CR1) */
+
+#define FIR_CR1_FIRUE		(1 << 7)
+#define FIR_CR1_ACE		(1 << 6)
+#define FIR_CR1_EOUS		(1 << 5)
+#define FIR_CR1_TIIE		(1 << 4)
+#define FIR_CR1_TFIE		(1 << 3)
+#define FIR_CR1_RFIE		(1 << 2)
+#define FIR_CR1_TXE		(1 << 1)
+#define FIR_CR1_RXE		(1 << 0)
+
+/* FIR Control Register 2 (FIR_CR2) */
+
+#define FIR_CR2_SIPE		(1 << 10)
+#define FIR_CR2_BCRC		(1 << 9)
+#define FIR_CR2_TFLRS		(1 << 8)
+#define FIR_CR2_ISS		(1 << 7)
+#define FIR_CR2_LMS		(1 << 6)
+#define FIR_CR2_TPPS		(1 << 5)
+#define FIR_CR2_RPPS		(1 << 4)
+#define FIR_CR2_TTRG_BIT	2
+#define FIR_CR2_TTRG_MASK	(0x3 << FIR_CR2_TTRG_BIT)
+  #define FIR_CR2_TTRG_16	  (0 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 16 */
+  #define FIR_CR2_TTRG_32	  (1 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 32 */
+  #define FIR_CR2_TTRG_64	  (2 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 64 */
+  #define FIR_CR2_TTRG_128	  (3 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 128 */
+#define FIR_CR2_RTRG_BIT	0
+#define FIR_CR2_RTRG_MASK	(0x3 << FIR_CR2_RTRG_BIT)
+  #define FIR_CR2_RTRG_16	  (0 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 16 */
+  #define FIR_CR2_RTRG_32	  (1 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 32 */
+  #define FIR_CR2_RTRG_64	  (2 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 64 */
+  #define FIR_CR2_RTRG_128	  (3 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 128 */
+
+/* FIR Status Register (FIR_SR) */
+
+#define FIR_SR_RFW		(1 << 12)
+#define FIR_SR_RFA		(1 << 11)
+#define FIR_SR_TFRTL		(1 << 10)
+#define FIR_SR_RFRTL		(1 << 9)
+#define FIR_SR_URUN		(1 << 8)
+#define FIR_SR_RFTE		(1 << 7)
+#define FIR_SR_ORUN		(1 << 6)
+#define FIR_SR_CRCE		(1 << 5)
+#define FIR_SR_FEND		(1 << 4)
+#define FIR_SR_TFF		(1 << 3)
+#define FIR_SR_RFE		(1 << 2)
+#define FIR_SR_TIDLE		(1 << 1)
+#define FIR_SR_RB		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * SCC
+ *************************************************************************/
+#define	SCC_DR(base)		((base) + 0x000)
+#define	SCC_FDR(base)		((base) + 0x004)
+#define	SCC_CR(base)		((base) + 0x008)
+#define	SCC_SR(base)		((base) + 0x00C)
+#define	SCC_TFR(base)		((base) + 0x010)
+#define	SCC_EGTR(base)		((base) + 0x014)
+#define	SCC_ECR(base)		((base) + 0x018)
+#define	SCC_RTOR(base)		((base) + 0x01C)
+
+#define REG_SCC_DR(base)	REG8(SCC_DR(base))
+#define REG_SCC_FDR(base)	REG8(SCC_FDR(base))
+#define REG_SCC_CR(base)	REG32(SCC_CR(base))
+#define REG_SCC_SR(base)	REG16(SCC_SR(base))
+#define REG_SCC_TFR(base)	REG16(SCC_TFR(base))
+#define REG_SCC_EGTR(base)	REG8(SCC_EGTR(base))
+#define REG_SCC_ECR(base)	REG32(SCC_ECR(base))
+#define REG_SCC_RTOR(base)	REG8(SCC_RTOR(base))
+
+/* SCC FIFO Data Count Register (SCC_FDR) */
+
+#define SCC_FDR_EMPTY		0x00
+#define SCC_FDR_FULL		0x10
+
+/* SCC Control Register (SCC_CR) */
+
+#define SCC_CR_SCCE		(1 << 31)
+#define SCC_CR_TRS		(1 << 30)
+#define SCC_CR_T2R		(1 << 29)
+#define SCC_CR_FDIV_BIT		24
+#define SCC_CR_FDIV_MASK	(0x3 << SCC_CR_FDIV_BIT)
+  #define SCC_CR_FDIV_1		  (0 << SCC_CR_FDIV_BIT) /* SCC_CLK frequency is the same as device clock */
+  #define SCC_CR_FDIV_2		  (1 << SCC_CR_FDIV_BIT) /* SCC_CLK frequency is half of device clock */
+#define SCC_CR_FLUSH		(1 << 23)
+#define SCC_CR_TRIG_BIT		16
+#define SCC_CR_TRIG_MASK	(0x3 << SCC_CR_TRIG_BIT)
+  #define SCC_CR_TRIG_1		  (0 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 1 */
+  #define SCC_CR_TRIG_4		  (1 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 4 */
+  #define SCC_CR_TRIG_8		  (2 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 8 */
+  #define SCC_CR_TRIG_14	  (3 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 14 */
+#define SCC_CR_TP		(1 << 15)
+#define SCC_CR_CONV		(1 << 14)
+#define SCC_CR_TXIE		(1 << 13)
+#define SCC_CR_RXIE		(1 << 12)
+#define SCC_CR_TENDIE		(1 << 11)
+#define SCC_CR_RTOIE		(1 << 10)
+#define SCC_CR_ECIE		(1 << 9)
+#define SCC_CR_EPIE		(1 << 8)
+#define SCC_CR_RETIE		(1 << 7)
+#define SCC_CR_EOIE		(1 << 6)
+#define SCC_CR_TSEND		(1 << 3)
+#define SCC_CR_PX_BIT		1
+#define SCC_CR_PX_MASK		(0x3 << SCC_CR_PX_BIT)
+  #define SCC_CR_PX_NOT_SUPPORT	  (0 << SCC_CR_PX_BIT) /* SCC does not support clock stop */
+  #define SCC_CR_PX_STOP_LOW	  (1 << SCC_CR_PX_BIT) /* SCC_CLK stops at state low */
+  #define SCC_CR_PX_STOP_HIGH	  (2 << SCC_CR_PX_BIT) /* SCC_CLK stops at state high */
+#define SCC_CR_CLKSTP		(1 << 0)
+
+/* SCC Status Register (SCC_SR) */
+
+#define SCC_SR_TRANS		(1 << 15)
+#define SCC_SR_ORER		(1 << 12)
+#define SCC_SR_RTO		(1 << 11)
+#define SCC_SR_PER		(1 << 10)
+#define SCC_SR_TFTG		(1 << 9)
+#define SCC_SR_RFTG		(1 << 8)
+#define SCC_SR_TEND		(1 << 7)
+#define SCC_SR_RETR_3		(1 << 4)
+#define SCC_SR_ECNTO		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * ETH
+ *************************************************************************/
+#define ETH_BMR		(ETH_BASE + 0x1000)
+#define ETH_TPDR	(ETH_BASE + 0x1004)
+#define ETH_RPDR	(ETH_BASE + 0x1008)
+#define ETH_RAR		(ETH_BASE + 0x100C)
+#define ETH_TAR		(ETH_BASE + 0x1010)
+#define ETH_SR		(ETH_BASE + 0x1014)
+#define ETH_CR		(ETH_BASE + 0x1018)
+#define ETH_IER		(ETH_BASE + 0x101C)
+#define ETH_MFCR	(ETH_BASE + 0x1020)
+#define ETH_CTAR	(ETH_BASE + 0x1050)
+#define ETH_CRAR	(ETH_BASE + 0x1054)
+#define ETH_MCR		(ETH_BASE + 0x0000)
+#define ETH_MAHR	(ETH_BASE + 0x0004)
+#define ETH_MALR	(ETH_BASE + 0x0008)
+#define ETH_HTHR	(ETH_BASE + 0x000C)
+#define ETH_HTLR	(ETH_BASE + 0x0010)
+#define ETH_MIAR	(ETH_BASE + 0x0014)
+#define ETH_MIDR	(ETH_BASE + 0x0018)
+#define ETH_FCR		(ETH_BASE + 0x001C)
+#define ETH_VTR1	(ETH_BASE + 0x0020)
+#define ETH_VTR2	(ETH_BASE + 0x0024)
+#define ETH_WKFR	(ETH_BASE + 0x0028)
+#define ETH_PMTR	(ETH_BASE + 0x002C)
+
+#define REG_ETH_BMR	REG32(ETH_BMR)
+#define REG_ETH_TPDR	REG32(ETH_TPDR)
+#define REG_ETH_RPDR	REG32(ETH_RPDR)
+#define REG_ETH_RAR	REG32(ETH_RAR)
+#define REG_ETH_TAR	REG32(ETH_TAR)
+#define REG_ETH_SR	REG32(ETH_SR)
+#define REG_ETH_CR	REG32(ETH_CR)
+#define REG_ETH_IER	REG32(ETH_IER)
+#define REG_ETH_MFCR	REG32(ETH_MFCR)
+#define REG_ETH_CTAR	REG32(ETH_CTAR)
+#define REG_ETH_CRAR	REG32(ETH_CRAR)
+#define REG_ETH_MCR	REG32(ETH_MCR)
+#define REG_ETH_MAHR	REG32(ETH_MAHR)
+#define REG_ETH_MALR	REG32(ETH_MALR)
+#define REG_ETH_HTHR	REG32(ETH_HTHR)
+#define REG_ETH_HTLR	REG32(ETH_HTLR)
+#define REG_ETH_MIAR	REG32(ETH_MIAR)
+#define REG_ETH_MIDR	REG32(ETH_MIDR)
+#define REG_ETH_FCR	REG32(ETH_FCR)
+#define REG_ETH_VTR1	REG32(ETH_VTR1)
+#define REG_ETH_VTR2	REG32(ETH_VTR2)
+#define REG_ETH_WKFR	REG32(ETH_WKFR)
+#define REG_ETH_PMTR	REG32(ETH_PMTR)
+
+/* Bus Mode Register (ETH_BMR) */
+
+#define ETH_BMR_DBO		(1 << 20)
+#define ETH_BMR_PBL_BIT		8
+#define ETH_BMR_PBL_MASK	(0x3f << ETH_BMR_PBL_BIT)
+  #define ETH_BMR_PBL_1		  (0x1 << ETH_BMR_PBL_BIT)
+  #define ETH_BMR_PBL_4		  (0x4 << ETH_BMR_PBL_BIT)
+#define ETH_BMR_BLE		(1 << 7)
+#define ETH_BMR_DSL_BIT		2
+#define ETH_BMR_DSL_MASK	(0x1f << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_0		  (0x0 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_1		  (0x1 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_2		  (0x2 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_4		  (0x4 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_8		  (0x8 << ETH_BMR_DSL_BIT)
+#define ETH_BMR_SWR		(1 << 0)
+
+/* DMA Status Register (ETH_SR) */
+
+#define ETH_SR_EB_BIT		23
+#define ETH_SR_EB_MASK		(0x7 << ETH_SR_EB_BIT)
+  #define ETH_SR_EB_TX_ABORT	  (0x1 << ETH_SR_EB_BIT)
+  #define ETH_SR_EB_RX_ABORT	  (0x2 << ETH_SR_EB_BIT)
+#define ETH_SR_TS_BIT		20
+#define ETH_SR_TS_MASK		(0x7 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_STOP	  (0x0 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_FTD		  (0x1 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_WEOT	  (0x2 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_QDAT	  (0x3 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_SUSPEND	  (0x6 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_CTD		  (0x7 << ETH_SR_TS_BIT)
+#define ETH_SR_RS_BIT		17
+#define ETH_SR_RS_MASK		(0x7 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_STOP	  (0x0 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_FRD		  (0x1 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_CEOR	  (0x2 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_WRP		  (0x3 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_SUSPEND	  (0x4 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_CRD		  (0x5 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_FCF		  (0x6 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_QRF		  (0x7 << ETH_SR_RS_BIT)
+#define ETH_SR_NIS		(1 << 16)
+#define ETH_SR_AIS		(1 << 15)
+#define ETH_SR_ERI		(1 << 14)
+#define ETH_SR_FBE		(1 << 13)
+#define ETH_SR_ETI		(1 << 10)
+#define ETH_SR_RWT		(1 << 9)
+#define ETH_SR_RPS		(1 << 8)
+#define ETH_SR_RU		(1 << 7)
+#define ETH_SR_RI		(1 << 6)
+#define ETH_SR_UNF		(1 << 5)
+#define ETH_SR_TJT		(1 << 3)
+#define ETH_SR_TU		(1 << 2)
+#define ETH_SR_TPS		(1 << 1)
+#define ETH_SR_TI		(1 << 0)
+
+/* Control (Operation Mode) Register (ETH_CR) */
+
+#define ETH_CR_TTM		(1 << 22)
+#define ETH_CR_SF		(1 << 21)
+#define ETH_CR_TR_BIT		14
+#define ETH_CR_TR_MASK		(0x3 << ETH_CR_TR_BIT)
+#define ETH_CR_ST		(1 << 13)
+#define ETH_CR_OSF		(1 << 2)
+#define ETH_CR_SR		(1 << 1)
+
+/* Interrupt Enable Register (ETH_IER) */
+
+#define ETH_IER_NI		(1 << 16)
+#define ETH_IER_AI		(1 << 15)
+#define ETH_IER_ERE		(1 << 14)
+#define ETH_IER_FBE		(1 << 13)
+#define ETH_IER_ET		(1 << 10)
+#define ETH_IER_RWE		(1 << 9)
+#define ETH_IER_RS		(1 << 8)
+#define ETH_IER_RU		(1 << 7)
+#define ETH_IER_RI		(1 << 6)
+#define ETH_IER_UN		(1 << 5)
+#define ETH_IER_TJ		(1 << 3)
+#define ETH_IER_TU		(1 << 2)
+#define ETH_IER_TS		(1 << 1)
+#define ETH_IER_TI		(1 << 0)
+
+/* Missed Frame and Buffer Overflow Counter Register (ETH_MFCR) */
+
+#define ETH_MFCR_OVERFLOW_BIT	17
+#define ETH_MFCR_OVERFLOW_MASK	(0x7ff << ETH_MFCR_OVERFLOW_BIT)
+#define ETH_MFCR_MFC_BIT	0
+#define ETH_MFCR_MFC_MASK	(0xffff << ETH_MFCR_MFC_BIT)
+
+/* MAC Control Register (ETH_MCR) */
+
+#define ETH_MCR_RA		(1 << 31)
+#define ETH_MCR_HBD		(1 << 28)
+#define ETH_MCR_PS		(1 << 27)
+#define ETH_MCR_DRO		(1 << 23)
+#define ETH_MCR_OM_BIT		21
+#define ETH_MCR_OM_MASK		(0x3 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_NORMAL	  (0x0 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_INTERNAL	  (0x1 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_EXTERNAL	  (0x2 << ETH_MCR_OM_BIT)
+#define ETH_MCR_F		(1 << 20)
+#define ETH_MCR_PM		(1 << 19)
+#define ETH_MCR_PR		(1 << 18)
+#define ETH_MCR_IF		(1 << 17)
+#define ETH_MCR_PB		(1 << 16)
+#define ETH_MCR_HO		(1 << 15)
+#define ETH_MCR_HP		(1 << 13)
+#define ETH_MCR_LCC		(1 << 12)
+#define ETH_MCR_DBF		(1 << 11)
+#define ETH_MCR_DTRY		(1 << 10)
+#define ETH_MCR_ASTP		(1 << 8)
+#define ETH_MCR_BOLMT_BIT	6
+#define ETH_MCR_BOLMT_MASK	(0x3 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_10	  (0 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_8	  (1 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_4	  (2 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_1	  (3 << ETH_MCR_BOLMT_BIT)
+#define ETH_MCR_DC		(1 << 5)
+#define ETH_MCR_TE		(1 << 3)
+#define ETH_MCR_RE		(1 << 2)
+
+/* MII Address Register (ETH_MIAR) */
+
+#define ETH_MIAR_PHY_ADDR_BIT	11
+#define ETH_MIAR_PHY_ADDR_MASK	(0x1f << ETH_MIAR_PHY_ADDR_BIT)
+#define ETH_MIAR_MII_REG_BIT	6
+#define ETH_MIAR_MII_REG_MASK	(0x1f << ETH_MIAR_MII_REG_BIT)
+#define ETH_MIAR_MII_WRITE	(1 << 1)
+#define ETH_MIAR_MII_BUSY	(1 << 0)
+
+/* Flow Control Register (ETH_FCR) */
+
+#define	ETH_FCR_PAUSE_TIME_BIT	16
+#define	ETH_FCR_PAUSE_TIME_MASK	(0xffff << ETH_FCR_PAUSE_TIME_BIT)
+#define	ETH_FCR_PCF		(1 << 2)
+#define	ETH_FCR_FCE		(1 << 1)
+#define	ETH_FCR_BUSY		(1 << 0)
+
+/* PMT Control and Status Register (ETH_PMTR) */
+
+#define ETH_PMTR_GU		(1 << 9)
+#define ETH_PMTR_RF		(1 << 6)
+#define ETH_PMTR_MF		(1 << 5)
+#define ETH_PMTR_RWK		(1 << 2)
+#define ETH_PMTR_MPK		(1 << 1)
+
+/* Receive Descriptor 0 (ETH_RD0) Bits */
+
+#define ETH_RD0_OWN		(1 << 31)
+#define ETH_RD0_FF		(1 << 30)
+#define ETH_RD0_FL_BIT		16
+#define ETH_RD0_FL_MASK		(0x3fff << ETH_RD0_FL_BIT)
+#define ETH_RD0_ES		(1 << 15)
+#define ETH_RD0_DE		(1 << 14)
+#define ETH_RD0_LE		(1 << 12)
+#define ETH_RD0_RF		(1 << 11)
+#define ETH_RD0_MF		(1 << 10)
+#define ETH_RD0_FD		(1 << 9)
+#define ETH_RD0_LD		(1 << 8)
+#define ETH_RD0_TL		(1 << 7)
+#define ETH_RD0_CS		(1 << 6)
+#define ETH_RD0_FT		(1 << 5)
+#define ETH_RD0_WT		(1 << 4)
+#define ETH_RD0_ME		(1 << 3)
+#define ETH_RD0_DB		(1 << 2)
+#define ETH_RD0_CE		(1 << 1)
+
+/* Receive Descriptor 1 (ETH_RD1) Bits */
+
+#define ETH_RD1_RER		(1 << 25)
+#define ETH_RD1_RCH		(1 << 24)
+#define ETH_RD1_RBS2_BIT	11
+#define ETH_RD1_RBS2_MASK	(0x7ff << ETH_RD1_RBS2_BIT)
+#define ETH_RD1_RBS1_BIT	0
+#define ETH_RD1_RBS1_MASK	(0x7ff << ETH_RD1_RBS1_BIT)
+
+/* Transmit Descriptor 0 (ETH_TD0) Bits */
+
+#define ETH_TD0_OWN		(1 << 31)
+#define ETH_TD0_FA		(1 << 15)
+#define ETH_TD0_LOC		(1 << 11)
+#define ETH_TD0_NC		(1 << 10)
+#define ETH_TD0_LC		(1 << 9)
+#define ETH_TD0_EC		(1 << 8)
+#define ETH_TD0_HBF		(1 << 7)
+#define ETH_TD0_CC_BIT		3
+#define ETH_TD0_CC_MASK		(0xf << ETH_TD0_CC_BIT)
+#define ETH_TD0_ED		(1 << 2)
+#define ETH_TD0_UF		(1 << 1)
+#define ETH_TD0_DF		(1 << 0)
+
+/* Transmit Descriptor 1 (ETH_TD1) Bits */
+
+#define ETH_TD1_IC		(1 << 31)
+#define ETH_TD1_LS		(1 << 30)
+#define ETH_TD1_FS		(1 << 29)
+#define ETH_TD1_AC		(1 << 26)
+#define ETH_TD1_TER		(1 << 25)
+#define ETH_TD1_TCH		(1 << 24)
+#define ETH_TD1_DPD		(1 << 23)
+#define ETH_TD1_TBS2_BIT	11
+#define ETH_TD1_TBS2_MASK	(0x7ff << ETH_TD1_TBS2_BIT)
+#define ETH_TD1_TBS1_BIT	0
+#define ETH_TD1_TBS1_MASK	(0x7ff << ETH_TD1_TBS1_BIT)
+
+
+
+
+/*************************************************************************
+ * WDT
+ *************************************************************************/
+#define WDT_WTCSR	(WDT_BASE + 0x00)
+#define WDT_WTCNT	(WDT_BASE + 0x04)
+
+#define REG_WDT_WTCSR	REG8(WDT_WTCSR)
+#define REG_WDT_WTCNT	REG32(WDT_WTCNT)
+
+#define WDT_WTCSR_START	(1 << 4)
+
+
+
+
+/*************************************************************************
+ * OST
+ *************************************************************************/
+#define OST_TER		(OST_BASE + 0x00)
+#define OST_TRDR(n)	(OST_BASE + 0x10 + ((n) * 0x20))
+#define OST_TCNT(n)	(OST_BASE + 0x14 + ((n) * 0x20))
+#define OST_TCSR(n)	(OST_BASE + 0x18 + ((n) * 0x20))
+#define OST_TCRB(n)	(OST_BASE + 0x1c + ((n) * 0x20))
+
+#define REG_OST_TER	REG8(OST_TER)
+#define REG_OST_TRDR(n)	REG32(OST_TRDR((n)))
+#define REG_OST_TCNT(n)	REG32(OST_TCNT((n)))
+#define REG_OST_TCSR(n)	REG16(OST_TCSR((n)))
+#define REG_OST_TCRB(n)	REG32(OST_TCRB((n)))
+
+#define OST_TCSR_BUSY		(1 << 7)
+#define OST_TCSR_UF		(1 << 6)
+#define OST_TCSR_UIE		(1 << 5)
+#define OST_TCSR_CKS_BIT	0
+#define OST_TCSR_CKS_MASK	(0x07 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_4	(0 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_16	(1 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_64	(2 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_256	(3 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_RTCCLK	(4 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_EXTAL	(5 << OST_TCSR_CKS_BIT)
+
+#define OST_TCSR0       OST_TCSR(0)
+#define OST_TCSR1       OST_TCSR(1)
+#define OST_TCSR2       OST_TCSR(2)
+#define OST_TRDR0       OST_TRDR(0)
+#define OST_TRDR1       OST_TRDR(1)
+#define OST_TRDR2       OST_TRDR(2)
+#define OST_TCNT0       OST_TCNT(0)
+#define OST_TCNT1       OST_TCNT(1)
+#define OST_TCNT2       OST_TCNT(2)
+#define OST_TCRB0       OST_TCRB(0)
+#define OST_TCRB1       OST_TCRB(1)
+#define OST_TCRB2       OST_TCRB(2)
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* register offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+
+/* register address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+
+#define UART1_RDR	(UART1_BASE + OFF_RDR)
+#define UART1_TDR	(UART1_BASE + OFF_TDR)
+#define UART1_DLLR	(UART1_BASE + OFF_DLLR)
+#define UART1_DLHR	(UART1_BASE + OFF_DLHR)
+#define UART1_IER	(UART1_BASE + OFF_IER)
+#define UART1_ISR	(UART1_BASE + OFF_ISR)
+#define UART1_FCR	(UART1_BASE + OFF_FCR)
+#define UART1_LCR	(UART1_BASE + OFF_LCR)
+#define UART1_MCR	(UART1_BASE + OFF_MCR)
+#define UART1_LSR	(UART1_BASE + OFF_LSR)
+#define UART1_MSR	(UART1_BASE + OFF_MSR)
+#define UART1_SPR	(UART1_BASE + OFF_SPR)
+#define UART1_SIRCR	(UART1_BASE + OFF_SIRCR)
+
+/*
+ * Define macros for UART_IER
+ * UART Interrupt Enable Register
+ */
+#define UART_IER_RIE	(1 << 0)	/* 0: receive fifo "full" interrupt disable */
+#define UART_IER_TIE	(1 << 1)	/* 0: transmit fifo "empty" interrupt disable */
+#define UART_IER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UART_IER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UART_IER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UART_ISR
+ * UART Interrupt Status Register
+ */
+#define UART_ISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UART_ISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UART_ISR_IID_MSI		(0 << 1)	/* Modem status interrupt */
+#define UART_ISR_IID_THRI	(1 << 1)	/* Transmitter holding register empty */
+#define UART_ISR_IID_RDI		(2 << 1)	/* Receiver data interrupt */
+#define UART_ISR_IID_RLSI	(3 << 1)	/* Receiver line status interrupt */
+#define UART_ISR_FFMS	(3 << 6)	/* FIFO mode select, set when UART_FCR.FE is set to 1 */
+#define UART_ISR_FFMS_NO_FIFO	(0 << 6)
+#define UART_ISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UART_FCR
+ * UART FIFO Control Register
+ */
+#define UART_FCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UART_FCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UART_FCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UART_FCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UART_FCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UART_FCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UART_FCR_RTRG_1	(0 << 6)
+#define UART_FCR_RTRG_4	(1 << 6)
+#define UART_FCR_RTRG_8	(2 << 6)
+#define UART_FCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UART_LCR
+ * UART Line Control Register
+ */
+#define UART_LCR_WLEN	(3 << 0)	/* word length */
+#define UART_LCR_WLEN_5	(0 << 0)
+#define UART_LCR_WLEN_6	(1 << 0)
+#define UART_LCR_WLEN_7	(2 << 0)
+#define UART_LCR_WLEN_8	(3 << 0)
+#define UART_LCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_1	(0 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UART_LCR_STOP_2	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+
+#define UART_LCR_PE	(1 << 3)	/* 0: parity disable */
+#define UART_LCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UART_LCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UART_LCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UART_LCR_DLAB	(1 << 7)	/* 0: access UART_RDR/TDR/IER  1: access UART_DLLR/DLHR */
+
+/*
+ * Define macros for UART_LSR
+ * UART Line Status Register
+ */
+#define UART_LSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UART_LSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UART_LSR_PER	(1 << 2)	/* 0: no parity error */
+#define UART_LSR_FER	(1 << 3)	/* 0; no framing error */
+#define UART_LSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UART_LSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UART_LSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UART_LSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UART_MCR
+ * UART Modem Control Register
+ */
+#define UART_MCR_DTR	(1 << 0)	/* 0: DTR_ ouput high */
+#define UART_MCR_RTS	(1 << 1)	/* 0: RTS_ output high */
+#define UART_MCR_OUT1	(1 << 2)	/* 0: UART_MSR.RI is set to 0 and RI_ input high */
+#define UART_MCR_OUT2	(1 << 3)	/* 0: UART_MSR.DCD is set to 0 and DCD_ input high */
+#define UART_MCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UART_MCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UART_MSR
+ * UART Modem Status Register
+ */
+#define UART_MSR_DCTS	(1 << 0)	/* 0: no change on CTS_ pin since last read of UART_MSR */
+#define UART_MSR_DDSR	(1 << 1)	/* 0: no change on DSR_ pin since last read of UART_MSR */
+#define UART_MSR_DRI	(1 << 2)	/* 0: no change on RI_ pin since last read of UART_MSR */
+#define UART_MSR_DDCD	(1 << 3)	/* 0: no change on DCD_ pin since last read of UART_MSR */
+#define UART_MSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+#define UART_MSR_DSR	(1 << 5)	/* 0: DSR_ pin is high */
+#define UART_MSR_RI	(1 << 6)	/* 0: RI_ pin is high */
+#define UART_MSR_DCD	(1 << 7)	/* 0: DCD_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)	/* 0: transmitter is in UART mode  1: IrDA mode */
+#define SIRCR_RSIRE	(1 << 1)	/* 0: receiver is in UART mode  1: IrDA mode */
+#define SIRCR_TPWS	(1 << 2)	/* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TXPL	(1 << 3)	/* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RXPL	(1 << 4)	/* 0: decoder interprets positive pulse as 0 */
+
+/*
+ * Define macros for REMRCR
+ */
+#define REMRCR_EN	(1 << 31)	/* Remote output receive enable */
+
+
+/*************************************************************************
+ * INTC
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+#define IRQ_I2C		1
+#define IRQ_UART1	8
+#define IRQ_UART0	9
+#define IRQ_SCC		10
+#define IRQ_UHC		13
+#define IRQ_RTC		15
+#define IRQ_SSI		17
+#define IRQ_PCIC	18
+#define IRQ_ETH		19
+#define IRQ_AIC		20
+#define IRQ_DMAC	21
+#define IRQ_OST2	22
+#define IRQ_OST1	23
+#define IRQ_OST0	24
+#define IRQ_GPIO2	26
+#define IRQ_GPIO1	27
+#define IRQ_GPIO0	28
+
+
+
+/*************************************************************************
+ * PWM
+ *************************************************************************/
+#define	PWM_CTR(n)		(PWM##n##_BASE + 0x000)
+#define	PWM_PER(n)		(PWM##n##_BASE + 0x004)
+#define	PWM_DUT(n)		(PWM##n##_BASE + 0x008)
+
+#define	REG_PWM_CTR(n)		REG8(PWM_CTR(n))
+#define	REG_PWM_PER(n)		REG16(PWM_PER(n))
+#define REG_PWM_DUT(n)		REG16(PWM_DUT(n))
+
+/* PWM Control Register (PWM_CTR) */
+
+#define	PWM_CTR_EN		(1 << 7)
+#define	PWM_CTR_SD		(1 << 6)
+#define	PWM_CTR_PRESCALE_BIT	0
+#define	PWM_CTR_PRESCALE_MASK	(0x3f << PWM_CTR_PRESCALE_BIT)
+
+/* PWM Period Register (PWM_PER) */
+
+#define	PWM_PER_PERIOD_BIT	0
+#define	PWM_PER_PERIOD_MASK	(0x3ff << PWM_PER_PERIOD_BIT)
+
+/* PWM Duty Register (PWM_DUT) */
+
+#define PWM_DUT_FDUTY		(1 << 10)
+#define PWM_DUT_DUTY_BIT	0
+#define PWM_DUT_DUTY_MASK	(0x3ff << PWM_DUT_DUTY_BIT)
+
+
+
+
+/*************************************************************************
+ * EMC
+ *************************************************************************/
+#define EMC_BCR		(EMC_BASE + 0x00)
+#define EMC_SMCR0	(EMC_BASE + 0x10)
+#define EMC_SMCR1	(EMC_BASE + 0x14)
+#define EMC_SMCR2	(EMC_BASE + 0x18)
+#define EMC_SMCR3	(EMC_BASE + 0x1c)
+#define EMC_SMCR4	(EMC_BASE + 0x20)
+#define EMC_SMCR5	(EMC_BASE + 0x24)
+#define EMC_SMCR6	(EMC_BASE + 0x28)
+#define EMC_SMCR7	(EMC_BASE + 0x2c)
+#define EMC_SACR0	(EMC_BASE + 0x30)
+#define EMC_SACR1	(EMC_BASE + 0x34)
+#define EMC_SACR2	(EMC_BASE + 0x38)
+#define EMC_SACR3	(EMC_BASE + 0x3c)
+#define EMC_SACR4	(EMC_BASE + 0x40)
+#define EMC_SACR5	(EMC_BASE + 0x44)
+#define EMC_SACR6	(EMC_BASE + 0x48)
+#define EMC_SACR7	(EMC_BASE + 0x4c)
+#define EMC_NFCSR	(EMC_BASE + 0x50)
+#define EMC_NFECC	(EMC_BASE + 0x54)
+#define EMC_PCCR1	(EMC_BASE + 0x60)
+#define EMC_PCCR2	(EMC_BASE + 0x64)
+#define EMC_PCCR3	(EMC_BASE + 0x68)
+#define EMC_PCCR4	(EMC_BASE + 0x6c)
+#define EMC_DMCR	(EMC_BASE + 0x80)
+#define EMC_RTCSR	(EMC_BASE + 0x84)
+#define EMC_RTCNT	(EMC_BASE + 0x88)
+#define EMC_RTCOR	(EMC_BASE + 0x8c)
+#define EMC_DMAR1	(EMC_BASE + 0x90)
+#define EMC_DMAR2	(EMC_BASE + 0x94)
+#define EMC_DMAR3	(EMC_BASE + 0x98)
+#define EMC_DMAR4	(EMC_BASE + 0x9c)
+
+#define EMC_SDMR0	(EMC_BASE + 0xa000)
+#define EMC_SDMR1	(EMC_BASE + 0xb000)
+#define EMC_SDMR2	(EMC_BASE + 0xc000)
+#define EMC_SDMR3	(EMC_BASE + 0xd000)
+
+/* NAND command/address/data port */
+#define NAND_DATAPORT    0xB4000000  /* read-write area */
+#define NAND_COMMPORT    0xB4040000  /* write only area */
+#define NAND_ADDRPORT    0xB4080000  /* write only area */
+
+#define REG_EMC_BCR	REG32(EMC_BCR)
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SMCR5	REG32(EMC_SMCR5)
+#define REG_EMC_SMCR6	REG32(EMC_SMCR6)
+#define REG_EMC_SMCR7	REG32(EMC_SMCR7)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+#define REG_EMC_SACR5	REG32(EMC_SACR5)
+#define REG_EMC_SACR6	REG32(EMC_SACR6)
+#define REG_EMC_SACR7	REG32(EMC_SACR7)
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+#define REG_EMC_NFECC	REG32(EMC_NFECC)
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR1	REG32(EMC_DMAR1)
+#define REG_EMC_DMAR2	REG32(EMC_DMAR2)
+#define REG_EMC_DMAR3	REG32(EMC_DMAR3)
+#define REG_EMC_DMAR4	REG32(EMC_DMAR4)
+#define REG_EMC_PCCR1	REG32(EMC_PCCR1)
+#define REG_EMC_PCCR2	REG32(EMC_PCCR2)
+#define REG_EMC_PCCR3	REG32(EMC_PCCR3)
+#define REG_EMC_PCCR4	REG32(EMC_PCCR4)
+
+
+#define EMC_BCR_BRE		(1 << 1)
+
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+#define EMC_NFCSR_RB		(1 << 7)
+#define EMC_NFCSR_BOOT_SEL_BIT	4
+#define EMC_NFCSR_BOOT_SEL_MASK	(0x07 << EMC_NFCSR_BOOT_SEL_BIT)
+#define EMC_NFCSR_ERST		(1 << 3)
+#define EMC_NFCSR_ECCE		(1 << 2)
+#define EMC_NFCSR_FCE		(1 << 1)
+#define EMC_NFCSR_NFE		(1 << 0)
+
+#define EMC_NFECC_ECC2_BIT	16
+#define EMC_NFECC_ECC2_MASK	(0xff << EMC_NFECC_ECC2_BIT)
+#define EMC_NFECC_ECC1_BIT	8
+#define EMC_NFECC_ECC1_MASK	(0xff << EMC_NFECC_ECC1_BIT)
+#define EMC_NFECC_ECC0_BIT	0
+#define EMC_NFECC_ECC0_MASK	(0xff << EMC_NFECC_ECC0_BIT)
+
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+  #define EMC_DMCR_BW_32	(0 << EMC_DMCR_BW_BIT)
+  #define EMC_DMCR_BW_16	(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+  #define EMC_DMCR_BA_2		(0 << EMC_DMCR_BA_BIT)
+  #define EMC_DMCR_BA_4		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+  #define EMC_DMCR_CASL_2	(1 << EMC_DMCR_TCL_BIT)
+  #define EMC_DMCR_CASL_3	(2 << EMC_DMCR_TCL_BIT)
+
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+#define EMC_SDMR_BM		(1 << 9)
+#define EMC_SDMR_OM_BIT		7
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_INTR	(1 << EMC_SDMR_BT_BIT)
+#define EMC_SDMR_BL_BIT		0
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+#define EMC_PCCR12_AMW		(1 << 31)
+#define EMC_PCCR12_AMAS_BIT	28
+#define EMC_PCCR12_AMAS_MASK	(0x07 << EMC_PCCR12_AMAS_BIT)
+#define EMC_PCCR12_AMAH_BIT	24
+#define EMC_PCCR12_AMAH_MASK	(0x07 << EMC_PCCR12_AMAH_BIT)
+#define EMC_PCCR12_AMPW_BIT	20
+#define EMC_PCCR12_AMPW_MASK	(0x0f << EMC_PCCR12_AMPW_BIT)
+#define EMC_PCCR12_AMRT_BIT	16
+#define EMC_PCCR12_AMRT_MASK	(0x0f << EMC_PCCR12_AMRT_BIT)
+#define EMC_PCCR12_CMW		(1 << 15)
+#define EMC_PCCR12_CMAS_BIT	12
+#define EMC_PCCR12_CMAS_MASK	(0x07 << EMC_PCCR12_CMAS_BIT)
+#define EMC_PCCR12_CMAH_BIT	8
+#define EMC_PCCR12_CMAH_MASK	(0x07 << EMC_PCCR12_CMAH_BIT)
+#define EMC_PCCR12_CMPW_BIT	4
+#define EMC_PCCR12_CMPW_MASK	(0x0f << EMC_PCCR12_CMPW_BIT)
+#define EMC_PCCR12_CMRT_BIT	0
+#define EMC_PCCR12_CMRT_MASK	(0x07 << EMC_PCCR12_CMRT_BIT)
+
+#define EMC_PCCR34_DRS_BIT	16
+#define EMC_PCCR34_DRS_MASK	(0x03 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_SPKR	(1 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_IOIS16	(2 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_INPACK	(3 << EMC_PCCR34_DRS_BIT)
+#define EMC_PCCR34_IOIS16	(1 << 15)
+#define EMC_PCCR34_IOW		(1 << 14)
+#define EMC_PCCR34_TCB_BIT	12
+#define EMC_PCCR34_TCB_MASK	(0x03 << EMC_PCCR34_TCB_BIT)
+#define EMC_PCCR34_IORT_BIT	8
+#define EMC_PCCR34_IORT_MASK	(0x07 << EMC_PCCR34_IORT_BIT)
+#define EMC_PCCR34_IOAE_BIT	6
+#define EMC_PCCR34_IOAE_MASK	(0x03 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_NONE	(0 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_1	(1 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_2	(2 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_5	(3 << EMC_PCCR34_IOAE_BIT)
+#define EMC_PCCR34_IOAH_BIT	4
+#define EMC_PCCR34_IOAH_MASK	(0x03 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_NONE	(0 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_1	(1 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_2	(2 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_5	(3 << EMC_PCCR34_IOAH_BIT)
+#define EMC_PCCR34_IOPW_BIT	0
+#define EMC_PCCR34_IOPW_MASK	(0x0f << EMC_PCCR34_IOPW_BIT)
+
+
+
+
+/*************************************************************************
+ * GPIO
+ *************************************************************************/
+#define GPIO_GPDR(n)	(GPIO_BASE + (0x00 + (n)*0x30))
+#define GPIO_GPPUR(n)	(GPIO_BASE + (0x0c + (n)*0x30))
+#define GPIO_GPSLR(n)	(GPIO_BASE + (0x10 + (n)*0x30))
+#define GPIO_GPSUR(n)	(GPIO_BASE + (0x14 + (n)*0x30))
+#define GPIO_GPFLR(n)	(GPIO_BASE + (0x18 + (n)*0x30))
+#define GPIO_GPFUR(n)	(GPIO_BASE + (0x1c + (n)*0x30))
+#define GPIO_GPIMR(n)	(GPIO_BASE + (0x24 + (n)*0x30))
+#define GPIO_GPFR(n)	(GPIO_BASE + (0x28 + (n)*0x30))
+
+#define REG_GPIO_GPDR(n)	REG32(GPIO_GPDR((n)))
+#define REG_GPIO_GPPUR(n)	REG32(GPIO_GPPUR((n)))
+#define REG_GPIO_GPSLR(n)	REG32(GPIO_GPSLR((n)))
+#define REG_GPIO_GPSUR(n)	REG32(GPIO_GPSUR((n)))
+#define REG_GPIO_GPFLR(n)	REG32(GPIO_GPFLR((n)))
+#define REG_GPIO_GPFUR(n)	REG32(GPIO_GPFUR((n)))
+#define REG_GPIO_GPIMR(n)	REG32(GPIO_GPIMR((n)))
+#define REG_GPIO_GPFR(n)	REG32(GPIO_GPFR((n)))
+
+#define IRQ_GPIO_0	48
+#define NUM_GPIO	70
+
+#define GPIO_GPDR0	REG_GPIO_GPDR(0)
+#define GPIO_GPDR1	REG_GPIO_GPDR(1)
+#define GPIO_GPDR2	REG_GPIO_GPDR(2)
+#define GPIO_GPPUR0	REG_GPIO_GPPUR(0)
+#define GPIO_GPPUR1	REG_GPIO_GPPUR(1)
+#define GPIO_GPPUR2	REG_GPIO_GPPUR(2)
+#define GPIO_GPSLR0	REG_GPIO_GPSLR(0)
+#define GPIO_GPSLR1	REG_GPIO_GPSLR(1)
+#define GPIO_GPSLR2	REG_GPIO_GPSLR(2)
+#define GPIO_GPSUR0	REG_GPIO_GPSUR(0)
+#define GPIO_GPSUR1	REG_GPIO_GPSUR(1)
+#define GPIO_GPSUR2	REG_GPIO_GPSUR(2)
+#define GPIO_GPFLR0	REG_GPIO_GPFLR(0)
+#define GPIO_GPFLR1	REG_GPIO_GPFLR(1)
+#define GPIO_GPFLR2	REG_GPIO_GPFLR(2)
+#define GPIO_GPFUR0	REG_GPIO_GPFUR(0)
+#define GPIO_GPFUR1	REG_GPIO_GPFUR(1)
+#define GPIO_GPFUR2	REG_GPIO_GPFUR(2)
+#define GPIO_GPIMR0	REG_GPIO_GPIMR(0)
+#define GPIO_GPIMR1	REG_GPIO_GPIMR(1)
+#define GPIO_GPIMR2	REG_GPIO_GPIMR(2)
+#define GPIO_GPFR0	REG_GPIO_GPFR(0)
+#define GPIO_GPFR1	REG_GPIO_GPFR(1)
+#define GPIO_GPFR2	REG_GPIO_GPFR(2)
+
+
+/*************************************************************************
+ * HARB
+ *************************************************************************/
+#define	HARB_HAPOR		(HARB_BASE + 0x000)
+#define	HARB_HMCTR		(HARB_BASE + 0x010)
+#define	HARB_HME8H		(HARB_BASE + 0x014)
+#define	HARB_HMCR1		(HARB_BASE + 0x018)
+#define	HARB_HMER2		(HARB_BASE + 0x01C)
+#define	HARB_HMER3		(HARB_BASE + 0x020)
+#define	HARB_HMLTR		(HARB_BASE + 0x024)
+
+#define	REG_HARB_HAPOR		REG32(HARB_HAPOR)
+#define	REG_HARB_HMCTR		REG32(HARB_HMCTR)
+#define	REG_HARB_HME8H		REG32(HARB_HME8H)
+#define	REG_HARB_HMCR1		REG32(HARB_HMCR1)
+#define	REG_HARB_HMER2		REG32(HARB_HMER2)
+#define	REG_HARB_HMER3		REG32(HARB_HMER3)
+#define	REG_HARB_HMLTR		REG32(HARB_HMLTR)
+
+/* HARB Priority Order Register (HARB_HAPOR) */
+
+#define	HARB_HAPOR_UCHSEL 		(1 << 7)
+#define	HARB_HAPOR_PRIO_BIT		0
+#define	HARB_HAPOR_PRIO_MASK		(0xf << HARB_HAPOR_PRIO_BIT)
+
+/* AHB Monitor Control Register (HARB_HMCTR) */
+
+#define	HARB_HMCTR_HET3_BIT		20
+#define	HARB_HMCTR_HET3_MASK		(0xf << HARB_HMCTR_HET3_BIT)
+#define	HARB_HMCTR_HMS3_BIT		16
+#define	HARB_HMCTR_HMS3_MASK		(0xf << HARB_HMCTR_HMS3_BIT)
+#define	HARB_HMCTR_HET2_BIT		12
+#define	HARB_HMCTR_HET2_MASK		(0xf << HARB_HMCTR_HET2_BIT)
+#define	HARB_HMCTR_HMS2_BIT		8
+#define	HARB_HMCTR_HMS2_MASK		(0xf << HARB_HMCTR_HMS2_BIT)
+#define	HARB_HMCTR_HOVF3		(1 << 7)
+#define	HARB_HMCTR_HOVF2		(1 << 6)
+#define	HARB_HMCTR_HOVF1		(1 << 5)
+#define	HARB_HMCTR_HRST			(1 << 4)
+#define	HARB_HMCTR_HEE3			(1 << 2)
+#define	HARB_HMCTR_HEE2			(1 << 1)
+#define	HARB_HMCTR_HEE1			(1 << 0)
+
+/* AHB Monitor Event 8bits High Register (HARB_HME8H) */
+
+#define HARB_HME8H_HC8H1_BIT		16
+#define HARB_HME8H_HC8H1_MASK		(0xff << HARB_HME8H_HC8H1_BIT)
+#define HARB_HME8H_HC8H2_BIT		8
+#define HARB_HME8H_HC8H2_MASK		(0xff << HARB_HME8H_HC8H2_BIT)
+#define HARB_HME8H_HC8H3_BIT		0
+#define HARB_HME8H_HC8H3_MASK		(0xff << HARB_HME8H_HC8H3_BIT)
+
+/* AHB Monitor Latency Register (HARB_HMLTR) */
+
+#define HARB_HMLTR_HLT2_BIT		16
+#define HARB_HMLTR_HLT2_MASK		(0xffff << HARB_HMLTR_HLT2_BIT)
+#define HARB_HMLTR_HLT3_BIT		0
+#define HARB_HMLTR_HLT3_MASK		(0xffff << HARB_HMLTR_HLT3_BIT)
+
+
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+
+/*************************************************************************
+ * DMAC 
+ *************************************************************************/
+#define DMAC_DSAR(n)	(DMAC_BASE + (0x00 + (n) * 0x20))
+#define DMAC_DDAR(n)	(DMAC_BASE + (0x04 + (n) * 0x20))
+#define DMAC_DTCR(n)	(DMAC_BASE + (0x08 + (n) * 0x20))
+#define DMAC_DRSR(n)	(DMAC_BASE + (0x0c + (n) * 0x20))
+#define DMAC_DCCSR(n)	(DMAC_BASE + (0x10 + (n) * 0x20))
+#define DMAC_DMAIPR	(DMAC_BASE + 0xf8)
+#define DMAC_DMACR	(DMAC_BASE + 0xfc)
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DDAR(n)	REG32(DMAC_DDAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DMAIPR		REG32(DMAC_DMAIPR)
+#define REG_DMAC_DMACR		REG32(DMAC_DMACR)
+
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x1f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_EXTREXTR		(0 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PCMCIAOUT	(4 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PCMCIAIN		(5 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO		(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_DESOUT		(10 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_DESIN		(11 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3OUT		(14 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3IN		(15 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2OUT		(16 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2IN		(17 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1OUT		(18 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1IN		(19 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT		(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN		(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIOUT		(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIIN		(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT		(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN		(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCOUT		(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCIN		(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_OST2		(28 << DMAC_DRSR_RS_BIT)
+
+#define DMAC_DCCSR_EACKS	(1 << 31)
+#define DMAC_DCCSR_EACKM	(1 << 30)
+#define DMAC_DCCSR_ERDM_BIT	28
+#define DMAC_DCCSR_ERDM_MASK	(0x03 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_LLEVEL	(0 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_FEDGE		(1 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_HLEVEL	(2 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_REDGE		(3 << DMAC_DCCSR_ERDM_BIT)
+#define DMAC_DCCSR_EOPM		(1 << 27)
+#define DMAC_DCCSR_SAM		(1 << 23)
+#define DMAC_DCCSR_DAM		(1 << 22)
+#define DMAC_DCCSR_RDIL_BIT	16
+#define DMAC_DCCSR_RDIL_MASK	(0x0f << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_IGN	(0 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_2	(1 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_4	(2 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_8	(3 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_12	(4 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_16	(5 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_20	(6 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_24	(7 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_28	(8 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_32	(9 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_48	(10 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_60	(11 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_64	(12 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_124	(13 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_128	(14 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_200	(15 << DMAC_DCCSR_RDIL_BIT)
+#define DMAC_DCCSR_SWDH_BIT	14
+#define DMAC_DCCSR_SWDH_MASK	(0x03 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_32	(0 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_8	(1 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_16	(2 << DMAC_DCCSR_SWDH_BIT)
+#define DMAC_DCCSR_DWDH_BIT	12
+#define DMAC_DCCSR_DWDH_MASK	(0x03 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_32	(0 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_8	(1 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_16	(2 << DMAC_DCCSR_DWDH_BIT)
+#define DMAC_DCCSR_DS_BIT	8
+#define DMAC_DCCSR_DS_MASK	(0x07 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_32b	(0 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_8b	(1 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_16b	(2 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_16B	(3 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_32B	(4 << DMAC_DCCSR_DS_BIT)
+#define DMAC_DCCSR_TM		(1 << 7)
+#define DMAC_DCCSR_AR		(1 << 4)
+#define DMAC_DCCSR_TC		(1 << 3)
+#define DMAC_DCCSR_HLT		(1 << 2)
+#define DMAC_DCCSR_TCIE		(1 << 1)
+#define DMAC_DCCSR_CHDE		(1 << 0)
+
+#define DMAC_DMAIPR_CINT_BIT	8
+#define DMAC_DMAIPR_CINT_MASK	(0xff << DMAC_DMAIPR_CINT_BIT)
+
+#define DMAC_DMACR_PR_BIT	8
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_01234567	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_02314675	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_20136457	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_ROUNDROBIN	(3 << DMAC_DMACR_PR_BIT)
+#define DMAC_DMACR_HTR		(1 << 3)
+#define DMAC_DMACR_AER		(1 << 2)
+#define DMAC_DMACR_DME		(1 << 0)
+
+#define IRQ_DMA_0	32
+#define NUM_DMA		6
+
+
+/*************************************************************************
+ * AIC 
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_AUSEL		(1 << 4)
+#define	AIC_FR_RST		(1 << 3)
+#define	AIC_FR_BCKD		(1 << 2)
+#define	AIC_FR_SYNCD		(1 << 1)
+#define	AIC_FR_ENB		(1 << 0)
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_RDMS		(1 << 15)
+#define	AIC_CR_TDMS		(1 << 14)
+#define	AIC_CR_FLUSH		(1 << 8)
+#define	AIC_CR_EROR		(1 << 6)
+#define	AIC_CR_ETUR		(1 << 5)
+#define	AIC_CR_ERFS		(1 << 4)
+#define	AIC_CR_ETFS		(1 << 3)
+#define	AIC_CR_ENLBF		(1 << 2)
+#define	AIC_CR_ERPL		(1 << 1)
+#define	AIC_CR_EREC		(1 << 0)
+
+#define AIC_CR_ASVTSU		(1 << 9)
+#define AIC_CR_ENDSW		(1 << 10)
+#define AIC_CR_M2S		(1 << 11)
+#define AIC_CR_OSS_BIT		19
+#define AIC_CR_OSS_MASK		(7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(4 << AIC_CR_OSS_BIT)
+#define AIC_CR_ISS_BIT		16
+#define AIC_CR_ISS_MASK		(7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(4 << AIC_CR_ISS_BIT)
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit */
+#define	AIC_ACCR1_XS_BIT	0
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18)
+#define	AIC_ACCR2_ESADR		(1 << 17)
+#define	AIC_ACCR2_ECADT		(1 << 16)
+#define	AIC_ACCR2_OASS_BIT	8
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)
+#define	AIC_ACCR2_SR		(1 << 2)
+#define	AIC_ACCR2_SS		(1 << 1)
+#define	AIC_ACCR2_SA		(1 << 0)
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12)
+#define	AIC_I2SCR_WL_BIT	1
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0)
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6)
+#define	AIC_SR_TUR		(1 << 5)
+#define	AIC_SR_RFS		(1 << 4)
+#define	AIC_SR_TFS		(1 << 3)
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_CRDY		(1 << 20)
+#define	AIC_ACSR_CLPM		(1 << 19)
+#define	AIC_ACSR_RSTO		(1 << 18)
+#define	AIC_ACSR_SADR		(1 << 17)
+#define	AIC_ACSR_CADT		(1 << 16)
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+
+/*************************************************************************
+ * DES
+ *************************************************************************/
+#define	DES_CR1			(DES_BASE + 0x000)
+#define	DES_CR2			(DES_BASE + 0x004)
+#define	DES_SR			(DES_BASE + 0x008)
+#define	DES_K1L			(DES_BASE + 0x010)
+#define	DES_K1R			(DES_BASE + 0x014)
+#define	DES_K2L			(DES_BASE + 0x018)
+#define	DES_K2R			(DES_BASE + 0x01C)
+#define	DES_K3L			(DES_BASE + 0x020)
+#define	DES_K3R			(DES_BASE + 0x024)
+#define	DES_IVL			(DES_BASE + 0x028)
+#define	DES_IVR			(DES_BASE + 0x02C)
+#define	DES_DIN			(DES_BASE + 0x030)
+#define	DES_DOUT		(DES_BASE + 0x034)
+
+#define REG_DES_CR1		REG32(DES_CR1)
+#define REG_DES_CR2		REG32(DES_CR2)
+#define REG_DES_SR		REG32(DES_SR)
+#define REG_DES_K1L		REG32(DES_K1L)
+#define REG_DES_K1R		REG32(DES_K1R)
+#define REG_DES_K2L		REG32(DES_K2L)
+#define REG_DES_K2R		REG32(DES_K2R)
+#define REG_DES_K3L		REG32(DES_K3L)
+#define REG_DES_K3R		REG32(DES_K3R)
+#define REG_DES_IVL		REG32(DES_IVL)
+#define REG_DES_IVR		REG32(DES_IVR)
+#define REG_DES_DIN		REG32(DES_DIN)
+#define REG_DES_DOUT		REG32(DES_DOUT)
+
+/* DES Control Register 1 (DES_CR1) */
+
+#define	DES_CR1_EN 		(1 << 0)
+
+/* DES Control Register 2 (DES_CR2) */
+
+#define	DES_CR2_ENDEC 		(1 << 3)
+#define	DES_CR2_MODE 		(1 << 2)
+#define	DES_CR2_ALG 		(1 << 1)
+#define	DES_CR2_DMAE		(1 << 0)
+
+/* DES State Register (DES_SR) */
+
+#define DES_SR_IN_FULL		(1 << 5)
+#define DES_SR_IN_LHF		(1 << 4)
+#define DES_SR_IN_EMPTY		(1 << 3)
+#define DES_SR_OUT_FULL		(1 << 2)
+#define DES_SR_OUT_GHF		(1 << 1)
+#define DES_SR_OUT_EMPTY	(1 << 0)
+
+
+
+
+/*************************************************************************
+ * CPM
+ *************************************************************************/
+#define CPM_CFCR	(CPM_BASE+0x00)
+#define CPM_PLCR1	(CPM_BASE+0x10)
+#define CPM_OCR		(CPM_BASE+0x1c)
+#define CPM_CFCR2	(CPM_BASE+0x60)
+#define CPM_LPCR	(CPM_BASE+0x04)
+#define CPM_RSTR	(CPM_BASE+0x08)
+#define CPM_MSCR	(CPM_BASE+0x20)
+#define CPM_SCR		(CPM_BASE+0x24)
+#define CPM_SPR		(CPM_BASE+0x44)
+
+#define REG_CPM_CFCR	REG32(CPM_CFCR)
+#define REG_CPM_PLCR1	REG32(CPM_PLCR1)
+#define REG_CPM_OCR	REG32(CPM_OCR)
+#define REG_CPM_CFCR2	REG32(CPM_CFCR2)
+#define REG_CPM_LPCR	REG32(CPM_LPCR)
+#define REG_CPM_RSTR	REG32(CPM_RSTR)
+#define REG_CPM_MSCR	REG32(CPM_MSCR)
+#define REG_CPM_SCR	REG32(CPM_SCR)
+#define REG_CPM_SPR     REG32(CPM_SPR)
+
+
+#define CPM_CFCR_SSI		(1 << 31)
+#define CPM_CFCR_CKOEN		(1 << 30)
+//#define CPM_CFCR_LFR_BIT	12
+#define CPM_CFCR_UCS		(1 << 29)
+#define CPM_CFCR_UFR_BIT	25
+#define CPM_CFCR_UFR_MASK	(0x07 << CPM_CFCR_UFR_BIT)
+#define CPM_CFCR_UPE		(1 << 24)
+#define CPM_CFCR_SSIFR_BIT	16
+#define CPM_CFCR_SSIFR_MASK	(0xff << CPM_CFCR_SSIFR_BIT)
+#define CPM_CFCR_MFR_BIT	12
+#define CPM_CFCR_MFR_MASK	(0x0f << CPM_CFCR_MFR_BIT)
+#define CPM_CFCR_PFR_BIT	8
+#define CPM_CFCR_PFR_MASK	(0x0f << CPM_CFCR_PFR_BIT)
+#define CPM_CFCR_SFR_BIT	4
+#define CPM_CFCR_SFR_MASK	(0x0f << CPM_CFCR_SFR_BIT)
+#define CPM_CFCR_IFR_BIT	0
+#define CPM_CFCR_IFR_MASK	(0x0f << CPM_CFCR_IFR_BIT)
+
+#define CPM_PLCR1_PLL1FD_BIT	23
+#define CPM_PLCR1_PLL1FD_MASK	(0x1ff << CPM_PLCR1_PLL1FD_BIT)
+#define CPM_PLCR1_PLL1RD_BIT	18
+#define CPM_PLCR1_PLL1RD_MASK	(0x1f << CPM_PLCR1_PLL1RD_BIT)
+#define CPM_PLCR1_PLL1OD_BIT	16
+#define CPM_PLCR1_PLL1OD_MASK	(0x03 << CPM_PLCR1_PLL1OD_BIT)
+#define CPM_PLCR1_PLL1S		(1 << 10)
+#define CPM_PLCR1_PLL1BP	(1 << 9)
+#define CPM_PLCR1_PLL1EN	(1 << 8)
+#define CPM_PLCR1_PLL1ST_BIT	0
+#define CPM_PLCR1_PLL1ST_MASK	(0xff << CPM_PLCR1_PLL1ST_BIT)
+
+#define CPM_OCR_O1ST_BIT	16
+#define CPM_OCR_O1ST_MASK	(0xff << CPM_OCR_O1ST_BIT)
+
+#define CPM_CFCR2_I2SFR_BIT	0
+#define CPM_CFCR2_I2SFR_MASK	(0x1ff << CPM_CFCR2_PXFR_BIT)
+
+#define CPM_LPCR_DUTY_BIT	3
+#define CPM_LPCR_DUTY_MASK	(0x1f << CPM_LPCR_DUTY_BIT)
+#define CPM_LPCR_DOZE		(1 << 2)
+#define CPM_LPCR_LPM_BIT	0
+#define CPM_LPCR_LPM_MASK	(0x03 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_IDLE		(0 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_SLEEP		(1 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_HIBERNATE	(2 << CPM_LPCR_LPM_BIT)
+
+#define CPM_RSTR_PR		(1 << 2)
+#define CPM_RSTR_WR		(1 << 1)
+#define CPM_RSTR_HR		(1 << 0)
+
+#define CPM_MSCR_MSTP_BIT	0
+#define CPM_MSCR_MSTP_MASK	(0xffff << CPM_MSCR_MSTP_BIT)
+  #define CPM_MSCR_MSTP_UART0	0
+  #define CPM_MSCR_MSTP_UART1	1
+  #define CPM_MSCR_MSTP_OST	2
+  #define CPM_MSCR_MSTP_RTC	3
+  #define CPM_MSCR_MSTP_DMAC	4
+  #define CPM_MSCR_MSTP_UHC	5
+  #define CPM_MSCR_MSTP_I2C	6
+  #define CPM_MSCR_MSTP_AIC1	7
+  #define CPM_MSCR_MSTP_PWM0	8
+  #define CPM_MSCR_MSTP_PWM1	9
+  #define CPM_MSCR_MSTP_SSI	10
+  #define CPM_MSCR_MSTP_SCC	11
+  #define CPM_MSCR_MSTP_AIC2	12
+  #define CPM_MSCR_MSTP_DES	13
+  #define CPM_MSCR_MSTP_ETH	14
+  #define CPM_MSCR_MSTP_PCI	15
+
+#define CPM_SCR_SUSPEND1	(1 << 7)
+#define CPM_SCR_SUSPEND0	(1 << 6)
+#define CPM_SCR_O2SE		(1 << 5)
+#define CPM_SCR_O1SE		(1 << 4)
+#define CPM_SCR_HGP             (1 << 3)
+#define CPM_SCR_HZP		(1 << 2)
+#define CPM_SCR_HZM		(1 << 1)
+
+
+
+/*************************************************************************
+ * SSI
+ *************************************************************************/
+#define	SSI_DR			(SSI_BASE + 0x000)
+#define	SSI_CR0			(SSI_BASE + 0x004)
+#define	SSI_CR1			(SSI_BASE + 0x008)
+#define	SSI_SR			(SSI_BASE + 0x00C)
+#define	SSI_ITR			(SSI_BASE + 0x010)
+#define	SSI_ICR			(SSI_BASE + 0x014)
+#define	SSI_GR			(SSI_BASE + 0x018)
+
+#define	REG_SSI_DR		REG32(SSI_DR)
+#define	REG_SSI_CR0		REG16(SSI_CR0)
+#define	REG_SSI_CR1		REG32(SSI_CR1)
+#define	REG_SSI_SR		REG32(SSI_SR)
+#define	REG_SSI_ITR		REG16(SSI_ITR)
+#define	REG_SSI_ICR		REG8(SSI_ICR)
+#define	REG_SSI_GR		REG16(SSI_GR)
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_TTRG_BIT	10
+#define SSI_CR1_TTRG_MASK	(0x3 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_1	  (0 << SSI_CR1_TTRG_BIT)/* Less than or equal to 1 */
+  #define SSI_CR1_TTRG_4	  (1 << SSI_CR1_TTRG_BIT) /* Less than or equal to 4 */
+  #define SSI_CR1_TTRG_8	  (2 << SSI_CR1_TTRG_BIT) /* Less than or equal to 8 */
+  #define SSI_CR1_TTRG_14	  (3 << SSI_CR1_TTRG_BIT) /* Less than or equal to 14 */
+#define SSI_CR1_RTRG_BIT	8
+#define SSI_CR1_RTRG_MASK	(0x3 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_1	  (0 << SSI_CR1_RTRG_BIT) /* More than or equal to 1 */
+  #define SSI_CR1_RTRG_4	  (1 << SSI_CR1_RTRG_BIT) /* More than or equal to 4 */
+  #define SSI_CR1_RTRG_8	  (2 << SSI_CR1_RTRG_BIT) /* More than or equal to 8 */
+  #define SSI_CR1_RTRG_14	  (3 << SSI_CR1_RTRG_BIT) /* More than or equal to 14 */
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	13
+#define SSI_SR_TFIFONUM_MASK	(0x1f << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0x1f << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+#ifndef __ASSEMBLY__
+
+
+/***************************************************************************
+ * RTC
+ ***************************************************************************/
+#define __rtc_start()	                ( REG_RTC_RCR |= RTC_RCR_START )
+#define __rtc_stop()	                ( REG_RTC_RCR &= ~RTC_RCR_START )
+
+#define __rtc_enable_alarm()	        ( REG_RTC_RCR |= RTC_RCR_AE )
+#define __rtc_disable_alarm()	        ( REG_RTC_RCR &= ~RTC_RCR_AE )
+#define __rtc_enable_alarm_irq()	( REG_RTC_RCR |= RTC_RCR_AIE )
+#define __rtc_disable_alarm_irq()	( REG_RTC_RCR &= ~RTC_RCR_AIE )
+
+#define __rtc_enable_1hz_irq()		( REG_RTC_RCR |= RTC_RCR_HZIE )
+#define __rtc_disable_1hz_irq()		( REG_RTC_RCR &= ~RTC_RCR_HZIE )
+
+#define __rtc_is_alarm_flag()		( REG_RTC_RCR & RTC_RCR_AF )
+#define __rtc_is_1hz_flag()		( REG_RTC_RCR & RTC_RCR_HZ )
+#define __rtc_clear_alarm_flag()	( REG_RTC_RCR &= ~RTC_RCR_AF )
+#define __rtc_clear_1hz_flag()		( REG_RTC_RCR &= ~RTC_RCR_HZ )
+
+#define __rtc_set_second(s)	        ( REG_RTC_RSR = (s) )
+#define __rtc_get_second()	        REG_RTC_RSR
+#define __rtc_set_alarm(s)	        ( REG_RTC_RSAR = (s) )
+#define __rtc_get_alarm()	        REG_RTC_RSAR
+
+#define __rtc_adjust_1hz(f32k) \
+  ( REG_RTC_RGR = (REG_RTC_RGR & ~(RTC_REG_DIV_MASK | RTC_RGR_ADJ_MASK)) | f32k | 0 )
+#define __rtc_lock_1hz()	( REG_RTC_RGR |= RTC_RGR_LOCK )
+
+
+/***************************************************************************
+ * PCIC
+ ***************************************************************************/
+#define __pcic_enable_irq(irq)			\
+do {						\
+	REG_PCIC_IER |= (1 << (irq + 3));	\
+} while (0)
+
+#define __pcic_disable_irq(irq)			\
+do {						\
+	REG_PCIC_IER &= ~(1 << (irq + 3));	\
+} while (0)
+
+#define __pcic_get_irq()			\
+({	unsigned int __t__, __i__;		\
+	__t__ = (REG_PCIC_SR >> 12) & 0x0f;	\
+	for (__i__ = 0; __i__ < 4; __i__ ++) {	\
+		if (__t__ & 0x01)		\
+			break;			\
+		__t__ >>= 1;			\
+	}					\
+	__i__;					\
+})
+
+#define __pcic_bus_errors_detected()		\
+	((REG_PCIC_CFG_STATUS & 0xf000) != 0)
+
+#define __pcic_clear_bus_errors()		\
+do {						\
+	REG_PCIC_CFG_STATUS = 0xf000;		\
+} while (0)
+ 
+/***************************************************************************
+ * SCC
+ ***************************************************************************/
+
+#define __scc_enable(base)	( REG_SCC_CR(base) |= SCC_CR_SCCE )
+#define __scc_disable(base)	( REG_SCC_CR(base) &= ~SCC_CR_SCCE )
+
+#define __scc_set_tx_mode(base)	( REG_SCC_CR(base) |= SCC_CR_TRS )
+#define __scc_set_rx_mode(base)	( REG_SCC_CR(base) &= ~SCC_CR_TRS )
+
+#define __scc_enable_t2r(base)	( REG_SCC_CR(base) |= SCC_CR_T2R )
+#define __scc_disable_t2r(base)	( REG_SCC_CR(base) &= ~SCC_CR_T2R )
+
+#define __scc_clk_as_devclk(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_FDIV_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_FDIV_1;		\
+} while (0)
+
+#define __scc_clk_as_half_devclk(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_FDIV_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_FDIV_2;		\
+} while (0)
+
+/* n=1,4,8,14 */
+#define __scc_set_fifo_trigger(base, n)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_TRIG_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_TRIG_##n;		\
+} while (0)
+
+#define __scc_set_protocol(base, p)		\
+do {						\
+	if (p)					\
+	  	REG_SCC_CR(base) |= SCC_CR_TP;	\
+	else					\
+	 	REG_SCC_CR(base) &= ~SCC_CR_TP;	\
+} while (0)
+
+#define __scc_flush_fifo(base)	( REG_SCC_CR(base) |= SCC_CR_FLUSH )
+
+#define __scc_set_invert_mode(base)	( REG_SCC_CR(base) |= SCC_CR_CONV )
+#define __scc_set_direct_mode(base)	( REG_SCC_CR(base) &= ~SCC_CR_CONV )
+
+#define SCC_ERR_INTRS \
+    ( SCC_CR_ECIE | SCC_CR_EPIE | SCC_CR_RETIE | SCC_CR_EOIE )
+#define SCC_ALL_INTRS \
+    ( SCC_CR_TXIE | SCC_CR_RXIE | SCC_CR_TENDIE | SCC_CR_RTOIE | \
+      SCC_CR_ECIE | SCC_CR_EPIE | SCC_CR_RETIE | SCC_CR_EOIE )
+
+#define __scc_enable_err_intrs(base)	( REG_SCC_CR(base) |= SCC_ERR_INTRS )
+#define __scc_disable_err_intrs(base)	( REG_SCC_CR(base) &= ~SCC_ERR_INTRS )
+
+#define SCC_ALL_ERRORS \
+    ( SCC_SR_ORER | SCC_SR_RTO | SCC_SR_PER | SCC_SR_RETR_3 | SCC_SR_ECNTO)
+
+#define __scc_clear_errors(base)	( REG_SCC_SR(base) &= ~SCC_ALL_ERRORS )
+
+#define __scc_enable_all_intrs(base)	( REG_SCC_CR(base) |= SCC_ALL_INTRS )
+#define __scc_disable_all_intrs(base)	( REG_SCC_CR(base) &= ~SCC_ALL_INTRS )
+
+#define __scc_enable_tx_intr(base)	( REG_SCC_CR(base) |= SCC_CR_TXIE | SCC_CR_TENDIE )
+#define __scc_disable_tx_intr(base)	( REG_SCC_CR(base) &= ~(SCC_CR_TXIE | SCC_CR_TENDIE) )
+
+#define __scc_enable_rx_intr(base)	( REG_SCC_CR(base) |= SCC_CR_RXIE)
+#define __scc_disable_rx_intr(base)	( REG_SCC_CR(base) &= ~SCC_CR_RXIE)
+
+#define __scc_set_tsend(base)		( REG_SCC_CR(base) |= SCC_CR_TSEND )
+#define __scc_clear_tsend(base)		( REG_SCC_CR(base) &= ~SCC_CR_TSEND )
+
+#define __scc_set_clockstop(base)	( REG_SCC_CR(base) |= SCC_CR_CLKSTP )
+#define __scc_clear_clockstop(base)	( REG_SCC_CR(base) &= ~SCC_CR_CLKSTP )
+
+#define __scc_clockstop_low(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_PX_MASK;		\
+  REG_SCC_CR(base) |= SCC_CR_PX_STOP_LOW;	\
+} while (0)
+
+#define __scc_clockstop_high(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_PX_MASK;		\
+  REG_SCC_CR(base) |= SCC_CR_PX_STOP_HIGH;	\
+} while (0)
+
+
+/* SCC status checking */
+#define __scc_check_transfer_status(base)  ( REG_SCC_SR(base) & SCC_SR_TRANS )
+#define __scc_check_rx_overrun_error(base) ( REG_SCC_SR(base) & SCC_SR_ORER )
+#define __scc_check_rx_timeout(base)	   ( REG_SCC_SR(base) & SCC_SR_RTO )
+#define __scc_check_parity_error(base)	   ( REG_SCC_SR(base) & SCC_SR_PER )
+#define __scc_check_txfifo_trigger(base)   ( REG_SCC_SR(base) & SCC_SR_TFTG )
+#define __scc_check_rxfifo_trigger(base)   ( REG_SCC_SR(base) & SCC_SR_RFTG )
+#define __scc_check_tx_end(base)	   ( REG_SCC_SR(base) & SCC_SR_TEND )
+#define __scc_check_retx_3(base)	   ( REG_SCC_SR(base) & SCC_SR_RETR_3 )
+#define __scc_check_ecnt_overflow(base)	   ( REG_SCC_SR(base) & SCC_SR_ECNTO )
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+
+#define __wdt_set_count(count) ( REG_WDT_WTCNT = (count) )
+#define __wdt_start()          ( REG_WDT_WTCSR |= WDT_WTCSR_START )
+#define __wdt_stop()           ( REG_WDT_WTCSR &= ~WDT_WTCSR_START )
+
+
+/***************************************************************************
+ * OST
+ ***************************************************************************/
+
+#define __ost_enable_all()         ( REG_OST_TER |= 0x07 )
+#define __ost_disable_all()        ( REG_OST_TER &= ~0x07 )
+#define __ost_enable_channel(n)    ( REG_OST_TER |= (1 << (n)) )
+#define __ost_disable_channel(n)   ( REG_OST_TER &= ~(1 << (n)) )
+#define __ost_set_reload(n, val)   ( REG_OST_TRDR(n) = (val) )
+#define __ost_set_count(n, val)    ( REG_OST_TCNT(n) = (val) )
+#define __ost_get_count(n)         ( REG_OST_TCNT(n) )
+#define __ost_set_clock(n, cs)     ( REG_OST_TCSR(n) |= (cs) )
+#define __ost_set_mode(n, val)     ( REG_OST_TCSR(n) = (val) )
+#define __ost_enable_interrupt(n)  ( REG_OST_TCSR(n) |= OST_TCSR_UIE )
+#define __ost_disable_interrupt(n) ( REG_OST_TCSR(n) &= ~OST_TCSR_UIE )
+#define __ost_uf_detected(n)       ( REG_OST_TCSR(n) & OST_TCSR_UF )
+#define __ost_clear_uf(n)          ( REG_OST_TCSR(n) &= ~OST_TCSR_UF )
+#define __ost_is_busy(n)           ( REG_OST_TCSR(n) & OST_TCSR_BUSY )
+#define __ost_clear_busy(n)        ( REG_OST_TCSR(n) &= ~OST_TCSR_BUSY )
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(n, devclk, baud)						\
+  do {											\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLLR) = (devclk / 16 / baud) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_PER) != 0 )
+
+#define __uart_clear_errors(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TDRQ) != 0 )
+
+#define __uart_transmit_end(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TEMT) != 0 )
+
+#define __uart_transmit_char(n, ch) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_TDR) = (ch)
+
+#define __uart_receive_fifo_full(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_ready(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_char(n) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_RDR)
+
+#define __uart_disable_irda() \
+  ( REG8(IRDA_BASE + OFF_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(IRDA_BASE + OFF_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) )
+
+/***************************************************************************
+ * PWM
+ ***************************************************************************/
+
+/* n is the pwm channel (0,1,..) */
+#define __pwm_enable_module(n)		( REG_PWM_CTR(n) |= PWM_CTR_EN )
+#define __pwm_disable_module(n)		( REG_PWM_CTR(n) &= ~PWM_CTR_EN )
+#define __pwm_graceful_shutdown_mode(n)	( REG_PWM_CTR(n) &= ~PWM_CTR_SD )
+#define __pwm_abrupt_shutdown_mode(n)	( REG_PWM_CTR(n) |= PWM_CTR_SD )
+#define __pwm_set_full_duty(n)		( REG_PWM_DUT(n) |= PWM_DUT_FDUTY )
+
+#define __pwm_set_prescale(n, p) \
+  ( REG_PWM_CTR(n) = ((REG_PWM_CTR(n) & ~PWM_CTR_PRESCALE_MASK) | (p) ) )
+#define __pwm_set_period(n, p) \
+  ( REG_PWM_PER(n) = ( (REG_PWM_PER(n) & ~PWM_PER_PERIOD_MASK) | (p) ) )
+#define __pwm_set_duty(n, d) \
+  ( REG_PWM_DUT(n) = ( (REG_PWM_DUT(n) & ~PWM_DUT_FDUTY) | (d) ) )
+
+/***************************************************************************
+ * EMC
+ ***************************************************************************/
+
+#define __emc_enable_split() ( REG_EMC_BCR = EMC_BCR_BRE )
+#define __emc_disable_split() ( REG_EMC_BCR = 0 )
+
+#define __emc_smem_bus_width(n) /* 8, 16 or 32*/		\
+	( REG_EMC_SMCR = (REG_EMC_SMCR & EMC_SMCR_BW_MASK) |	\
+			 EMC_SMCR_BW_##n##BIT )
+#define __emc_smem_byte_control() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR | EMC_SMCR_BCM )
+#define __emc_normal_smem() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR & ~EMC_SMCR_SMT )
+#define __emc_burst_smem() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR | EMC_SMCR_SMT )
+#define __emc_smem_burstlen(n) /* 4, 8, 16 or 32 */ \
+	( REG_EMC_SMCR = (REG_EMC_SMCR & EMC_SMCR_BL_MASK) | (EMC_SMCR_BL_##n )
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+/* p is the port number (0,1,2,3)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-70), regardless of the port
+ * m is the interrupt manner (low/high/falling/rising)
+ */
+
+#define __gpio_port_data(p)	( REG_GPIO_GPDR(p) )
+
+#define __gpio_port_as_gpiofn(p, o, fn)			\
+do {							\
+	unsigned int tmp;				\
+							\
+	if (o < 16) {					\
+		tmp = REG_GPIO_GPSLR(p);		\
+		tmp &= ~(3 << ((o) << 1));		\
+		REG_GPIO_GPSLR(p) = tmp;		\
+		tmp = REG_GPIO_GPFLR(p);		\
+		tmp &= ~(3 << ((o) << 1));		\
+		tmp |= fn << ((o) << 1);		\
+		REG_GPIO_GPFLR(p) = tmp;		\
+	} else {					\
+		tmp = REG_GPIO_GPSUR(p);		\
+		tmp &= ~(3 << (((o) - 16) << 1));	\
+		REG_GPIO_GPSUR(p) = tmp;		\
+		tmp = REG_GPIO_GPFUR(p);		\
+		tmp &= ~(3 << (((o) - 16) << 1));	\
+		tmp |= fn << (((o) - 16) << 1);		\
+		REG_GPIO_GPFUR(p) = tmp;		\
+	}						\
+							\
+} while (0)
+
+#define __gpio_port_as_output(p, o)			\
+do {							\
+	__gpio_port_as_gpiofn((p), (o), 1);		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)			\
+do {							\
+	__gpio_port_as_gpiofn((p), (o), 0);		\
+} while (0)
+
+#define __gpio_port_as_output_opendrain(p, o)		\
+do {							\
+	__gpio_port_as_gpiofn((p), (o), 2);		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_data(p) |= (1 << o);	\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_data(p) &= ~(1 << o);	\
+} while (0)
+
+static __inline__ unsigned int __gpio_get_pin(unsigned int n)
+{
+	unsigned int p, o;
+	p = (n) / 32;
+	o = (n) % 32;
+	if (__gpio_port_data(p) & (1 << o))
+		return 1;
+	else
+		return 0;
+}
+
+#define __gpio_as_irq(n, m)				\
+do {							\
+	unsigned int p, o, tmp;				\
+	p = (n) / 32;					\
+	o = (n) % 32;					\
+	if (o < 16) {					\
+		tmp = REG_GPIO_GPSLR(p);		\
+		tmp &= ~(3 << ((o) << 1));		\
+		tmp |= 2 << ((o) << 1);			\
+		REG_GPIO_GPSLR(p) = tmp;		\
+		tmp = REG_GPIO_GPFLR(p);		\
+		tmp &= ~(3 << ((o) << 1));		\
+		tmp |= (m) << ((o) << 1);		\
+		REG_GPIO_GPFLR(p) = tmp;		\
+	} else {					\
+		tmp = REG_GPIO_GPSUR(p);		\
+		tmp &= ~(3 << (((o) - 16) << 1));	\
+		tmp |= 2 << (((o) - 16) << 1);		\
+		REG_GPIO_GPSUR(p) = tmp;		\
+		tmp = REG_GPIO_GPFUR(p);		\
+		tmp &= ~(3 << (((o) - 16) << 1));	\
+		tmp |= (m) << (((o) - 16) << 1);	\
+		REG_GPIO_GPFUR(p) = tmp;		\
+	}						\
+} while (0)
+
+
+#define __gpio_as_irq_low_level(n)	__gpio_as_irq(n, 0)
+#define __gpio_as_irq_high_level(n)	__gpio_as_irq(n, 1)
+#define __gpio_as_irq_fall_edge(n)	__gpio_as_irq(n, 2)
+#define __gpio_as_irq_rise_edge(n)	__gpio_as_irq(n, 3)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPIMR(p) &= ~(1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPIMR(p) |= (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPFR(p) |= (1 << o);		\
+} while (0)
+
+
+static __inline__ unsigned int __gpio_get_irq(void)
+{
+	unsigned int tmp, i;
+
+	tmp = REG_GPIO_GPFR(2);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return 0x40 + i;
+	tmp = REG_GPIO_GPFR(1);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return 0x20 + i;
+	tmp = REG_GPIO_GPFR(0);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return i;
+	return 0;
+}
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_GPFR((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+/* Init the alternate function pins */
+
+
+#define __gpio_as_ssi()						\
+do {								\
+	GPIO_GPSUR1 = (GPIO_GPSUR1 & 0xfc00ffff) | 0x01550000;	\
+	GPIO_GPFUR1 = (GPIO_GPFUR1 & 0xfc00ffff);		\
+} while (0)
+
+#define __gpio_as_uart1()					\
+do {								\
+	GPIO_GPSLR0 = (GPIO_GPSLR0 & 0xfff0ffff) | 0x00050000;	\
+	GPIO_GPFLR0 = (GPIO_GPFLR0 & 0xfff0ffff);		\
+	GPIO_GPSUR0 = (GPIO_GPSUR0 & 0xfffffff0) | 0x00000005;	\
+	GPIO_GPFUR0 = (GPIO_GPFUR0 & 0xfffffff0);		\
+} while (0)
+
+#define __gpio_as_uart0()					\
+do {								\
+	GPIO_GPSLR2 = (GPIO_GPSLR2 & 0xfffffff0) | 0x00000005;	\
+	GPIO_GPFLR2 = (GPIO_GPFLR2 & 0xfffffff0);		\
+} while (0)
+
+
+#define __gpio_as_scc0()					\
+do {								\
+	GPIO_GPSUR1 = (GPIO_GPSUR1 & 0xc3ffffff) | 0x14000000;	\
+	GPIO_GPFUR1 = (GPIO_GPFUR1 & 0xc3ffffff);		\
+} while (0)
+
+#define __gpio_as_scc() __gpio_as_scc0();
+
+#define __gpio_as_dma()						\
+do {								\
+	GPIO_GPSLR0 = (GPIO_GPSLR0 & 0x000fffff) | 0x55500000;	\
+	GPIO_GPFLR0 = (GPIO_GPFLR0 & 0x000fffff);		\
+} while (0)
+
+#define __gpio_as_pcmcia()					\
+do {								\
+	GPIO_GPSUR0 = (GPIO_GPSUR0 & 0xf000ffff) | 0x05550000;	\
+	GPIO_GPFUR0 = (GPIO_GPFUR0 & 0xf000ffff);		\
+} while (0)
+
+#define __gpio_as_emc(csmask)					\
+do {								\
+	GPIO_GPSLR1 = (GPIO_GPSLR1 & 0xfff00003) | 0x00055554;	\
+	GPIO_GPFLR1 = (GPIO_GPFLR1 & 0xfff00003);		\
+} while (0)
+
+#define __gpio_as_usbclk()					\
+do {								\
+	GPIO_GPSLR1 = (GPIO_GPSLR1 & 0xfffffffc) | 0x00000001;	\
+	GPIO_GPFLR1 = (GPIO_GPFLR1 & 0xfffffffc);		\
+} while (0)
+
+#define __gpio_as_ac97()					\
+do {								\
+	GPIO_GPSUR1 = (GPIO_GPSUR1 & 0xffff030f) | 0x00005450;	\
+	GPIO_GPFUR1 = (GPIO_GPFUR1 & 0xffff030f) | 0x00000040;	\
+} while (0)
+
+#define __gpio_as_i2s_slave()					\
+do {								\
+	GPIO_GPSUR1 = (GPIO_GPSUR1 & 0xffff0c0f) | 0x00005150;	\
+	GPIO_GPFUR1 = (GPIO_GPFUR1 & 0xffff0c0f);		\
+} while (0)
+
+#define __gpio_as_i2s_master()					\
+do {								\
+	GPIO_GPSUR1 = (GPIO_GPSUR1 & 0xffff0c0f) | 0x00005150;	\
+	GPIO_GPFUR1 = (GPIO_GPFUR1 & 0xffff0c0f) | 0x00000050;	\
+} while (0)
+
+#define __gpio_as_pci()						\
+do {								\
+	GPIO_GPSLR1 = (GPIO_GPSLR1 & 0x000fffff) | 0x55500000;	\
+	GPIO_GPFLR1 = (GPIO_GPFLR1 & 0x000fffff);		\
+	GPIO_GPSUR1 = (GPIO_GPSUR1 & 0xfffffff0) | 0x00000005;	\
+	GPIO_GPFUR1 = (GPIO_GPFUR1 & 0xfffffff0);		\
+} while (0)
+
+#define __gpio_as_eth()						\
+do {								\
+	GPIO_GPSLR0 = (GPIO_GPSLR0 & 0xffff0003) | 0x00005554;	\
+	GPIO_GPFLR0 = (GPIO_GPFLR0 & 0xffff0003);		\
+	GPIO_GPSUR0 = (GPIO_GPSUR0 & 0xffff000f) | 0x00005550;	\
+	GPIO_GPFUR0 = (GPIO_GPFUR0 & 0xffff000f);		\
+} while (0)
+
+#define __gpio_as_pwm()						\
+do {								\
+	GPIO_GPSUR0 = (GPIO_GPSUR0 & 0x0fffffff) | 0x50000000;	\
+	GPIO_GPFUR0 = (GPIO_GPFUR0 & 0x0fffffff);		\
+} while (0)
+
+
+/***************************************************************************
+ * HARB
+ ***************************************************************************/
+
+#define __harb_usb0_udc()			\
+do {						\
+  REG_HARB_HAPOR &= ~HARB_HAPOR_UCHSEL; 	\
+} while (0)
+
+#define __harb_usb0_uhc()			\
+do {						\
+  REG_HARB_HAPOR |= HARB_HAPOR_UCHSEL; 		\
+} while (0)
+
+#define __harb_set_priority(n)			\
+do {						\
+  REG_HARB_HAPOR = ((REG_HARB_HAPOR & ~HARB_HAPOR_PRIO_MASK) | n);	\
+} while (0)
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* n is the DMA channel (0 - 7) */
+
+#define __dmac_enable_all_channels() \
+  ( REG_DMAC_DMACR |= DMAC_DMACR_DME | DMAC_DMACR_PR_ROUNDROBIN )
+#define __dmac_disable_all_channels() \
+  ( REG_DMAC_DMACR &= ~DMAC_DMACR_DME )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(p) 				\
+do {							\
+	REG_DMAC_DMACR &= ~DMAC_DMACR_PR_MASK;		\
+	REG_DMAC_DMACR |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error() ( REG_DMAC_DMACR & DMAC_DMACR_HTR )
+#define __dmac_test_addr_error() ( REG_DMAC_DMACR & DMAC_DMACR_AER )
+
+#define __dmac_enable_channel(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_CHDE )
+#define __dmac_disable_channel(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_CHDE )
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR(n) & DMAC_DCCSR_CHDE )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_TCIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TCIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_TC )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_AR )
+
+#define __dmac_channel_clear_transmit_halt(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT )
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TC )
+#define __dmac_channel_clear_address_error(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR )
+
+#define __dmac_channel_set_single_mode(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TM )
+#define __dmac_channel_set_block_mode(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_TM )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_32b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_16b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_8b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_16B;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_32B;		\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DWDH_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SWDH_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_RDIL_MASK;		\
+	REG_DMAC_DCCSR(n) |= ((v) << DMAC_DCCSR_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DAM )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DAM )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SAM )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_SAM )
+
+#define __dmac_channel_set_eop_high(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EOPM )
+#define __dmac_channel_set_eop_low(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EOPM )
+
+#define __dmac_channel_set_erdm(n,m)				\
+do {								\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SWDH_MASK;		\
+	REG_DMAC_DCCSR(n) |= ((m) << DMAC_DCCSR_ERDM_BIT);	\
+} while (0)
+
+#define __dmac_channel_set_eackm(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EACKM )
+#define __dmac_channel_clear_eackm(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EACKM )
+
+#define __dmac_channel_set_eacks(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EACKS )
+#define __dmac_channel_clear_eacks(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EACKS )
+
+
+#define __dmac_channel_irq_detected(n) \
+  ( REG_DMAC_DCCSR(n) & (DMAC_DCCSR_TC | DMAC_DCCSR_AR) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i=0;i<NUM_DMA;i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+#define __aic_reset()		( REG_AIC_FR |= AIC_FR_RST )
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()	(REG_AIC_CR |= AIC_CR_M2S)
+#define __aic_disable_mono2stereo()	(REG_AIC_CR &= ~AIC_CR_M2S)
+#define __aic_enable_byteswap()		(REG_AIC_CR |= AIC_CR_ENDSW)
+#define __aic_disable_byteswap()	(REG_AIC_CR &= ~AIC_CR_ENDSW)
+#define __aic_enable_unsignadj()	(REG_AIC_CR |= AIC_CR_ASVTSU)
+#define __aic_disable_unsignadj()	(REG_AIC_CR &= ~AIC_CR_ASVTSU)
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(1);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define Jz_AC97_RESET_BUG 1
+
+#ifndef Jz_AC97_RESET_BUG
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SO;		\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(1);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+#else
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	__gpio_as_output(54); /* SDATA_OUT */	\
+	__gpio_as_output(55); /* SDATA_IN */	\
+	__gpio_as_output(51); /* SYNC */	\
+	__gpio_as_output(53); /* RESET# */	\
+	__gpio_clear_pin(54);			\
+	__gpio_clear_pin(55);			\
+	__gpio_clear_pin(51);			\
+	__gpio_clear_pin(53);			\
+	udelay(10);				\
+	__gpio_set_pin(53);			\
+	udelay(1);				\
+	__gpio_as_ac97();			\
+ } while (0)
+#endif
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_left_justified() ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+#define __i2s_set_sample_size(n) \
+do { \
+	__ac97_set_iass(n); \
+	__ac97_set_oass(n); \
+} while (0)
+
+#define __i2s_stop_clock()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_clock()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+
+#define __i2s_is_busy() ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#if 0
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+#else
+#define __i2s_set_sample_rate(i2sclk, sync) do { } while(0)
+#endif
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+        __gpio_as_output(55); /* SDATA_OUT */	\
+        __gpio_as_input(54);  /* SDATA_IN */	\
+        __gpio_as_output(51); /* SYNC */	\
+        __gpio_as_output(53); /* RESET# */	\
+	__gpio_clear_pin(55);			\
+	__gpio_clear_pin(54);			\
+	__gpio_clear_pin(51);			\
+	__gpio_clear_pin(53);			\
+        __gpio_as_i2s_master();			\
+ } while (0)
+
+
+/***************************************************************************
+ * DES
+ ***************************************************************************/
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_plcr1_fd() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1FD_MASK) >> CPM_PLCR1_PLL1FD_BIT)
+#define __cpm_plcr1_rd() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1RD_MASK) >> CPM_PLCR1_PLL1RD_BIT)
+#define __cpm_plcr1_od() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1OD_MASK) >> CPM_PLCR1_PLL1OD_BIT)
+#define __cpm_cfcr_mfr() \
+	((REG_CPM_CFCR & CPM_CFCR_MFR_MASK) >> CPM_CFCR_MFR_BIT)
+#define __cpm_cfcr_pfr() \
+	((REG_CPM_CFCR & CPM_CFCR_PFR_MASK) >> CPM_CFCR_PFR_BIT)
+#define __cpm_cfcr_sfr() \
+	((REG_CPM_CFCR & CPM_CFCR_SFR_MASK) >> CPM_CFCR_SFR_BIT)
+#define __cpm_cfcr_ifr() \
+	((REG_CPM_CFCR & CPM_CFCR_IFR_MASK) >> CPM_CFCR_IFR_BIT)
+
+static __inline__ unsigned int __cpm_divisor_encode(unsigned int n)
+{
+	unsigned int encode[10] = {1,2,3,4,6,8,12,16,24,32};
+	int i;
+	for (i=0;i<10;i++)
+		if (n < encode[i])
+			break;
+	return i;
+}
+
+#define __cpm_set_mclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_MFR_MASK) | \
+		       ((n) << (CPM_CFCR_MFR_BIT)); \
+} while (0)
+
+#define __cpm_set_pclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_PFR_MASK) | \
+		       ((n) << (CPM_CFCR_PFR_BIT)); \
+} while (0)
+
+#define __cpm_set_sclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_SFR_MASK) | \
+		       ((n) << (CPM_CFCR_SFR_BIT)); \
+} while (0)
+
+#define __cpm_set_iclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_IFR_MASK) | \
+		       ((n) << (CPM_CFCR_IFR_BIT)); \
+} while (0)
+
+#define __cpm_set_lcdclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_LFR_MASK) | \
+		       ((n) << (CPM_CFCR_LFR_BIT)); \
+} while (0)
+
+#define __cpm_enable_cko()  (REG_CPM_CFCR |= CPM_CFCR_CKOEN)
+#define __cpm_disable_cko()  (REG_CPM_CFCR &= ~CPM_CFCR_CKOEN)
+
+#define __cpm_idle_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_IDLE)
+#define __cpm_sleep_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_SLEEP)
+#define __cpm_hibernate_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_HIBERNATE)
+
+#define __cpm_stop_uart(n) \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_UART##n << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_pwm(n) \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_PWM##n << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_aic(n) \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_AIC##n << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_ost() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_OST << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_rtc() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_RTC << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_dmac() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_DMAC << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_uhc() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_UHC << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_lcd() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_LCD << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_i2c() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_I2C << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_ssi() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_SSI << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_msc() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_MSC << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_scc() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_SCC << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_fir() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_FIR << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_des() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_DES << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_eth() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_ETH << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_ps2() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_PS2 << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_cim() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_CIM << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_udc() \
+	(REG_CPM_MSCR |= (CPM_MSCR_MSTP_UDC << CPM_MSCR_MSTP_BIT))
+#define __cpm_stop_all() (REG_CPM_MSCR = 0xffffffff)
+
+#define __cpm_start_uart(n) \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_UART##n << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_pwm(n) \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_PWM##n << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_aic(n) \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_AIC##n << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_ost() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_OST << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_rtc() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_RTC << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_dmac() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_DMAC << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_uhc() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_UHC << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_lcd() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_LCD << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_i2c() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_I2C << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_ssi() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_SSI << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_msc() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_MSC << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_scc() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_SCC << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_fir() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_FIR << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_des() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_DES << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_eth() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_ETH << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_ps2() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_PS2 << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_cim() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_CIM << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_udc() \
+	(REG_CPM_MSCR &= ~(CPM_MSCR_MSTP_UDC << CPM_MSCR_MSTP_BIT))
+#define __cpm_start_all() (REG_CPM_MSCR = 0x00000000)
+
+
+/***************************************************************************
+ * SSI
+ ***************************************************************************/
+
+#define __ssi_enable()    ( REG_SSI_CR0 |= SSI_CR0_SSIE )
+#define __ssi_disable()   ( REG_SSI_CR0 &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce() ( REG_SSI_CR0 &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode() ( REG_SSI_ITR &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2() 		\
+do { 					\
+	REG_SSI_CR0 |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 &= ~SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_select_gpc() 		\
+do { 					\
+	REG_SSI_CR0 &= ~SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 |= SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_loopback()  ( REG_SSI_CR0 |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback() ( REG_SSI_CR0 &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive()   ( REG_SSI_CR0 &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive()  ( REG_SSI_CR0 |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive() 	\
+  ( REG_SSI_CR0 |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo()   ( REG_SSI_CR0 |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo()   ( REG_SSI_CR0 |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo() \
+  ( REG_SSI_CR0 |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit() ( REG_SSI_CR1 &= ~SSI_CR1_UNFIN )
+
+#define __ssi_spi_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SPI; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN); 	\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SSP; 			\
+} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format() 				\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_MW1; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+	REG_SSI_CR0 &= ~SSI_CR0_RFINE; 				\
+} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+ /* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	| SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	\
+
+#define __ssi_spi_set_misc(frmhl,endian,flen,mcom,pha,pol)	\
+do { 								\
+	REG_SSI_CR1 &= ~SSICR1_MISC_MASK; 			\
+	REG_SSI_CR1 |= ((frmhl) << 30) | ((endian) << 25) | 	\
+		 (((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+	         ((pha) << 1) | (pol); 				\
+} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb() ( REG_SSI_CR1 &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb() ( REG_SSI_CR1 |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n) \
+    REG_SSI_CR1 = (REG_SSI_CR1 & ~SSI_CR1_FLEN_MASK) | (((n) - 2) << 4) 
+
+/* n = 1 - 16 */
+#define __ssi_set_microwire_command_length(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##n##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_PHA) | (n&0x1)) )
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_POL) | (n&0x1)) )
+
+/* n = i*8 (i=0,1,2...,15) */
+#define __ssi_set_tx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_TTRG_MASK; 	\
+	REG_SSI_CR1 |= (n>>3) << SSI_CR1_TTRG_BIT; 	\
+} while (0)
+
+/* n = i*8 (i=0,1,2...,15) */
+#define __ssi_set_rx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_RTRG_MASK; 	\
+	REG_SSI_CR1 |= (n>>3) << SSI_CR1_RTRG_BIT; 	\
+} while (0)
+
+#define __ssi_get_txfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_clear_errors() \
+    ( REG_SSI_SR &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_transfer_end()	( REG_SSI_SR & SSI_SR_END )
+#define __ssi_is_busy()		( REG_SSI_SR & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full()	( REG_SSI_SR & SSI_SR_TFF )
+#define __ssi_rxfifo_empty()	( REG_SSI_SR & SSI_SR_RFE )
+#define __ssi_rxfifo_noempty()	( REG_SSI_SR & SSI_SR_RFHF )
+
+#define __ssi_set_clk(dev_clk, ssi_clk) \
+  ( REG_SSI_GR = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data()    REG_SSI_DR
+#define __ssi_transmit_data(v)  ( REG_SSI_DR = (v) )
+
+/* 
+ * CPU clocks
+ */
+#ifdef CFG_EXTAL
+#define JZ_EXTAL		CFG_EXTAL
+#else
+#define JZ_EXTAL		3686400
+#endif
+#define JZ_EXTAL2		32768 /* RTC clock */
+
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned int nf, nr, no, pllout;
+	unsigned long plcr = REG_CPM_PLCR1;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if (plcr & CPM_PLCR1_PLL1EN) {
+		nf = (plcr & CPM_PLCR1_PLL1FD_MASK) >> CPM_PLCR1_PLL1FD_BIT;
+		nr = (plcr & CPM_PLCR1_PLL1RD_MASK) >> CPM_PLCR1_PLL1RD_BIT;
+		no = od[((plcr & CPM_PLCR1_PLL1OD_MASK) >> CPM_PLCR1_PLL1OD_BIT)];
+		pllout = (JZ_EXTAL) / ((nr+2) * no) * (nf+2);
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+static __inline__ unsigned int __cpm_get_iclk(void)
+{
+	unsigned int iclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		iclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_IFR_MASK) >> CPM_CFCR_IFR_BIT];
+	else
+		iclk = JZ_EXTAL;
+	return iclk;
+}
+
+static __inline__ unsigned int __cpm_get_sclk(void)
+{
+	unsigned int sclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		sclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_SFR_MASK) >> CPM_CFCR_SFR_BIT];
+	else
+		sclk = JZ_EXTAL;
+	return sclk;
+}
+
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	unsigned int mclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		mclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_MFR_MASK) >> CPM_CFCR_MFR_BIT];
+	else
+		mclk = JZ_EXTAL;
+	return mclk;
+}
+
+static __inline__ unsigned int __cpm_get_devclk(void)
+{
+	unsigned int devclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		devclk = __cpm_get_pllout() /
+			 div[(cfcr & CPM_CFCR_PFR_MASK) >> CPM_CFCR_PFR_BIT];
+	else
+		devclk = JZ_EXTAL;
+	return devclk;
+}
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __JZ5730_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/apus.h u-boot-1.1.6/include/configs/apus.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/apus.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/apus.h	2008-12-17 18:04:57.000000000 +0800
@@ -0,0 +1,250 @@
+/*
+ * (C) Copyright 2008  Ingenic Semiconductor
+ * 
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the apus board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4750		1  /* Jz4750 SoC */
+#define CONFIG_APUS		1  /* APUS validation board */
+
+#define JZ4750_NORBOOT_CFG	JZ4750_NORBOOT_16BIT	/* NOR Boot config code */
+
+#define CFG_EXTAL		24000000        /* EXTAL freq: 24 MHz */
+
+#define CFG_CPU_SPEED		336000000	/* CPU clock */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART3_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_MMC      	1
+#define CONFIG_FAT      	1    
+#define CONFIG_SUPPORT_VFAT 	1
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_NAND   | \
+				 CFG_CMD_MSC	| \
+				 CFG_CMD_MMC	| \
+				 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING)
+
+#define CONFIG_BOOTP_MASK	CONFIG_BOOTP_DEFAUL
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS3,57600n8 ip=dhcp nfsroot=192.168.1.20:/nfsroot/root26 rw ethaddr=00:2a:c6:43:ad:00"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:2a:c6:2c:ab:f0    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"APUS # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		896*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL) && !defined(CONFIG_MSC_SPL) && !defined(CONFIG_MSC_U_BOOT)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#elif defined(CONFIG_MSC_U_BOOT)
+#define CFG_ENV_IS_IN_MSC	1	/* use MSC for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_NAND_BW8		1              /* Data bus width: 0-16bit, 1-8bit */
+#define CFG_NAND_PAGE_SIZE      2048
+#define CFG_NAND_ROW_CYCLE	3     
+#define CFG_NAND_BLOCK_SIZE	(256 << 10)	/* NAND chip block size		*/
+#define CFG_NAND_BADBLOCK_PAGE	127		/* NAND bad block was marked at this page in a block, starting from 0 */
+#define CFG_NAND_BCH_BIT        8               /* Specify the hardware BCH algorithm for 4750 (4|8) */
+#define CFG_NAND_ECC_POS        3               /* Ecc offset position in oob area, its default value is 3 if it isn't defined. */
+#define CFG_NAND_IS_SHARE	1
+
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from MSC (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (MSUB) from MSC and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the MSC controller so that the special U-Boot image can be
+ * loaded from MSC to SDRAM.
+ *
+ * MSUB (MMC/SD U-Boot)
+ * This MSC U-Boot (MSUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_MSC_U_BOOT_DST	0x80100000	/* Load MSUB to this addr	 */
+#define CFG_MSC_U_BOOT_START	CFG_MSC_U_BOOT_DST /* Start MSUB from this addr */
+
+/*
+ * Define the partitioning of the MMC/SD card (only RAM U-Boot is needed here)
+ */
+#define CFG_MSC_U_BOOT_OFFS	(16 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_MSC_U_BOOT_SIZE	(256 << 10)	/* Size of RAM U-Boot image	*/
+
+#define CFG_MSC_BLOCK_SIZE	512 
+
+#ifdef CFG_ENV_IS_IN_MSC
+#define CFG_ENV_SIZE		CFG_MSC_BLOCK_SIZE
+#define CFG_ENV_OFFSET		((CFG_MSC_BLOCK_SIZE * 16) + CFG_MSC_U_BOOT_SIZE + (CFG_MSC_BLOCK_SIZE * 16))	/* environment starts here  */
+#endif
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(135)	/* max number of sectors on one chip: Spansion S29GL064N90 */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	0xa8000000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* Environment settings */
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#endif
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1  /* SDRAM BANK Number: 1, 2 */
+
+//#define CONFIG_MOBILE_SDRAM		/* use mobile sdram */
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+/*====================================================================== 
+ * GPIO
+ */
+#define GPIO_SD0_VCC_EN_N	(32*2+10) /* GPC10 */
+#define GPIO_SD0_CD_N		(32*2+11) /* GPC11 */
+#define GPIO_SD0_WP		(32*2+12) /* GPC12 */
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/dipper.h u-boot-1.1.6/include/configs/dipper.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/dipper.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/dipper.h	2008-06-05 09:22:09.000000000 +0800
@@ -0,0 +1,230 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the jz4725 dipper board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4725		1  /* Jz4725 SoC */
+#define CONFIG_JZ4740		1  /* Jz4740 SoC */
+#define CONFIG_DIPPER		1  /* DIPPER validation board */
+
+//#define CONFIG_LCD                 /* LCD support */
+#define CONFIG_JZLCD_SAMSUNG_LTP400WQF02_18BIT
+#define LCD_BPP			5  /* 5: 18,24,32 bits per pixel */
+#define CFG_WHITE_ON_BLACK
+#define CONFIG_LCD_LOGO
+
+#define JZ4740_NORBOOT_CFG	JZ4740_NORBOOT_16BIT	/* NOR Boot config code */
+#define JZ4740_NANDBOOT_CFG	JZ4740_NANDBOOT_B8R3	/* NAND Boot config code */
+
+#define CFG_CPU_SPEED		336000000	/* CPU clock: 336 MHz */
+#define CFG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_MMC      	1
+#define CONFIG_FAT      	1    
+#define CONFIG_SUPPORT_VFAT 	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+                                 CFG_CMD_NAND   | \
+				 CFG_CMD_MMC    | \
+                                 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=32M console=ttyS0,57600n8 ip=off root=/dev/mtdblock2 rw"
+#define CONFIG_BOOTCOMMAND	"nand read 0x80600000 0x400000 0x300000;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+//#define CONFIG_NET_MULTI
+
+#define CONFIG_DRIVER_CS8900      1
+#define CS8900_BASE             (0xa8000000)
+#define CS8900_BUS16
+
+#define CONFIG_ETHADDR		00:2a:cc:2a:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"DIPPER # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#define CFG_NAND_BLOCK_SIZE	(16 << 10)	/* NAND chip block size		*/
+#define CFG_NAND_BADBLOCK_PAGE	0		/* NAND bad block was marked at this page in a block, starting from 0 */
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	TEXT_BASE   /* in dipper/config.mk TEXT_BASE=0x88000000*/ 
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+#ifdef CFG_ENV_IS_IN_FLASH
+#define	CFG_ENV_IS_NOWHERE	1
+#define CFG_ENV_ADDR		0xa8040000
+#define CFG_ENV_SIZE		0x20000
+#endif
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		1	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		3	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+/*-----------------------------------------------------------------------
+ * GPIO definition
+ */
+
+#define GPIO_SD_VCC_EN_N	85  /* GPC21 */
+#define GPIO_SD_CD_N		91  /* GPC27 */
+#define GPIO_SD_WP		112 /* GPD16 */
+#define GPIO_USB_DETE		124 /* GPD28 */
+#define GPIO_DC_DETE_N		103 /* GPD7 */
+#define GPIO_CHARG_STAT_N	86 /* GPC22 */
+#define GPIO_DISP_OFF_N		118 /* GPD22 */
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/emurus.h u-boot-1.1.6/include/configs/emurus.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/emurus.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/emurus.h	2007-06-12 17:21:39.000000000 +0800
@@ -0,0 +1,147 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the emurus board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4740		1  /* Jz4740 SoC */
+#define CONFIG_EMURUS		1  /* emurus validation board */
+#define CONFIG_FPGA		1  /* emurus is an FPGA board */
+
+#define JZ4740_NORBOOT_CFG	JZ4740_NORBOOT_8BIT	/* NOR Boot config code */
+#define JZ4740_NANDBOOT_CFG	JZ4740_NANDBOOT_B8R3	/* NAND Boot config code */
+
+#define CFG_EXTAL		8000000		/* EXTAL freq: 8 MHz */
+#define CFG_CPU_SPEED		CFG_EXTAL	/* CPU clock: 384 MHz */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		9600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		((CONFIG_CMD_DFL | CFG_CMD_DHCP) & ~(CFG_CMD_ENV))
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,9600n8 ip=dhcp nfsroot=192.168.1.20:/stdev/development/nfsroot/pmp-root rw ethaddr=00:2a:cd:1c:af:fe"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:2a:cd:1c:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"EMURUS # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+
+//#define PHYS_FLASH_1		0xb8000000 /* Flash Bank #1 */
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+#define	CFG_ENV_IS_NOWHERE	1
+
+/* Address and size of Primary Environment Sector	*/
+//#define CFG_ENV_ADDR		0xb8040000
+#define CFG_ENV_ADDR		0xa8040000
+#define CFG_ENV_SIZE		0x20000
+
+/*
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/fcr.h u-boot-1.1.6/include/configs/fcr.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/fcr.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/fcr.h	2007-05-23 17:46:13.000000000 +0800
@@ -0,0 +1,144 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the fcr board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_FCR		1  /* fcr board */
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 3.6864 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=16M console=ttyS0,115200n8 ip=bootp nfsroot=192.168.1.20:/nfsroot/miniroot rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:50:c2:1e:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"FCR # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Flash configuration
+ * (SST39VF020: 4KB * 64 = 256KB)
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xbfc00000    /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1  /* Flash beginning from 0xbfc00000 */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(192*1024)  /* Reserve 192 kB for Monitor */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ) /* Timeout for Flash Write */
+
+/* Environment settings */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		12	/* Row address: 11 to 13 */
+#define SDRAM_COL		8	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/fprint.h u-boot-1.1.6/include/configs/fprint.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/fprint.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/fprint.h	2007-05-23 17:46:13.000000000 +0800
@@ -0,0 +1,149 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the fingerprint board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_FPRINT		1  /* fprint board */
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 3.6864 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART2_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_COMMANDS		((CONFIG_CMD_DFL & \
+					 ~(CFG_CMD_MEMORY | \
+					   CFG_CMD_LOADS | \
+					   CFG_CMD_LOADB | \
+					   CFG_CMD_BDI | \
+					   CFG_CMD_CONSOLE | \
+					   CFG_CMD_IMI | \
+					   CFG_CMD_IMLS | \
+					   CFG_CMD_ITEST | \
+					   CFG_CMD_NFS | \
+					   CFG_CMD_AUTOSCRIPT)) | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_DHCP )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=16M console=ttyS2,115200n8 ip=bootp nfsroot=192.168.1.20:/nfsroot/miniroot rw"
+#define CONFIG_BOOTCOMMAND	"setenv bootargs ethaddr=$(ethaddr) $(bootargs);bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:51:b6:2d:12:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"FPRINT # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Flash configuration
+ * (AM29LV320DB: 4MB)
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	71	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xbfc00000    /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1  /* Flash beginning from 0xbfc00000 */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(128*1024)  /* Reserve 128 kB for Monitor */
+
+/* Environment settings */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		12	/* Row address: 11 to 13 */
+#define SDRAM_COL		8	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/fuwa1.h u-boot-1.1.6/include/configs/fuwa1.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/fuwa1.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/fuwa1.h	2008-12-23 18:42:38.000000000 +0800
@@ -0,0 +1,207 @@
+/*
+ * (C) Copyright 2008  Ingenic Semiconductor
+ * 
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the fuwa board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4750D		1  /* Jz4750 SoC */
+#define CONFIG_FUWA1		1  /* fuwa1 validation board */
+#define CONFIG_FPGA		1  /* fuwa1 is an FPGA board */
+
+#define JZ4750_NORBOOT_CFG	JZ4750_NORBOOT_8BIT	/* NOR Boot config code */
+
+#define CFG_EXTAL		48000000	/* EXTAL freq: 12 MHz */
+#define CFG_CPU_SPEED		CFG_EXTAL	/* CPU clock */
+#define CFG_DIV                 1               /* hclk=pclk=mclk=CFG_EXTAL/CFG_DIV, just for FPGA board */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		9600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_NAND   | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS1,9600n8 ip=dhcp nfsroot=192.168.1.4:/nfsroot/root26 rw ethaddr=00:2a:c6:2c:ad:fc"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.4;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:2a:c6:2c:ad:fc    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"FUWA1 # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_NAND_BW8		1               /* Data bus width: 0-16bit, 1-8bit */
+#define CFG_NAND_PAGE_SIZE      2048
+#define CFG_NAND_ROW_CYCLE	3     
+#define CFG_NAND_BLOCK_SIZE	(256 << 10)	/* NAND chip block size		*/
+#define CFG_NAND_BADBLOCK_PAGE	127		/* NAND bad block was marked at this page in a block, starting from 0 */
+#define CFG_NAND_BCH_BIT        8               /* Specify the hardware BCH algorithm for 4750 (4|8) */
+#define CFG_NAND_ECC_POS        28              /* Ecc offset position in oob area, its default value is 3 if it isn't defined. */
+
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* Environment settings */
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x20000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#endif
+#define CFG_ENV_ADDR		0xa8040000
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1  /* SDRAM BANK Number: 1, 2*/
+
+//#define CONFIG_MOBILE_SDRAM		/* use mobile sdram */
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/fuwa.h u-boot-1.1.6/include/configs/fuwa.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/fuwa.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/fuwa.h	2008-12-18 19:41:56.000000000 +0800
@@ -0,0 +1,207 @@
+/*
+ * (C) Copyright 2008  Ingenic Semiconductor
+ * 
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the fuwa board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4750		1  /* Jz4750 SoC */
+#define CONFIG_FUWA		1  /* fuwa validation board */
+#define CONFIG_FPGA		1  /* fuwa is an FPGA board */
+
+#define JZ4750_NORBOOT_CFG	JZ4750_NORBOOT_8BIT	/* NOR Boot config code */
+
+#define CFG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+#define CFG_CPU_SPEED		CFG_EXTAL	/* CPU clock */
+#define CFG_DIV                 3               /* hclk=pclk=mclk=CFG_EXTAL/CFG_DIV, just for FPGA board */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART1_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		9600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_NAND   | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS1,9600n8 ip=dhcp nfsroot=192.168.1.20:/nfsroot/root26 rw ethaddr=00:2a:c6:2c:ad:fc"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:2a:c6:2c:ad:fc    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"FUWA # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_NAND_BW8		1               /* Data bus width: 0-16bit, 1-8bit */
+#define CFG_NAND_PAGE_SIZE      2048
+#define CFG_NAND_ROW_CYCLE	3     
+#define CFG_NAND_BLOCK_SIZE	(256 << 10)	/* NAND chip block size		*/
+#define CFG_NAND_BADBLOCK_PAGE	127		/* NAND bad block was marked at this page in a block, starting from 0 */
+#define CFG_NAND_BCH_BIT        8               /* Specify the hardware BCH algorithm for 4750 (4|8) */
+#define CFG_NAND_ECC_POS        28              /* Ecc offset position in oob area, its default value is 3 if it isn't defined. */
+
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* Environment settings */
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x20000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#endif
+#define CFG_ENV_ADDR		0xa8040000
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1  /* SDRAM BANK Number: 1, 2*/
+
+//#define CONFIG_MOBILE_SDRAM		/* use mobile sdram */
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/gps.h u-boot-1.1.6/include/configs/gps.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/gps.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/gps.h	2007-05-23 17:46:13.000000000 +0800
@@ -0,0 +1,140 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <seeger.chin@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the GPS board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_GPS		1  /* gps board */
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 3.6864 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=16M console=ttyS0,115200 ip=bootp nfsroot=192.168.1.20:/nfsroot/miniroot rw ethaddr=00:19:11:20:00:01"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:19:11:20:00:01    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"GPS # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Flash configuration
+ * (SST 39VF3201 16-bit Flash): 2KWord(4KB) * 1024 = 4MB
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max # of memory banks	*/
+#define CFG_MAX_FLASH_SECT	1024	/* max # of sectors on one chip	*/
+
+#define PHYS_FLASH_1		0xbfc00000   /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1 /* Flash at 0xbfc00000 - 0xbfffffff */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(180*1024)  /* Reserve 256 kB for Monitor */
+
+/* Environment settings */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	(20*1024) /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		12	/* Row address: 11 to 13 */
+#define SDRAM_COL		8	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		35	/* RAS# Active Time */
+#define SDRAM_RCD		15	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        ((64*1000000)/(1<<SDRAM_ROW))	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/iptv.h u-boot-1.1.6/include/configs/iptv.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/iptv.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/iptv.h	2007-06-12 17:21:39.000000000 +0800
@@ -0,0 +1,199 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the iptv board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ5730		1  /* Jz5730 Soc */
+#define CONFIG_IPTV		1  /* iptv board */
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 3.6864 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+                                 CFG_CMD_NAND   | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,115200n8 ip=bootp nfsroot=192.168.1.20:/nfsroot/miniroot rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:50:c2:1e:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"IPTV # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB4000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 4k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 4kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(128 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_NAND_BLOCK_SIZE	(16 << 10)	/* NAND chip block size		*/
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_U_BOOT_OFFS + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*-----------------------------------------------------------------------
+ * NOR Flash configuration
+ * (Intel Strataflash: 28F128J3A 128Mbit = 128K x 128)
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max # of memory banks	*/
+//#define CFG_FLASH_CFI		1	/* flash is CFI conformant	*/
+//#define CFG_FLASH_CFI_DRIVER	1	/* use common cfi driver	*/
+//#define CFG_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster) */
+#define CFG_MAX_FLASH_SECT	2048	/* max # of sectors on one chip	*/
+//#define PHYS_FLASH_SECT_SIZE	(128*1024)	/* Size of a sector (128kB) */
+
+#define PHYS_FLASH_1		0xbf800000   /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1 /* Flash at 0xbf000000 - 0xbfffffff */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ) /* Timeout for Flash Write */
+
+/* Environment settings */
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x10000
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#endif
+
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/jdi.h u-boot-1.1.6/include/configs/jdi.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/jdi.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/jdi.h	2007-06-27 11:25:43.000000000 +0800
@@ -0,0 +1,142 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the jdi board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_JDI		1  /* JDI board */
+
+#define CFG_CPU_SPEED		360000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 3.6864 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=32M console=ttyS0,115200n8 ip=bootp nfsroot=192.168.1.20:/nfsroot/jdi-root rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:52:c2:1b:c1:f2    /* Ethernet address */
+
+#define CONFIG_SILENT_CONSOLE	1	/* enable silent startup	*/
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"JDI # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Flash configuration
+ * (SST 39VF3201 16-bit Flash): 2KWord(4KB) * 1024 sectors = 4MB
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	1024	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xbfc00000   /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1 /* Flash at 0xbfc00000 - 0xbfffffff */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(128*1024)  /* Reserve 128 kB for Monitor */
+
+/* Environment settings */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	(64*1024) /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		1	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/kaifa.h u-boot-1.1.6/include/configs/kaifa.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/kaifa.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/kaifa.h	2007-05-23 17:46:13.000000000 +0800
@@ -0,0 +1,146 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the fcr board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_KAIFA		1  /* kaifa board */
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 3.6864 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=16M console=ttyS0,115200 ip=bootp nfsroot=192.168.1.20:/nfsroot/miniroot rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:50:c2:1e:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"UBOOT # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Flash configuration
+ * Spansion FLASH
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xbfc00000    /* Flash Bank #1 */
+#define PHYS_FLASH_SIZE		0x400000
+#define CFG_FLASH_BASE		PHYS_FLASH_1  /* Flash beginning from 0xbfc00000 */
+
+#define	CFG_MONITOR_BASE	CFG_FLASH_BASE
+#define	CFG_MONITOR_LEN		(192*1024)  /* Reserve 192 kB for Monitor */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ) /* Timeout for Flash Write */
+
+/* Environment settings */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		12	/* Row address: 11 to 13 */
+#define SDRAM_COL		8	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
+
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/leo.h u-boot-1.1.6/include/configs/leo.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/leo.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/leo.h	2007-12-10 19:53:32.000000000 +0800
@@ -0,0 +1,216 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the leo board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4740		1  /* Jz4740 SoC */
+#define CONFIG_LEO		1  /* LEO validation board */
+
+#define JZ4740_NORBOOT_CFG	JZ4740_NORBOOT_16BIT	/* NOR Boot config code */
+#define JZ4740_NANDBOOT_CFG	JZ4740_NANDBOOT_B8R3	/* NAND Boot config code */
+
+#define CFG_CPU_SPEED		384000000	/* CPU clock: 384 MHz */
+#define CFG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_MMC      	1
+#define CONFIG_FAT      	1    
+#define CONFIG_SUPPORT_VFAT 	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+                                 CFG_CMD_NAND   | \
+				 CFG_CMD_MMC    | \
+                                 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,57600n8 ip=off root=/dev/ram0 rw"
+#define CONFIG_BOOTCOMMAND	"bootm 0xa8100000"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+//#define CONFIG_NET_MULTI
+#define CONFIG_DRIVER_RTL8019   1
+#define	RTL8019_BASE		(0xac600000)
+
+#define CONFIG_ETHADDR		00:2a:cc:2a:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"LEO # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 4k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 4kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#define CFG_NAND_BLOCK_SIZE	(256 << 10)	/* NAND chip block size		*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	TEXT_BASE   /* in leo/config.mk TEXT_BASE=0x88000000*/ 
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+#ifdef CFG_ENV_IS_IN_FLASH
+#define	CFG_ENV_IS_NOWHERE	1
+#define CFG_ENV_ADDR		0xa8040000
+#define CFG_ENV_SIZE		0x20000
+#endif
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+/*-----------------------------------------------------------------------
+ * GPIO definition
+ */
+#define GPIO_SD_VCC_EN_N	119
+#define GPIO_SD_CD_N		120
+#define GPIO_SD_WP		111
+#define GPIO_DISP_OFF_N		100
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/lib4750.h u-boot-1.1.6/include/configs/lib4750.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/lib4750.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/lib4750.h	2008-11-21 17:16:20.000000000 +0800
@@ -0,0 +1,206 @@
+/*
+ * (C) Copyright 2008  Ingenic Semiconductor
+ * 
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the fuwa board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4750		1  /* Jz4750 SoC */
+#define CONFIG_LIB4750		1  /* lib4750 validation board */
+
+//#define JZ4750_NORBOOT_CFG	JZ4750_NORBOOT_8BIT	/* NOR Boot config code */
+#define JZ4750_NORBOOT_CFG	JZ4750_NORBOOT_16BIT	/* NOR Boot config code */
+
+#define CFG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+
+#define CFG_CPU_SPEED		336000000	/* CPU clock */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART1_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_NAND   | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS1,57600n8 ip=dhcp nfsroot=192.168.1.20:/nfsroot/root26 rw ethaddr=00:2a:c6:43:ad:00"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:2a:c6:2c:ab:f0    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"LIB4750 # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_NAND_BW8		1              /* Data bus width: 0-16bit, 1-8bit */
+#define CFG_NAND_PAGE_SIZE      2048
+#define CFG_NAND_ROW_CYCLE	3     
+#define CFG_NAND_BLOCK_SIZE	(256 << 10)	/* NAND chip block size		*/
+#define CFG_NAND_BADBLOCK_PAGE	127		/* NAND bad block was marked at this page in a block, starting from 0 */
+#define CFG_NAND_BCH_BIT        8               /* Specify the hardware BCH algorithm for 4750 (4|8) */
+
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(135)	/* max number of sectors on one chip: Spansion S29GL064N90 */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	0xa8000000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* Environment settings */
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#endif
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1  /* SDRAM BANK Number: 1, 2 */
+
+//#define CONFIG_MOBILE_SDRAM		/* use mobile sdram */
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/libra.h u-boot-1.1.6/include/configs/libra.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/libra.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/libra.h	2007-05-23 17:46:13.000000000 +0800
@@ -0,0 +1,155 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the libra board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_LIBRA		1  /* libra board */
+
+#define CONFIG_LCD                 /* LCD support */
+#define CONFIG_JZLCD_SAMSUNG_LTP400WQF01
+#define LCD_BPP			4  /* 4: 16bits per pixel */
+#define CFG_WHITE_ON_BLACK
+#define CONFIG_LCD_LOGO
+//#define CFG_LCD_LOGOONLY_NOINFO
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 3.6864 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,115200n8 ip=bootp nfsroot=192.168.1.20:/nfsroot/miniroot rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:50:c2:1e:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"LIBRA # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz4730 eth */
+
+/*-----------------------------------------------------------------------
+ * Flash configuration
+ * (Intel Strataflash: 28F128J3A 128Mbit = 128K x 128)
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max # of memory banks	*/
+#define CFG_FLASH_CFI		1	/* flash is CFI conformant	*/
+#define CFG_FLASH_CFI_DRIVER	1	/* use common cfi driver	*/
+#define CFG_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster) */
+#define CFG_MAX_FLASH_SECT	128	/* max # of sectors on one chip	*/
+#define PHYS_FLASH_SECT_SIZE	(128*1024)	/* Size of a sector (128kB) */
+
+#define PHYS_FLASH_1		0xbf000000   /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1 /* Flash at 0xbf000000 - 0xbfffffff */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ) /* Timeout for Flash Write */
+
+/* Environment settings */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	0x20000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/pavo.h u-boot-1.1.6/include/configs/pavo.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/pavo.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/pavo.h	2009-02-04 16:47:27.000000000 +0800
@@ -0,0 +1,240 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the pavo board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4740		1  /* Jz4740 SoC */
+#define CONFIG_PAVO		1  /* PAVO validation board */
+
+#define CONFIG_LCD                 /* LCD support */
+//#define CONFIG_SLCD                 /* LCD support */
+
+#ifndef CONFIG_SLCD                 /* LCD support */
+#define CONFIG_JZLCD_SAMSUNG_LTP400WQF02_18BIT
+#endif
+
+#ifdef CONFIG_SLCD
+#define CONFIG_JZ_SLCD_SPFD5408A
+#define SLCD_DMA_CHAN_ID	0  /* DMA Channel for Smart LCD */
+#endif
+
+#define LCD_BPP			5  /* 5: 18,24,32 bits per pixel */
+#define CFG_WHITE_ON_BLACK
+#define CONFIG_LCD_LOGO
+
+#define JZ4740_NORBOOT_CFG	JZ4740_NORBOOT_16BIT	/* NOR Boot config code */
+#define JZ4740_NANDBOOT_CFG	JZ4740_NANDBOOT_B8R3	/* NAND Boot config code */
+
+#define CFG_CPU_SPEED		336000000	/* CPU clock: 336 MHz */
+#define CFG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_MMC      	1
+#define CONFIG_FAT      	1    
+#define CONFIG_SUPPORT_VFAT 	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+                                 CFG_CMD_NAND   | \
+				 CFG_CMD_MMC    | \
+                                 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,57600n8 ip=off rootfstype=yaffs2 root=/dev/mtdblock2 rw"
+#define CONFIG_BOOTCOMMAND	"nand read 0x80600000 0x400000 0x300000;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+//#define CONFIG_NET_MULTI
+
+#define CONFIG_DRIVER_CS8900      1
+#define CS8900_BASE             (0xa8000000)
+#define CS8900_BUS16
+
+#define CONFIG_ETHADDR		00:2a:cc:2a:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"PAVO # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		896*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_NAND_PAGE_SIZE      2048
+#define CFG_NAND_BLOCK_SIZE	(256 << 10)	/* NAND chip block size		*/
+#define CFG_NAND_BADBLOCK_PAGE	127		/* NAND bad block was marked at this page in a block, starting from 0 */
+#define CFG_NAND_ECC_POS        6               /* Ecc offset position in oob area, its default value is 6 if it isn't defined. */
+
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	TEXT_BASE   /* in pavo/config.mk TEXT_BASE=0x88000000*/ 
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+#ifdef CFG_ENV_IS_IN_FLASH
+#define	CFG_ENV_IS_NOWHERE	1
+#define CFG_ENV_ADDR		0xa8040000
+#define CFG_ENV_SIZE		0x20000
+#endif
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+/*-----------------------------------------------------------------------
+ * GPIO definition
+ */
+#define GPIO_SD_VCC_EN_N	113 /* GPD17 */
+#define GPIO_SD_CD_N		110 /* GPD14 */
+#define GPIO_SD_WP		112 /* GPD16 */
+#define GPIO_USB_DETE		102 /* GPD6 */
+#define GPIO_DC_DETE_N		103 /* GPD7 */
+#define GPIO_CHARG_STAT_N	111 /* GPD15 */
+#define GPIO_DISP_OFF_N		118 /* GPD22 */
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/pmpv1.h u-boot-1.1.6/include/configs/pmpv1.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/pmpv1.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/pmpv1.h	2007-06-15 15:59:38.000000000 +0800
@@ -0,0 +1,219 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the pmp board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_PMPV1		1  /* PMP ver 1.x board */
+
+#define CONFIG_LCD                 /* LCD support */
+#define CONFIG_JZLCD_SAMSUNG_LTP400WQF01 /* LCD panel */
+#define LCD_BPP			4  /* 4: 16bits per pixel */
+#define CFG_WHITE_ON_BLACK
+#define CONFIG_LCD_LOGO
+//#define CFG_LCD_LOGOONLY_NOINFO
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 12 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART3_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_MMC      1
+#define CONFIG_FAT      1    
+#define CONFIG_SUPPORT_VFAT 1
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+                                 CFG_CMD_NAND   | \
+				 CFG_CMD_MMC    | \
+                                 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS3,115200n8 ip=dhcp nfsroot=192.168.1.20:/nfsroot/pmp-root rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:52:c2:2a:bd:f5    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"PMP # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz4730 eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB4000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 4k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 4kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(128 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#define CFG_NAND_BLOCK_SIZE	(128 << 10)	/* NAND chip block size		*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_U_BOOT_OFFS + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*-----------------------------------------------------------------------
+ * Flash configuration
+ * (SST 39VF6401 16-bit Flash): 2KWord(4KB) * 2048 sectors = 8MB
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	2048	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xbf800000   /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1 /* Flash at 0xbf800000 - 0xbfffffff */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#endif
+
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+/*-----------------------------------------------------------------------
+ * GPIO definition
+ */
+#define GPIO_PW_I		97
+#define GPIO_PW_O		66
+#define GPIO_LED_EN		92
+#define GPIO_DISP_OFF_N		93
+#define GPIO_RTC_IRQ		96
+#define GPIO_USB_CLK_EN		29
+#define GPIO_CHARG_STAT		125
+#define GPIO_SD_VCC_EN_N	91
+#define GPIO_SD_CD_N		90
+#define GPIO_SD_WP		82
+
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/pmpv2.h u-boot-1.1.6/include/configs/pmpv2.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/pmpv2.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/pmpv2.h	2007-06-15 15:59:38.000000000 +0800
@@ -0,0 +1,219 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the pmp ver 2.x board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_PMPV2		1  /* PMP ver 2.x board */
+
+#define CONFIG_LCD                 /* LCD support */
+#define CONFIG_JZLCD_SAMSUNG_LTP400WQF01 /* LCD panel */
+#define LCD_BPP			4  /* 4: 16bits per pixel */
+#define CFG_WHITE_ON_BLACK
+#define CONFIG_LCD_LOGO
+//#define CFG_LCD_LOGOONLY_NOINFO
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART3_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_MMC      1
+#define CONFIG_FAT      1    
+#define CONFIG_SUPPORT_VFAT 1
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+                                 CFG_CMD_NAND   | \
+				 CFG_CMD_MMC    | \
+                                 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS3,57600n8 ip=dhcp nfsroot=192.168.1.20:/nfsroot/pmp-root rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:52:c2:2a:bd:f5    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"PMP # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz4730 eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB4000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 4k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 4kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(128 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#define CFG_NAND_BLOCK_SIZE	(128 << 10)	/* NAND chip block size		*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_U_BOOT_OFFS + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*-----------------------------------------------------------------------
+ * NOR Flash configuration
+ * (SST 39VF6401 16-bit Flash): 2KWord(4KB) * 2048 sectors = 8MB
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	2048	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xbf800000   /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1 /* Flash at 0xbf800000 - 0xbfffffff */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#endif
+
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+
+/*-----------------------------------------------------------------------
+ * GPIO definition
+ */
+#define GPIO_PW_I		97
+#define GPIO_PW_O		66
+#define GPIO_LED_EN		92
+#define GPIO_DISP_OFF_N		93
+#define GPIO_RTC_IRQ		96
+#define GPIO_USB_CLK_EN		29
+#define GPIO_CHARG_STAT		125
+#define GPIO_SD_VCC_EN_N	91
+#define GPIO_SD_CD_N		90
+#define GPIO_SD_WP		82
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/slt_50.h u-boot-1.1.6/include/configs/slt_50.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/slt_50.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/slt_50.h	2008-12-10 21:31:08.000000000 +0800
@@ -0,0 +1,241 @@
+/*
+ * (C) Copyright 2008  Ingenic Semiconductor
+ * 
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the apus board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4750		1  /* Jz4750 SoC */
+#define CONFIG_APUS		1  /* APUS validation board */
+
+#define CONFIG_SLT50		1  /* APUS validation board */
+#define CFG_CHIP_COUNT		1
+#define CFG_EEPROM_AT24C16A 	1
+
+#define JZ4750_NORBOOT_CFG	JZ4750_NORBOOT_16BIT	/* NOR Boot config code */
+
+#define CFG_EXTAL		24000000        /* EXTAL freq: 24 MHz */
+
+#define CFG_CPU_SPEED		300000000	/* CPU clock */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART1_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_NAND   | \
+				 CFG_CMD_MSC	| \
+                                 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING)
+
+#define CONFIG_BOOTP_MASK	CONFIG_BOOTP_DEFAUL
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS1,57600n8 ip=off root=/dev/mtdblock2 rw"
+#define CONFIG_BOOTCOMMAND	"nand read 0x80600000 0x400000 0x200000;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:2a:c6:2c:ab:f0    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"SLT_50 # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL) && !defined(CONFIG_MSC_SPL) && !defined(CONFIG_MSC_U_BOOT)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#elif defined(CONFIG_MSC_U_BOOT)
+#define CFG_ENV_IS_IN_MSC	1	/* use MSC for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_NAND_BW8		1              /* Data bus width: 0-16bit, 1-8bit */
+#define CFG_NAND_PAGE_SIZE      2048
+#define CFG_NAND_ROW_CYCLE	3     
+#define CFG_NAND_BLOCK_SIZE	(256 << 10)	/* NAND chip block size		*/
+#define CFG_NAND_BADBLOCK_PAGE	127		/* NAND bad block was marked at this page in a block, starting from 0 */
+#define CFG_NAND_BCH_BIT        8               /* Specify the hardware BCH algorithm for 4750 (4|8) */
+
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from MSC (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (MSUB) from MSC and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the MSC controller so that the special U-Boot image can be
+ * loaded from MSC to SDRAM.
+ *
+ * MSUB (MMC/SD U-Boot)
+ * This MSC U-Boot (MSUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_MSC_U_BOOT_DST	0x80100000	/* Load MSUB to this addr	 */
+#define CFG_MSC_U_BOOT_START	CFG_MSC_U_BOOT_DST /* Start MSUB from this addr */
+
+/*
+ * Define the partitioning of the MMC/SD card (only RAM U-Boot is needed here)
+ */
+#define CFG_MSC_U_BOOT_OFFS	(16 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_MSC_U_BOOT_SIZE	(256 << 10)	/* Size of RAM U-Boot image	*/
+
+#define CFG_MSC_BLOCK_SIZE	512 
+
+#ifdef CFG_ENV_IS_IN_MSC
+#define CFG_ENV_SIZE		CFG_MSC_BLOCK_SIZE
+#define CFG_ENV_OFFSET		((CFG_MSC_BLOCK_SIZE * 16) + CFG_MSC_U_BOOT_SIZE + (CFG_MSC_BLOCK_SIZE * 16))	/* environment starts here  */
+#endif
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(135)	/* max number of sectors on one chip: Spansion S29GL064N90 */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	0xa8000000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* Environment settings */
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#endif
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1  /* SDRAM BANK Number: 1, 2 */
+
+//#define CONFIG_MOBILE_SDRAM		/* use mobile sdram */
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/slt.h u-boot-1.1.6/include/configs/slt.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/slt.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/slt.h	2007-09-14 17:21:23.000000000 +0800
@@ -0,0 +1,222 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * slt: System Level Test
+ * This file contains the configuration parameters for the Jz4730 chip-sorting board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_SLT		1  /* SLT board, Jz4730 Chip-sorting */
+
+#define CFG_BOOT_FROM_NFSROOT   1
+
+#define CFG_CHIP_COUNT 		1
+//#define CFG_EEPROM_AT24C02A 	1
+#define CFG_EEPROM_AT24C16A 	1
+
+#define CFG_CPU_SPEED		100000000	/* CPU bootup speed */
+
+#define CFG_EXTAL		3686400	/* EXTAL freq: 12 MHz */
+//#define CFG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+//#define CONFIG_BAUDRATE		57600
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_FAT      1    
+#define CONFIG_SUPPORT_VFAT 1
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+                                 CFG_CMD_NAND   | \
+                                 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+
+#if  CFG_BOOT_FROM_NFSROOT
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,115200n8 ip=dhcp nfsroot=192.168.1.20:/nfsroot/pmp-root rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+
+#else
+
+#define CONFIG_BOOTDELAY	0
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,115200n8 ip=off fstype=yaffs2 root=/dev/mtdblock0 rw"
+#define CONFIG_BOOTCOMMAND	"nand read 0x80600000 0x100000 0x100000;bootm"
+
+#endif
+
+
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:52:c2:2a:bd:f5    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"SLT # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz4730 eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB4000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 4k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 4kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(128 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#define CFG_NAND_BLOCK_SIZE	(128 << 10)	/* NAND chip block size		*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_U_BOOT_OFFS + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+/*-----------------------------------------------------------------------
+ * NOR Flash configuration
+ * (SST 39VF6401 16-bit Flash): 2KWord(4KB) * 2048 sectors = 8MB
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	2048	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xbf800000   /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1 /* Flash at 0xbf800000 - 0xbfffffff */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#ifdef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SECT_SIZE	0x10000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#endif
+
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+
+/*-----------------------------------------------------------------------
+ * GPIO definition
+ */
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/taurus.h u-boot-1.1.6/include/configs/taurus.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/taurus.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/taurus.h	2007-05-23 17:46:13.000000000 +0800
@@ -0,0 +1,149 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the taurus board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ5730		1  /* Jz5730 Soc */
+#define CONFIG_TAURUS		1  /* taurus board */
+
+#define CFG_CPU_SPEED		336000000	/* CPU speed */
+
+#define CFG_EXTAL		3686400		/* EXTAL freq: 3.6864 MHz */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,115200n8 ip=bootp nfsroot=192.168.1.20:/nfsroot/miniroot rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:50:c2:1e:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"TAURUS # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Flash configuration
+ * (Intel Strataflash: 28F128J3A 128Mbit = 128K x 128)
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max # of memory banks	*/
+#define CFG_FLASH_CFI		1	/* flash is CFI conformant	*/
+#define CFG_FLASH_CFI_DRIVER	1	/* use common cfi driver	*/
+#define CFG_FLASH_USE_BUFFER_WRITE 1	/* use buffered writes (20x faster) */
+#define CFG_MAX_FLASH_SECT	128	/* max # of sectors on one chip	*/
+#define PHYS_FLASH_SECT_SIZE	(128*1024)	/* Size of a sector (128kB) */
+
+#define PHYS_FLASH_1		0xbf000000   /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1 /* Flash at 0xbf000000 - 0xbfffffff */
+
+#define	CFG_MONITOR_BASE	0xbfc00000
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(20*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(20*CFG_HZ) /* Timeout for Flash Write */
+
+/* Environment settings */
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_SECT_SIZE	0x20000 /* Total Size of Environment Sector */
+#define CFG_ENV_SIZE		CFG_ENV_SECT_SIZE
+#define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN) /* Environment after Monitor */
+
+#define CFG_DIRECT_FLASH_TFTP	1	/* allow direct tftp to flash */
+#define CONFIG_ENV_OVERWRITE	1	/* allow overwrite MAC address */
+
+/*
+ *  SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 8192 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/uranus.h u-boot-1.1.6/include/configs/uranus.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/uranus.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/uranus.h	2007-05-23 17:46:13.000000000 +0800
@@ -0,0 +1,141 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the uranus board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4730		1  /* Jz4730 SoC */
+#define CONFIG_URANUS		1  /* uranus validation board */
+#define CONFIG_FPGA		1  /* uranus is a FPGA board */
+
+#define CFG_EXTAL		8000000		/* EXTAL freq: 8 MHz */
+#define CFG_CPU_SPEED		CFG_EXTAL	/* CPU speed */
+#define	CFG_HZ			(CFG_CPU_SPEED/(3*256)) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+#define CONFIG_BAUDRATE		9600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		((CONFIG_CMD_DFL | CFG_CMD_DHCP) & ~(CFG_CMD_ENV))
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=64M console=ttyS0,9600n8 ip=bootp nfsroot=192.168.1.20:/nfsroot/miniroot rw"
+#define CONFIG_BOOTCOMMAND	"bootp;setenv serverip 192.168.1.20;tftp;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHADDR		00:50:c2:1e:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"URANUS # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xbfc00000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	TEXT_BASE
+#define	CFG_MONITOR_LEN		(192 << 10)
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+#define	CFG_ENV_IS_NOWHERE	1
+
+/* Address and size of Primary Environment Sector	*/
+#define CFG_ENV_ADDR		0xBFC40000
+#define CFG_ENV_SIZE		0x20000
+
+/*
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		0	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/configs/virgo.h u-boot-1.1.6/include/configs/virgo.h
--- /develop/source/01boot/u-boot-1.1.6/include/configs/virgo.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/include/configs/virgo.h	2007-11-28 09:21:20.000000000 +0800
@@ -0,0 +1,232 @@
+/*
+ * (C) Copyright 2006
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the virgo board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MIPS32		1  /* MIPS32 CPU core */
+#define CONFIG_JzRISC		1  /* JzRISC core */
+#define CONFIG_JZSOC		1  /* Jz SoC */
+#define CONFIG_JZ4720		1  /* Jz4720 SoC */
+#define CONFIG_JZ4740		1  /* Jz4740 SoC */
+#define CONFIG_VIRGO		1  /* virgo validation board */
+
+#define CONFIG_LCD                 /* LCD support */
+#define CONFIG_JZLCD_SAMSUNG_LTP400WQF02_18BIT
+#define LCD_BPP			5  /* 5: 18,24,32 bits per pixel */
+#define CFG_WHITE_ON_BLACK
+#define CONFIG_LCD_LOGO
+
+#define JZ4740_NORBOOT_CFG	JZ4740_NORBOOT_16BIT	/* NOR Boot config code */
+#define JZ4740_NANDBOOT_CFG	JZ4740_NANDBOOT_B8R3	/* NAND Boot config code */
+
+#define CFG_CPU_SPEED		336000000	/* CPU clock: 336 MHz */
+//#define CFG_CPU_SPEED		144000000	/* CPU clock: 336 MHz */
+#define CFG_EXTAL		12000000	/* EXTAL freq: 12 MHz */
+#define	CFG_HZ			(CFG_EXTAL/256) /* incrementer freq */
+
+#define CFG_UART_BASE  		UART0_BASE	/* Base of the UART channel */
+
+#define CONFIG_BAUDRATE		57600
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_MMC      	1
+#define CONFIG_FAT      	1    
+#define CONFIG_SUPPORT_VFAT 	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | \
+				 CFG_CMD_ASKENV | \
+                                 CFG_CMD_NAND   | \
+				 CFG_CMD_MMC    | \
+                                 CFG_CMD_FAT    | \
+				 CFG_CMD_DHCP	| \
+				 CFG_CMD_PING   )
+
+#define CONFIG_BOOTP_MASK	( CONFIG_BOOTP_DEFAUL )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	1
+#define CONFIG_BOOTFILE	        "uImage"	/* file to load */
+#define CONFIG_BOOTARGS		"mem=32M console=ttyS0,57600n8 ip=off root=/dev/mtdblock2 rw"
+#define CONFIG_BOOTCOMMAND	"nand read 0x80600000 0x400000 0x300000;bootm"
+#define CFG_AUTOLOAD		"n"		/* No autoload */
+
+//#define CONFIG_NET_MULTI
+
+#define CONFIG_DRIVER_CS8900      1
+#define CS8900_BASE             (0xa8000000)
+#define CS8900_BUS16
+
+#define CONFIG_ETHADDR		00:2a:cc:2a:af:fe    /* Ethernet address */
+
+/*
+ * Serial download configuration
+ *
+ */
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download	*/
+#define CFG_LOADS_BAUD_CHANGE	1	/* allow baudrate change	*/
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory      */
+#define	CFG_PROMPT		"VIRGO # "	/* Monitor Command Prompt    */
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size   */
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)  /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args*/
+
+#define CFG_MALLOC_LEN		128*1024
+#define CFG_BOOTPARAMS_LEN	128*1024
+
+#define CFG_SDRAM_BASE		0x80000000     /* Cached addr */
+
+#define CFG_INIT_SP_OFFSET	0x400000
+
+#define	CFG_LOAD_ADDR		0x80600000     /* default load address	*/
+
+#define CFG_MEMTEST_START	0x80100000
+#define CFG_MEMTEST_END		0x80800000
+
+#define CFG_RX_ETH_BUFFER	16	/* use 16 rx buffers on jz47xx eth */
+
+/*-----------------------------------------------------------------------
+ * Environment
+ *----------------------------------------------------------------------*/
+#if !defined(CONFIG_NAND_U_BOOT) && !defined(CONFIG_NAND_SPL)
+#define CFG_ENV_IS_IN_FLASH     1	/* use FLASH for environment vars	*/
+#else
+#define CFG_ENV_IS_IN_NAND	1	/* use NAND for environment vars	*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH configuration
+ */
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+#define CFG_NAND_BASE           0xB8000000
+#define CFG_NAND_SELECT_DEVICE  1       /* nand driver supports mutipl. chips   */
+
+/*
+ * IPL (Initial Program Loader, integrated inside CPU)
+ * Will load first 8k from NAND (SPL) into cache and execute it from there.
+ *
+ * SPL (Secondary Program Loader)
+ * Will load special U-Boot version (NUB) from NAND and execute it. This SPL
+ * has to fit into 8kByte. It sets up the CPU and configures the SDRAM
+ * controller and the NAND controller so that the special U-Boot image can be
+ * loaded from NAND to SDRAM.
+ *
+ * NUB (NAND U-Boot)
+ * This NAND U-Boot (NUB) is a special U-Boot version which can be started
+ * from RAM. Therefore it mustn't (re-)configure the SDRAM controller.
+ *
+ */
+#define CFG_NAND_U_BOOT_DST	0x80100000	/* Load NUB to this addr	*/
+#define CFG_NAND_U_BOOT_START	CFG_NAND_U_BOOT_DST /* Start NUB from this addr	*/
+
+/*
+ * Define the partitioning of the NAND chip (only RAM U-Boot is needed here)
+ */
+#define CFG_NAND_U_BOOT_OFFS	(256 << 10)	/* Offset to RAM U-Boot image	*/
+#define CFG_NAND_U_BOOT_SIZE	(512 << 10)	/* Size of RAM U-Boot image	*/
+
+#define CFG_NAND_BLOCK_SIZE	(256 << 10)	/* NAND chip block size		*/
+
+#ifdef CFG_ENV_IS_IN_NAND
+#define CFG_ENV_SIZE		CFG_NAND_BLOCK_SIZE
+#define CFG_ENV_OFFSET		(CFG_NAND_BLOCK_SIZE + CFG_NAND_U_BOOT_SIZE + CFG_NAND_BLOCK_SIZE)	/* environment starts here  */
+#define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET + CFG_ENV_SIZE)
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	(128)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xa8000000 /* Flash Bank #1 */
+
+/* The following #defines are needed to get flash environment right */
+#define	CFG_MONITOR_BASE	TEXT_BASE   /* in virgo/config.mk TEXT_BASE=0x88000000*/ 
+#define	CFG_MONITOR_LEN		(256*1024)  /* Reserve 256 kB for Monitor */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(2 * CFG_HZ) /* Timeout for Flash Write */
+
+#ifdef CFG_ENV_IS_IN_FLASH
+#define	CFG_ENV_IS_NOWHERE	1
+#define CFG_ENV_ADDR		0xa8040000
+#define CFG_ENV_SIZE		0x20000
+#endif
+
+/*-----------------------------------------------------------------------
+ * SDRAM Info.
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+
+// SDRAM paramters
+#define SDRAM_BW16		1	/* Data bus width: 0-32bit, 1-16bit */
+#define SDRAM_BANK4		1	/* Banks each chip: 0-2bank, 1-4bank */
+#define SDRAM_ROW		13	/* Row address: 11 to 13 */
+#define SDRAM_COL		9	/* Column address: 8 to 12 */
+#define SDRAM_CASL		2	/* CAS latency: 2 or 3 */
+
+// SDRAM Timings, unit: ns
+#define SDRAM_TRAS		45	/* RAS# Active Time */
+#define SDRAM_RCD		20	/* RAS# to CAS# Delay */
+#define SDRAM_TPC		20	/* RAS# Precharge Time */
+#define SDRAM_TRWL		7	/* Write Latency Time */
+#define SDRAM_TREF	        7812	/* Refresh period: 4096 refresh cycles/64ms */
+//#define SDRAM_TREF	        15625	/* Refresh period: 4096 refresh cycles/64ms */
+
+/*-----------------------------------------------------------------------
+ * Cache Configuration
+ */
+#define CFG_DCACHE_SIZE		16384
+#define CFG_ICACHE_SIZE		16384
+#define CFG_CACHELINE_SIZE	32
+
+/*-----------------------------------------------------------------------
+ * GPIO definition
+ */
+
+#define GPIO_SD_VCC_EN_N	115 /* GPD19 */	
+#define GPIO_SD_CD_N		116 /* GPD20 */
+
+#define GPIO_USB_DETE		114 /* GPD18 */
+#define GPIO_DC_DETE_N		120 /* GPD24 */
+
+#define GPIO_DISP_OFF_N		118 /* GPD22 */
+//#define GPIO_CHARG_STAT_N	121 /* GPD25 */
+//#define GPIO_SD_WP	        110 /* GPD17 */
+#endif	/* __CONFIG_H */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/environment.h u-boot-1.1.6/include/environment.h
--- /develop/source/01boot/u-boot-1.1.6/include/environment.h	2007-10-31 00:43:20.000000000 +0800
+++ u-boot-1.1.6/include/environment.h	2008-10-30 21:55:16.000000000 +0800
@@ -85,6 +85,21 @@
 # endif
 #endif /* CFG_ENV_IS_IN_NAND */
 
+#if defined(CFG_ENV_IS_IN_MSC)
+# ifndef CFG_ENV_OFFSET
+#  error "Need to define CFG_ENV_OFFSET when using CFG_ENV_IS_IN_MSC"
+# endif
+# ifndef CFG_ENV_SIZE
+#  error "Need to define CFG_ENV_SIZE when using CFG_ENV_IS_IN_MSC"
+# endif
+# ifdef CFG_ENV_OFFSET_REDUND
+#  define CFG_REDUNDAND_ENVIRONMENT
+# endif
+# if defined(CONFIG_MSC_U_BOOT)
+/* Use embedded environment in MSC boot versions */
+# define ENV_IS_EMBEDDED	1
+# endif
+#endif /* CFG_ENV_IS_IN_MSC */
 
 #ifdef CFG_REDUNDAND_ENVIRONMENT
 # define ENV_HEADER_SIZE	(sizeof(unsigned long) + 1)
@@ -92,7 +107,6 @@
 # define ENV_HEADER_SIZE	(sizeof(unsigned long))
 #endif
 
-
 #define ENV_SIZE (CFG_ENV_SIZE - ENV_HEADER_SIZE)
 
 typedef	struct environment_s {
diff -urN /develop/source/01boot/u-boot-1.1.6/include/lcd.h u-boot-1.1.6/include/lcd.h
--- /develop/source/01boot/u-boot-1.1.6/include/lcd.h	2007-10-31 00:43:09.000000000 +0800
+++ u-boot-1.1.6/include/lcd.h	2009-02-03 21:05:16.000000000 +0800
@@ -155,7 +155,59 @@
 
 	u_char	vl_bpix;	/* Bits per pixel, 0 = 1 */
 } vidinfo_t;
-#endif /* CONFIG_MPC823, CONFIG_PXA250 or CONFIG_MCC200 */
+#elif defined(CONFIG_JZSOC)
+
+#ifdef CONFIG_SLCD
+/*
+ * Descriptor structure for JZ4740 DMA engine
+ * Note: this structure must always be aligned to a 16-bytes boundary.
+ */
+struct jz_fb_dma_descriptor {
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+	volatile u32 dsadr;	/* DSAR value for the current transfer */
+	volatile u32 dtadr;	/* DTAR value for the current transfer */
+	volatile u32 ddadr;	/* Points to the next descriptor + transfer count */
+};
+
+#else
+/*
+ * LCD controller stucture for JZSOC: JZ4730 JZ4740
+ */
+struct jz_fb_dma_descriptor {
+	u_long	fdadr;		/* Frame descriptor address register */
+	u_long	fsadr;		/* Frame source address register */
+	u_long	fidr;		/* Frame ID register */
+	u_long	ldcmd;		/* Command register */
+};
+#endif
+
+/*
+ * Jz LCD info
+ */
+struct jz_fb_info {
+
+	u_long	fdadr0;	/* physical address of frame/palette descriptor */
+	u_long	fdadr1;	/* physical address of frame descriptor */
+
+	/* DMA descriptors */
+	struct	jz_fb_dma_descriptor *	dmadesc_fblow;
+	struct	jz_fb_dma_descriptor *	dmadesc_fbhigh;
+	struct	jz_fb_dma_descriptor *	dmadesc_palette;
+
+	u_long	screen;		/* address of frame buffer */
+	u_long	palette;	/* address of palette memory */
+	u_int	palette_size;
+};
+typedef struct vidinfo {
+	ushort	vl_col;		/* Number of columns (i.e. 640) */
+	ushort	vl_row;		/* Number of rows (i.e. 480) */
+	u_char	vl_bpix;	/* Bits per pixel, 0 = 1, 1 = 2, 2 = 4, 3 = 8 */
+
+	struct jz_fb_info jz_fb;
+} vidinfo_t;
+
+extern vidinfo_t panel_info;
+#endif /* CONFIG_MPC823, CONFIG_PXA250, CONFIG_MCC200 or CONFIG_JZ4730 */
 
 /* Video functions */
 
@@ -191,6 +243,10 @@
 #define LCD_COLOR4	2
 #define LCD_COLOR8	3
 #define LCD_COLOR16	4
+#define LCD_COLOR32	5
+
+#define LCD_COLOR18	LCD_COLOR32
+#define LCD_COLOR24	LCD_COLOR32
 
 /*----------------------------------------------------------------------*/
 #if defined(CONFIG_LCD_INFO_BELOW_LOGO)
@@ -242,14 +298,21 @@
 # define CONSOLE_COLOR_GREY	14
 # define CONSOLE_COLOR_WHITE	15	/* Must remain last / highest	*/
 
-#else
-
+#elif LCD_BPP == LCD_COLOR16
 /*
  * 16bpp color definitions
  */
 # define CONSOLE_COLOR_BLACK	0x0000
 # define CONSOLE_COLOR_WHITE	0xffff	/* Must remain last / highest	*/
 
+#elif LCD_BPP == LCD_COLOR32
+/*
+ * 18bpp color definitions
+ */
+# define CONSOLE_COLOR_BLACK	0x00000000
+# define CONSOLE_COLOR_WHITE	0xffffffff	/* Must remain last / highest	*/
+#else
+
 #endif /* color definitions */
 
 /************************************************************************/
@@ -281,6 +344,10 @@
 				 (c) << 4 | (c) << 5 | (c) << 6 | (c) << 7)
 #elif LCD_BPP == LCD_COLOR8
 # define COLOR_MASK(c)		(c)
+#elif LCD_BPP == LCD_COLOR16
+# define COLOR_MASK(c)		(c)
+#elif LCD_BPP == LCD_COLOR32
+# define COLOR_MASK(c)		(c)
 #else
 # error Unsupported LCD BPP.
 #endif
diff -urN /develop/source/01boot/u-boot-1.1.6/include/linux/mtd/mtd-abi.h u-boot-1.1.6/include/linux/mtd/mtd-abi.h
--- /develop/source/01boot/u-boot-1.1.6/include/linux/mtd/mtd-abi.h	2007-10-31 00:43:18.000000000 +0800
+++ u-boot-1.1.6/include/linux/mtd/mtd-abi.h	2008-12-23 01:54:24.000000000 +0800
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd-abi.h,v 1.7 2004/11/23 15:37:32 gleixner Exp $
+ * $Id: mtd-abi.h,v 1.2 2008-07-09 05:17:37 lhhuang Exp $
  *
  * Portions of MTD ABI definition which are shared by kernel and user space
  */
@@ -89,11 +89,20 @@
 #define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
 #define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
 
+#if !defined(CONFIG_JZ4750) && !defined(CONFIG_JZ4750D)
 struct nand_oobinfo {
 	uint32_t useecc;
 	uint32_t eccbytes;
 	uint32_t oobfree[8][2];
-	uint32_t eccpos[32];
+	uint32_t eccpos[72];
 };
+#else
+struct nand_oobinfo {
+	uint32_t useecc;
+	uint32_t eccbytes;
+	uint32_t oobfree[8][2];
+	uint32_t eccpos[104];
+};
+#endif
 
 #endif /* __MTD_ABI_H__ */
diff -urN /develop/source/01boot/u-boot-1.1.6/include/linux/mtd/nand.h u-boot-1.1.6/include/linux/mtd/nand.h
--- /develop/source/01boot/u-boot-1.1.6/include/linux/mtd/nand.h	2007-10-31 00:43:18.000000000 +0800
+++ u-boot-1.1.6/include/linux/mtd/nand.h	2008-12-11 22:41:49.000000000 +0800
@@ -5,7 +5,7 @@
  *		       Steven J. Hill <sjhill@realitydiluted.com>
  *		       Thomas Gleixner <tglx@linutronix.de>
  *
- * $Id: nand.h,v 1.68 2004/11/12 10:40:37 gleixner Exp $
+ * $Id: nand.h,v 1.2 2008-07-09 04:50:27 lhhuang Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -135,6 +135,12 @@
 #define NAND_ECC_HW8_512	6
 /* Hardware ECC 12 byte ECC per 2048 Byte data */
 #define NAND_ECC_HW12_2048	7
+/* Hardware ECC 9 byte ECC per 512 Byte data */
+#define NAND_ECC_HW9_512	8
+/* Hardware ECC 7 byte ECC per 512 Byte data(4-bit BCH) */
+#define NAND_ECC_HW7_512	9
+/* Hardware ECC 13 byte ECC per 512 Byte data(8-bit BCH) */
+#define NAND_ECC_HW13_512	10
 
 /*
  * Constants for Hardware ECC
@@ -348,6 +354,9 @@
 #define NAND_MFR_NATIONAL	0x8f
 #define NAND_MFR_RENESAS	0x07
 #define NAND_MFR_STMICRO	0x20
+#define NAND_MFR_HYNIX     	0xad
+#define NAND_MFR_MICRON		0x2c
+#define NAND_MFR_AMD		0x01
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
diff -urN /develop/source/01boot/u-boot-1.1.6/include/mmc.h u-boot-1.1.6/include/mmc.h
--- /develop/source/01boot/u-boot-1.1.6/include/mmc.h	2007-10-31 00:43:10.000000000 +0800
+++ u-boot-1.1.6/include/mmc.h	2007-05-23 10:05:57.000000000 +0800
@@ -23,7 +23,13 @@
 
 #ifndef _MMC_H_
 #define _MMC_H_
-#include <asm/arch/mmc.h>
+
+#ifdef CONFIG_JZ4730
+#include <asm-mips/jz4730.h>
+#endif
+#ifdef CONFIG_JZ4740
+#include <asm-mips/jz4740.h>
+#endif
 
 int mmc_init(int verbose);
 int mmc_read(ulong src, uchar *dst, int size);
diff -urN /develop/source/01boot/u-boot-1.1.6/lib_mips/board.c u-boot-1.1.6/lib_mips/board.c
--- /develop/source/01boot/u-boot-1.1.6/lib_mips/board.c	2007-10-31 00:43:58.000000000 +0800
+++ u-boot-1.1.6/lib_mips/board.c	2007-05-23 10:17:44.000000000 +0800
@@ -41,6 +41,14 @@
 
 #undef DEBUG
 
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+extern void nand_init (void);
+#endif
+
+#if defined(CONFIG_JZSOC)
+extern int jz_board_init(void);
+#endif
+
 extern int timer_init(void);
 
 extern int incaip_set_cpuclk(void);
@@ -68,7 +76,7 @@
  */
 static void mem_malloc_init (void)
 {
-	ulong dest_addr = CFG_MONITOR_BASE + gd->reloc_off;
+	ulong dest_addr = TEXT_BASE + gd->reloc_off;
 
 	mem_malloc_end = dest_addr;
 	mem_malloc_start = dest_addr - TOTAL_MALLOC_LEN;
@@ -159,6 +167,9 @@
 typedef int (init_fnc_t) (void);
 
 init_fnc_t *init_sequence[] = {
+#if defined(CONFIG_JZSOC)
+	jz_board_init,		/* init gpio/clocks/dram etc. */
+#endif
 	timer_init,
 	env_init,		/* initialize environment */
 #ifdef CONFIG_INCA_IP
@@ -179,7 +190,7 @@
 	gd_t gd_data, *id;
 	bd_t *bd;
 	init_fnc_t **init_fnc_ptr;
-	ulong addr, addr_sp, len = (ulong)&uboot_end - CFG_MONITOR_BASE;
+	ulong addr, addr_sp, len = (ulong)&uboot_end - TEXT_BASE;
 	ulong *s;
 #ifdef CONFIG_PURPLE
 	void copy_code (ulong);
@@ -213,6 +224,12 @@
 	addr &= ~(4096 - 1);
 	debug ("Top of RAM usable for U-Boot at: %08lx\n", addr);
 
+#ifdef CONFIG_LCD
+	/* reserve memory for LCD display (always full pages) */
+	addr = lcd_setmem (addr);
+	gd->fb_base = addr;
+#endif /* CONFIG_LCD */
+
 	/* Reserve memory for U-Boot code, data & bss
 	 * round down to next 16 kB limit
 	 */
@@ -310,7 +327,7 @@
 
 	debug ("Now running in RAM - U-Boot at: %08lx\n", dest_addr);
 
-	gd->reloc_off = dest_addr - CFG_MONITOR_BASE;
+	gd->reloc_off = dest_addr - TEXT_BASE;
 
 	monitor_flash_len = (ulong)&uboot_end_data - dest_addr;
 
@@ -364,6 +381,11 @@
 	mem_malloc_init();
 	malloc_bin_reloc();
 
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+	puts ("NAND:");
+	nand_init();		/* go init the NAND */
+#endif
+
 	/* relocate environment function pointers etc. */
 	env_relocate();
 
diff -urN /develop/source/01boot/u-boot-1.1.6/lib_mips/mips_linux.c u-boot-1.1.6/lib_mips/mips_linux.c
--- /develop/source/01boot/u-boot-1.1.6/lib_mips/mips_linux.c	2007-10-31 00:43:58.000000000 +0800
+++ u-boot-1.1.6/lib_mips/mips_linux.c	2007-03-01 16:58:38.000000000 +0800
@@ -40,6 +40,10 @@
 # define SHOW_BOOT_PROGRESS(arg)
 #endif
 
+#ifdef CONFIG_JzRISC
+extern void flush_cache_all(void);
+#endif
+
 extern image_header_t header;           /* from cmd_bootm.c */
 
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
@@ -213,6 +217,11 @@
 	/* we assume that the kernel is in place */
 	printf ("\nStarting kernel ...\n\n");
 
+#ifdef CONFIG_JzRISC
+	/* flush both i&d caches before calling into linux */
+	flush_cache_all();
+#endif
+
 	theKernel (linux_argc, linux_argv, linux_env, 0);
 }
 
diff -urN /develop/source/01boot/u-boot-1.1.6/lib_mips/time.c u-boot-1.1.6/lib_mips/time.c
--- /develop/source/01boot/u-boot-1.1.6/lib_mips/time.c	2007-10-31 00:43:58.000000000 +0800
+++ u-boot-1.1.6/lib_mips/time.c	2007-03-01 16:58:38.000000000 +0800
@@ -23,6 +23,7 @@
 
 #include <common.h>
 
+#ifndef CONFIG_JzRISC
 
 static inline void mips_compare_set(u32 v)
 {
@@ -97,3 +98,5 @@
 {
 	return CFG_HZ;
 }
+
+#endif /* !CONFIG_JzRISC */
diff -urN /develop/source/01boot/u-boot-1.1.6/MAKEALL u-boot-1.1.6/MAKEALL
--- /develop/source/01boot/u-boot-1.1.6/MAKEALL	2007-10-31 00:43:24.000000000 +0800
+++ u-boot-1.1.6/MAKEALL	2008-12-10 19:43:54.000000000 +0800
@@ -254,7 +254,17 @@
 
 LIST_au1xx0_el="dbau1550_el"
 
-LIST_mips_el="${LIST_mips4kc_el} ${LIST_mips5kc_el} ${LIST_au1xx0_el}"
+LIST_jz_el="	\
+	uranus		emurus		libra		fcr		\
+	fprint		jdi		pmpv1		pmpv2		\
+	pmpv1_nand	pmpv2_nand	taurus		iptv		\
+	leo		leo_nand	pavo		pavo_nand	\
+	virgo		virgo_nand	dipper		dipper_nand	\
+	fuwa		fuwa_nand	lib4750				\
+	apus		apus_nand	apus_msc       slt_50
+"
+
+LIST_mips_el="${LIST_mips4kc_el} ${LIST_mips5kc_el} ${LIST_au1xx0_el} ${LIST_jz_el}"
 
 #########################################################################
 ## i386 Systems
diff -urN /develop/source/01boot/u-boot-1.1.6/Makefile u-boot-1.1.6/Makefile
--- /develop/source/01boot/u-boot-1.1.6/Makefile	2007-10-31 00:43:22.000000000 +0800
+++ u-boot-1.1.6/Makefile	2008-12-23 01:54:24.000000000 +0800
@@ -7,7 +7,7 @@
 #
 # This program is free software; you can redistribute it and/or
 # modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundatio; either version 2 of
+# published by the Free Software Foundation; either version 2 of
 # the License, or (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
@@ -135,7 +135,7 @@
 endif
 endif
 ifeq ($(ARCH),mips)
-CROSS_COMPILE = mips_4KC-
+CROSS_COMPILE = mipsel-linux-
 endif
 ifeq ($(ARCH),nios)
 CROSS_COMPILE = nios-elf-
@@ -226,9 +226,16 @@
 .PHONY : $(SUBDIRS)
 
 ifeq ($(CONFIG_NAND_U_BOOT),y)
+ifneq ($(CONFIG_MSC_U_BOOT),y)
 NAND_SPL = nand_spl
 U_BOOT_NAND = $(obj)u-boot-nand.bin
 endif
+endif
+
+ifeq ($(CONFIG_MSC_U_BOOT),y)
+MSC_SPL = msc_spl
+U_BOOT_MSC = $(obj)u-boot-msc.bin
+endif
 
 __OBJS := $(subst $(obj),,$(OBJS))
 __LIBS := $(subst $(obj),,$(LIBS))
@@ -236,7 +243,7 @@
 #########################################################################
 #########################################################################
 
-ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)
+ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND) $(U_BOOT_MSC)
 
 all:		$(ALL)
 
@@ -278,7 +285,13 @@
 		$(MAKE) -C nand_spl/board/$(BOARDDIR) all
 
 $(U_BOOT_NAND):	$(NAND_SPL) $(obj)u-boot.bin
-		cat $(obj)nand_spl/u-boot-spl-16k.bin $(obj)u-boot.bin > $(obj)u-boot-nand.bin
+		cat $(obj)nand_spl/u-boot-spl-pad.bin $(obj)u-boot.bin > $(obj)u-boot-nand.bin
+
+$(MSC_SPL):	version
+		$(MAKE) -C msc_spl/board/$(BOARDDIR) all
+
+$(U_BOOT_MSC):	$(MSC_SPL) $(obj)u-boot.bin
+		cat $(obj)msc_spl/u-boot-spl-pad.bin $(obj)u-boot.bin > $(obj)u-boot-msc.bin
 
 version:
 		@echo -n "#define U_BOOT_VERSION \"U-Boot " > $(VERSION_FILE); \
@@ -2083,6 +2096,193 @@
 
 tb0229_config: unconfig
 	@$(MKCONFIG) $(@:_config=) mips mips tb0229
+#########################################################################
+## MIPS32 Jz47XX
+#########################################################################
+fuwa_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_FUWA 1" >>include/config.h
+	@./mkconfig -a fuwa mips mips fuwa
+fuwa_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for fuwa"
+	@./mkconfig -a fuwa mips mips fuwa
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/fuwa/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+fuwa1_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_FUWA1 1" >>include/config.h
+	@./mkconfig -a fuwa1 mips mips fuwa1
+
+apus_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_APUS 1" >>include/config.h
+	@./mkconfig -a apus mips mips apus
+
+apus_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for apus"
+	@./mkconfig -a apus mips mips apus
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/apus/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+apus_msc_config		:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "#define CONFIG_MSC_U_BOOT"  > $(obj)include/config.h
+	@echo "Compile MSC boot image for apus"
+	@./mkconfig -a apus mips mips apus
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/apus/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+	@echo "CONFIG_MSC_U_BOOT = y"  >> $(obj)include/config.mk
+
+lib4750_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_LIB4750 1" >>include/config.h
+	@./mkconfig -a lib4750 mips mips lib4750
+
+slt_50_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for slt_50"
+	@./mkconfig -a slt_50 mips mips slt_50
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/slt_50/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+emurus_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_EMURUS 1" >>include/config.h
+	@./mkconfig -a emurus mips mips emurus
+
+virgo_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_VIRGO 1" >>include/config.h
+	@./mkconfig -a virgo mips mips virgo
+
+virgo_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for virgo"
+	@./mkconfig -a virgo mips mips virgo
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/virgo/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+leo_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_LEO 1" >>include/config.h
+	@./mkconfig -a leo mips mips leo
+
+leo_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for leo"
+	@./mkconfig -a leo mips mips leo
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/leo/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+pavo_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_PAVO 1" >>include/config.h
+	@./mkconfig -a pavo mips mips pavo
+
+pavo_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for pavo"
+	@./mkconfig -a pavo mips mips pavo
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/pavo/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+dipper_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_DIPPER 1" >>include/config.h
+	@./mkconfig -a dipper mips mips dipper
+
+dipper_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for dipper"
+	@./mkconfig -a dipper mips mips dipper
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/dipper/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+uranus_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_URANUS 1" >>include/config.h
+	@./mkconfig -a uranus mips mips uranus
+
+libra_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_LIBRA 1" >>include/config.h
+	@./mkconfig -a libra mips mips libra
+
+fcr_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_FCR 1" >>include/config.h
+	@./mkconfig -a fcr mips mips fcr
+
+fprint_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_FPRINT 1" >>include/config.h
+	@./mkconfig -a fprint mips mips fprint
+
+jdi_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_JDI 1" >>include/config.h
+	@./mkconfig -a jdi mips mips jdi
+
+pmpv1_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_PMPV1 1" >>include/config.h
+	@./mkconfig -a pmpv1 mips mips pmpv1
+
+pmpv1_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for pmpv1"
+	@./mkconfig -a pmpv1 mips mips pmpv1
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/pmpv1/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+pmpv2_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_PMPV2 1" >>include/config.h
+	@./mkconfig -a pmpv2 mips mips pmpv2
+
+pmpv2_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for pmpv2"
+	@./mkconfig -a pmpv2 mips mips pmpv2
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/pmpv2/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+slt_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for slt board(Jz4730 chip-sorting board)"
+	@./mkconfig -a slt mips mips slt
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/slt/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+taurus_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_TAURUS 1" >>include/config.h
+	@./mkconfig -a taurus mips mips taurus
+
+iptv_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_IPTV 1" >>include/config.h
+	@./mkconfig -a iptv mips mips iptv
+
+iptv_nand_config	:	unconfig
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "Compile NAND boot image for iptv"
+	@./mkconfig -a iptv mips mips iptv
+	@echo "TEXT_BASE = 0x80100000" > $(obj)board/iptv/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+gps_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_GPS 1" >>include/config.h
+	@./mkconfig -a gps mips mips gps
+
+kaifa_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_KAIFA 1" >>include/config.h
+	@./mkconfig -a kaifa mips mips kaifa
 
 #########################################################################
 ## MIPS32 AU1X00
@@ -2279,6 +2479,7 @@
 	rm -f $(obj)board/integratorap/u-boot.lds $(obj)board/integratorcp/u-boot.lds
 	rm -f $(obj)include/bmp_logo.h
 	rm -f $(obj)nand_spl/u-boot-spl $(obj)nand_spl/u-boot-spl.map
+	rm -f $(obj)msc_spl/u-boot-spl $(obj)msc_spl/u-boot-spl.map
 
 clobber:	clean
 	find $(OBJTREE) -type f \( -name .depend \
@@ -2291,7 +2492,7 @@
 	rm -f $(obj)tools/crc32.c $(obj)tools/environment.c $(obj)tools/env/crc32.c
 	rm -f $(obj)tools/inca-swap-bytes $(obj)cpu/mpc824x/bedbug_603e.c
 	rm -f $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
-	[ ! -d $(OBJTREE)/nand_spl ] || find $(obj)nand_spl -lname "*" -print | xargs rm -f
+#	[ ! -d $(OBJTREE)/nand_spl ] || find $(obj)nand_spl -lname "*" -print | xargs rm -f
 
 ifeq ($(OBJTREE),$(SRCTREE))
 mrproper \
diff -urN /develop/source/01boot/u-boot-1.1.6/msc_spl/board/apus/config.mk u-boot-1.1.6/msc_spl/board/apus/config.mk
--- /develop/source/01boot/u-boot-1.1.6/msc_spl/board/apus/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/msc_spl/board/apus/config.mk	2008-10-30 23:31:59.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4740 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/msc_spl/board/apus/Makefile u-boot-1.1.6/msc_spl/board/apus/Makefile
--- /develop/source/01boot/u-boot-1.1.6/msc_spl/board/apus/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/msc_spl/board/apus/Makefile	2008-10-30 23:31:59.000000000 +0800
@@ -0,0 +1,97 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/msc_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/msc_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL -DCONFIG_MSC_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL -DCONFIG_MSC_SPL
+
+SOBJS	= start.o
+COBJS	= msc_boot_jz4750.o cpu.o jz4750.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS) 
+LNDIR	:= $(OBJTREE)/msc_spl/board/$(BOARDDIR)
+
+mscobj	:= $(OBJTREE)/msc_spl/
+
+ALL	= $(mscobj)u-boot-spl $(mscobj)u-boot-spl.bin $(mscobj)u-boot-spl-pad.bin
+all:	$(obj).depend $(ALL)
+
+$(mscobj)u-boot-spl-pad.bin: $(mscobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(mscobj)junk1
+	cat $< $(mscobj)junk1 > $(mscobj)junk2
+	dd bs=1024 count=8 if=$(mscobj)junk2 of=$(mscobj)junk3
+	cat $(mscobj)junk3 $(mscobj)junk3 > $@
+	rm -f $(mscobj)junk*
+
+$(mscobj)u-boot-spl.bin:	$(mscobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(mscobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(mscobj)u-boot-spl.map \
+		-o $(mscobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4750.c:
+	@rm -f $(obj)jz4750.c
+	ln -s $(SRCTREE)/cpu/mips/jz4750.c $(obj)jz4750.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)msc_boot_jz4750.c:
+	@rm -f $(obj)msc_boot_jz4750.c
+	ln -s $(SRCTREE)/msc_spl/msc_boot_jz4750.c $(obj)msc_boot_jz4750.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/msc_spl/board/apus/u-boot.lds u-boot-1.1.6/msc_spl/board/apus/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/msc_spl/board/apus/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/msc_spl/board/apus/u-boot.lds	2008-10-30 23:31:59.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/msc_spl/msc_boot_jz4750.c u-boot-1.1.6/msc_spl/msc_boot_jz4750.c
--- /develop/source/01boot/u-boot-1.1.6/msc_spl/msc_boot_jz4750.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/msc_spl/msc_boot_jz4750.c	2008-10-31 18:28:40.000000000 +0800
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2007 Ingenic Semiconductor Inc.
+ * Author: Peter <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/jz4750.h>
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+extern void sdram_init(void);
+
+#define u32 unsigned int
+#define u16 unsigned short
+#define u8 unsigned char
+static int rca;
+static int sd2_0 = 0;
+
+/*
+ * GPIO definition
+ */
+#define MMC_IRQ_MASK()				\
+do {						\
+	REG_MSC_IMASK = 0xffff;			\
+	REG_MSC_IREG = 0xffff;			\
+} while (0)
+
+/* Stop the MMC clock and wait while it happens */
+static inline int jz_mmc_stop_clock(void)
+{
+	int timeout = 1000;
+	int wait = 12; /* 1 us */ 
+
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;
+	while (timeout && (REG_MSC_STAT & MSC_STAT_CLK_EN)) {
+		timeout--;
+		if (timeout == 0) {
+			return -1;
+		}
+		wait = 12;
+		while (wait--)
+			;
+	}
+	return 0;
+}
+
+/* Start the MMC clock and operation */
+static inline int jz_mmc_start_clock(void)
+{
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START | MSC_STRPCL_START_OP;
+	return 0;
+}
+
+static u8 * mmc_cmd(u16 cmd, unsigned int arg, unsigned int cmdat, u16 rtype)
+{
+	static u8 resp[20];
+	u32 timeout = 0x3fffff;
+	int words, i;
+
+	jz_mmc_stop_clock();
+	REG_MSC_CMD   = cmd;
+	REG_MSC_ARG   = arg;
+	REG_MSC_CMDAT = cmdat;
+
+	REG_MSC_IMASK = ~MSC_IMASK_END_CMD_RES;
+	jz_mmc_start_clock();
+
+	while (timeout-- && !(REG_MSC_STAT & MSC_STAT_END_CMD_RES))
+		;
+
+	REG_MSC_IREG = MSC_IREG_END_CMD_RES;
+
+	switch (rtype) {
+	case MSC_CMDAT_RESPONSE_R1:
+		case MSC_CMDAT_RESPONSE_R3:
+			words = 3;
+			break;
+		case MSC_CMDAT_RESPONSE_R2:
+			words = 8;
+			break;
+		default:
+			return 0;
+	}
+
+	for (i = words-1; i >= 0; i--) {
+		u16 res_fifo = REG_MSC_RES;
+		int offset = i << 1;
+		
+		resp[offset] = ((u8 *)&res_fifo)[0];
+		resp[offset+1] = ((u8 *)&res_fifo)[1];
+	}
+	return resp;
+}
+
+int mmc_block_readm(u32 src, u32 num, u8 *dst)
+{
+	u8 *resp;
+	u32 stat, timeout, data, cnt, wait, nob;
+
+	resp = mmc_cmd(16, 0x200, 0x401, MSC_CMDAT_RESPONSE_R1);
+	REG_MSC_BLKLEN = 0x200;
+	REG_MSC_NOB = num / 512;
+
+	if (sd2_0) 
+		resp = mmc_cmd(18, src, 0x409, MSC_CMDAT_RESPONSE_R1); // for sdhc card
+	else
+		resp = mmc_cmd(18, src * 512, 0x409, MSC_CMDAT_RESPONSE_R1);
+	nob  = num / 512;
+
+	for (nob; nob >= 1; nob--) {
+		timeout = 0x3ffffff;
+		while (timeout) {
+			timeout--;
+			stat = REG_MSC_STAT;
+
+			if (stat & MSC_STAT_TIME_OUT_READ) {
+				serial_puts("\n MSC_STAT_TIME_OUT_READ\n\n");
+				return -1;
+			}
+			else if (stat & MSC_STAT_CRC_READ_ERROR) {
+				serial_puts("\n MSC_STAT_CRC_READ_ERROR\n\n");
+				return -1;
+			}
+			else if (!(stat & MSC_STAT_DATA_FIFO_EMPTY)) {
+				/* Ready to read data */
+				break;
+			}
+			wait = 12;
+			while (wait--)
+				;
+		}
+		if (!timeout) {
+			serial_puts("\n mmc/sd read timeout\n");
+			return -1;
+		}
+
+		/* Read data from RXFIFO. It could be FULL or PARTIAL FULL */
+		cnt = 128;
+		while (cnt) {
+			while (cnt && (REG_MSC_STAT & MSC_STAT_DATA_FIFO_EMPTY))
+				;
+			cnt --;
+			data = REG_MSC_RXFIFO;
+			{
+				*dst++ = (u8)(data >> 0);
+				*dst++ = (u8)(data >> 8);
+				*dst++ = (u8)(data >> 16);
+				*dst++ = (u8)(data >> 24);
+			}
+		}
+	}
+
+	resp = mmc_cmd(12, 0, 0x41, MSC_CMDAT_RESPONSE_R1);
+	jz_mmc_stop_clock();
+
+	return 0;
+}
+
+static void sd_init(void)
+{
+	int retries, wait;
+	u8 *resp;
+	unsigned int cardaddr;
+	serial_puts("SD card found!\n");
+
+	resp = mmc_cmd(41, 0x40ff8000, 0x3, MSC_CMDAT_RESPONSE_R3);
+	retries = 100;
+	while (retries-- && resp && !(resp[4] & 0x80)) {
+		resp = mmc_cmd(55, 0, 0x1, MSC_CMDAT_RESPONSE_R1);
+		resp = mmc_cmd(41, 0x40ff8000, 0x3, MSC_CMDAT_RESPONSE_R3);
+		wait = 1350000; // mdelay(100);
+		while (wait--)
+			;
+	}
+
+	if (resp[4] & 0x80) 
+		serial_puts("SD init ok\n");
+	else 
+		serial_puts("SD init fail\n");
+
+	/* try to get card id */
+	resp = mmc_cmd(2, 0, 0x2, MSC_CMDAT_RESPONSE_R2);
+	resp = mmc_cmd(3, 0, 0x6, MSC_CMDAT_RESPONSE_R1);
+	cardaddr = (resp[4] << 8) | resp[3]; 
+	rca = cardaddr << 16;
+
+	resp = mmc_cmd(9, rca, 0x2, MSC_CMDAT_RESPONSE_R2);
+	sd2_0 = (resp[14] & 0xc0) >> 6;
+	REG_MSC_CLKRT = 0;
+	resp = mmc_cmd(7, rca, 0x41, MSC_CMDAT_RESPONSE_R1);
+	resp = mmc_cmd(55, rca, 0x1, MSC_CMDAT_RESPONSE_R1);
+	resp = mmc_cmd(6, 0x2, 0x401, MSC_CMDAT_RESPONSE_R1);
+}
+
+/* init mmc/sd card we assume that the card is in the slot */
+int  mmc_init(void)
+{
+	int retries, wait;
+	u8 *resp;
+
+	__gpio_as_msc0_8bit();
+	__msc_reset();
+	MMC_IRQ_MASK();	
+	REG_MSC_CLKRT = 6;    //250k
+
+	serial_puts("\n\nMMC/SD INIT\n");
+
+	/* reset */
+	resp = mmc_cmd(0, 0, 0x80, 0);
+	resp = mmc_cmd(8, 0x1aa, 0x1, MSC_CMDAT_RESPONSE_R1);
+	resp = mmc_cmd(55, 0, 0x1, MSC_CMDAT_RESPONSE_R1);
+	if(!(resp[0] & 0x20) && (resp[5] != 0x37)) { 
+		serial_puts("MMC card found!\n");
+		resp = mmc_cmd(1, 0xff8000, 0x3, MSC_CMDAT_RESPONSE_R3);
+		retries = 100;
+		while (retries-- && resp && !(resp[4] & 0x80)) {
+			resp = mmc_cmd(1, 0x40300000, 0x3, MSC_CMDAT_RESPONSE_R3);
+			wait = 1350000; // mdelay(100);
+			while (wait--)
+				;
+		}
+
+		if (resp[4]== 0x80) 
+			serial_puts("MMC init ok\n");
+		else 
+			serial_puts("MMC init fail\n");
+
+		/* try to get card id */
+		resp = mmc_cmd(2, 0, 0x2, MSC_CMDAT_RESPONSE_R2);
+		resp = mmc_cmd(3, 0x10, 0x1, MSC_CMDAT_RESPONSE_R1);
+
+		REG_MSC_CLKRT = 0;	/* 16/1 MHz */
+		resp = mmc_cmd(7, 0x10, 0x1, MSC_CMDAT_RESPONSE_R1);
+		resp = mmc_cmd(6, 0x3b70101, 0x401, MSC_CMDAT_RESPONSE_R1);
+	}
+	else
+		sd_init();
+	return 0;
+}
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+	__gpio_as_sdram_32bit();
+
+	/*
+	 * Initialize UART1 pins
+	 */
+	__gpio_as_uart3();
+}
+
+/*
+ * Load kernel image from MMC/SD into RAM
+ */
+static int mmc_load(int uboot_size, u8 *dst)
+{
+	mmc_init();
+	mmc_block_readm(32, uboot_size, dst);
+
+	return 0;
+}
+
+void nand_boot(void)
+{
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nMSC Secondary Program Loader\n");
+
+	sdram_init();
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	mmc_load(CFG_MSC_U_BOOT_SIZE, (uchar *)CFG_MSC_U_BOOT_DST);
+
+	uboot = (void (*)(void))CFG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/apus/config.mk u-boot-1.1.6/nand_spl/board/apus/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/apus/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/apus/config.mk	2008-11-11 18:39:06.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic apus Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4750 platforms the SPL is located at 0x80000000...0x80002000,
+# in the first 8KBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/apus/Makefile u-boot-1.1.6/nand_spl/board/apus/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/apus/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/apus/Makefile	2008-11-11 18:39:06.000000000 +0800
@@ -0,0 +1,100 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4750.o cpu.o jz4750.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(nandobj)junk1
+	cat $< $(nandobj)junk1 > $(nandobj)junk2
+	dd bs=1024 count=8 if=$(nandobj)junk2 of=$(nandobj)junk3
+	cat $(nandobj)junk3 $(nandobj)junk3 > $(nandobj)junk4
+	dd bs=1024 count=256 if=/dev/zero of=$(nandobj)junk5
+	cat $(nandobj)junk4 $(nandobj)junk5 > $(nandobj)junk6
+	dd bs=1024 count=256 if=$(nandobj)junk6 of=$@
+	rm -f $(nandobj)junk*
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4750.c:
+	@rm -f $(obj)jz4750.c
+	ln -s $(SRCTREE)/cpu/mips/jz4750.c $(obj)jz4750.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4750.c:
+	@rm -f $(obj)nand_boot_jz4750.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4750.c $(obj)nand_boot_jz4750.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/apus/u-boot.lds u-boot-1.1.6/nand_spl/board/apus/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/apus/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/apus/u-boot.lds	2008-11-11 18:39:06.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/dipper/config.mk u-boot-1.1.6/nand_spl/board/dipper/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/dipper/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/dipper/config.mk	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4740 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/dipper/Makefile u-boot-1.1.6/nand_spl/board/dipper/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/dipper/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/dipper/Makefile	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,100 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4740.o cpu.o jz4740.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(nandobj)junk1
+	cat $< $(nandobj)junk1 > $(nandobj)junk2
+	dd bs=1024 count=8 if=$(nandobj)junk2 of=$(nandobj)junk3
+	cat $(nandobj)junk3 $(nandobj)junk3 > $(nandobj)junk4
+	dd bs=1024 count=256 if=/dev/zero of=$(nandobj)junk5
+	cat $(nandobj)junk4 $(nandobj)junk5 > $(nandobj)junk6
+	dd bs=1024 count=256 if=$(nandobj)junk6 of=$@
+	rm -f $(nandobj)junk*
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4740.c:
+	@rm -f $(obj)jz4740.c
+	ln -s $(SRCTREE)/cpu/mips/jz4740.c $(obj)jz4740.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4740.c:
+	@rm -f $(obj)nand_boot_jz4740.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4740.c $(obj)nand_boot_jz4740.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/dipper/u-boot.lds u-boot-1.1.6/nand_spl/board/dipper/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/dipper/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/dipper/u-boot.lds	2008-05-30 14:01:07.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/config.mk u-boot-1.1.6/nand_spl/board/fuwa/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/fuwa/config.mk	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4740 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/cpu.c u-boot-1.1.6/nand_spl/board/fuwa/cpu.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/cpu.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/fuwa/cpu.c	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,176 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/inca-ip.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+
+#ifdef CONFIG_JZ4730
+#include <asm/jz4730.h>
+#endif
+
+#ifdef CONFIG_JZ4740
+#include <asm/jz4740.h>
+#endif
+
+#ifdef CONFIG_JZ5730
+#include <asm/jz5730.h>
+#endif
+
+#ifndef CONFIG_NAND_SPL
+
+int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+#ifdef CONFIG_JZ4730
+	__wdt_set_count(0xffffffff-32);
+	__wdt_start();
+	while(1);
+#endif
+#ifdef CONFIG_JZ4740
+	__wdt_select_extalclk();
+	__wdt_select_clk_div64();
+	__wdt_set_data(100);
+	__wdt_set_count(0);
+	__tcu_start_wdt_clock();
+	__wdt_start();
+	while(1);
+#endif
+#if defined(CONFIG_INCA_IP)
+	*INCA_IP_WDT_RST_REQ = 0x3f;
+#elif defined(CONFIG_PURPLE) || defined(CONFIG_TB0229) || defined(CONFIG_JzRISC)
+	void (*f)(void) = (void *) 0xbfc00000;
+
+	f();
+#endif
+	fprintf(stderr, "*** reset failed ***\n");
+	return 0;
+}
+
+#define cache16_unroll32(base,op)				\
+	__asm__ __volatile__("					\
+		.set noreorder;					\
+		.set mips3;					\
+		cache %1, 0x000(%0); cache %1, 0x010(%0);	\
+		cache %1, 0x020(%0); cache %1, 0x030(%0);	\
+		cache %1, 0x040(%0); cache %1, 0x050(%0);	\
+		cache %1, 0x060(%0); cache %1, 0x070(%0);	\
+		cache %1, 0x080(%0); cache %1, 0x090(%0);	\
+		cache %1, 0x0a0(%0); cache %1, 0x0b0(%0);	\
+		cache %1, 0x0c0(%0); cache %1, 0x0d0(%0);	\
+		cache %1, 0x0e0(%0); cache %1, 0x0f0(%0);	\
+		cache %1, 0x100(%0); cache %1, 0x110(%0);	\
+		cache %1, 0x120(%0); cache %1, 0x130(%0);	\
+		cache %1, 0x140(%0); cache %1, 0x150(%0);	\
+		cache %1, 0x160(%0); cache %1, 0x170(%0);	\
+		cache %1, 0x180(%0); cache %1, 0x190(%0);	\
+		cache %1, 0x1a0(%0); cache %1, 0x1b0(%0);	\
+		cache %1, 0x1c0(%0); cache %1, 0x1d0(%0);	\
+		cache %1, 0x1e0(%0); cache %1, 0x1f0(%0);	\
+		.set mips0;					\
+		.set reorder"					\
+		:						\
+		: "r" (base),					\
+		  "i" (op));
+
+void flush_cache (ulong start_addr, ulong size)
+{
+#ifdef CONFIG_JzRISC
+	unsigned long start = start_addr;
+	unsigned long end = start + size;
+
+	while (start < end) {
+		cache16_unroll32(start,Hit_Writeback_Inv_D);
+		start += 0x200;
+	}
+#endif
+}
+
+void write_one_tlb( int index, u32 pagemask, u32 hi, u32 low0, u32 low1 ){
+	write_32bit_cp0_register(CP0_ENTRYLO0, low0);
+	write_32bit_cp0_register(CP0_PAGEMASK, pagemask);
+	write_32bit_cp0_register(CP0_ENTRYLO1, low1);
+	write_32bit_cp0_register(CP0_ENTRYHI, hi);
+	write_32bit_cp0_register(CP0_INDEX, index);
+	tlb_write_indexed();
+}
+
+#endif /* !CONFIG_NAND_SPL */
+
+#ifdef CONFIG_JzRISC
+
+void flush_icache_all(void)
+{
+	u32 addr, t = 0;
+
+	asm volatile ("mtc0 $0, $28"); /* Clear Taglo */
+	asm volatile ("mtc0 $0, $29"); /* Clear TagHi */
+
+	for (addr = K0BASE; addr < K0BASE + CFG_ICACHE_SIZE;
+	     addr += CFG_CACHELINE_SIZE) {
+		asm volatile (
+			".set mips3\n\t"
+			" cache %0, 0(%1)\n\t"
+			".set mips2\n\t"
+			:
+			: "I" (Index_Store_Tag_I), "r"(addr));
+	}
+
+	/* invalicate btb */
+	asm volatile (
+		".set mips32\n\t"
+		"mfc0 %0, $16, 7\n\t"
+		"nop\n\t"
+		"ori %0,2\n\t"
+		"mtc0 %0, $16, 7\n\t"
+		".set mips2\n\t"
+		:
+		: "r" (t));
+}
+
+void flush_dcache_all(void)
+{
+	u32 addr;
+
+	for (addr = K0BASE; addr < K0BASE + CFG_DCACHE_SIZE; 
+	     addr += CFG_CACHELINE_SIZE) {
+		asm volatile (
+			".set mips3\n\t"
+			" cache %0, 0(%1)\n\t"
+			".set mips2\n\t"
+			:
+			: "I" (Index_Writeback_Inv_D), "r"(addr));
+	}
+
+	asm volatile ("sync");
+}
+
+void flush_cache_all(void)
+{
+	flush_dcache_all();
+	flush_icache_all();
+}
+
+#endif
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/jz4750.c u-boot-1.1.6/nand_spl/board/fuwa/jz4750.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/jz4750.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/fuwa/jz4750.c	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,589 @@
+/*
+ * Jz4750 common routines
+ *
+ *  Copyright (c) 2006
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_JZ4750
+
+#include <common.h>
+#include <command.h>
+
+#include <asm/jz4750.h>
+
+extern void board_early_init(void);
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 3, 3, 3, 3}; /* divisors of I:S:P:L:M */
+	int nf, pllout2;
+
+	cfcr = CPM_CPCCR_CLKOEN |
+		CPM_CPCCR_PCS |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? CFG_CPU_SPEED : (CFG_CPU_SPEED / 2);
+
+	/* Init USB Host clock, pllout2 must be n*48MHz */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+
+	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(0 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void pll_add_test(int new_freq)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 4, 4, 4, 4}; /* divisors of I:S:P:M:L */
+	int nf, pllout2;
+
+	cfcr = CPM_CPCCR_CLKOEN |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? new_freq : (new_freq / 2);
+
+	/* Init UHC clock */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+	
+	//nf = new_freq * 2 / CFG_EXTAL;
+	nf = new_freq / 1000000; //step length is 1M
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(10 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void calc_clocks_add_test(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+void sdram_add_test(int new_freq)
+{
+	register unsigned int dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = new_freq;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_DISABLE;
+	REG_EMC_RTCOR = 0;
+	REG_EMC_RTCNT = 0;
+
+	/* Basic DMCR register value. */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg parameters */
+	ns = 1000000000 / mem_clk;
+
+#if 0
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+#else
+	dmcr |= 0xfffc;
+#endif
+
+	/* First, precharge phase */
+	REG_EMC_DMCR = dmcr;
+
+	/* Set refresh registers */
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* SDRAM mode values */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* precharge all chip-selects */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 200;
+	while (tmp--);
+
+	/* enable refresh and set SDRAM mode */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* write sdram mode register for each chip-select */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* everything is ok now */
+}
+
+void sdram_init(void)
+{
+	register unsigned int dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+#ifdef CONFIG_MOBILE_SDRAM
+	register unsigned int sdemode; /*SDRAM Extended Mode*/
+#endif
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = CFG_CPU_SPEED;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	/*set REG_EMC_DMARn for two 64M sdram*/
+	REG_EMC_DMAR0 = EMC_DMAR0_BASE | EMC_DMAR_MASK_64_64;
+
+#if CONFIG_NR_DRAM_BANKS == 2   /*Use Two Banks SDRAM*/
+	REG_EMC_DMAR1 = EMC_DMAR1_BASE_64M | EMC_DMAR_MASK_64_64; 
+#endif
+
+	REG_EMC_BCR = 0;	/* Disable bus release */
+	REG_EMC_RTCSR = 0;	/* Disable clock for counting */
+
+	/* Basic DMCR value */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg */
+	ns = 1000000000 / mem_clk;
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode value */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Stage 1. Precharge all banks by writing SDMR with DMCR.MRSET=0 */
+	REG_EMC_DMCR = dmcr;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/*Precharge Bank1 SDRAM*/
+#if CONFIG_NR_DRAM_BANKS == 2   
+	REG_EMC_DMCR = dmcr | EMC_DMCR_MBSEL_B1;
+	REG8(EMC_SDMR0|sdmode) = 0;
+#endif
+
+#ifdef CONFIG_MOBILE_SDRAM
+	/* Mobile SDRAM Extended Mode Register */
+	sdemode = EMC_SDMR_SET_BA1 | EMC_SDMR_DS_FULL | EMC_SDMR_PRSR_ALL;
+#endif
+
+	/* Wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 2. Enable auto-refresh */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH;
+
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCNT = 0;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* Wait for number of auto-refresh cycles */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+ 	/* Stage 3. Mode Register Set */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET | EMC_DMCR_MBSEL_B0;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+
+#ifdef CONFIG_MOBILE_SDRAM
+	REG8(EMC_SDMR0|sdemode) = 0;   	/* Set Mobile SDRAM Extended Mode Register */
+#endif
+
+#if CONFIG_NR_DRAM_BANKS == 2
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET | EMC_DMCR_MBSEL_B1;
+	REG8(EMC_SDMR0|sdmode) = 0;	/* Set Bank1 SDRAM Register */
+
+
+#ifdef CONFIG_MOBILE_SDRAM
+	REG8(EMC_SDMR0|sdemode) = 0;	/* Set Mobile SDRAM Extended Mode Register */
+#endif
+
+#endif   /*CONFIG_NR_DRAM_BANKS == 2*/
+
+	/* Set back to basic DMCR value */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* everything is ok now */
+}
+
+#ifndef CONFIG_NAND_SPL
+
+static void calc_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+static void rtc_init(void)
+{
+
+	while ( !__rtc_write_ready()) ;
+	__rtc_enable_alarm();	/* enable alarm */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_RGR   = 0x00007fff; /* type value */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HWFCR = 0x0000ffe0; /* Power on delay 2s */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HRCR  = 0x00000fe0; /* reset delay 125ms */
+
+}
+
+
+//----------------------------------------------------------------------
+// jz4750 board init routine
+
+int jz_board_init(void)
+{
+	board_early_init();  /* init gpio, pll etc. */
+#ifndef CONFIG_NAND_U_BOOT
+#ifndef CONFIG_FPGA
+	pll_init();          /* init PLL */
+#endif
+	serial_init();
+	sdram_init();        /* init sdram memory */
+#endif
+	calc_clocks();       /* calc the clocks */
+#ifndef CONFIG_FPGA
+	rtc_init();		/* init rtc on any reset: */
+#endif
+	return 0;
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+long int initdram(int board_type)
+{
+	u32 dmcr;
+	u32 rows, cols, dw, banks;
+	ulong size;
+
+	dmcr = REG_EMC_DMCR;
+	rows = 11 + ((dmcr & EMC_DMCR_RA_MASK) >> EMC_DMCR_RA_BIT);
+	cols = 8 + ((dmcr & EMC_DMCR_CA_MASK) >> EMC_DMCR_CA_BIT);
+	dw = (dmcr & EMC_DMCR_BW) ? 2 : 4;
+	banks = (dmcr & EMC_DMCR_BA) ? 4 : 2;
+
+	size = (1 << (rows + cols)) * dw * banks;
+	size *= CONFIG_NR_DRAM_BANKS;
+
+	return size;
+}
+
+//----------------------------------------------------------------------
+// Timer routines
+
+#define TIMER_CHAN  0
+#define TIMER_FDATA 0xffff  /* Timer full data value */
+#define TIMER_HZ    CFG_HZ
+
+#define READ_TIMER  REG_TCU_TCNT(TIMER_CHAN)  /* macro to read the 16 bit timer */
+
+static ulong timestamp;
+static ulong lastdec;
+
+void	reset_timer_masked	(void);
+ulong	get_timer_masked	(void);
+void	udelay_masked		(unsigned long usec);
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	REG_TCU_TCSR(TIMER_CHAN) = TCU_TCSR_PRESCALE256 | TCU_TCSR_EXT_EN;
+	REG_TCU_TCNT(TIMER_CHAN) = 0;
+	REG_TCU_TDHR(TIMER_CHAN) = 0;
+	REG_TCU_TDFR(TIMER_CHAN) = TIMER_FDATA;
+
+	REG_TCU_TMSR = (1 << TIMER_CHAN) | (1 << (TIMER_CHAN + 16)); /* mask irqs */
+	REG_TCU_TSCR = (1 << TIMER_CHAN); /* enable timer clock */
+	REG_TCU_TESR = (1 << TIMER_CHAN); /* start counting up */
+
+	lastdec = 0;
+	timestamp = 0;
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void udelay (unsigned long usec)
+{
+	ulong tmo,tmp;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	}
+	else {
+		if (usec >= 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		}
+		else
+			tmo = 1;
+	}
+
+	/* check for rollover during this delay */
+	tmp = get_timer (0);
+	if ((tmp + tmo) < tmp )
+		reset_timer_masked();  /* timer would roll over */
+	else
+		tmo += tmp;
+
+	while (get_timer_masked () < tmo);
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;
+	timestamp = 0;
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;
+
+	if (lastdec <= now) {
+		/* normal mode */
+		timestamp += (now - lastdec);
+	} else {
+		/* we have an overflow ... */
+		timestamp += TIMER_FDATA + now - lastdec;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	} else {
+		if (usec > 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		} else {
+			tmo = 1;
+		}
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	return TIMER_HZ;
+}
+
+#endif /* CONFIG_NAND_SPL */
+
+//---------------------------------------------------------------------
+// End of timer routine.
+//---------------------------------------------------------------------
+
+#endif /* CONFIG_JZ4750 */
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/jz_serial.c u-boot-1.1.6/nand_spl/board/fuwa/jz_serial.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/jz_serial.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/fuwa/jz_serial.c	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,151 @@
+/*
+ * Jz47xx UART support
+ *
+ * Hardcoded to UART 0 for now
+ * Options also hardcoded to 8N1
+ *
+ *  Copyright (c) 2005
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#if defined(CONFIG_JZ4730) || defined(CONFIG_JZ4740) || defined(CONFIG_JZ4750) || defined(CONFIG_JZ5730)
+
+#include <common.h>
+
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ4750)
+#include <asm/jz4750.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+
+#undef UART_BASE
+#ifndef CFG_UART_BASE
+#define UART_BASE  UART0_BASE
+#else
+#define UART_BASE  CFG_UART_BASE
+#endif
+
+/******************************************************************************
+*
+* serial_init - initialize a channel
+*
+* This routine initializes the number of data bits, parity
+* and set the selected baud rate. Interrupts are disabled.
+* Set the modem control signals if the option is selected.
+*
+* RETURNS: N/A
+*/
+
+int serial_init (void)
+{
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+	volatile u8 *uart_fcr = (volatile u8 *)(UART_BASE + OFF_FCR);
+	volatile u8 *uart_lcr = (volatile u8 *)(UART_BASE + OFF_LCR);
+	volatile u8 *uart_ier = (volatile u8 *)(UART_BASE + OFF_IER);
+	volatile u8 *uart_sircr = (volatile u8 *)(UART_BASE + OFF_SIRCR);
+
+	/* Disable port interrupts while changing hardware */
+	*uart_ier = 0;
+
+	/* Disable UART unit function */
+	*uart_fcr = ~UART_FCR_UUE;
+
+	/* Set both receiver and transmitter in UART mode (not SIR) */
+	*uart_sircr = ~(SIRCR_RSIRE | SIRCR_TSIRE);
+
+	/* Set databits, stopbits and parity. (8-bit data, 1 stopbit, no parity) */
+	*uart_lcr = UART_LCR_WLEN_8 | UART_LCR_STOP_1;
+	
+	/* Set baud rate */
+	serial_setbrg();
+	
+	/* Enable UART unit, enable and clear FIFO */
+	*uart_fcr = UART_FCR_UUE | UART_FCR_FE | UART_FCR_TFLS | UART_FCR_RFLS;
+#endif
+	return 0;
+}
+
+void serial_setbrg (void)
+{
+	volatile u8 *uart_lcr = (volatile u8 *)(UART_BASE + OFF_LCR);
+	volatile u8 *uart_dlhr = (volatile u8 *)(UART_BASE + OFF_DLHR);
+	volatile u8 *uart_dllr = (volatile u8 *)(UART_BASE + OFF_DLLR);
+	u32 baud_div, tmp;
+
+	baud_div = CFG_EXTAL / 16 / CONFIG_BAUDRATE;
+	tmp = *uart_lcr;
+	tmp |= UART_LCR_DLAB;
+	*uart_lcr = tmp;
+
+	*uart_dlhr = (baud_div >> 8) & 0xff;
+	*uart_dllr = baud_div & 0xff;
+
+	tmp &= ~UART_LCR_DLAB;
+	*uart_lcr = tmp;
+}
+
+void serial_putc (const char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART_BASE + OFF_TDR);
+
+	if (c == '\n') serial_putc ('\r');
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UART_LSR_TDRQ | UART_LSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+int serial_getc (void)
+{
+	volatile u8 *uart_rdr = (volatile u8 *)(UART_BASE + OFF_RDR);
+
+	while (!serial_tstc());
+
+	return *uart_rdr;
+}
+
+int serial_tstc (void)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART_BASE + OFF_LSR);
+
+	if (*uart_lsr & UART_LSR_DR) {
+		/* Data in rfifo */
+		return (1);
+	}
+	return 0;
+}
+
+#endif /* CONFIG_JZ4730 || CONFIG_JZ4740 || CONFIG_JZ4750 || CONFIG_JZ45730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/Makefile u-boot-1.1.6/nand_spl/board/fuwa/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/fuwa/Makefile	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,100 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4750.o cpu.o jz4750.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(nandobj)junk1
+	cat $< $(nandobj)junk1 > $(nandobj)junk2
+	dd bs=1024 count=8 if=$(nandobj)junk2 of=$(nandobj)junk3
+	cat $(nandobj)junk3 $(nandobj)junk3 > $(nandobj)junk4
+	dd bs=1024 count=256 if=/dev/zero of=$(nandobj)junk5
+	cat $(nandobj)junk4 $(nandobj)junk5 > $(nandobj)junk6
+	dd bs=1024 count=256 if=$(nandobj)junk6 of=$@
+	rm -f $(nandobj)junk*
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4750.c:
+	@rm -f $(obj)jz4750.c
+	ln -s $(SRCTREE)/cpu/mips/jz4750.c $(obj)jz4750.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4750.c:
+	@rm -f $(obj)nand_boot_jz4750.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4750.c $(obj)nand_boot_jz4750.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/nand_boot_jz4750.c u-boot-1.1.6/nand_spl/board/fuwa/nand_boot_jz4750.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/nand_boot_jz4750.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/fuwa/nand_boot_jz4750.c	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,378 @@
+/*
+ * Copyright (C) 2007 Ingenic Semiconductor Inc.
+ * Author: Peter <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/jz4750.h>
+
+/*
+ * NAND flash definitions
+ */
+
+#define NAND_DATAPORT	0xb8000000
+unsigned int NAND_ADDRPORT;
+unsigned int NAND_COMMPORT;
+
+#define ECC_BLOCK	512
+#define ECC_POS		3
+#define PAR_SIZE	13
+
+#define __nand_cmd(n)		(REG8(NAND_COMMPORT) = (n))
+#define __nand_addr(n)		(REG8(NAND_ADDRPORT) = (n))
+#define __nand_data8()		REG8(NAND_DATAPORT)
+#define __nand_data16()		REG16(NAND_DATAPORT)
+
+#define __nand_enable()		(REG_EMC_NFCSR |= EMC_NFCSR_NFE1 | EMC_NFCSR_NFCE1)
+#define __nand_disable()	(REG_EMC_NFCSR &= ~(EMC_NFCSR_NFCE1))
+
+static inline void nand_wait_ready(void)
+{
+	unsigned int timeout = 1000;
+	while ((REG_GPIO_PXPIN(2) & 0x08000000) && timeout--);
+	while (!(REG_GPIO_PXPIN(2) & 0x08000000));
+}
+
+/*
+ * NAND flash parameters
+ */
+static int bus_width = 8;
+static int page_size = 2048;
+static int oob_size = 64;
+static int ecc_count = 4;
+static int row_cycle = 3;
+static int page_per_block = 64;
+static int bad_block_pos = 0;
+static int block_size = 131072;
+
+static unsigned char oob_buf[128] = {0};
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+extern void sdram_init(void);
+extern void pll_init(void);
+
+/*
+ * NAND flash routines
+ */
+
+static inline void nand_read_buf16(void *buf, int count)
+{
+	int i;
+	u16 *p = (u16 *)buf;
+
+	for (i = 0; i < count; i += 2)
+		*p++ = __nand_data16();
+}
+
+static inline void nand_read_buf8(void *buf, int count)
+{
+	int i;
+	u8 *p = (u8 *)buf;
+
+	for (i = 0; i < count; i++)
+		*p++ = __nand_data8();
+}
+
+static inline void nand_read_buf(void *buf, int count, int bw)
+{
+	if (bw == 8)
+		nand_read_buf8(buf, count);
+	else
+		nand_read_buf16(buf, count);
+}
+
+/*
+ * Correct the error bit in 512-bytes data
+ */
+static void bch_correct(unsigned char *dat, int idx)
+{
+	int i, bit;  // the 'bit' of i byte is error 
+	i = (idx - 1) >> 3;
+	bit = (idx - 1) & 0x7;
+	dat[i] ^= (1 << bit);
+}
+
+/*
+ * Read oob
+ */
+static int nand_read_oob(int page_addr, u8 *buf, int size)
+{
+	int col_addr;
+
+	if (page_size != 512)
+		col_addr = page_size;
+	else
+		col_addr = 0;
+
+	if (page_size != 512)
+		/* Send READ0 command */
+		__nand_cmd(NAND_CMD_READ0);
+	else
+		/* Send READOOB command */
+		__nand_cmd(NAND_CMD_READOOB);
+
+	/* Send column address */
+	__nand_addr(col_addr & 0xff);
+	if (page_size != 512)
+		__nand_addr((col_addr >> 8) & 0xff);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	nand_wait_ready();
+
+	/* Read oob data */
+	nand_read_buf(buf, size, bus_width);
+
+	if (page_size == 512)
+		nand_wait_ready();
+
+	return 0;
+}
+
+static int nand_read_page(int block, int page, uchar *dst, uchar *oobbuf)
+{
+	int page_addr = page + block * page_per_block;
+	uchar *data_buf = dst;
+	int i, j;
+
+	/*
+	 * Read oob data
+	 */
+	nand_read_oob(page_addr, oobbuf, oob_size);
+
+	/*
+	 * Read page data
+	 */
+
+	/* Send READ0 command */
+	__nand_cmd(NAND_CMD_READ0);
+
+	/* Send column address */
+	__nand_addr(0);
+	if (page_size != 512)
+		__nand_addr(0);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	nand_wait_ready();
+
+	/* Read page data */
+	data_buf = dst;
+
+	ecc_count = page_size / ECC_BLOCK;
+
+	for (i = 0; i < ecc_count; i++) {
+		unsigned int stat;
+
+		/* Read data */
+		nand_read_buf((void *)data_buf, ECC_BLOCK, bus_width);
+	        
+                /* Enable 8bit BCH decoding */
+		REG_BCH_INTS = 0xffffffff;
+		__ecc_decoding_8bit();
+
+                /* Write 512 bytes and PAR_SIZE parities to REG_BCH_DR */
+		for (j = 0; j < ECC_BLOCK; j++) {
+			REG_BCH_DR = data_buf[j];
+		}
+
+		for (j = 0; j < PAR_SIZE; j++) {
+			REG_BCH_DR = oob_buf[ECC_POS + i*PAR_SIZE + j];
+		}
+
+		/* Wait for completion */
+		__ecc_decode_sync();
+		__ecc_disable();
+
+		/* Check decoding */
+		stat = REG_BCH_INTS;
+		if (stat & BCH_INTS_ERR) {
+			if (stat & BCH_INTS_UNCOR) {
+				/* Uncorrectable error occurred */
+			}
+			else {
+				unsigned int errcnt = (stat & BCH_INTS_ERRC_MASK) >> BCH_INTS_ERRC_BIT;
+				switch (errcnt) {
+				case 8:
+					bch_correct(data_buf, (REG_BCH_ERR3 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 7:
+					bch_correct(data_buf, (REG_BCH_ERR3 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 6:
+					bch_correct(data_buf, (REG_BCH_ERR2 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 5:
+					bch_correct(data_buf, (REG_BCH_ERR2 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 4:
+					bch_correct(data_buf, (REG_BCH_ERR1 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 3:
+					bch_correct(data_buf, (REG_BCH_ERR1 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 2:
+					bch_correct(data_buf, (REG_BCH_ERR0 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 1:
+					bch_correct(data_buf, (REG_BCH_ERR0 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+		/* increment pointer */
+		data_buf += ECC_BLOCK;
+	}
+
+	return 0;
+}
+
+#ifndef CFG_NAND_BADBLOCK_PAGE
+#define CFG_NAND_BADBLOCK_PAGE 0 /* NAND bad block was marked at this page in a block, starting from 0 */
+#endif
+
+static void nand_load(int offs, int uboot_size, uchar *dst)
+{
+	int block;
+	int blockcopy_count;
+	int page;
+
+	__nand_enable();
+
+	/*
+	 * offs has to be aligned to a block address!
+	 */
+	block = offs / block_size;
+	blockcopy_count = 0;
+
+	while (blockcopy_count < (uboot_size / block_size)) {
+
+		/* New block is required to check the bad block flag */
+		nand_read_oob(block * page_per_block + CFG_NAND_BADBLOCK_PAGE, oob_buf, oob_size);
+
+		if (oob_buf[bad_block_pos] != 0xff) {
+			block++;
+			/* Skip bad block */
+			continue;
+		}
+
+		for (page = 0; page < page_per_block; page++) {
+
+			/* Load this page to dst, do the ECC */
+			nand_read_page(block, page, dst, oob_buf);
+
+			dst += page_size;
+		}
+
+		block++;
+		blockcopy_count++;
+	}
+
+	__nand_disable();
+}
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+	__gpio_as_sdram_32bit();
+
+	/*
+	 * Initialize UART1 pins
+	 */
+	__gpio_as_uart1();
+}
+
+void nand_boot(void)
+{
+	int boot_sel;
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nNAND Secondary Program Loader\n\n");
+
+	pll_init();
+	sdram_init();
+
+	/*
+	 * JZ4750 can get some NAND parameters from NAND infomation in fuwa.h
+	 */
+	bus_width = (CFG_NAND_BW8==1) ? 8 : 16;
+	page_size = CFG_NAND_PAGE_SIZE;
+	row_cycle = CFG_NAND_ROW_CYCLE;
+	block_size = CFG_NAND_BLOCK_SIZE;
+	page_per_block =  CFG_NAND_BLOCK_SIZE / CFG_NAND_PAGE_SIZE;
+	bad_block_pos = (page_size == 512) ? 5 : 0;
+	oob_size = page_size / 32;
+	ecc_count = page_size / ECC_BLOCK;
+
+	if (REG_EMC_BCR && EMC_BCR_BSR_MASK == EMC_BCR_BSR_SHARE) {
+		NAND_ADDRPORT =	0xb8010000;
+		NAND_COMMPORT =	0xb8008000;
+	} else {
+		NAND_ADDRPORT =	0xb8000010;
+		NAND_COMMPORT =	0xb8000008;
+	}
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	nand_load(CFG_NAND_U_BOOT_OFFS, CFG_NAND_U_BOOT_SIZE,
+		  (uchar *)CFG_NAND_U_BOOT_DST);
+
+	uboot = (void (*)(void))CFG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/start.S u-boot-1.1.6/nand_spl/board/fuwa/start.S
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/start.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/fuwa/start.S	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,668 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+
+#ifdef CONFIG_JZ4730
+#include <asm/jz4730.h>
+#endif
+
+#ifdef CONFIG_JZ4740
+#include <asm/jz4740.h>
+#endif
+
+#ifdef CONFIG_JZ4750
+#include <asm/jz4750.h>
+#define JZ4750_NANDBOOT_CFG0 (0x55555500 | (CFG_NAND_BW8*0xff))
+#define JZ4750_NANDBOOT_CFG1 0x55555555	
+#define JZ4750_NANDBOOT_CFG2 ((CFG_NAND_PAGE_SIZE==2048)&0xff0000) | ((CFG_NAND_PAGE_SIZE!=512)&0xff00) | ((CFG_NAND_ROW_CYCLE==3)&0xff)
+#endif
+
+#define RVECENT(f,n) \
+   b f; nop
+#define XVECENT(f,bev) \
+   b f     ;           \
+   li k0,bev
+
+	.set noreorder
+
+	.globl _start
+	.text
+_start:
+#if defined(CONFIG_JZ4740)
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	.word JZ4740_NORBOOT_CFG	/* fetched during NOR Boot */
+#else
+#if defined(CONFIG_NAND_SPL)
+	.word JZ4740_NANDBOOT_CFG	/* fetched during NAND Boot */
+#endif
+#endif
+#endif /* CONFIG_JZ4740 */
+#if defined(CONFIG_JZ4750)
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	.word JZ4750_NORBOOT_CFG	/* fetched during NOR Boot */
+#else
+#if defined(CONFIG_NAND_SPL)
+	/* First three words fetched by CPU during NAND Boot */
+	.word JZ4750_NANDBOOT_CFG0
+	.word JZ4750_NANDBOOT_CFG1
+	.word JZ4750_NANDBOOT_CFG2	
+#endif
+#endif
+#endif /* CONFIG_JZ4750 */
+#if !defined(CONFIG_JzRISC)
+	RVECENT(reset,0)	/* U-boot entry point */
+	RVECENT(reset,1)	/* software reboot */
+#if defined(CONFIG_INCA_IP)
+	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
+	.word 0x00000000           /* phase of the flash                    */
+#elif defined(CONFIG_PURPLE)
+	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
+	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
+#else
+	RVECENT(romReserved,2)
+#endif
+	RVECENT(romReserved,3)
+	RVECENT(romReserved,4)
+	RVECENT(romReserved,5)
+	RVECENT(romReserved,6)
+	RVECENT(romReserved,7)
+	RVECENT(romReserved,8)
+	RVECENT(romReserved,9)
+	RVECENT(romReserved,10)
+	RVECENT(romReserved,11)
+	RVECENT(romReserved,12)
+	RVECENT(romReserved,13)
+	RVECENT(romReserved,14)
+	RVECENT(romReserved,15)
+	RVECENT(romReserved,16)
+	RVECENT(romReserved,17)
+	RVECENT(romReserved,18)
+	RVECENT(romReserved,19)
+	RVECENT(romReserved,20)
+	RVECENT(romReserved,21)
+	RVECENT(romReserved,22)
+	RVECENT(romReserved,23)
+	RVECENT(romReserved,24)
+	RVECENT(romReserved,25)
+	RVECENT(romReserved,26)
+	RVECENT(romReserved,27)
+	RVECENT(romReserved,28)
+	RVECENT(romReserved,29)
+	RVECENT(romReserved,30)
+	RVECENT(romReserved,31)
+	RVECENT(romReserved,32)
+	RVECENT(romReserved,33)
+	RVECENT(romReserved,34)
+	RVECENT(romReserved,35)
+	RVECENT(romReserved,36)
+	RVECENT(romReserved,37)
+	RVECENT(romReserved,38)
+	RVECENT(romReserved,39)
+	RVECENT(romReserved,40)
+	RVECENT(romReserved,41)
+	RVECENT(romReserved,42)
+	RVECENT(romReserved,43)
+	RVECENT(romReserved,44)
+	RVECENT(romReserved,45)
+	RVECENT(romReserved,46)
+	RVECENT(romReserved,47)
+	RVECENT(romReserved,48)
+	RVECENT(romReserved,49)
+	RVECENT(romReserved,50)
+	RVECENT(romReserved,51)
+	RVECENT(romReserved,52)
+	RVECENT(romReserved,53)
+	RVECENT(romReserved,54)
+	RVECENT(romReserved,55)
+	RVECENT(romReserved,56)
+	RVECENT(romReserved,57)
+	RVECENT(romReserved,58)
+	RVECENT(romReserved,59)
+	RVECENT(romReserved,60)
+	RVECENT(romReserved,61)
+	RVECENT(romReserved,62)
+	RVECENT(romReserved,63)
+	XVECENT(romExcHandle,0x200)	/* bfc00200: R4000 tlbmiss vector */
+	RVECENT(romReserved,65)
+	RVECENT(romReserved,66)
+	RVECENT(romReserved,67)
+	RVECENT(romReserved,68)
+	RVECENT(romReserved,69)
+	RVECENT(romReserved,70)
+	RVECENT(romReserved,71)
+	RVECENT(romReserved,72)
+	RVECENT(romReserved,73)
+	RVECENT(romReserved,74)
+	RVECENT(romReserved,75)
+	RVECENT(romReserved,76)
+	RVECENT(romReserved,77)
+	RVECENT(romReserved,78)
+	RVECENT(romReserved,79)
+	XVECENT(romExcHandle,0x280)	/* bfc00280: R4000 xtlbmiss vector */
+	RVECENT(romReserved,81)
+	RVECENT(romReserved,82)
+	RVECENT(romReserved,83)
+	RVECENT(romReserved,84)
+	RVECENT(romReserved,85)
+	RVECENT(romReserved,86)
+	RVECENT(romReserved,87)
+	RVECENT(romReserved,88)
+	RVECENT(romReserved,89)
+	RVECENT(romReserved,90)
+	RVECENT(romReserved,91)
+	RVECENT(romReserved,92)
+	RVECENT(romReserved,93)
+	RVECENT(romReserved,94)
+	RVECENT(romReserved,95)
+	XVECENT(romExcHandle,0x300)	/* bfc00300: R4000 cache vector */
+	RVECENT(romReserved,97)
+	RVECENT(romReserved,98)
+	RVECENT(romReserved,99)
+	RVECENT(romReserved,100)
+	RVECENT(romReserved,101)
+	RVECENT(romReserved,102)
+	RVECENT(romReserved,103)
+	RVECENT(romReserved,104)
+	RVECENT(romReserved,105)
+	RVECENT(romReserved,106)
+	RVECENT(romReserved,107)
+	RVECENT(romReserved,108)
+	RVECENT(romReserved,109)
+	RVECENT(romReserved,110)
+	RVECENT(romReserved,111)
+	XVECENT(romExcHandle,0x380)	/* bfc00380: R4000 general vector */
+	RVECENT(romReserved,113)
+	RVECENT(romReserved,114)
+	RVECENT(romReserved,115)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,118)
+	RVECENT(romReserved,119)
+	RVECENT(romReserved,120)
+	RVECENT(romReserved,121)
+	RVECENT(romReserved,122)
+	RVECENT(romReserved,123)
+	RVECENT(romReserved,124)
+	RVECENT(romReserved,125)
+	RVECENT(romReserved,126)
+	RVECENT(romReserved,127)
+
+	/* We hope there are no more reserved vectors!
+	 * 128 * 8 == 1024 == 0x400
+	 * so this is address R_VEC+0x400 == 0xbfc00400
+	 */
+#ifdef CONFIG_PURPLE
+/* 0xbfc00400 */
+	.word	0xdc870000
+	.word	0xfca70000
+	.word	0x20840008
+	.word	0x20a50008
+	.word	0x20c6ffff
+	.word	0x14c0fffa
+	.word	0x00000000
+	.word	0x03e00008
+	.word	0x00000000
+	.word   0x00000000
+/* 0xbfc00428 */
+	.word	0xdc870000
+	.word	0xfca70000
+	.word	0x20840008
+	.word	0x20a50008
+	.word	0x20c6ffff
+	.word	0x14c0fffa
+	.word	0x00000000
+	.word	0x03e00008
+	.word	0x00000000
+	.word   0x00000000
+#endif /* CONFIG_PURPLE */
+	.align 4
+#endif /* CONFIG_JzRISC */
+
+reset:
+
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+
+#ifdef CONFIG_JZ4730
+
+	/* Disable interrupts */
+	la	t0, INTC_IMR
+	li	t1, 0xffffffff
+	sw	t1, 0(t0)
+
+	/*
+	 * Clear SCR.HGP
+	 */
+	la	t0, CPM_SCR
+	lw	t1, 0(t0)
+	ori	t1, 0x8
+	xori	t1, 0x8
+	sw	t1, 0(t0)
+
+	/*
+	 * Set usb port0 as host
+	 */
+	la	t0, HARB_HAPOR
+	lw	t1, 0(t0)
+	ori	t1, HARB_HAPOR_UCHSEL
+	sw	t1, 0(t0)
+
+	/*
+	 * Check reset status
+	 */
+	la	t0, CPM_RSTR
+	lw	t1, 0(t0)
+	andi	t1, 0x4
+	bnez	t1, resume_from_hibernate
+	nop
+#endif /* CONFIG_JZ4730 */
+
+#ifndef CONFIG_NAND_SPL
+	/* Clear watch registers.
+	 */
+	mtc0	zero, CP0_WATCHLO
+	mtc0	zero, CP0_WATCHHI
+#endif
+
+	/* STATUS register */
+#ifdef CONFIG_JzRISC
+	/* 
+	 * CU0=UM=EXL=IE=0, BEV=ERL=1, IP2~7=1
+	 */
+	li	t0, 0x0040FC04
+	mtc0	t0, CP0_STATUS
+#else
+#ifdef  CONFIG_TB0229
+	li	k0, ST0_CU0
+#else
+	mfc0	k0, CP0_STATUS
+#endif
+	li	k1, ~ST0_IE
+	and	k0, k1
+	mtc0	k0, CP0_STATUS
+#endif
+
+	/* CAUSE register */
+#ifdef CONFIG_JzRISC
+	/* IV=1, use the specical interrupt vector (0x200) */
+	li	t1, 0x00800000
+	mtc0	t1, CP0_CAUSE
+#else
+	mtc0	zero, CP0_CAUSE
+#endif
+
+#ifndef CONFIG_JzRISC
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+#endif
+
+#endif /* !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL) */
+
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	/* CONFIG0 register */
+	li	t0, CONF_CM_UNCACHED
+	mtc0	t0, CP0_CONFIG
+#endif
+
+	/* Initialize GOT pointer.
+	*/
+	bal     1f
+	nop
+	.word   _GLOBAL_OFFSET_TABLE_
+	1:
+	move    gp, ra
+	lw      t1, 0(ra)
+	move	gp, t1
+
+#ifdef CONFIG_INCA_IP
+	/* Disable INCA-IP Watchdog.
+	 */
+	la      t9, disable_incaip_wdt
+	jalr    t9
+	nop
+#endif
+
+/* JzRISC will init external memory in board_init_f,
+   which uses cache as stack and calls into C code. */
+#ifndef CONFIG_JzRISC
+	/* Initialize any external memory.
+	 */
+	la      t9, lowlevel_init
+	jalr    t9
+	nop
+#endif
+
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	/* Initialize caches...
+	 */
+#ifdef CONFIG_JzRISC
+	.set	mips32
+	mtc0	zero, CP0_TAGLO
+	mtc0	zero, CP0_TAGHI
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_DCACHE_SIZE
+1:
+	cache	Index_Store_Tag_D, 0(t0)
+	bne	t0, t1, 1b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_ICACHE_SIZE
+2:
+	cache	Index_Store_Tag_I, 0(t0)
+	bne	t0, t1, 2b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	/* Invalidate BTB */
+	mfc0	t0, CP0_CONFIG, 7
+	nop
+	ori	t0, 2
+	mtc0	t0, CP0_CONFIG, 7
+	nop
+
+	.set	mips2
+#else
+	la      t9, mips_cache_reset
+	jalr    t9
+	nop
+#endif
+
+	/* ... and enable them.
+	 */
+	li	t0, CONF_CM_CACHABLE_NONCOHERENT
+	mtc0	t0, CP0_CONFIG
+	nop
+
+#endif /* !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT) */
+
+	/* Set up temporary stack.
+	 */
+#ifndef CONFIG_JzRISC
+	li	a0, CFG_INIT_SP_OFFSET
+	la      t9, mips_cache_lock
+	jalr    t9
+	nop
+#endif
+
+#ifdef CONFIG_NAND_SPL
+	la	sp, 0x80004000
+	la	t9, nand_boot
+	j	t9
+	nop
+#else
+	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
+	la	sp, 0(t0)
+
+	la	t9, board_init_f
+	j	t9
+	nop
+
+
+/*
+ * void relocate_code (addr_sp, gd, addr_moni)
+ *
+ * This "function" does not return, instead it continues in RAM
+ * after relocating the monitor code.
+ *
+ * a0 = addr_sp
+ * a1 = gd
+ * a2 = destination address
+ */
+	.globl	relocate_code
+	.ent	relocate_code
+relocate_code:
+	move	sp, a0		/* Set new stack pointer		*/
+
+	li	t0, TEXT_BASE
+	la	t3, in_ram
+	lw	t2, -12(t3)	/* t2 <-- uboot_end_data	*/
+	move	t1, a2
+
+	/*
+	 * Fix GOT pointer:
+	 *
+	 * New GOT-PTR = (old GOT-PTR - TEXT_BASE) + Destination Address
+	 */
+	move	t6, gp
+	sub	gp, TEXT_BASE
+	add	gp, a2			/* gp now adjusted		*/
+	sub	t6, gp, t6		/* t6 <-- relocation offset	*/
+
+	/*
+	 * t0 = source address
+	 * t1 = target address
+	 * t2 = source end address
+	 */
+	/* On the purple board we copy the code earlier in a special way
+	 * in order to solve flash problems
+	 */
+#ifndef CONFIG_PURPLE
+1:
+	lw	t3, 0(t0)
+	sw	t3, 0(t1)
+	addu	t0, 4
+	ble	t0, t2, 1b
+	addu	t1, 4			/* delay slot			*/
+#endif
+
+	/* If caches were enabled, we would have to flush them here.
+	 */
+#ifdef CONFIG_JzRISC
+	/* flush d-cache */
+	.set	mips32
+	li	t0, KSEG0
+	addi	t1, t0, CFG_DCACHE_SIZE
+2:
+	cache	Index_Writeback_Inv_D, 0(t0)
+	bne	t0, t1, 2b
+	addi	t0, CFG_CACHELINE_SIZE
+
+	sync
+
+	/* flush i-cache */
+	li	t0, KSEG0
+	addi	t1, t0, CFG_ICACHE_SIZE
+3:
+	cache	Index_Invalidate_I, 0(t0)
+	bne	t0, t1, 3b
+	addi	t0, CFG_CACHELINE_SIZE
+
+	/* Invalidate BTB */
+	mfc0	t0, CP0_CONFIG, 7
+	nop
+	ori	t0, 2
+	mtc0	t0, CP0_CONFIG, 7
+	nop
+
+	.set	mips0
+#endif
+
+	/* Jump to where we've relocated ourselves.
+	 */
+	addi	t0, a2, in_ram - _start
+	j	t0
+	nop
+
+	.word	uboot_end_data
+	.word	uboot_end
+	.word	num_got_entries
+
+in_ram:
+	/* Now we want to update GOT.
+	 */
+	lw	t3, -4(t0)	/* t3 <-- num_got_entries	*/
+	addi	t4, gp, 8	/* Skipping first two entries.	*/
+	li	t2, 2
+1:
+	lw	t1, 0(t4)
+	beqz	t1, 2f
+	add	t1, t6
+	sw	t1, 0(t4)
+2:
+	addi	t2, 1
+	blt	t2, t3, 1b
+	addi	t4, 4		/* delay slot			*/
+
+	/* Clear BSS.
+	 */
+	lw	t1, -12(t0)	/* t1 <-- uboot_end_data	*/
+	lw	t2, -8(t0)	/* t2 <-- uboot_end		*/
+	add	t1, t6		/* adjust pointers		*/
+	add	t2, t6
+
+	sub	t1, 4
+1:	addi	t1, 4
+	bltl	t1, t2, 1b
+	sw	zero, 0(t1)	/* delay slot			*/
+
+	move	a0, a1
+	la	t9, board_init_r
+	j	t9
+	move	a1, a2		/* delay slot			*/
+
+	.end	relocate_code
+
+#endif /* CONFIG_NAND_SPL */
+
+#if !defined(CONFIG_JzRISC)
+	/* Exception handlers.
+	 */
+romReserved:
+	b romReserved
+
+romExcHandle:
+	b romExcHandle
+#endif
+
+#ifdef CONFIG_JZ4730
+
+/* These are the runtime values, modify them according to your platform. */
+#define PLCR1_VAL     0x1b000520
+#define CFCR_VAL      0x0c526220
+
+#define DMCR_VAL0     0x042a3211
+#define DMCR_VAL1     0x05aa3211 /*(DMCR_VAL0|EMC_DMCR_RFSH|EMC_DMCR_MRSET)*/
+
+#define RTCOR_VAL     0x10
+#define RTCSR_VAL     0x83
+
+	/*
+	 * cpu was reset from hibernate mode
+	 */
+resume_from_hibernate:
+	/*
+	 * Init PLL
+	 */
+	la	t0, 0xB0000000	/* CFCR */
+	li	t1, CFCR_VAL
+	sw	t1, 0(t0)
+
+	la	t0, 0xB0000010	/* PLCR1 */
+	li	t1, PLCR1_VAL
+	sw	t1, 0(t0)
+	nop;nop;nop;nop
+
+	/* Init caches */
+	.set	mips32
+	mtc0	zero, CP0_TAGLO
+	mtc0	zero, CP0_TAGHI
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_DCACHE_SIZE
+1:
+	cache	Index_Store_Tag_D, 0(t0)
+	cache	Index_Store_Tag_I, 0(t0)
+	bne	t0, t1, 1b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	/*
+	 * Init SDRAM
+	 */
+	la	t0, 0xB0010070	/* GPALR2 */
+	lw	t1, 0(t0)
+	li	t2, 0x3FFFFFFF
+	and	t1, t2
+	li	t2, 0x40000000
+	or	t1, t2
+	sw	t1, 0(t0)
+
+	la	t0, 0xB0010074	/* GPAUR2 */
+	lw	t1, 0(t0)
+	li	t2, 0xFFFF0000
+	and	t1, t2
+	li	t2, 0x00005555
+	or	t1, t2
+	sw	t1, 0(t0)
+
+	la	t0, 0xB3010000	/* EMC base address */
+
+	li	t1, DMCR_VAL0	/* DMCR */
+	sw	t1, 0x80(t0)
+
+	li	t1, RTCOR_VAL
+	sh	t1, 0x8c(t0)	/* RTCOR */
+
+	li	t1, RTCSR_VAL
+	sh	t1, 0x84(t0)	/* RTCSR */
+
+	/* precharge all chip-selects */
+	ori	t1, t0, 0xa088
+	sb	$0, 0(t1)
+	ori	t1, t0, 0xb088
+	sb	$0, 0(t1)
+
+	/* delay about 200us */
+	li	t1, 0x20000
+1:
+	bnez	t1, 1b
+	sub	t1, 1
+
+	la	t1, DMCR_VAL1	/* DMCR */
+	sw	t1, 0x80(t0)
+
+	/* write sdram mode register for each chip-select */
+	ori	t1, t0, 0xa088
+	sb	$0, 0(t1)
+	ori	t1, t0, 0xb088
+	sb	$0, 0(t1)
+
+	/*
+	 * jump to resume entry point
+	 */
+	la	t0, CPM_SPR
+	lw	t1, 0(t0)
+	li	t0, 0x80000000
+	or	t0, t1
+
+	j	t0
+	nop
+
+#endif /* CONFIG_JZ4730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/u-boot.lds u-boot-1.1.6/nand_spl/board/fuwa/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/fuwa/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/fuwa/u-boot.lds	2008-07-09 13:10:03.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/iptv/config.mk u-boot-1.1.6/nand_spl/board/iptv/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/iptv/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/iptv/config.mk	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4730 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/iptv/Makefile u-boot-1.1.6/nand_spl/board/iptv/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/iptv/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/iptv/Makefile	2007-11-10 12:31:34.000000000 +0800
@@ -0,0 +1,93 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz5730.o cpu.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=128 if=/dev/zero of=$(nandobj)/junk
+	cat $< $(nandobj)/junk > $(nandobj)/junk2
+	dd bs=1024 count=128 if=$(nandobj)/junk2 of=$@
+	rm -f $(nandobj)/junk $(nandobj)/junk2
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz5730.c:
+	@rm -f $(obj)nand_boot_jz5730.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz5730.c $(obj)nand_boot_jz5730.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/iptv/u-boot.lds u-boot-1.1.6/nand_spl/board/iptv/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/iptv/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/iptv/u-boot.lds	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/leo/config.mk u-boot-1.1.6/nand_spl/board/leo/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/leo/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/leo/config.mk	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4740 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/leo/Makefile u-boot-1.1.6/nand_spl/board/leo/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/leo/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/leo/Makefile	2007-12-10 19:53:32.000000000 +0800
@@ -0,0 +1,101 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4740.o cpu.o jz4740.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(nandobj)junk1
+	cat $< $(nandobj)junk1 > $(nandobj)junk2
+	dd bs=1024 count=8 if=$(nandobj)junk2 of=$(nandobj)junk3
+	cat $(nandobj)junk3 $(nandobj)junk3 > $(nandobj)junk4
+	dd bs=1024 count=256 if=/dev/zero of=$(nandobj)junk5
+	cat $(nandobj)junk4 $(nandobj)junk5 > $(nandobj)junk6
+	dd bs=1024 count=256 if=$(nandobj)junk6 of=$@
+	rm -f $(nandobj)junk*
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4740.c:
+	@rm -f $(obj)jz4740.c
+	ln -s $(SRCTREE)/cpu/mips/jz4740.c $(obj)jz4740.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4740.c:
+	@rm -f $(obj)nand_boot_jz4740.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4740.c $(obj)nand_boot_jz4740.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/leo/u-boot.lds u-boot-1.1.6/nand_spl/board/leo/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/leo/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/leo/u-boot.lds	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pavo/config.mk u-boot-1.1.6/nand_spl/board/pavo/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pavo/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pavo/config.mk	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4740 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pavo/Makefile u-boot-1.1.6/nand_spl/board/pavo/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pavo/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pavo/Makefile	2007-11-10 12:10:46.000000000 +0800
@@ -0,0 +1,100 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4740.o cpu.o jz4740.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(nandobj)junk1
+	cat $< $(nandobj)junk1 > $(nandobj)junk2
+	dd bs=1024 count=8 if=$(nandobj)junk2 of=$(nandobj)junk3
+	cat $(nandobj)junk3 $(nandobj)junk3 > $(nandobj)junk4
+	dd bs=1024 count=256 if=/dev/zero of=$(nandobj)junk5
+	cat $(nandobj)junk4 $(nandobj)junk5 > $(nandobj)junk6
+	dd bs=1024 count=256 if=$(nandobj)junk6 of=$@
+	rm -f $(nandobj)junk*
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4740.c:
+	@rm -f $(obj)jz4740.c
+	ln -s $(SRCTREE)/cpu/mips/jz4740.c $(obj)jz4740.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4740.c:
+	@rm -f $(obj)nand_boot_jz4740.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4740.c $(obj)nand_boot_jz4740.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pavo/u-boot.lds u-boot-1.1.6/nand_spl/board/pavo/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pavo/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pavo/u-boot.lds	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv1/config.mk u-boot-1.1.6/nand_spl/board/pmpv1/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv1/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pmpv1/config.mk	2007-05-28 15:08:27.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4730 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv1/Makefile u-boot-1.1.6/nand_spl/board/pmpv1/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv1/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pmpv1/Makefile	2007-11-10 12:10:46.000000000 +0800
@@ -0,0 +1,93 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4730.o cpu.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=128 if=/dev/zero of=$(nandobj)/junk
+	cat $< $(nandobj)/junk > $(nandobj)/junk2
+	dd bs=1024 count=128 if=$(nandobj)/junk2 of=$@
+	rm -f $(nandobj)/junk $(nandobj)/junk2
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4730.c:
+	@rm -f $(obj)nand_boot_jz4730.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4730.c $(obj)nand_boot_jz4730.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv1/u-boot.lds u-boot-1.1.6/nand_spl/board/pmpv1/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv1/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pmpv1/u-boot.lds	2007-05-28 15:08:27.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv2/config.mk u-boot-1.1.6/nand_spl/board/pmpv2/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv2/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pmpv2/config.mk	2007-05-28 15:08:27.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4730 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv2/Makefile u-boot-1.1.6/nand_spl/board/pmpv2/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pmpv2/Makefile	2007-11-10 12:31:34.000000000 +0800
@@ -0,0 +1,93 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4730.o cpu.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=128 if=/dev/zero of=$(nandobj)/junk
+	cat $< $(nandobj)/junk > $(nandobj)/junk2
+	dd bs=1024 count=128 if=$(nandobj)/junk2 of=$@
+	rm -f $(nandobj)/junk $(nandobj)/junk2
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4730.c:
+	@rm -f $(obj)nand_boot_jz4730.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4730.c $(obj)nand_boot_jz4730.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv2/u-boot.lds u-boot-1.1.6/nand_spl/board/pmpv2/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/pmpv2/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/pmpv2/u-boot.lds	2007-05-28 15:08:27.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt/config.mk u-boot-1.1.6/nand_spl/board/slt/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt/config.mk	2007-08-29 14:14:57.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4730 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt/Makefile u-boot-1.1.6/nand_spl/board/slt/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt/Makefile	2007-11-10 12:10:46.000000000 +0800
@@ -0,0 +1,93 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4730.o cpu.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=128 if=/dev/zero of=$(nandobj)/junk
+	cat $< $(nandobj)/junk > $(nandobj)/junk2
+	dd bs=1024 count=128 if=$(nandobj)/junk2 of=$@
+	rm -f $(nandobj)/junk $(nandobj)/junk2
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+#$(obj)nand_boot_jz4730.c:
+#	@rm -f $(obj)nand_boot_jz4730.c
+#	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4730.c $(obj)nand_boot_jz4730.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt/nand_boot_jz4730.c u-boot-1.1.6/nand_spl/board/slt/nand_boot_jz4730.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt/nand_boot_jz4730.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt/nand_boot_jz4730.c	2007-08-29 14:14:57.000000000 +0800
@@ -0,0 +1,448 @@
+/*
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/jz4730.h>
+
+#define SLOW_MEM    1
+
+
+/*
+ * HW ECC info
+ */
+#define NAND_ECC_ENABLE		1
+
+#define ECC_BLOCK		256 /* 3-bytes HW ECC per 256-bytes data */
+#define ECC_POS			4   /* ECC offset to spare area */
+
+/*
+ * NAND flash routines
+ */
+#define __nand_enable()		(REG_EMC_NFCSR |= EMC_NFCSR_NFE | EMC_NFCSR_FCE)
+#define __nand_disable()	(REG_EMC_NFCSR &= ~(EMC_NFCSR_NFE | EMC_NFCSR_FCE))
+#define __nand_ecc_enable()	(REG_EMC_NFCSR |= EMC_NFCSR_ECCE | EMC_NFCSR_ERST)
+#define __nand_ecc_disable()	(REG_EMC_NFCSR &= ~EMC_NFCSR_ECCE)
+#define __nand_dev_ready()	while (!(REG_EMC_NFCSR & EMC_NFCSR_RB))
+#define __nand_ecc()		(REG_EMC_NFECC & 0x00ffffff)
+#define __nand_cmd(n)		(REG8(NAND_COMMPORT) = (n))
+#define __nand_addr(n)		(REG8(NAND_ADDRPORT) = (n))
+#define __nand_data8()		REG8(NAND_DATAPORT)
+#define __nand_data16()		REG16(NAND_DATAPORT)
+
+/*
+ * NAND flash parameters
+ */
+static int bus_width = 8;
+static int page_size = 2048;
+static int oob_size = 64;
+static int ecc_count = 4;
+static int row_cycle = 3;
+static int page_per_block = 64;
+static int bad_block_pos = 0;
+static int block_size = 131072;
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+
+/*
+ * Init SDRAM memory.
+ */
+#define CPU_CLK (CFG_CPU_SPEED)
+#define MEM_CLK (CFG_CPU_SPEED/3)
+
+static void sdram_init(void)
+{
+	register unsigned int dmcr, sdmode, tmp, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	REG_EMC_BCR = EMC_BCR_BRE;	/* Enable SPLIT */
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_DISABLE;
+	REG_EMC_RTCOR = 0;
+	REG_EMC_RTCNT = 0;
+
+	/* Basic DMCR register value. */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg parameters */
+	ns = 1000000000 / MEM_CLK;
+
+#if SLOW_MEM
+	dmcr |= 0xfffc;
+#else
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4)
+		tmp = 4;
+	if (tmp > 11)
+		tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7)
+		tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14)
+		tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+#endif
+	/* SDRAM mode values */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	if (SDRAM_BW16)
+		sdmode <<= 1;
+	else
+		sdmode <<= 2;
+
+	/* First, precharge phase */
+	REG_EMC_DMCR = dmcr;
+
+	/* Set refresh registers */
+#if SLOW_MEM
+	REG_EMC_RTCOR = 1;
+#else
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff)
+		tmp = 0xff;
+
+	REG_EMC_RTCOR = tmp;
+#endif
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* precharge all chip-selects */
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+	/* wait for precharge, > 200us */
+	tmp = (CPU_CLK / 1000000) * 200;
+	while (tmp--);
+
+	/* enable refresh and set SDRAM mode */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* write sdram mode register for each chip-select */
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+	/* everything is ok now */
+}
+
+/* Init PLL
+ *
+ * PLL output = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+static void pll_init(void)
+{
+	unsigned int nf, plcr1;
+
+	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+	plcr1 = ((nf-2) << CPM_PLCR1_PLL1FD_BIT) |
+		(0 << CPM_PLCR1_PLL1RD_BIT) |	/* RD=0, NR=2, 1.8432 = 3.6864/2 */
+		(0 << CPM_PLCR1_PLL1OD_BIT) |   /* OD=0, NO=1 */
+		(0x20 << CPM_PLCR1_PLL1ST_BIT) | /* PLL stable time */
+		CPM_PLCR1_PLL1EN;                /* enable PLL */          
+
+	/* Clock divisors.
+	 * 
+	 * CFCR values: when CPM_CFCR_UCS(bit 28) is set, select external USB clock.
+	 *
+	 * 0x10411110 -> 1:2:2:2:2
+	 * 0x10422220 -> 1:3:3:3:3
+	 * 0x10433330 -> 1:4:4:4:4
+	 * 0x10444440 -> 1:6:6:6:6
+	 * 0x10455550 -> 1:8:8:8:8
+	 * 0x10466660 -> 1:12:12:12:12
+	 */
+//	REG_CPM_CFCR = 0x00422220 | (((CFG_CPU_SPEED/48000000) - 1) << 25); /* 1:3 */
+	REG_CPM_CFCR = 0x00433330 | (((CFG_CPU_SPEED/48000000) - 1) << 25); /* 1:4 */
+
+	/* PLL out frequency */
+	REG_CPM_PLCR1 = plcr1;
+}
+
+static void gpio_init(void)
+{
+#if (CFG_UART_BASE == UART0_BASE)
+	__gpio_as_uart0();
+#endif
+#if (CFG_UART_BASE == UART1_BASE)
+	__gpio_as_uart1();
+#endif
+#if (CFG_UART_BASE == UART2_BASE)
+	__gpio_as_uart2();
+#endif
+#if (CFG_UART_BASE == UART3_BASE)
+	__gpio_as_uart3();
+#endif
+	__gpio_as_emc();
+}
+
+/* NAND flash routines */
+
+static inline void nand_read_buf16(void *buf, int count)
+{
+	int i;
+	u16 *p = (u16 *)buf;
+
+	for (i = 0; i < count; i += 2)
+		*p++ = __nand_data16();
+}
+
+static inline void nand_read_buf8(void *buf, int count)
+{
+	int i;
+	u8 *p = (u8 *)buf;
+
+	for (i = 0; i < count; i++)
+		*p++ = __nand_data8();
+}
+
+static inline void nand_read_buf(void *buf, int count, int bw)
+{
+	if (bw == 8)
+		nand_read_buf8(buf, count);
+	else
+		nand_read_buf16(buf, count);
+}
+
+#ifdef NAND_ECC_ENABLE
+
+/* Detect and correct a 1 bit error for 256 byte block */
+
+static int nand_correct_data(uchar *dat, uchar *read_ecc, uchar *calc_ecc)
+{
+	uchar d1, d2, d3;
+	ulong d, bit, i, j;
+
+	/* Do error detection */ 
+	d1 = calc_ecc[0] ^ read_ecc[0];
+	d2 = calc_ecc[1] ^ read_ecc[1];
+	d3 = calc_ecc[2] ^ read_ecc[2];
+
+	d = (d3 << 16) | (d2 << 8) | d1;
+
+	if (d == 0) {
+		/* No errors */
+		return 0;
+	}
+
+	/* Found and will correct single bit error in the data */
+	bit = 0;
+	for (i = 0; i < 24; i++) {
+		if ((d >> i) & 0x1)
+			bit++;
+	}
+
+	if (bit != 11) {
+		/* Uncorrectable Error */
+		return -2;
+	} else {
+		/* ECC Code Error Correction */
+		bit = 0;
+		for (i = 12; i >= 1; i--) {
+			bit <<= 1;
+			bit |= ((d>>(i*2-1)) & 0x1);
+		}
+		j = bit & 0x07;
+		dat[(bit >> 3)] ^= (1 << j);
+		return 1;
+	}
+}
+#endif /* NAND_ECC_ENABLE */
+
+static int nand_read_page(int block, int page, uchar *dst, uchar *oob_buf, ulong *calc_ecc)
+{
+	int page_addr = page + block * page_per_block;
+	uchar *databuf = dst;
+	ulong *eccbuf = calc_ecc;
+	int i;
+
+	/* Send READ0 command */
+	__nand_cmd(NAND_CMD_READ0);
+
+	/* Send column address */
+	__nand_addr(0);
+	if (page_size == 2048)
+		__nand_addr(0);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 ps NAND */
+	if (page_size == 2048)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	__nand_dev_ready();
+
+	/* Read page data */
+	for (i = 0; i < ecc_count; i++) {
+		__nand_ecc_enable();
+		nand_read_buf((void *)databuf, ECC_BLOCK, bus_width);
+		__nand_ecc_disable();
+		eccbuf[i] = __nand_ecc();
+		databuf += ECC_BLOCK;
+	}
+
+	/* Read oob data */
+	nand_read_buf((void *)oob_buf, oob_size, bus_width);
+
+
+	return 0;
+}
+
+static int nand_load(int offs, int uboot_size, uchar *dst)
+{
+	int block;
+	int blockcopy_count;
+	int page;
+	int i;
+	uchar oob_buf[64];
+	ulong calc_ecc[16];
+	ulong *read_ecc;
+
+	__nand_enable();
+
+	/*
+	 * offs has to be aligned to a block address!
+	 */
+	block = offs / block_size;
+	blockcopy_count = 0;
+
+	while (blockcopy_count < (uboot_size / block_size)) {
+		for (page = 0; page < page_per_block; page++) {
+			nand_read_page(block, page, dst, oob_buf, calc_ecc);
+
+			if (page == 0) {
+				if (oob_buf[bad_block_pos] != 0xff) {
+					block++;
+
+					/*
+					 * Skip bad block
+					 */
+					continue;
+				}
+			}
+#ifdef NAND_ECC_ENABLE
+			read_ecc = (ulong *)(((u32)oob_buf) + ECC_POS);
+			for (i = 0; i < ecc_count; i++) {
+				nand_correct_data(dst + i * ECC_BLOCK, (uchar *)(read_ecc + i), (uchar *)(calc_ecc + i));
+			}
+#endif
+
+			dst += page_size;
+
+		}
+
+		block++;
+		blockcopy_count++;
+	}
+
+	__nand_disable();
+
+	return 0;
+}
+
+void nand_boot(void)
+{
+	int boot_sel, ret;
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nNAND Secondary Program Loader\n\n");
+
+	pll_init();
+	sdram_init();
+
+	/*
+	 * Decode the CPU boot select
+	 */
+	boot_sel = (REG_EMC_NFCSR & 0x70) >> 4;
+	bus_width = (boot_sel & 0x1) ? 16 : 8;
+	page_size = (boot_sel & 0x2) ? 2048 : 512;
+	row_cycle = (boot_sel & 0x4) ? 3 : 2;
+	page_per_block = (page_size == 2048) ? 64 : 32;
+	bad_block_pos = (page_size == 2048) ? 0 : 5;
+	ecc_count = page_size / ECC_BLOCK;
+	oob_size = page_size / 32;
+	block_size = page_size * page_per_block;
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	ret = nand_load(CFG_NAND_U_BOOT_OFFS, CFG_NAND_U_BOOT_SIZE,
+			(uchar *)CFG_NAND_U_BOOT_DST);
+
+	uboot = (void (*)(void))CFG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt/u-boot.lds u-boot-1.1.6/nand_spl/board/slt/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt/u-boot.lds	2007-08-29 14:14:57.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/config.mk u-boot-1.1.6/nand_spl/board/slt_50/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt_50/config.mk	2008-12-10 19:51:39.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic apus Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4750 platforms the SPL is located at 0x80000000...0x80002000,
+# in the first 8KBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/cpu.c u-boot-1.1.6/nand_spl/board/slt_50/cpu.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/cpu.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt_50/cpu.c	2008-12-10 19:51:39.000000000 +0800
@@ -0,0 +1,180 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/inca-ip.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+
+#ifdef CONFIG_JZ4730
+#include <asm/jz4730.h>
+#endif
+
+#ifdef CONFIG_JZ4740
+#include <asm/jz4740.h>
+#endif
+
+#ifdef CONFIG_JZ5730
+#include <asm/jz5730.h>
+#endif
+
+#ifdef CONFIG_JZ4750
+#include <asm/jz4750.h>
+#endif
+
+#if !defined (CONFIG_NAND_SPL) && !defined (CONFIG_MSC_SPL) 
+
+int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+#ifdef CONFIG_JZ4730
+	__wdt_set_count(0xffffffff-32);
+	__wdt_start();
+	while(1);
+#endif
+#ifdef CONFIG_JZ4740
+	__wdt_select_extalclk();
+	__wdt_select_clk_div64();
+	__wdt_set_data(100);
+	__wdt_set_count(0);
+	__tcu_start_wdt_clock();
+	__wdt_start();
+	while(1);
+#endif
+#if defined(CONFIG_INCA_IP)
+	*INCA_IP_WDT_RST_REQ = 0x3f;
+#elif defined(CONFIG_PURPLE) || defined(CONFIG_TB0229) || defined(CONFIG_JzRISC)
+	void (*f)(void) = (void *) 0xbfc00000;
+
+	f();
+#endif
+	fprintf(stderr, "*** reset failed ***\n");
+	return 0;
+}
+
+#define cache16_unroll32(base,op)				\
+	__asm__ __volatile__("					\
+		.set noreorder;					\
+		.set mips3;					\
+		cache %1, 0x000(%0); cache %1, 0x010(%0);	\
+		cache %1, 0x020(%0); cache %1, 0x030(%0);	\
+		cache %1, 0x040(%0); cache %1, 0x050(%0);	\
+		cache %1, 0x060(%0); cache %1, 0x070(%0);	\
+		cache %1, 0x080(%0); cache %1, 0x090(%0);	\
+		cache %1, 0x0a0(%0); cache %1, 0x0b0(%0);	\
+		cache %1, 0x0c0(%0); cache %1, 0x0d0(%0);	\
+		cache %1, 0x0e0(%0); cache %1, 0x0f0(%0);	\
+		cache %1, 0x100(%0); cache %1, 0x110(%0);	\
+		cache %1, 0x120(%0); cache %1, 0x130(%0);	\
+		cache %1, 0x140(%0); cache %1, 0x150(%0);	\
+		cache %1, 0x160(%0); cache %1, 0x170(%0);	\
+		cache %1, 0x180(%0); cache %1, 0x190(%0);	\
+		cache %1, 0x1a0(%0); cache %1, 0x1b0(%0);	\
+		cache %1, 0x1c0(%0); cache %1, 0x1d0(%0);	\
+		cache %1, 0x1e0(%0); cache %1, 0x1f0(%0);	\
+		.set mips0;					\
+		.set reorder"					\
+		:						\
+		: "r" (base),					\
+		  "i" (op));
+
+void flush_cache (ulong start_addr, ulong size)
+{
+#ifdef CONFIG_JzRISC
+	unsigned long start = start_addr;
+	unsigned long end = start + size;
+
+	while (start < end) {
+		cache16_unroll32(start,Hit_Writeback_Inv_D);
+		start += 0x200;
+	}
+#endif
+}
+
+void write_one_tlb( int index, u32 pagemask, u32 hi, u32 low0, u32 low1 ){
+	write_32bit_cp0_register(CP0_ENTRYLO0, low0);
+	write_32bit_cp0_register(CP0_PAGEMASK, pagemask);
+	write_32bit_cp0_register(CP0_ENTRYLO1, low1);
+	write_32bit_cp0_register(CP0_ENTRYHI, hi);
+	write_32bit_cp0_register(CP0_INDEX, index);
+	tlb_write_indexed();
+}
+
+#endif /* !CONFIG_NAND_SPL */
+
+#ifdef CONFIG_JzRISC
+
+void flush_icache_all(void)
+{
+	u32 addr, t = 0;
+
+	asm volatile ("mtc0 $0, $28"); /* Clear Taglo */
+	asm volatile ("mtc0 $0, $29"); /* Clear TagHi */
+
+	for (addr = K0BASE; addr < K0BASE + CFG_ICACHE_SIZE;
+	     addr += CFG_CACHELINE_SIZE) {
+		asm volatile (
+			".set mips3\n\t"
+			" cache %0, 0(%1)\n\t"
+			".set mips2\n\t"
+			:
+			: "I" (Index_Store_Tag_I), "r"(addr));
+	}
+
+	/* invalicate btb */
+	asm volatile (
+		".set mips32\n\t"
+		"mfc0 %0, $16, 7\n\t"
+		"nop\n\t"
+		"ori %0,2\n\t"
+		"mtc0 %0, $16, 7\n\t"
+		".set mips2\n\t"
+		:
+		: "r" (t));
+}
+
+void flush_dcache_all(void)
+{
+	u32 addr;
+
+	for (addr = K0BASE; addr < K0BASE + CFG_DCACHE_SIZE; 
+	     addr += CFG_CACHELINE_SIZE) {
+		asm volatile (
+			".set mips3\n\t"
+			" cache %0, 0(%1)\n\t"
+			".set mips2\n\t"
+			:
+			: "I" (Index_Writeback_Inv_D), "r"(addr));
+	}
+
+	asm volatile ("sync");
+}
+
+void flush_cache_all(void)
+{
+	flush_dcache_all();
+	flush_icache_all();
+}
+
+#endif
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/jz4750.c u-boot-1.1.6/nand_spl/board/slt_50/jz4750.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/jz4750.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt_50/jz4750.c	2008-12-10 19:51:39.000000000 +0800
@@ -0,0 +1,604 @@
+/*
+ * Jz4750 common routines
+ *
+ *  Copyright (c) 2006
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_JZ4750
+
+#include <common.h>
+#include <command.h>
+
+#include <asm/jz4750.h>
+
+extern void board_early_init(void);
+
+/* PLL output clock = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+void pll_init(void)
+{
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 4, 4, 4, 4}; /* divisors of I:S:P:L:M */
+	int nf, pllout2;
+
+	cfcr = 	CPM_CPCCR_PCS |
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	if (CFG_EXTAL > 16000000)
+		cfcr |= CPM_CPCCR_ECS;
+	else
+		cfcr &= ~CPM_CPCCR_ECS;
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? CFG_CPU_SPEED : (CFG_CPU_SPEED / 2);
+
+	/* Init USB Host clock, pllout2 must be n*48MHz */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+
+	nf = CFG_CPU_SPEED  / 1000000;
+//	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(22 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void pll_add_test(int new_freq)
+{
+//	serial_out("pll_add_test\n");
+	register unsigned int cfcr, plcr1;
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[5] = {1, 6, 6, 6, 6}; /* divisors of I:S:P:M:L */
+//	int div[5] = {1, 4, 4, 4, 4}; /* divisors of I:S:P:M:L */
+	int nf, pllout2;
+
+	cfcr = 	(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) | 
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) | 
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT) |
+		(n2FR[div[4]] << CPM_CPCCR_LDIV_BIT);
+
+	if (CFG_EXTAL > 16000000)
+		cfcr |= CPM_CPCCR_ECS;
+	else
+		cfcr &= ~CPM_CPCCR_ECS;
+
+
+	pllout2 = (cfcr & CPM_CPCCR_PCS) ? new_freq : (new_freq / 2);
+
+	/* Init UHC clock */
+	REG_CPM_UHCCDR = pllout2 / 48000000 - 1;
+	
+	//nf = new_freq * 2 / CFG_EXTAL;
+	nf = new_freq / 1000000; //step length is 1M
+	plcr1 = ((nf - 2) << CPM_CPPCR_PLLM_BIT) | /* FD */
+		(22 << CPM_CPPCR_PLLN_BIT) |	/* RD=0, NR=2 */
+		(0 << CPM_CPPCR_PLLOD_BIT) |    /* OD=0, NO=1 */
+		(0x20 << CPM_CPPCR_PLLST_BIT) | /* PLL stable time */
+		CPM_CPPCR_PLLEN;                /* enable PLL */          
+
+	/* init PLL */
+	REG_CPM_CPCCR = cfcr;
+	REG_CPM_CPPCR = plcr1;
+}
+
+void calc_clocks_add_test(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+void sdram_add_test(int new_freq)
+{
+	register unsigned int dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = new_freq;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_DISABLE;
+	REG_EMC_RTCOR = 0;
+	REG_EMC_RTCNT = 0;
+
+	/* Basic DMCR register value. */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg parameters */
+	ns = 1000000000 / mem_clk;
+
+#if 0
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+#else
+	dmcr |= 0xfffc;
+#endif
+
+	/* First, precharge phase */
+	REG_EMC_DMCR = dmcr;
+
+	/* Set refresh registers */
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* SDRAM mode values */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* precharge all chip-selects */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 200;
+	while (tmp--);
+
+	/* enable refresh and set SDRAM mode */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* write sdram mode register for each chip-select */
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/* everything is ok now */
+}
+
+void sdram_init(void)
+{
+	register unsigned int dmcr, sdmode, tmp, cpu_clk, mem_clk, ns;
+
+#ifdef CONFIG_MOBILE_SDRAM
+	register unsigned int sdemode; /*SDRAM Extended Mode*/
+#endif
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	cpu_clk = CFG_CPU_SPEED;
+	mem_clk = cpu_clk * div[__cpm_get_cdiv()] / div[__cpm_get_mdiv()];
+
+	/*set REG_EMC_DMARn for two 64M sdram*/
+	REG_EMC_DMAR0 = EMC_DMAR0_BASE | EMC_DMAR_MASK_64_64;
+
+#if CONFIG_NR_DRAM_BANKS == 2   /*Use Two Banks SDRAM*/
+	REG_EMC_DMAR1 = EMC_DMAR1_BASE_64M | EMC_DMAR_MASK_64_64; 
+#endif
+
+	REG_EMC_BCR = 0;	/* Disable bus release */
+	REG_EMC_RTCSR = 0;	/* Disable clock for counting */
+
+	/* Basic DMCR value */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg */
+	ns = 1000000000 / mem_clk;
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4) tmp = 4;
+	if (tmp > 11) tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7) tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3) tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14) tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode value */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Stage 1. Precharge all banks by writing SDMR with DMCR.MRSET=0 */
+	REG_EMC_DMCR = dmcr;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+	/*Precharge Bank1 SDRAM*/
+#if CONFIG_NR_DRAM_BANKS == 2   
+	REG_EMC_DMCR = dmcr | EMC_DMCR_MBSEL_B1;
+	REG8(EMC_SDMR0|sdmode) = 0;
+#endif
+
+#ifdef CONFIG_MOBILE_SDRAM
+	/* Mobile SDRAM Extended Mode Register */
+	sdemode = EMC_SDMR_SET_BA1 | EMC_SDMR_DS_FULL | EMC_SDMR_PRSR_ALL;
+#endif
+
+	/* Wait for precharge, > 200us */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 2. Enable auto-refresh */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH;
+
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff) tmp = 0xff;
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCNT = 0;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* Wait for number of auto-refresh cycles */
+	tmp = (cpu_clk / 1000000) * 1000;
+	while (tmp--);
+
+ 	/* Stage 3. Mode Register Set */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET | EMC_DMCR_MBSEL_B0;
+	REG8(EMC_SDMR0|sdmode) = 0;
+
+
+#ifdef CONFIG_MOBILE_SDRAM
+	REG8(EMC_SDMR0|sdemode) = 0;   	/* Set Mobile SDRAM Extended Mode Register */
+#endif
+
+#if CONFIG_NR_DRAM_BANKS == 2
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET | EMC_DMCR_MBSEL_B1;
+	REG8(EMC_SDMR0|sdmode) = 0;	/* Set Bank1 SDRAM Register */
+
+
+#ifdef CONFIG_MOBILE_SDRAM
+	REG8(EMC_SDMR0|sdemode) = 0;	/* Set Mobile SDRAM Extended Mode Register */
+#endif
+
+#endif   /*CONFIG_NR_DRAM_BANKS == 2*/
+
+	/* Set back to basic DMCR value */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* everything is ok now */
+}
+
+#ifndef CONFIG_NAND_SPL
+
+static void calc_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_FPGA
+	unsigned int pllout;
+	unsigned int div[10] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	pllout = __cpm_get_pllout();
+
+	gd->cpu_clk = pllout / div[__cpm_get_cdiv()];
+	gd->sys_clk = pllout / div[__cpm_get_hdiv()];
+	gd->per_clk = pllout / div[__cpm_get_pdiv()];
+	gd->mem_clk = pllout / div[__cpm_get_mdiv()];
+	gd->dev_clk = CFG_EXTAL;
+#else
+	gd->cpu_clk = gd->sys_clk = gd->per_clk = 
+		gd->mem_clk = gd->dev_clk = CFG_EXTAL;
+#endif
+}
+
+static void rtc_init(void)
+{
+
+	while ( !__rtc_write_ready()) ;
+	__rtc_enable_alarm();	/* enable alarm */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_RGR   = 0x00007fff; /* type value */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HWFCR = 0x0000ffe0; /* Power on delay 2s */
+
+	while ( !__rtc_write_ready()) 
+		;
+	REG_RTC_HRCR  = 0x00000fe0; /* reset delay 125ms */
+
+}
+
+
+//----------------------------------------------------------------------
+// jz4750 board init routine
+
+int jz_board_init(void)
+{
+	board_early_init();  /* init gpio, pll etc. */
+#ifndef CONFIG_NAND_U_BOOT
+#ifndef CONFIG_FPGA
+	pll_init();          /* init PLL */
+#endif
+	serial_init();
+	sdram_init();        /* init sdram memory */
+#endif
+#if defined CONFIG_MSC_U_BOOT
+	pll_init();          /* init PLL */
+#endif
+	calc_clocks();       /* calc the clocks */
+#ifndef CONFIG_FPGA
+	rtc_init();		/* init rtc on any reset: */
+#endif
+	return 0;
+}
+
+//----------------------------------------------------------------------
+// U-Boot common routines
+
+long int initdram(int board_type)
+{
+	u32 dmcr;
+	u32 rows, cols, dw, banks;
+	ulong size;
+
+	dmcr = REG_EMC_DMCR;
+	rows = 11 + ((dmcr & EMC_DMCR_RA_MASK) >> EMC_DMCR_RA_BIT);
+	cols = 8 + ((dmcr & EMC_DMCR_CA_MASK) >> EMC_DMCR_CA_BIT);
+	dw = (dmcr & EMC_DMCR_BW) ? 2 : 4;
+	banks = (dmcr & EMC_DMCR_BA) ? 4 : 2;
+
+	size = (1 << (rows + cols)) * dw * banks;
+	size *= CONFIG_NR_DRAM_BANKS;
+
+	return size;
+}
+
+//----------------------------------------------------------------------
+// Timer routines
+
+#define TIMER_CHAN  0
+#define TIMER_FDATA 0xffff  /* Timer full data value */
+#define TIMER_HZ    CFG_HZ
+
+#define READ_TIMER  REG_TCU_TCNT(TIMER_CHAN)  /* macro to read the 16 bit timer */
+
+static ulong timestamp;
+static ulong lastdec;
+
+void	reset_timer_masked	(void);
+ulong	get_timer_masked	(void);
+void	udelay_masked		(unsigned long usec);
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	REG_TCU_TCSR(TIMER_CHAN) = TCU_TCSR_PRESCALE256 | TCU_TCSR_EXT_EN;
+	REG_TCU_TCNT(TIMER_CHAN) = 0;
+	REG_TCU_TDHR(TIMER_CHAN) = 0;
+	REG_TCU_TDFR(TIMER_CHAN) = TIMER_FDATA;
+
+	REG_TCU_TMSR = (1 << TIMER_CHAN) | (1 << (TIMER_CHAN + 16)); /* mask irqs */
+	REG_TCU_TSCR = (1 << TIMER_CHAN); /* enable timer clock */
+	REG_TCU_TESR = (1 << TIMER_CHAN); /* start counting up */
+
+	lastdec = 0;
+	timestamp = 0;
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void udelay (unsigned long usec)
+{
+	ulong tmo,tmp;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	}
+	else {
+		if (usec >= 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		}
+		else
+			tmo = 1;
+	}
+
+	/* check for rollover during this delay */
+	tmp = get_timer (0);
+	if ((tmp + tmo) < tmp )
+		reset_timer_masked();  /* timer would roll over */
+	else
+		tmo += tmp;
+
+	while (get_timer_masked () < tmo);
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;
+	timestamp = 0;
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;
+
+	if (lastdec <= now) {
+		/* normal mode */
+		timestamp += (now - lastdec);
+	} else {
+		/* we have an overflow ... */
+		timestamp += TIMER_FDATA + now - lastdec;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	/* normalize */
+	if (usec >= 1000) {
+		tmo = usec / 1000;
+		tmo *= TIMER_HZ;
+		tmo /= 1000;
+	} else {
+		if (usec > 1) {
+			tmo = usec * TIMER_HZ;
+			tmo /= (1000*1000);
+		} else {
+			tmo = 1;
+		}
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	return TIMER_HZ;
+}
+
+#endif /* CONFIG_NAND_SPL */
+
+//---------------------------------------------------------------------
+// End of timer routine.
+//---------------------------------------------------------------------
+
+#endif /* CONFIG_JZ4750 */
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/jz_serial.c u-boot-1.1.6/nand_spl/board/slt_50/jz_serial.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/jz_serial.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt_50/jz_serial.c	2008-12-10 19:51:39.000000000 +0800
@@ -0,0 +1,161 @@
+/*
+ * Jz47xx UART support
+ *
+ * Hardcoded to UART 0 for now
+ * Options also hardcoded to 8N1
+ *
+ *  Copyright (c) 2005
+ *  Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#if defined(CONFIG_JZ4730) || defined(CONFIG_JZ4740) || defined(CONFIG_JZ4750) || defined(CONFIG_JZ5730)
+
+#include <common.h>
+
+#if defined(CONFIG_JZ4730)
+#include <asm/jz4730.h>
+#endif
+#if defined(CONFIG_JZ4740)
+#include <asm/jz4740.h>
+#endif
+#if defined(CONFIG_JZ4750)
+#include <asm/jz4750.h>
+#endif
+#if defined(CONFIG_JZ5730)
+#include <asm/jz5730.h>
+#endif
+
+#undef UART_BASE
+#ifndef CFG_UART_BASE
+#define UART_BASE  UART0_BASE
+#else
+#define UART_BASE  CFG_UART_BASE
+#endif
+
+/******************************************************************************
+*
+* serial_init - initialize a channel
+*
+* This routine initializes the number of data bits, parity
+* and set the selected baud rate. Interrupts are disabled.
+* Set the modem control signals if the option is selected.
+*
+* RETURNS: N/A
+*/
+
+int serial_init (void)
+{
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+	volatile u8 *uart_fcr = (volatile u8 *)(UART_BASE + OFF_FCR);
+	volatile u8 *uart_lcr = (volatile u8 *)(UART_BASE + OFF_LCR);
+	volatile u8 *uart_ier = (volatile u8 *)(UART_BASE + OFF_IER);
+	volatile u8 *uart_sircr = (volatile u8 *)(UART_BASE + OFF_SIRCR);
+
+	/* Disable port interrupts while changing hardware */
+	*uart_ier = 0;
+
+	/* Disable UART unit function */
+	*uart_fcr = ~UART_FCR_UUE;
+
+	/* Set both receiver and transmitter in UART mode (not SIR) */
+	*uart_sircr = ~(SIRCR_RSIRE | SIRCR_TSIRE);
+
+	/* Set databits, stopbits and parity. (8-bit data, 1 stopbit, no parity) */
+	*uart_lcr = UART_LCR_WLEN_8 | UART_LCR_STOP_1;
+	
+	/* Set baud rate */
+	serial_setbrg();
+	
+	/* Enable UART unit, enable and clear FIFO */
+	*uart_fcr = UART_FCR_UUE | UART_FCR_FE | UART_FCR_TFLS | UART_FCR_RFLS;
+#endif
+	return 0;
+}
+
+void serial_setbrg (void)
+{
+	volatile u8 *uart_lcr = (volatile u8 *)(UART_BASE + OFF_LCR);
+	volatile u8 *uart_dlhr = (volatile u8 *)(UART_BASE + OFF_DLHR);
+	volatile u8 *uart_dllr = (volatile u8 *)(UART_BASE + OFF_DLLR);
+	u32 baud_div, tmp;
+
+#if defined(CONFIG_JZ4750)
+	if (CFG_EXTAL > 16000000) {
+		REG_CPM_CPCCR |= CPM_CPCCR_ECS;
+		baud_div = CFG_EXTAL / 32 / CONFIG_BAUDRATE;
+	} else {
+		REG_CPM_CPCCR &= ~CPM_CPCCR_ECS;
+		baud_div = CFG_EXTAL / 16 / CONFIG_BAUDRATE;
+	}
+#else /* CONFIG_JZ4740 | CONFIG_JZ4730 */
+	baud_div = CFG_EXTAL / 16 / CONFIG_BAUDRATE;
+#endif
+	tmp = *uart_lcr;
+	tmp |= UART_LCR_DLAB;
+	*uart_lcr = tmp;
+
+	*uart_dlhr = (baud_div >> 8) & 0xff;
+	*uart_dllr = baud_div & 0xff;
+
+	tmp &= ~UART_LCR_DLAB;
+	*uart_lcr = tmp;
+}
+
+void serial_putc (const char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART_BASE + OFF_TDR);
+
+	if (c == '\n') serial_putc ('\r');
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UART_LSR_TDRQ | UART_LSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+int serial_getc (void)
+{
+	volatile u8 *uart_rdr = (volatile u8 *)(UART_BASE + OFF_RDR);
+
+	while (!serial_tstc());
+
+	return *uart_rdr;
+}
+
+int serial_tstc (void)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART_BASE + OFF_LSR);
+
+	if (*uart_lsr & UART_LSR_DR) {
+		/* Data in rfifo */
+		return (1);
+	}
+	return 0;
+}
+
+#endif /* CONFIG_JZ4730 || CONFIG_JZ4740 || CONFIG_JZ4750 || CONFIG_JZ45730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/Makefile u-boot-1.1.6/nand_spl/board/slt_50/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt_50/Makefile	2008-12-10 19:51:39.000000000 +0800
@@ -0,0 +1,100 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4750.o cpu.o jz4750.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(nandobj)junk1
+	cat $< $(nandobj)junk1 > $(nandobj)junk2
+	dd bs=1024 count=8 if=$(nandobj)junk2 of=$(nandobj)junk3
+	cat $(nandobj)junk3 $(nandobj)junk3 > $(nandobj)junk4
+	dd bs=1024 count=256 if=/dev/zero of=$(nandobj)junk5
+	cat $(nandobj)junk4 $(nandobj)junk5 > $(nandobj)junk6
+	dd bs=1024 count=256 if=$(nandobj)junk6 of=$@
+	rm -f $(nandobj)junk*
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4750.c:
+	@rm -f $(obj)jz4750.c
+	ln -s $(SRCTREE)/cpu/mips/jz4750.c $(obj)jz4750.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4750.c:
+	@rm -f $(obj)nand_boot_jz4750.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4750.c $(obj)nand_boot_jz4750.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/nand_boot_jz4750.c u-boot-1.1.6/nand_spl/board/slt_50/nand_boot_jz4750.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/nand_boot_jz4750.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt_50/nand_boot_jz4750.c	2008-12-10 19:51:39.000000000 +0800
@@ -0,0 +1,379 @@
+/*
+ * Copyright (C) 2007 Ingenic Semiconductor Inc.
+ * Author: Peter <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/jz4750.h>
+
+/*
+ * NAND flash definitions
+ */
+
+#define NAND_DATAPORT	0xb8000000
+unsigned int NAND_ADDRPORT;
+unsigned int NAND_COMMPORT;
+
+#define ECC_BLOCK	512
+#define ECC_POS		3
+static int par_size;
+
+#define __nand_cmd(n)		(REG8(NAND_COMMPORT) = (n))
+#define __nand_addr(n)		(REG8(NAND_ADDRPORT) = (n))
+#define __nand_data8()		REG8(NAND_DATAPORT)
+#define __nand_data16()		REG16(NAND_DATAPORT)
+
+#define __nand_enable()		(REG_EMC_NFCSR |= EMC_NFCSR_NFE1 | EMC_NFCSR_NFCE1)
+#define __nand_disable()	(REG_EMC_NFCSR &= ~(EMC_NFCSR_NFCE1))
+
+static inline void nand_wait_ready(void)
+{
+	unsigned int timeout = 1000;
+	while ((REG_GPIO_PXPIN(2) & 0x08000000) && timeout--);
+	while (!(REG_GPIO_PXPIN(2) & 0x08000000));
+}
+
+/*
+ * NAND flash parameters
+ */
+static int bus_width = 8;
+static int page_size = 2048;
+static int oob_size = 64;
+static int ecc_count = 4;
+static int row_cycle = 3;
+static int page_per_block = 64;
+static int bad_block_pos = 0;
+static int block_size = 131072;
+
+static unsigned char oob_buf[128] = {0};
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+extern void sdram_init(void);
+extern void pll_init(void);
+
+/*
+ * NAND flash routines
+ */
+
+static inline void nand_read_buf16(void *buf, int count)
+{
+	int i;
+	u16 *p = (u16 *)buf;
+
+	for (i = 0; i < count; i += 2)
+		*p++ = __nand_data16();
+}
+
+static inline void nand_read_buf8(void *buf, int count)
+{
+	int i;
+	u8 *p = (u8 *)buf;
+
+	for (i = 0; i < count; i++)
+		*p++ = __nand_data8();
+}
+
+static inline void nand_read_buf(void *buf, int count, int bw)
+{
+	if (bw == 8)
+		nand_read_buf8(buf, count);
+	else
+		nand_read_buf16(buf, count);
+}
+
+/*
+ * Correct the error bit in 512-bytes data
+ */
+static void bch_correct(unsigned char *dat, int idx)
+{
+	int i, bit;  // the 'bit' of i byte is error 
+	i = (idx - 1) >> 3;
+	bit = (idx - 1) & 0x7;
+	dat[i] ^= (1 << bit);
+}
+
+/*
+ * Read oob
+ */
+static int nand_read_oob(int page_addr, u8 *buf, int size)
+{
+	int col_addr;
+
+	if (page_size != 512)
+		col_addr = page_size;
+	else
+		col_addr = 0;
+
+	if (page_size != 512)
+		/* Send READ0 command */
+		__nand_cmd(NAND_CMD_READ0);
+	else
+		/* Send READOOB command */
+		__nand_cmd(NAND_CMD_READOOB);
+
+	/* Send column address */
+	__nand_addr(col_addr & 0xff);
+	if (page_size != 512)
+		__nand_addr((col_addr >> 8) & 0xff);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	nand_wait_ready();
+
+	/* Read oob data */
+	nand_read_buf(buf, size, bus_width);
+
+	if (page_size == 512)
+		nand_wait_ready();
+
+	return 0;
+}
+
+static int nand_read_page(int page_addr, uchar *dst, uchar *oobbuf)
+{
+	uchar *data_buf = dst;
+	int i, j;
+
+	/* Send READ0 command */
+	__nand_cmd(NAND_CMD_READ0);
+
+	/* Send column address */
+	__nand_addr(0);
+	if (page_size != 512)
+		__nand_addr(0);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	nand_wait_ready();
+
+	/* Read page data */
+	data_buf = dst;
+
+	/* Read data */
+	nand_read_buf((void *)data_buf, page_size, bus_width);
+	nand_read_buf((void *)oobbuf, oob_size, bus_width);
+
+	ecc_count = page_size / ECC_BLOCK;
+
+	for (i = 0; i < ecc_count; i++) {
+		unsigned int stat;
+      
+                /* Enable BCH decoding */
+		REG_BCH_INTS = 0xffffffff;
+		if (CFG_NAND_BCH_BIT == 8)
+			__ecc_decoding_8bit();
+		else
+			__ecc_decoding_4bit();
+
+                /* Write 512 bytes and par_size parities to REG_BCH_DR */
+		for (j = 0; j < ECC_BLOCK; j++) {
+			REG_BCH_DR = data_buf[j];
+		}
+
+		for (j = 0; j < par_size; j++) {
+			REG_BCH_DR = oob_buf[ECC_POS + i*par_size + j];
+		}
+
+		/* Wait for completion */
+		__ecc_decode_sync();
+		__ecc_disable();
+
+		/* Check decoding */
+		stat = REG_BCH_INTS;
+		if (stat & BCH_INTS_ERR) {
+			if (stat & BCH_INTS_UNCOR) {
+				/* Uncorrectable error occurred */
+				serial_puts("Uncorrectable\n");
+			}
+			else {
+				unsigned int errcnt = (stat & BCH_INTS_ERRC_MASK) >> BCH_INTS_ERRC_BIT;
+				switch (errcnt) {
+				case 8:
+					bch_correct(data_buf, (REG_BCH_ERR3 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 7:
+					bch_correct(data_buf, (REG_BCH_ERR3 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 6:
+					bch_correct(data_buf, (REG_BCH_ERR2 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 5:
+					bch_correct(data_buf, (REG_BCH_ERR2 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 4:
+					bch_correct(data_buf, (REG_BCH_ERR1 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 3:
+					bch_correct(data_buf, (REG_BCH_ERR1 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 2:
+					bch_correct(data_buf, (REG_BCH_ERR0 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 1:
+					bch_correct(data_buf, (REG_BCH_ERR0 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+		/* increment pointer */
+		data_buf += ECC_BLOCK;
+	}
+
+	return 0;
+}
+
+#ifndef CFG_NAND_BADBLOCK_PAGE
+#define CFG_NAND_BADBLOCK_PAGE 0 /* NAND bad block was marked at this page in a block, starting from 0 */
+#endif
+
+static void nand_load(int offs, int uboot_size, uchar *dst)
+{
+	int page;
+	int pagecopy_count;
+
+	__nand_enable();
+
+	page = offs / page_size;
+	pagecopy_count = 0;
+	while (pagecopy_count < (uboot_size / page_size)) {
+		if (page % page_per_block == 0) {
+			nand_read_oob(page + CFG_NAND_BADBLOCK_PAGE, oob_buf, oob_size);
+			if (oob_buf[bad_block_pos] != 0xff) {
+				page += page_per_block;
+				/* Skip bad block */
+				continue;
+			}
+		}
+		/* Load this page to dst, do the ECC */
+		nand_read_page(page, dst, oob_buf);
+
+		dst += page_size;
+		page++;
+		pagecopy_count++;
+	}
+
+	__nand_disable();
+}
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+	__gpio_as_sdram_32bit();
+
+	/*
+	 * Initialize UART3 pins
+	 */
+	switch (CFG_UART_BASE) {
+	case UART0_BASE:
+		__gpio_as_uart0();
+		break;
+	case UART1_BASE:
+		__gpio_as_uart1();
+		break;
+	case UART2_BASE:
+		__gpio_as_uart2();
+		break;
+	case UART3_BASE:
+		__gpio_as_uart3();
+		break;
+	}
+}
+
+void nand_boot(void)
+{
+	int boot_sel;
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nNAND Secondary Program Loader\n\n");
+
+	pll_init();
+	sdram_init();
+
+	/*
+	 * JZ4750 can get some NAND parameters from NAND infomation in fuwa.h
+	 */
+	bus_width = (CFG_NAND_BW8==1) ? 8 : 16;
+	page_size = CFG_NAND_PAGE_SIZE;
+	row_cycle = CFG_NAND_ROW_CYCLE;
+	block_size = CFG_NAND_BLOCK_SIZE;
+	page_per_block =  CFG_NAND_BLOCK_SIZE / CFG_NAND_PAGE_SIZE;
+	bad_block_pos = (page_size == 512) ? 5 : 0;
+	oob_size = page_size / 32;
+	ecc_count = page_size / ECC_BLOCK;
+	if (CFG_NAND_BCH_BIT == 8)
+		par_size = 13;
+	else
+		par_size = 7;
+
+	if ((REG_EMC_BCR & EMC_BCR_BSR_MASK) == EMC_BCR_BSR_SHARE) {
+		NAND_ADDRPORT =	0xb8010000;
+		NAND_COMMPORT =	0xb8008000;
+	} else {
+		NAND_ADDRPORT =	0xb8000010;
+		NAND_COMMPORT =	0xb8000008;
+	}
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	nand_load(CFG_NAND_U_BOOT_OFFS, CFG_NAND_U_BOOT_SIZE,
+		  (uchar *)CFG_NAND_U_BOOT_DST);
+
+	uboot = (void (*)(void))CFG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/start.S u-boot-1.1.6/nand_spl/board/slt_50/start.S
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/start.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt_50/start.S	2008-12-10 19:51:39.000000000 +0800
@@ -0,0 +1,668 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/cacheops.h>
+
+#ifdef CONFIG_JZ4730
+#include <asm/jz4730.h>
+#endif
+
+#ifdef CONFIG_JZ4740
+#include <asm/jz4740.h>
+#endif
+
+#ifdef CONFIG_JZ4750
+#include <asm/jz4750.h>
+#define JZ4750_NANDBOOT_CFG0 (0x55555500 | (CFG_NAND_BW8*0xff))
+#define JZ4750_NANDBOOT_CFG1 0x55555555	
+#define JZ4750_NANDBOOT_CFG2 ((CFG_NAND_PAGE_SIZE==2048)&0xff0000) | ((CFG_NAND_PAGE_SIZE!=512)&0xff00) | ((CFG_NAND_ROW_CYCLE==3)&0xff)
+#endif
+
+#define RVECENT(f,n) \
+   b f; nop
+#define XVECENT(f,bev) \
+   b f     ;           \
+   li k0,bev
+
+	.set noreorder
+
+	.globl _start
+	.text
+_start:
+#if defined(CONFIG_JZ4740)
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	.word JZ4740_NORBOOT_CFG	/* fetched during NOR Boot */
+#else
+#if defined(CONFIG_NAND_SPL)
+	.word JZ4740_NANDBOOT_CFG	/* fetched during NAND Boot */
+#endif
+#endif
+#endif /* CONFIG_JZ4740 */
+#if defined(CONFIG_JZ4750)
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	.word JZ4750_NORBOOT_CFG	/* fetched during NOR Boot */
+#else
+#if defined(CONFIG_NAND_SPL) && !defined(CONFIG_MSC_SPL)
+	/* First three words fetched by CPU during NAND Boot */
+	.word JZ4750_NANDBOOT_CFG0
+	.word JZ4750_NANDBOOT_CFG1
+	.word JZ4750_NANDBOOT_CFG2
+#endif
+#endif
+#endif /* CONFIG_JZ4750 */
+#if !defined(CONFIG_JzRISC)
+	RVECENT(reset,0)	/* U-boot entry point */
+	RVECENT(reset,1)	/* software reboot */
+#if defined(CONFIG_INCA_IP)
+	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
+	.word 0x00000000           /* phase of the flash                    */
+#elif defined(CONFIG_PURPLE)
+	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
+	.word INFINEON_EBU_BOOTCFG /* EBU init code, fetched during booting */
+#else
+	RVECENT(romReserved,2)
+#endif
+	RVECENT(romReserved,3)
+	RVECENT(romReserved,4)
+	RVECENT(romReserved,5)
+	RVECENT(romReserved,6)
+	RVECENT(romReserved,7)
+	RVECENT(romReserved,8)
+	RVECENT(romReserved,9)
+	RVECENT(romReserved,10)
+	RVECENT(romReserved,11)
+	RVECENT(romReserved,12)
+	RVECENT(romReserved,13)
+	RVECENT(romReserved,14)
+	RVECENT(romReserved,15)
+	RVECENT(romReserved,16)
+	RVECENT(romReserved,17)
+	RVECENT(romReserved,18)
+	RVECENT(romReserved,19)
+	RVECENT(romReserved,20)
+	RVECENT(romReserved,21)
+	RVECENT(romReserved,22)
+	RVECENT(romReserved,23)
+	RVECENT(romReserved,24)
+	RVECENT(romReserved,25)
+	RVECENT(romReserved,26)
+	RVECENT(romReserved,27)
+	RVECENT(romReserved,28)
+	RVECENT(romReserved,29)
+	RVECENT(romReserved,30)
+	RVECENT(romReserved,31)
+	RVECENT(romReserved,32)
+	RVECENT(romReserved,33)
+	RVECENT(romReserved,34)
+	RVECENT(romReserved,35)
+	RVECENT(romReserved,36)
+	RVECENT(romReserved,37)
+	RVECENT(romReserved,38)
+	RVECENT(romReserved,39)
+	RVECENT(romReserved,40)
+	RVECENT(romReserved,41)
+	RVECENT(romReserved,42)
+	RVECENT(romReserved,43)
+	RVECENT(romReserved,44)
+	RVECENT(romReserved,45)
+	RVECENT(romReserved,46)
+	RVECENT(romReserved,47)
+	RVECENT(romReserved,48)
+	RVECENT(romReserved,49)
+	RVECENT(romReserved,50)
+	RVECENT(romReserved,51)
+	RVECENT(romReserved,52)
+	RVECENT(romReserved,53)
+	RVECENT(romReserved,54)
+	RVECENT(romReserved,55)
+	RVECENT(romReserved,56)
+	RVECENT(romReserved,57)
+	RVECENT(romReserved,58)
+	RVECENT(romReserved,59)
+	RVECENT(romReserved,60)
+	RVECENT(romReserved,61)
+	RVECENT(romReserved,62)
+	RVECENT(romReserved,63)
+	XVECENT(romExcHandle,0x200)	/* bfc00200: R4000 tlbmiss vector */
+	RVECENT(romReserved,65)
+	RVECENT(romReserved,66)
+	RVECENT(romReserved,67)
+	RVECENT(romReserved,68)
+	RVECENT(romReserved,69)
+	RVECENT(romReserved,70)
+	RVECENT(romReserved,71)
+	RVECENT(romReserved,72)
+	RVECENT(romReserved,73)
+	RVECENT(romReserved,74)
+	RVECENT(romReserved,75)
+	RVECENT(romReserved,76)
+	RVECENT(romReserved,77)
+	RVECENT(romReserved,78)
+	RVECENT(romReserved,79)
+	XVECENT(romExcHandle,0x280)	/* bfc00280: R4000 xtlbmiss vector */
+	RVECENT(romReserved,81)
+	RVECENT(romReserved,82)
+	RVECENT(romReserved,83)
+	RVECENT(romReserved,84)
+	RVECENT(romReserved,85)
+	RVECENT(romReserved,86)
+	RVECENT(romReserved,87)
+	RVECENT(romReserved,88)
+	RVECENT(romReserved,89)
+	RVECENT(romReserved,90)
+	RVECENT(romReserved,91)
+	RVECENT(romReserved,92)
+	RVECENT(romReserved,93)
+	RVECENT(romReserved,94)
+	RVECENT(romReserved,95)
+	XVECENT(romExcHandle,0x300)	/* bfc00300: R4000 cache vector */
+	RVECENT(romReserved,97)
+	RVECENT(romReserved,98)
+	RVECENT(romReserved,99)
+	RVECENT(romReserved,100)
+	RVECENT(romReserved,101)
+	RVECENT(romReserved,102)
+	RVECENT(romReserved,103)
+	RVECENT(romReserved,104)
+	RVECENT(romReserved,105)
+	RVECENT(romReserved,106)
+	RVECENT(romReserved,107)
+	RVECENT(romReserved,108)
+	RVECENT(romReserved,109)
+	RVECENT(romReserved,110)
+	RVECENT(romReserved,111)
+	XVECENT(romExcHandle,0x380)	/* bfc00380: R4000 general vector */
+	RVECENT(romReserved,113)
+	RVECENT(romReserved,114)
+	RVECENT(romReserved,115)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,116)
+	RVECENT(romReserved,118)
+	RVECENT(romReserved,119)
+	RVECENT(romReserved,120)
+	RVECENT(romReserved,121)
+	RVECENT(romReserved,122)
+	RVECENT(romReserved,123)
+	RVECENT(romReserved,124)
+	RVECENT(romReserved,125)
+	RVECENT(romReserved,126)
+	RVECENT(romReserved,127)
+
+	/* We hope there are no more reserved vectors!
+	 * 128 * 8 == 1024 == 0x400
+	 * so this is address R_VEC+0x400 == 0xbfc00400
+	 */
+#ifdef CONFIG_PURPLE
+/* 0xbfc00400 */
+	.word	0xdc870000
+	.word	0xfca70000
+	.word	0x20840008
+	.word	0x20a50008
+	.word	0x20c6ffff
+	.word	0x14c0fffa
+	.word	0x00000000
+	.word	0x03e00008
+	.word	0x00000000
+	.word   0x00000000
+/* 0xbfc00428 */
+	.word	0xdc870000
+	.word	0xfca70000
+	.word	0x20840008
+	.word	0x20a50008
+	.word	0x20c6ffff
+	.word	0x14c0fffa
+	.word	0x00000000
+	.word	0x03e00008
+	.word	0x00000000
+	.word   0x00000000
+#endif /* CONFIG_PURPLE */
+	.align 4
+#endif /* CONFIG_JzRISC */
+
+reset:
+
+#if !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL)
+
+#ifdef CONFIG_JZ4730
+
+	/* Disable interrupts */
+	la	t0, INTC_IMR
+	li	t1, 0xffffffff
+	sw	t1, 0(t0)
+
+	/*
+	 * Clear SCR.HGP
+	 */
+	la	t0, CPM_SCR
+	lw	t1, 0(t0)
+	ori	t1, 0x8
+	xori	t1, 0x8
+	sw	t1, 0(t0)
+
+	/*
+	 * Set usb port0 as host
+	 */
+	la	t0, HARB_HAPOR
+	lw	t1, 0(t0)
+	ori	t1, HARB_HAPOR_UCHSEL
+	sw	t1, 0(t0)
+
+	/*
+	 * Check reset status
+	 */
+	la	t0, CPM_RSTR
+	lw	t1, 0(t0)
+	andi	t1, 0x4
+	bnez	t1, resume_from_hibernate
+	nop
+#endif /* CONFIG_JZ4730 */
+
+#ifndef CONFIG_NAND_SPL
+	/* Clear watch registers.
+	 */
+	mtc0	zero, CP0_WATCHLO
+	mtc0	zero, CP0_WATCHHI
+#endif
+
+	/* STATUS register */
+#ifdef CONFIG_JzRISC
+	/* 
+	 * CU0=UM=EXL=IE=0, BEV=ERL=1, IP2~7=1
+	 */
+	li	t0, 0x0040FC04
+	mtc0	t0, CP0_STATUS
+#else
+#ifdef  CONFIG_TB0229
+	li	k0, ST0_CU0
+#else
+	mfc0	k0, CP0_STATUS
+#endif
+	li	k1, ~ST0_IE
+	and	k0, k1
+	mtc0	k0, CP0_STATUS
+#endif
+
+	/* CAUSE register */
+#ifdef CONFIG_JzRISC
+	/* IV=1, use the specical interrupt vector (0x200) */
+	li	t1, 0x00800000
+	mtc0	t1, CP0_CAUSE
+#else
+	mtc0	zero, CP0_CAUSE
+#endif
+
+#ifndef CONFIG_JzRISC
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+#endif
+
+#endif /* !defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SPL) */
+
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	/* CONFIG0 register */
+	li	t0, CONF_CM_UNCACHED
+	mtc0	t0, CP0_CONFIG
+#endif
+
+	/* Initialize GOT pointer.
+	*/
+	bal     1f
+	nop
+	.word   _GLOBAL_OFFSET_TABLE_
+	1:
+	move    gp, ra
+	lw      t1, 0(ra)
+	move	gp, t1
+
+#ifdef CONFIG_INCA_IP
+	/* Disable INCA-IP Watchdog.
+	 */
+	la      t9, disable_incaip_wdt
+	jalr    t9
+	nop
+#endif
+
+/* JzRISC will init external memory in board_init_f,
+   which uses cache as stack and calls into C code. */
+#ifndef CONFIG_JzRISC
+	/* Initialize any external memory.
+	 */
+	la      t9, lowlevel_init
+	jalr    t9
+	nop
+#endif
+
+#if !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT)
+	/* Initialize caches...
+	 */
+#ifdef CONFIG_JzRISC
+	.set	mips32
+	mtc0	zero, CP0_TAGLO
+	mtc0	zero, CP0_TAGHI
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_DCACHE_SIZE
+1:
+	cache	Index_Store_Tag_D, 0(t0)
+	bne	t0, t1, 1b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_ICACHE_SIZE
+2:
+	cache	Index_Store_Tag_I, 0(t0)
+	bne	t0, t1, 2b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	/* Invalidate BTB */
+	mfc0	t0, CP0_CONFIG, 7
+	nop
+	ori	t0, 2
+	mtc0	t0, CP0_CONFIG, 7
+	nop
+
+	.set	mips2
+#else
+	la      t9, mips_cache_reset
+	jalr    t9
+	nop
+#endif
+
+	/* ... and enable them.
+	 */
+	li	t0, CONF_CM_CACHABLE_NONCOHERENT
+	mtc0	t0, CP0_CONFIG
+	nop
+
+#endif /* !defined(CONFIG_NAND_SPL) && !defined(CONFIG_NAND_U_BOOT) */
+
+	/* Set up temporary stack.
+	 */
+#ifndef CONFIG_JzRISC
+	li	a0, CFG_INIT_SP_OFFSET
+	la      t9, mips_cache_lock
+	jalr    t9
+	nop
+#endif
+
+#ifdef CONFIG_NAND_SPL
+	la	sp, 0x80004000
+	la	t9, nand_boot
+	j	t9
+	nop
+#else
+	li	t0, CFG_SDRAM_BASE + CFG_INIT_SP_OFFSET
+	la	sp, 0(t0)
+
+	la	t9, board_init_f
+	j	t9
+	nop
+
+
+/*
+ * void relocate_code (addr_sp, gd, addr_moni)
+ *
+ * This "function" does not return, instead it continues in RAM
+ * after relocating the monitor code.
+ *
+ * a0 = addr_sp
+ * a1 = gd
+ * a2 = destination address
+ */
+	.globl	relocate_code
+	.ent	relocate_code
+relocate_code:
+	move	sp, a0		/* Set new stack pointer		*/
+
+	li	t0, TEXT_BASE
+	la	t3, in_ram
+	lw	t2, -12(t3)	/* t2 <-- uboot_end_data	*/
+	move	t1, a2
+
+	/*
+	 * Fix GOT pointer:
+	 *
+	 * New GOT-PTR = (old GOT-PTR - TEXT_BASE) + Destination Address
+	 */
+	move	t6, gp
+	sub	gp, TEXT_BASE
+	add	gp, a2			/* gp now adjusted		*/
+	sub	t6, gp, t6		/* t6 <-- relocation offset	*/
+
+	/*
+	 * t0 = source address
+	 * t1 = target address
+	 * t2 = source end address
+	 */
+	/* On the purple board we copy the code earlier in a special way
+	 * in order to solve flash problems
+	 */
+#ifndef CONFIG_PURPLE
+1:
+	lw	t3, 0(t0)
+	sw	t3, 0(t1)
+	addu	t0, 4
+	ble	t0, t2, 1b
+	addu	t1, 4			/* delay slot			*/
+#endif
+
+	/* If caches were enabled, we would have to flush them here.
+	 */
+#ifdef CONFIG_JzRISC
+	/* flush d-cache */
+	.set	mips32
+	li	t0, KSEG0
+	addi	t1, t0, CFG_DCACHE_SIZE
+2:
+	cache	Index_Writeback_Inv_D, 0(t0)
+	bne	t0, t1, 2b
+	addi	t0, CFG_CACHELINE_SIZE
+
+	sync
+
+	/* flush i-cache */
+	li	t0, KSEG0
+	addi	t1, t0, CFG_ICACHE_SIZE
+3:
+	cache	Index_Invalidate_I, 0(t0)
+	bne	t0, t1, 3b
+	addi	t0, CFG_CACHELINE_SIZE
+
+	/* Invalidate BTB */
+	mfc0	t0, CP0_CONFIG, 7
+	nop
+	ori	t0, 2
+	mtc0	t0, CP0_CONFIG, 7
+	nop
+
+	.set	mips0
+#endif
+
+	/* Jump to where we've relocated ourselves.
+	 */
+	addi	t0, a2, in_ram - _start
+	j	t0
+	nop
+
+	.word	uboot_end_data
+	.word	uboot_end
+	.word	num_got_entries
+
+in_ram:
+	/* Now we want to update GOT.
+	 */
+	lw	t3, -4(t0)	/* t3 <-- num_got_entries	*/
+	addi	t4, gp, 8	/* Skipping first two entries.	*/
+	li	t2, 2
+1:
+	lw	t1, 0(t4)
+	beqz	t1, 2f
+	add	t1, t6
+	sw	t1, 0(t4)
+2:
+	addi	t2, 1
+	blt	t2, t3, 1b
+	addi	t4, 4		/* delay slot			*/
+
+	/* Clear BSS.
+	 */
+	lw	t1, -12(t0)	/* t1 <-- uboot_end_data	*/
+	lw	t2, -8(t0)	/* t2 <-- uboot_end		*/
+	add	t1, t6		/* adjust pointers		*/
+	add	t2, t6
+
+	sub	t1, 4
+1:	addi	t1, 4
+	bltl	t1, t2, 1b
+	sw	zero, 0(t1)	/* delay slot			*/
+
+	move	a0, a1
+	la	t9, board_init_r
+	j	t9
+	move	a1, a2		/* delay slot			*/
+
+	.end	relocate_code
+
+#endif /* CONFIG_NAND_SPL */
+
+#if !defined(CONFIG_JzRISC)
+	/* Exception handlers.
+	 */
+romReserved:
+	b romReserved
+
+romExcHandle:
+	b romExcHandle
+#endif
+
+#ifdef CONFIG_JZ4730
+
+/* These are the runtime values, modify them according to your platform. */
+#define PLCR1_VAL     0x1b000520
+#define CFCR_VAL      0x0c526220
+
+#define DMCR_VAL0     0x042a3211
+#define DMCR_VAL1     0x05aa3211 /*(DMCR_VAL0|EMC_DMCR_RFSH|EMC_DMCR_MRSET)*/
+
+#define RTCOR_VAL     0x10
+#define RTCSR_VAL     0x83
+
+	/*
+	 * cpu was reset from hibernate mode
+	 */
+resume_from_hibernate:
+	/*
+	 * Init PLL
+	 */
+	la	t0, 0xB0000000	/* CFCR */
+	li	t1, CFCR_VAL
+	sw	t1, 0(t0)
+
+	la	t0, 0xB0000010	/* PLCR1 */
+	li	t1, PLCR1_VAL
+	sw	t1, 0(t0)
+	nop;nop;nop;nop
+
+	/* Init caches */
+	.set	mips32
+	mtc0	zero, CP0_TAGLO
+	mtc0	zero, CP0_TAGHI
+
+	li	t0, K0BASE
+	ori	t1, t0, CFG_DCACHE_SIZE
+1:
+	cache	Index_Store_Tag_D, 0(t0)
+	cache	Index_Store_Tag_I, 0(t0)
+	bne	t0, t1, 1b
+	addiu	t0, t0, CFG_CACHELINE_SIZE
+
+	/*
+	 * Init SDRAM
+	 */
+	la	t0, 0xB0010070	/* GPALR2 */
+	lw	t1, 0(t0)
+	li	t2, 0x3FFFFFFF
+	and	t1, t2
+	li	t2, 0x40000000
+	or	t1, t2
+	sw	t1, 0(t0)
+
+	la	t0, 0xB0010074	/* GPAUR2 */
+	lw	t1, 0(t0)
+	li	t2, 0xFFFF0000
+	and	t1, t2
+	li	t2, 0x00005555
+	or	t1, t2
+	sw	t1, 0(t0)
+
+	la	t0, 0xB3010000	/* EMC base address */
+
+	li	t1, DMCR_VAL0	/* DMCR */
+	sw	t1, 0x80(t0)
+
+	li	t1, RTCOR_VAL
+	sh	t1, 0x8c(t0)	/* RTCOR */
+
+	li	t1, RTCSR_VAL
+	sh	t1, 0x84(t0)	/* RTCSR */
+
+	/* precharge all chip-selects */
+	ori	t1, t0, 0xa088
+	sb	$0, 0(t1)
+	ori	t1, t0, 0xb088
+	sb	$0, 0(t1)
+
+	/* delay about 200us */
+	li	t1, 0x20000
+1:
+	bnez	t1, 1b
+	sub	t1, 1
+
+	la	t1, DMCR_VAL1	/* DMCR */
+	sw	t1, 0x80(t0)
+
+	/* write sdram mode register for each chip-select */
+	ori	t1, t0, 0xa088
+	sb	$0, 0(t1)
+	ori	t1, t0, 0xb088
+	sb	$0, 0(t1)
+
+	/*
+	 * jump to resume entry point
+	 */
+	la	t0, CPM_SPR
+	lw	t1, 0(t0)
+	li	t0, 0x80000000
+	or	t0, t1
+
+	j	t0
+	nop
+
+#endif /* CONFIG_JZ4730 */
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/u-boot.lds u-boot-1.1.6/nand_spl/board/slt_50/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/slt_50/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/slt_50/u-boot.lds	2008-12-10 19:51:39.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/virgo/config.mk u-boot-1.1.6/nand_spl/board/virgo/config.mk
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/virgo/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/virgo/config.mk	2007-11-02 11:13:55.000000000 +0800
@@ -0,0 +1,34 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Ingenic JZ4740 Reference Platform
+#
+
+#
+# TEXT_BASE for SPL:
+#
+# On JZ4730 platforms the SPL is located at 0x80000000...0x80001000,
+# in the first 4kBytes of memory space in cache. So we set
+# TEXT_BASE to starting address in internal cache here.
+#
+TEXT_BASE = 0x80000000
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/virgo/Makefile u-boot-1.1.6/nand_spl/board/virgo/Makefile
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/virgo/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/virgo/Makefile	2007-11-10 12:10:46.000000000 +0800
@@ -0,0 +1,101 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS	= -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o
+COBJS	= nand_boot_jz4740.o cpu.o jz4740.o jz_serial.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/$(BOARDDIR)
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-pad.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-pad.bin: $(nandobj)u-boot-spl.bin
+	dd bs=1024 count=8 if=/dev/zero of=$(nandobj)junk1
+	cat $< $(nandobj)junk1 > $(nandobj)junk2
+	dd bs=1024 count=8 if=$(nandobj)junk2 of=$(nandobj)junk3
+	cat $(nandobj)junk3 $(nandobj)junk3 > $(nandobj)junk4
+	dd bs=1024 count=256 if=/dev/zero of=$(nandobj)junk5
+	cat $(nandobj)junk4 $(nandobj)junk5 > $(nandobj)junk6
+	dd bs=1024 count=256 if=$(nandobj)junk6 of=$@
+	rm -f $(nandobj)junk*
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS)
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $(obj)start.S
+	ln -s $(SRCTREE)/cpu/mips/start.S $(obj)start.S
+
+$(obj)cpu.c:
+	@rm -f $(obj)cpu.c
+	ln -s $(SRCTREE)/cpu/mips/cpu.c $(obj)cpu.c
+
+$(obj)jz4740.c:
+	@rm -f $(obj)jz4740.c
+	ln -s $(SRCTREE)/cpu/mips/jz4740.c $(obj)jz4740.c
+
+$(obj)jz_serial.c:
+	@rm -f $(obj)jz_serial.c
+	ln -s $(SRCTREE)/cpu/mips/jz_serial.c $(obj)jz_serial.c
+
+# from nand_spl directory
+$(obj)nand_boot_jz4740.c:
+	@rm -f $(obj)nand_boot_jz4740.c
+	ln -s $(SRCTREE)/nand_spl/nand_boot_jz4740.c $(obj)nand_boot_jz4740.c
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/board/virgo/u-boot.lds u-boot-1.1.6/nand_spl/board/virgo/u-boot.lds
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/board/virgo/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/board/virgo/u-boot.lds	2007-11-02 11:19:23.000000000 +0800
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2005
+ * Ingenic Semiconductor, <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradlittlemips", "elf32-tradlittlemips", "elf32-tradlittlemips")
+
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata  : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	. = ALIGN(4);
+	.sbss  : { *(.sbss) }
+	.bss  : { *(.bss) }
+	uboot_end = .;
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/nand_boot_jz4730.c u-boot-1.1.6/nand_spl/nand_boot_jz4730.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/nand_boot_jz4730.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/nand_boot_jz4730.c	2008-12-01 23:47:35.000000000 +0800
@@ -0,0 +1,452 @@
+/*
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/jz4730.h>
+
+
+/*
+ * HW ECC info
+ */
+#define NAND_ECC_ENABLE		1
+
+#define ECC_BLOCK		256 /* 3-bytes HW ECC per 256-bytes data */
+#define ECC_POS			4   /* ECC offset to spare area */
+
+/*
+ * NAND flash routines
+ */
+#define __nand_enable()		(REG_EMC_NFCSR |= EMC_NFCSR_NFE | EMC_NFCSR_FCE)
+#define __nand_disable()	(REG_EMC_NFCSR &= ~(EMC_NFCSR_NFE | EMC_NFCSR_FCE))
+#define __nand_ecc_enable()	(REG_EMC_NFCSR |= EMC_NFCSR_ECCE | EMC_NFCSR_ERST)
+#define __nand_ecc_disable()	(REG_EMC_NFCSR &= ~EMC_NFCSR_ECCE)
+#define __nand_dev_ready()	while (!(REG_EMC_NFCSR & EMC_NFCSR_RB))
+#define __nand_ecc()		(REG_EMC_NFECC & 0x00ffffff)
+#define __nand_cmd(n)		(REG8(NAND_COMMPORT) = (n))
+#define __nand_addr(n)		(REG8(NAND_ADDRPORT) = (n))
+#define __nand_data8()		REG8(NAND_DATAPORT)
+#define __nand_data16()		REG16(NAND_DATAPORT)
+
+/*
+ * NAND flash parameters
+ */
+static int bus_width = 8;
+static int page_size = 2048;
+static int oob_size = 64;
+static int ecc_count = 4;
+static int row_cycle = 3;
+static int page_per_block = 64;
+static int bad_block_pos = 0;
+static int block_size = 131072;
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+
+/*
+ * Init SDRAM memory.
+ */
+#define CPU_CLK (CFG_CPU_SPEED)
+#define MEM_CLK (CFG_CPU_SPEED/3)
+static void sdram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	register unsigned int dmcr0, dmcr, sdmode, tmp, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	REG_EMC_BCR = 0;	/* Disable bus release */
+	REG_EMC_RTCSR = 0;	/* Disable clock for counting */
+
+	/* Fault DMCR value for mode register setting*/
+#define SDRAM_ROW0    11
+#define SDRAM_COL0     8
+#define SDRAM_BANK40   0
+
+	dmcr0 = ((SDRAM_ROW0-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL0-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK40<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* Basic DMCR value */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timing */
+	ns = 1000000000 / MEM_CLK;
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4)
+		tmp = 4;
+	if (tmp > 11)
+		tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7)
+		tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14)
+		tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode value */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+	if (SDRAM_BW16)
+		sdmode <<= 1;
+	else
+		sdmode <<= 2;
+
+	/* Stage 1. Precharge all banks by writing SDMR with DMCR.MRSET=0 */
+	REG_EMC_DMCR = dmcr;
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+	/* Wait for precharge, > 200us */
+	tmp = (CPU_CLK / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 2. Enable auto-refresh */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH;
+
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff)	tmp = 0xff;
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCNT = 0;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* Wait for number of auto-refresh cycles */
+	tmp = (CPU_CLK / 1000000) * 1000;
+	while (tmp--);
+
+	/* Stage 3. Mode Register Set */
+	REG_EMC_DMCR = dmcr0 | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+        /* Set back to the ture basic DMCR value */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* everything is ok now */
+}
+
+/* Init PLL
+ *
+ * PLL output = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+static void pll_init(void)
+{
+	unsigned int nf, plcr1;
+
+	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+	plcr1 = ((nf-2) << CPM_PLCR1_PLL1FD_BIT) |
+		(0 << CPM_PLCR1_PLL1RD_BIT) |	/* RD=0, NR=2, 1.8432 = 3.6864/2 */
+		(0 << CPM_PLCR1_PLL1OD_BIT) |   /* OD=0, NO=1 */
+		(0x20 << CPM_PLCR1_PLL1ST_BIT) | /* PLL stable time */
+		CPM_PLCR1_PLL1EN;                /* enable PLL */          
+
+	/* Clock divisors.
+	 * 
+	 * CFCR values: when CPM_CFCR_UCS(bit 28) is set, select external USB clock.
+	 *
+	 * 0x10411110 -> 1:2:2:2:2
+	 * 0x10422220 -> 1:3:3:3:3
+	 * 0x10433330 -> 1:4:4:4:4
+	 * 0x10444440 -> 1:6:6:6:6
+	 * 0x10455550 -> 1:8:8:8:8
+	 * 0x10466660 -> 1:12:12:12:12
+	 */
+	REG_CPM_CFCR = 0x00422220 | (((CFG_CPU_SPEED/48000000) - 1) << 25);
+
+	/* PLL out frequency */
+	REG_CPM_PLCR1 = plcr1;
+}
+
+static void gpio_init(void)
+{
+#if (CFG_UART_BASE == UART0_BASE)
+	__gpio_as_uart0();
+#endif
+#if (CFG_UART_BASE == UART1_BASE)
+	__gpio_as_uart1();
+#endif
+#if (CFG_UART_BASE == UART2_BASE)
+	__gpio_as_uart2();
+#endif
+#if (CFG_UART_BASE == UART3_BASE)
+	__gpio_as_uart3();
+#endif
+	__gpio_as_emc();
+}
+
+/* NAND flash routines */
+
+static inline void nand_read_buf16(void *buf, int count)
+{
+	int i;
+	u16 *p = (u16 *)buf;
+
+	for (i = 0; i < count; i += 2)
+		*p++ = __nand_data16();
+}
+
+static inline void nand_read_buf8(void *buf, int count)
+{
+	int i;
+	u8 *p = (u8 *)buf;
+
+	for (i = 0; i < count; i++)
+		*p++ = __nand_data8();
+}
+
+static inline void nand_read_buf(void *buf, int count, int bw)
+{
+	if (bw == 8)
+		nand_read_buf8(buf, count);
+	else
+		nand_read_buf16(buf, count);
+}
+
+#ifdef NAND_ECC_ENABLE
+
+/* Detect and correct a 1 bit error for 256 byte block */
+
+static int nand_correct_data(uchar *dat, uchar *read_ecc, uchar *calc_ecc)
+{
+	uchar d1, d2, d3;
+	ulong d, bit, i, j;
+
+	/* Do error detection */ 
+	d1 = calc_ecc[0] ^ read_ecc[0];
+	d2 = calc_ecc[1] ^ read_ecc[1];
+	d3 = calc_ecc[2] ^ read_ecc[2];
+
+	d = (d3 << 16) | (d2 << 8) | d1;
+
+	if (d == 0) {
+		/* No errors */
+		return 0;
+	}
+
+	/* Found and will correct single bit error in the data */
+	bit = 0;
+	for (i = 0; i < 24; i++) {
+		if ((d >> i) & 0x1)
+			bit++;
+	}
+
+	if (bit != 11) {
+		/* Uncorrectable Error */
+		return -2;
+	} else {
+		/* ECC Code Error Correction */
+		bit = 0;
+		for (i = 12; i >= 1; i--) {
+			bit <<= 1;
+			bit |= ((d>>(i*2-1)) & 0x1);
+		}
+		j = bit & 0x07;
+		dat[(bit >> 3)] ^= (1 << j);
+		return 1;
+	}
+}
+#endif /* NAND_ECC_ENABLE */
+
+static int nand_read_page(int block, int page, uchar *dst, uchar *oob_buf, ulong *calc_ecc)
+{
+	int page_addr = page + block * page_per_block;
+	uchar *databuf = dst;
+	ulong *eccbuf = calc_ecc;
+	int i;
+
+	/* Send READ0 command */
+	__nand_cmd(NAND_CMD_READ0);
+
+	/* Send column address */
+	__nand_addr(0);
+	if (page_size == 2048)
+		__nand_addr(0);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 ps NAND */
+	if (page_size == 2048)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	__nand_dev_ready();
+
+	/* Read page data */
+	for (i = 0; i < ecc_count; i++) {
+		__nand_ecc_enable();
+		nand_read_buf((void *)databuf, ECC_BLOCK, bus_width);
+		__nand_ecc_disable();
+		eccbuf[i] = __nand_ecc();
+		databuf += ECC_BLOCK;
+	}
+
+	/* Read oob data */
+	nand_read_buf((void *)oob_buf, oob_size, bus_width);
+
+
+	return 0;
+}
+
+static int nand_load(int offs, int uboot_size, uchar *dst)
+{
+	int block;
+	int blockcopy_count;
+	int page;
+	int i;
+	uchar oob_buf[64];
+	ulong calc_ecc[16];
+	ulong *read_ecc;
+
+	__nand_enable();
+
+	/*
+	 * offs has to be aligned to a block address!
+	 */
+	block = offs / block_size;
+	blockcopy_count = 0;
+
+	while (blockcopy_count < (uboot_size / block_size)) {
+
+		/* New block is required to check the bad block flag */
+		nand_read_page(block, 0, dst, oob_buf, calc_ecc);
+		if (oob_buf[bad_block_pos] != 0xff) {
+			block++;
+
+			/*
+			 * Skip bad block
+			 */
+			continue;
+		}
+
+		for (page = 0; page < page_per_block; page++) {
+			nand_read_page(block, page, dst, oob_buf, calc_ecc);
+#ifdef NAND_ECC_ENABLE
+			read_ecc = (ulong *)(((u32)oob_buf) + ECC_POS);
+			for (i = 0; i < ecc_count; i++) {
+				nand_correct_data(dst + i * ECC_BLOCK, (uchar *)(read_ecc + i), (uchar *)(calc_ecc + i));
+			}
+#endif
+
+			dst += page_size;
+
+		}
+
+		block++;
+		blockcopy_count++;
+	}
+
+	__nand_disable();
+
+	return 0;
+}
+
+void nand_boot(void)
+{
+	int boot_sel, ret;
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nNAND Secondary Program Loader\n\n");
+
+	pll_init();
+	sdram_init();
+
+	/*
+	 * Decode the CPU boot select
+	 */
+	boot_sel = (REG_EMC_NFCSR & 0x70) >> 4;
+	bus_width = (boot_sel & 0x1) ? 16 : 8;
+	page_size = (boot_sel & 0x2) ? 2048 : 512;
+	row_cycle = (boot_sel & 0x4) ? 3 : 2;
+	page_per_block = (page_size == 2048) ? 64 : 32;
+	bad_block_pos = (page_size == 2048) ? 0 : 5;
+	ecc_count = page_size / ECC_BLOCK;
+	oob_size = page_size / 32;
+	block_size = page_size * page_per_block;
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	ret = nand_load(CFG_NAND_U_BOOT_OFFS, CFG_NAND_U_BOOT_SIZE,
+			(uchar *)CFG_NAND_U_BOOT_DST);
+
+	uboot = (void (*)(void))CFG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/nand_boot_jz4740.c u-boot-1.1.6/nand_spl/nand_boot_jz4740.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/nand_boot_jz4740.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/nand_boot_jz4740.c	2008-12-02 21:37:56.000000000 +0800
@@ -0,0 +1,405 @@
+/*
+ * Copyright (C) 2007 Ingenic Semiconductor Inc.
+ * Author: Peter <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/jz4740.h>
+
+/*
+ * NAND flash definitions
+ */
+
+#define NAND_DATAPORT	0xb8000000
+#define NAND_ADDRPORT	0xb8010000
+#define NAND_COMMPORT	0xb8008000
+
+#define ECC_BLOCK	512
+#define ECC_POS		6
+#define PAR_SIZE	9
+
+#define __nand_enable()		(REG_EMC_NFCSR |= EMC_NFCSR_NFE1 | EMC_NFCSR_NFCE1)
+#define __nand_disable()	(REG_EMC_NFCSR &= ~(EMC_NFCSR_NFCE1))
+#define __nand_ecc_rs_encoding() \
+	(REG_EMC_NFECR = EMC_NFECR_ECCE | EMC_NFECR_ERST | EMC_NFECR_RS | EMC_NFECR_RS_ENCODING)
+#define __nand_ecc_rs_decoding() \
+	(REG_EMC_NFECR = EMC_NFECR_ECCE | EMC_NFECR_ERST | EMC_NFECR_RS | EMC_NFECR_RS_DECODING)
+#define __nand_ecc_disable()	(REG_EMC_NFECR &= ~EMC_NFECR_ECCE)
+#define __nand_ecc_encode_sync() while (!(REG_EMC_NFINTS & EMC_NFINTS_ENCF))
+#define __nand_ecc_decode_sync() while (!(REG_EMC_NFINTS & EMC_NFINTS_DECF))
+
+static inline void __nand_dev_ready(void)
+{
+	unsigned int timeout = 10000;
+	while ((REG_GPIO_PXPIN(2) & 0x40000000) && timeout--);
+	while (!(REG_GPIO_PXPIN(2) & 0x40000000));
+}
+
+#define __nand_cmd(n)		(REG8(NAND_COMMPORT) = (n))
+#define __nand_addr(n)		(REG8(NAND_ADDRPORT) = (n))
+#define __nand_data8()		REG8(NAND_DATAPORT)
+#define __nand_data16()		REG16(NAND_DATAPORT)
+
+/*
+ * NAND flash parameters
+ */
+static int bus_width = 8;
+static int page_size = 2048;
+static int oob_size = 64;
+static int ecc_count = 4;
+static int row_cycle = 3;
+static int page_per_block = 64;
+static int bad_block_pos = 0;
+static int block_size = 131072;
+
+static unsigned char oob_buf[128] = {0};
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+extern void sdram_init(void);
+extern void pll_init(void);
+
+/*
+ * NAND flash routines
+ */
+
+static inline void nand_read_buf16(void *buf, int count)
+{
+	int i;
+	u16 *p = (u16 *)buf;
+
+	for (i = 0; i < count; i += 2)
+		*p++ = __nand_data16();
+}
+
+static inline void nand_read_buf8(void *buf, int count)
+{
+	int i;
+	u8 *p = (u8 *)buf;
+
+	for (i = 0; i < count; i++)
+		*p++ = __nand_data8();
+}
+
+static inline void nand_read_buf(void *buf, int count, int bw)
+{
+	if (bw == 8)
+		nand_read_buf8(buf, count);
+	else
+		nand_read_buf16(buf, count);
+}
+
+/* Correct 1~9-bit errors in 512-bytes data */
+static void rs_correct(unsigned char *dat, int idx, int mask)
+{
+	int i;
+
+	idx--;
+
+	i = idx + (idx >> 3);
+	if (i >= 512)
+		return;
+
+	mask <<= (idx & 0x7);
+
+	dat[i] ^= mask & 0xff;
+	if (i < 511)
+		dat[i+1] ^= (mask >> 8) & 0xff;
+}
+
+static int nand_read_oob(int page_addr, uchar *buf, int size)
+{
+	int col_addr;
+	if (page_size != 512)
+		col_addr = page_size;
+	else {
+		col_addr = 0;
+		__nand_dev_ready();
+	}
+
+	if (page_size != 512)
+		/* Send READ0 command */
+		__nand_cmd(NAND_CMD_READ0);
+	else
+		/* Send READOOB command */
+		__nand_cmd(NAND_CMD_READOOB);
+
+	/* Send column address */
+	__nand_addr(col_addr & 0xff);
+	if (page_size != 512)
+		__nand_addr((col_addr >> 8) & 0xff);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	__nand_dev_ready();
+
+	/* Read oob data */
+	nand_read_buf(buf, size, bus_width);
+	if (page_size == 512)
+		__nand_dev_ready();
+	return 0;
+}
+
+static int nand_read_page(int page_addr, uchar *dst, uchar *oobbuf)
+{
+	uchar *databuf = dst, *tmpbuf;
+	int i, j;
+
+	/*
+	 * Read oob data
+	 */
+	nand_read_oob(page_addr, oobbuf, oob_size);
+
+	/*
+	 * Read page data
+	 */
+
+	/* Send READ0 command */
+	__nand_cmd(NAND_CMD_READ0);
+
+	/* Send column address */
+	__nand_addr(0);
+	if (page_size != 512)
+		__nand_addr(0);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	__nand_dev_ready();
+
+	/* Read page data */
+	tmpbuf = databuf;
+
+	for (i = 0; i < ecc_count; i++) {
+		volatile unsigned char *paraddr = (volatile unsigned char *)EMC_NFPAR0;
+		unsigned int stat;
+
+		/* Enable RS decoding */
+		REG_EMC_NFINTS = 0x0;
+		__nand_ecc_rs_decoding();
+
+		/* Read data */
+		nand_read_buf((void *)tmpbuf, ECC_BLOCK, bus_width);
+
+		/* Set PAR values */
+		for (j = 0; j < PAR_SIZE; j++) {
+#if defined(CFG_NAND_ECC_POS)
+			*paraddr++ = oobbuf[CFG_NAND_ECC_POS + i*PAR_SIZE + j];
+#else
+			*paraddr++ = oobbuf[ECC_POS + i*PAR_SIZE + j];
+#endif
+		}
+
+		/* Set PRDY */
+		REG_EMC_NFECR |= EMC_NFECR_PRDY;
+
+		/* Wait for completion */
+		__nand_ecc_decode_sync();
+
+		/* Disable decoding */
+		__nand_ecc_disable();
+
+		/* Check result of decoding */
+		stat = REG_EMC_NFINTS;
+		if (stat & EMC_NFINTS_ERR) {
+			/* Error occurred */
+//			serial_puts("\n Error occurred\n");
+			if (stat & EMC_NFINTS_UNCOR) {
+				/* Uncorrectable error occurred */
+//					serial_puts("\nUncorrectable error occurred\n");
+			}
+			else {
+				unsigned int errcnt, index, mask;
+
+				errcnt = (stat & EMC_NFINTS_ERRCNT_MASK) >> EMC_NFINTS_ERRCNT_BIT;
+				switch (errcnt) {
+				case 4:
+					index = (REG_EMC_NFERR3 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT;
+					mask = (REG_EMC_NFERR3 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT;
+					rs_correct(tmpbuf, index, mask);
+					/* FALL-THROUGH */
+				case 3:
+					index = (REG_EMC_NFERR2 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT;
+					mask = (REG_EMC_NFERR2 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT;
+					rs_correct(tmpbuf, index, mask);
+					/* FALL-THROUGH */
+				case 2:
+					index = (REG_EMC_NFERR1 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT;
+					mask = (REG_EMC_NFERR1 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT;
+					rs_correct(tmpbuf, index, mask);
+					/* FALL-THROUGH */
+				case 1:
+					index = (REG_EMC_NFERR0 & EMC_NFERR_INDEX_MASK) >> EMC_NFERR_INDEX_BIT;
+					mask = (REG_EMC_NFERR0 & EMC_NFERR_MASK_MASK) >> EMC_NFERR_MASK_BIT;
+					rs_correct(tmpbuf, index, mask);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+
+		tmpbuf += ECC_BLOCK;
+	}
+
+	return 0;
+}
+
+#ifndef CFG_NAND_BADBLOCK_PAGE
+#define CFG_NAND_BADBLOCK_PAGE 0 /* NAND bad block was marked at this page in a block, starting from 0 */
+#endif
+
+static void nand_load(int offs, int uboot_size, uchar *dst)
+{
+	int page;
+	int pagecopy_count;
+
+	__nand_enable();
+
+	page = offs / page_size;
+	pagecopy_count = 0;
+	while (pagecopy_count < (uboot_size / page_size)) {
+		if (page % page_per_block == 0) {
+			nand_read_oob(page + CFG_NAND_BADBLOCK_PAGE, oob_buf, oob_size);
+			if (oob_buf[bad_block_pos] != 0xff) {
+				page += page_per_block;
+				/* Skip bad block */
+				continue;
+			}
+		}
+		/* Load this page to dst, do the ECC */
+		nand_read_page(page, dst, oob_buf);
+
+		dst += page_size;
+		page++;
+		pagecopy_count++;
+	}
+
+	__nand_disable();
+}
+
+static void nand_init(void) {
+
+ 	/* Optimize the timing of nand */
+	REG_EMC_SMCR1 = 0x094c4400;
+}
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+#if defined(CONFIG_JZ4720)
+	__gpio_as_sdram_16bit_4720();
+#elif defined(CONFIG_JZ4725)
+	__gpio_as_sdram_16bit_4725();
+#else
+	__gpio_as_sdram_32bit();
+#endif
+
+	/*
+	 * Initialize UART0 pins
+	 */
+	__gpio_as_uart0();
+}
+
+void nand_boot(void)
+{
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	nand_init();
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nNAND Secondary Program Loader\n\n");
+
+	pll_init();
+	sdram_init();
+
+#if (JZ4740_NANDBOOT_CFG == JZ4740_NANDBOOT_B8R3)
+	bus_width = 8;
+	row_cycle = 3;
+#endif
+
+#if (JZ4740_NANDBOOT_CFG == JZ4740_NANDBOOT_B8R2)
+	bus_width = 8;
+	row_cycle = 2;
+#endif
+
+#if (JZ4740_NANDBOOT_CFG == JZ4740_NANDBOOT_B16R3)
+	bus_width = 16;
+	row_cycle = 3;
+#endif
+
+#if (JZ4740_NANDBOOT_CFG == JZ4740_NANDBOOT_B16R2)
+	bus_width = 16;
+	row_cycle = 2;
+#endif
+	page_size = CFG_NAND_PAGE_SIZE;
+	block_size = CFG_NAND_BLOCK_SIZE;
+	page_per_block = CFG_NAND_BLOCK_SIZE / CFG_NAND_PAGE_SIZE;
+	bad_block_pos = (page_size == 512) ? 5 : 0;
+	oob_size = page_size / 32;
+	ecc_count = page_size / ECC_BLOCK;
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	nand_load(CFG_NAND_U_BOOT_OFFS, CFG_NAND_U_BOOT_SIZE,
+		  (uchar *)CFG_NAND_U_BOOT_DST);
+
+	uboot = (void (*)(void))CFG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/nand_boot_jz4750.c u-boot-1.1.6/nand_spl/nand_boot_jz4750.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/nand_boot_jz4750.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/nand_boot_jz4750.c	2009-01-14 01:14:20.000000000 +0800
@@ -0,0 +1,392 @@
+/*
+ * Copyright (C) 2007 Ingenic Semiconductor Inc.
+ * Author: Peter <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/jz4750.h>
+
+/*
+ * NAND flash definitions
+ */
+
+#define NAND_DATAPORT	0xb8000000
+unsigned int NAND_ADDRPORT;
+unsigned int NAND_COMMPORT;
+
+#define ECC_BLOCK	512
+#define ECC_POS		3
+static int par_size;
+
+#define __nand_cmd(n)		(REG8(NAND_COMMPORT) = (n))
+#define __nand_addr(n)		(REG8(NAND_ADDRPORT) = (n))
+#define __nand_data8()		REG8(NAND_DATAPORT)
+#define __nand_data16()		REG16(NAND_DATAPORT)
+
+#define __nand_enable()		(REG_EMC_NFCSR |= EMC_NFCSR_NFE1 | EMC_NFCSR_NFCE1)
+#define __nand_disable()	(REG_EMC_NFCSR &= ~(EMC_NFCSR_NFCE1))
+
+static inline void nand_wait_ready(void)
+{
+	unsigned int timeout = 1000;
+	while ((REG_GPIO_PXPIN(2) & 0x08000000) && timeout--);
+	while (!(REG_GPIO_PXPIN(2) & 0x08000000));
+}
+
+/*
+ * NAND flash parameters
+ */
+static int bus_width = 8;
+static int page_size = 2048;
+static int oob_size = 64;
+static int ecc_count = 4;
+static int row_cycle = 3;
+static int page_per_block = 64;
+static int bad_block_pos = 0;
+static int block_size = 131072;
+
+static unsigned char oob_buf[128] = {0};
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+extern void sdram_init(void);
+extern void pll_init(void);
+
+/*
+ * NAND flash routines
+ */
+
+static inline void nand_read_buf16(void *buf, int count)
+{
+	int i;
+	u16 *p = (u16 *)buf;
+
+	for (i = 0; i < count; i += 2)
+		*p++ = __nand_data16();
+}
+
+static inline void nand_read_buf8(void *buf, int count)
+{
+	int i;
+	u8 *p = (u8 *)buf;
+
+	for (i = 0; i < count; i++)
+		*p++ = __nand_data8();
+}
+
+static inline void nand_read_buf(void *buf, int count, int bw)
+{
+	if (bw == 8)
+		nand_read_buf8(buf, count);
+	else
+		nand_read_buf16(buf, count);
+}
+
+/*
+ * Correct the error bit in 512-bytes data
+ */
+static void bch_correct(unsigned char *dat, int idx)
+{
+	int i, bit;  // the 'bit' of i byte is error 
+	i = (idx - 1) >> 3;
+	bit = (idx - 1) & 0x7;
+	if (i < 512)
+		dat[i] ^= (1 << bit);
+}
+
+/*
+ * Read oob
+ */
+static int nand_read_oob(int page_addr, u8 *buf, int size)
+{
+	int col_addr;
+
+	if (page_size != 512)
+		col_addr = page_size;
+	else
+		col_addr = 0;
+
+	if (page_size != 512)
+		/* Send READ0 command */
+		__nand_cmd(NAND_CMD_READ0);
+	else
+		/* Send READOOB command */
+		__nand_cmd(NAND_CMD_READOOB);
+
+	/* Send column address */
+	__nand_addr(col_addr & 0xff);
+	if (page_size != 512)
+		__nand_addr((col_addr >> 8) & 0xff);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	nand_wait_ready();
+
+	/* Read oob data */
+	nand_read_buf(buf, size, bus_width);
+
+	if (page_size == 512)
+		nand_wait_ready();
+
+	return 0;
+}
+
+static int nand_read_page(int page_addr, uchar *dst, uchar *oobbuf)
+{
+	uchar *data_buf = dst;
+	int i, j;
+
+	/* Send READ0 command */
+	__nand_cmd(NAND_CMD_READ0);
+
+	/* Send column address */
+	__nand_addr(0);
+	if (page_size != 512)
+		__nand_addr(0);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 or 4096 ps NAND */
+	if (page_size != 512)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	nand_wait_ready();
+
+	/* Read page data */
+	data_buf = dst;
+
+	/* Read data */
+	nand_read_buf((void *)data_buf, page_size, bus_width);
+	nand_read_buf((void *)oobbuf, oob_size, bus_width);
+
+	ecc_count = page_size / ECC_BLOCK;
+
+	for (i = 0; i < ecc_count; i++) {
+		unsigned int stat;
+
+		__ecc_cnt_dec(ECC_BLOCK + par_size);
+
+                /* Enable BCH decoding */
+		REG_BCH_INTS = 0xffffffff;
+		if (CFG_NAND_BCH_BIT == 8)
+			__ecc_decoding_8bit();
+		else
+			__ecc_decoding_4bit();
+
+                /* Write 512 bytes and par_size parities to REG_BCH_DR */
+		for (j = 0; j < ECC_BLOCK; j++) {
+			REG_BCH_DR = data_buf[j];
+		}
+
+		for (j = 0; j < par_size; j++) {
+#if defined(CFG_NAND_ECC_POS)
+			REG_BCH_DR = oob_buf[CFG_NAND_ECC_POS + i*par_size + j];
+#else
+			REG_BCH_DR = oob_buf[ECC_POS + i*par_size + j];
+#endif
+		}
+
+		/* Wait for completion */
+		__ecc_decode_sync();
+		__ecc_disable();
+
+		/* Check decoding */
+		stat = REG_BCH_INTS;
+		if (stat & BCH_INTS_ERR) {
+			if (stat & BCH_INTS_UNCOR) {
+				/* Uncorrectable error occurred */
+				serial_puts("Uncorrectable\n");
+			}
+			else {
+				unsigned int errcnt = (stat & BCH_INTS_ERRC_MASK) >> BCH_INTS_ERRC_BIT;
+				switch (errcnt) {
+				case 8:
+					bch_correct(data_buf, (REG_BCH_ERR3 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 7:
+					bch_correct(data_buf, (REG_BCH_ERR3 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 6:
+					bch_correct(data_buf, (REG_BCH_ERR2 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 5:
+					bch_correct(data_buf, (REG_BCH_ERR2 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 4:
+					bch_correct(data_buf, (REG_BCH_ERR1 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 3:
+					bch_correct(data_buf, (REG_BCH_ERR1 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+				case 2:
+					bch_correct(data_buf, (REG_BCH_ERR0 & BCH_ERR_INDEX_ODD_MASK) >> BCH_ERR_INDEX_ODD_BIT);
+				case 1:
+					bch_correct(data_buf, (REG_BCH_ERR0 & BCH_ERR_INDEX_EVEN_MASK) >> BCH_ERR_INDEX_EVEN_BIT);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+		/* increment pointer */
+		data_buf += ECC_BLOCK;
+	}
+
+	return 0;
+}
+
+#ifndef CFG_NAND_BADBLOCK_PAGE
+#define CFG_NAND_BADBLOCK_PAGE 0 /* NAND bad block was marked at this page in a block, starting from 0 */
+#endif
+
+static void nand_load(int offs, int uboot_size, uchar *dst)
+{
+	int page;
+	int pagecopy_count;
+
+	__nand_enable();
+
+	page = offs / page_size;
+	pagecopy_count = 0;
+	while (pagecopy_count < (uboot_size / page_size)) {
+		if (page % page_per_block == 0) {
+			nand_read_oob(page + CFG_NAND_BADBLOCK_PAGE, oob_buf, oob_size);
+			if (oob_buf[bad_block_pos] != 0xff) {
+				page += page_per_block;
+				/* Skip bad block */
+				continue;
+			}
+		}
+		/* Load this page to dst, do the ECC */
+		nand_read_page(page, dst, oob_buf);
+
+		dst += page_size;
+		page++;
+		pagecopy_count++;
+	}
+
+	__nand_disable();
+}
+
+static void gpio_init(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+#if CONFIG_NR_DRAM_BANKS == 2   /* Use Two Banks: DCS0 and DCS1 */
+	__gpio_as_sdram_x2_32bit();
+#else
+	__gpio_as_sdram_32bit();
+#endif
+
+	/*
+	 * Initialize UART3 pins
+	 */
+	switch (CFG_UART_BASE) {
+	case UART0_BASE:
+		__gpio_as_uart0();
+		break;
+	case UART1_BASE:
+		__gpio_as_uart1();
+		break;
+	case UART2_BASE:
+		__gpio_as_uart2();
+		break;
+	case UART3_BASE:
+		__gpio_as_uart3();
+		break;
+	}
+}
+
+void nand_boot(void)
+{
+	int boot_sel;
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nNAND Secondary Program Loader\n\n");
+
+#ifndef CONFIG_FPGA
+	pll_init();
+#endif
+	sdram_init();
+
+	/*
+	 * JZ4750 can get some NAND parameters from NAND infomation in fuwa.h
+	 */
+	bus_width = (CFG_NAND_BW8==1) ? 8 : 16;
+	page_size = CFG_NAND_PAGE_SIZE;
+	row_cycle = CFG_NAND_ROW_CYCLE;
+	block_size = CFG_NAND_BLOCK_SIZE;
+	page_per_block =  CFG_NAND_BLOCK_SIZE / CFG_NAND_PAGE_SIZE;
+	bad_block_pos = (page_size == 512) ? 5 : 0;
+	oob_size = page_size / 32;
+	ecc_count = page_size / ECC_BLOCK;
+	if (CFG_NAND_BCH_BIT == 8)
+		par_size = 13;
+	else
+		par_size = 7;
+
+	if ((REG_EMC_BCR & EMC_BCR_BSR_MASK) == EMC_BCR_BSR_SHARE) {
+		NAND_ADDRPORT =	0xb8010000;
+		NAND_COMMPORT =	0xb8008000;
+	} else {
+		NAND_ADDRPORT =	0xb8000010;
+		NAND_COMMPORT =	0xb8000008;
+	}
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	nand_load(CFG_NAND_U_BOOT_OFFS, CFG_NAND_U_BOOT_SIZE,
+		  (uchar *)CFG_NAND_U_BOOT_DST);
+
+	uboot = (void (*)(void))CFG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/nand_spl/nand_boot_jz5730.c u-boot-1.1.6/nand_spl/nand_boot_jz5730.c
--- /develop/source/01boot/u-boot-1.1.6/nand_spl/nand_boot_jz5730.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/nand_spl/nand_boot_jz5730.c	2007-06-12 17:27:54.000000000 +0800
@@ -0,0 +1,438 @@
+/*
+ * (C) Copyright 2006
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+
+#include <asm/io.h>
+#include <asm/jz5730.h>
+
+
+/*
+ * HW ECC info
+ */
+#define NAND_ECC_ENABLE		1
+
+#define ECC_BLOCK		256 /* 3-bytes HW ECC per 256-bytes data */
+#define ECC_POS			4   /* ECC offset to spare area */
+
+/*
+ * NAND flash routines
+ */
+#define __nand_enable()		(REG_EMC_NFCSR |= EMC_NFCSR_NFE | EMC_NFCSR_FCE)
+#define __nand_disable()	(REG_EMC_NFCSR &= ~(EMC_NFCSR_NFE | EMC_NFCSR_FCE))
+#define __nand_ecc_enable()	(REG_EMC_NFCSR |= EMC_NFCSR_ECCE | EMC_NFCSR_ERST)
+#define __nand_ecc_disable()	(REG_EMC_NFCSR &= ~EMC_NFCSR_ECCE)
+#define __nand_dev_ready()	while (!(REG_EMC_NFCSR & EMC_NFCSR_RB))
+#define __nand_ecc()		(REG_EMC_NFECC & 0x00ffffff)
+#define __nand_cmd(n)		(REG8(NAND_COMMPORT) = (n))
+#define __nand_addr(n)		(REG8(NAND_ADDRPORT) = (n))
+#define __nand_data8()		REG8(NAND_DATAPORT)
+#define __nand_data16()		REG16(NAND_DATAPORT)
+
+/*
+ * NAND flash parameters
+ */
+static int bus_width = 8;
+static int page_size = 2048;
+static int oob_size = 64;
+static int ecc_count = 4;
+static int row_cycle = 3;
+static int page_per_block = 64;
+static int bad_block_pos = 0;
+static int block_size = 131072;
+
+/*
+ * External routines
+ */
+extern void flush_cache_all(void);
+extern int serial_init(void);
+extern void serial_puts(const char *s);
+
+/*
+ * Init SDRAM memory.
+ */
+#define CPU_CLK (CFG_CPU_SPEED)
+#define MEM_CLK (CFG_CPU_SPEED/3)
+
+static void sdram_init(void)
+{
+	register unsigned int dmcr, sdmode, tmp, ns;
+
+	unsigned int cas_latency_sdmr[2] = {
+		EMC_SDMR_CAS_2,
+		EMC_SDMR_CAS_3,
+	};
+
+	unsigned int cas_latency_dmcr[2] = {
+		1 << EMC_DMCR_TCL_BIT,	/* CAS latency is 2 */
+		2 << EMC_DMCR_TCL_BIT	/* CAS latency is 3 */
+	};
+
+	REG_EMC_BCR = EMC_BCR_BRE;	/* Enable SPLIT */
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_DISABLE;
+	REG_EMC_RTCOR = 0;
+	REG_EMC_RTCNT = 0;
+
+	/* Basic DMCR register value. */
+	dmcr = ((SDRAM_ROW-11)<<EMC_DMCR_RA_BIT) |
+		((SDRAM_COL-8)<<EMC_DMCR_CA_BIT) |
+		(SDRAM_BANK4<<EMC_DMCR_BA_BIT) |
+		(SDRAM_BW16<<EMC_DMCR_BW_BIT) |
+		EMC_DMCR_EPIN |
+		cas_latency_dmcr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	/* SDRAM timimg parameters */
+	ns = 1000000000 / MEM_CLK;
+
+	tmp = SDRAM_TRAS/ns;
+	if (tmp < 4)
+		tmp = 4;
+	if (tmp > 11)
+		tmp = 11;
+	dmcr |= ((tmp-4) << EMC_DMCR_TRAS_BIT);
+	tmp = SDRAM_RCD/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_RCD_BIT);
+	tmp = SDRAM_TPC/ns;
+	if (tmp > 7)
+		tmp = 7;
+	dmcr |= (tmp << EMC_DMCR_TPC_BIT);
+	tmp = SDRAM_TRWL/ns;
+	if (tmp > 3)
+		tmp = 3;
+	dmcr |= (tmp << EMC_DMCR_TRWL_BIT);
+	tmp = (SDRAM_TRAS + SDRAM_TPC)/ns;
+	if (tmp > 14)
+		tmp = 14;
+	dmcr |= (((tmp + 1) >> 1) << EMC_DMCR_TRC_BIT);
+
+	/* SDRAM mode values */
+	sdmode = EMC_SDMR_BT_SEQ | 
+		 EMC_SDMR_OM_NORMAL |
+		 EMC_SDMR_BL_4 | 
+		 cas_latency_sdmr[((SDRAM_CASL == 3) ? 1 : 0)];
+
+	if (SDRAM_BW16)
+		sdmode <<= 1;
+	else
+		sdmode <<= 2;
+
+	/* First, precharge phase */
+	REG_EMC_DMCR = dmcr;
+
+	/* Set refresh registers */
+	tmp = SDRAM_TREF/ns;
+	tmp = tmp/64 + 1;
+	if (tmp > 0xff)
+		tmp = 0xff;
+
+	REG_EMC_RTCOR = tmp;
+	REG_EMC_RTCSR = EMC_RTCSR_CKS_64;	/* Divisor is 64, CKO/64 */
+
+	/* precharge all chip-selects */
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+	/* wait for precharge, > 200us */
+	tmp = (CPU_CLK / 1000000) * 200;
+	while (tmp--);
+
+	/* enable refresh and set SDRAM mode */
+	REG_EMC_DMCR = dmcr | EMC_DMCR_RFSH | EMC_DMCR_MRSET;
+
+	/* write sdram mode register for each chip-select */
+	REG8(EMC_SDMR0|sdmode) = 0;
+	REG8(EMC_SDMR1|sdmode) = 0;
+
+	/* everything is ok now */
+}
+
+/* Init PLL
+ *
+ * PLL output = EXTAL * NF / (NR * NO)
+ *
+ * NF = FD + 2, NR = RD + 2
+ * NO = 1 (if OD = 0), NO = 2 (if OD = 1 or 2), NO = 4 (if OD = 3)
+ */
+static void pll_init(void)
+{
+	unsigned int nf, plcr1;
+
+	nf = CFG_CPU_SPEED * 2 / CFG_EXTAL;
+	plcr1 = ((nf-2) << CPM_PLCR1_PLL1FD_BIT) |
+		(0 << CPM_PLCR1_PLL1RD_BIT) |	/* RD=0, NR=2, 1.8432 = 3.6864/2 */
+		(0 << CPM_PLCR1_PLL1OD_BIT) |   /* OD=0, NO=1 */
+		(0x20 << CPM_PLCR1_PLL1ST_BIT) | /* PLL stable time */
+		CPM_PLCR1_PLL1EN;                /* enable PLL */          
+
+	/* Clock divisors.
+	 * 
+	 * CFCR values: when CPM_CFCR_UCS(bit 28) is set, select external USB clock.
+	 *
+	 * 0x10411110 -> 1:2:2:2:2
+	 * 0x10422220 -> 1:3:3:3:3
+	 * 0x10433330 -> 1:4:4:4:4
+	 * 0x10444440 -> 1:6:6:6:6
+	 * 0x10455550 -> 1:8:8:8:8
+	 * 0x10466660 -> 1:12:12:12:12
+	 */
+	REG_CPM_CFCR = 0x00422220 | (((CFG_CPU_SPEED/48000000) - 1) << 25);
+
+	/* PLL out frequency */
+	REG_CPM_PLCR1 = plcr1;
+}
+
+static void gpio_init(void)
+{
+#if (CFG_UART_BASE == UART0_BASE)
+	__gpio_as_uart0();
+#endif
+#if (CFG_UART_BASE == UART1_BASE)
+	__gpio_as_uart1();
+#endif
+#if (CFG_UART_BASE == UART2_BASE)
+	__gpio_as_uart2();
+#endif
+#if (CFG_UART_BASE == UART3_BASE)
+	__gpio_as_uart3();
+#endif
+//	__gpio_as_emc();
+}
+
+/* NAND flash routines */
+
+static inline void nand_read_buf16(void *buf, int count)
+{
+	int i;
+	u16 *p = (u16 *)buf;
+
+	for (i = 0; i < count; i += 2)
+		*p++ = __nand_data16();
+}
+
+static inline void nand_read_buf8(void *buf, int count)
+{
+	int i;
+	u8 *p = (u8 *)buf;
+
+	for (i = 0; i < count; i++)
+		*p++ = __nand_data8();
+}
+
+static inline void nand_read_buf(void *buf, int count, int bw)
+{
+	if (bw == 8)
+		nand_read_buf8(buf, count);
+	else
+		nand_read_buf16(buf, count);
+}
+
+#ifdef NAND_ECC_ENABLE
+
+/* Detect and correct a 1 bit error for 256 byte block */
+
+static int nand_correct_data(uchar *dat, uchar *read_ecc, uchar *calc_ecc)
+{
+	uchar d1, d2, d3;
+	ulong d, bit, i, j;
+
+	/* Do error detection */ 
+	d1 = calc_ecc[0] ^ read_ecc[0];
+	d2 = calc_ecc[1] ^ read_ecc[1];
+	d3 = calc_ecc[2] ^ read_ecc[2];
+
+	d = (d3 << 16) | (d2 << 8) | d1;
+
+	if (d == 0) {
+		/* No errors */
+		return 0;
+	}
+
+	/* Found and will correct single bit error in the data */
+	bit = 0;
+	for (i = 0; i < 24; i++) {
+		if ((d >> i) & 0x1)
+			bit++;
+	}
+
+	if (bit != 11) {
+		/* Uncorrectable Error */
+		return -2;
+	} else {
+		/* ECC Code Error Correction */
+		bit = 0;
+		for (i = 12; i >= 1; i--) {
+			bit <<= 1;
+			bit |= ((d>>(i*2-1)) & 0x1);
+		}
+		j = bit & 0x07;
+		dat[(bit >> 3)] ^= (1 << j);
+		return 1;
+	}
+}
+#endif /* NAND_ECC_ENABLE */
+
+static int nand_read_page(int block, int page, uchar *dst, uchar *oob_buf, ulong *calc_ecc)
+{
+	int page_addr = page + block * page_per_block;
+	uchar *databuf = dst;
+	ulong *eccbuf = calc_ecc;
+	int i;
+
+	/* Send READ0 command */
+	__nand_cmd(NAND_CMD_READ0);
+
+	/* Send column address */
+	__nand_addr(0);
+	if (page_size == 2048)
+		__nand_addr(0);
+
+	/* Send page address */
+	__nand_addr(page_addr & 0xff);
+	__nand_addr((page_addr >> 8) & 0xff);
+	if (row_cycle == 3)
+		__nand_addr((page_addr >> 16) & 0xff);
+
+	/* Send READSTART command for 2048 ps NAND */
+	if (page_size == 2048)
+		__nand_cmd(NAND_CMD_READSTART);
+
+	/* Wait for device ready */
+	__nand_dev_ready();
+
+	/* Read page data */
+	for (i = 0; i < ecc_count; i++) {
+		__nand_ecc_enable();
+		nand_read_buf((void *)databuf, ECC_BLOCK, bus_width);
+		__nand_ecc_disable();
+		eccbuf[i] = __nand_ecc();
+		databuf += ECC_BLOCK;
+	}
+
+	/* Read oob data */
+	nand_read_buf((void *)oob_buf, oob_size, bus_width);
+
+
+	return 0;
+}
+
+static int nand_load(int offs, int uboot_size, uchar *dst)
+{
+	int block;
+	int blockcopy_count;
+	int page;
+	int i;
+	uchar oob_buf[64];
+	ulong calc_ecc[16];
+	ulong *read_ecc;
+
+	__nand_enable();
+
+	/*
+	 * offs has to be aligned to a block address!
+	 */
+	block = offs / block_size;
+	blockcopy_count = 0;
+
+	while (blockcopy_count < (uboot_size / block_size)) {
+		for (page = 0; page < page_per_block; page++) {
+			nand_read_page(block, page, dst, oob_buf, calc_ecc);
+
+			if (page == 0) {
+				if (oob_buf[bad_block_pos] != 0xff) {
+					block++;
+
+					/*
+					 * Skip bad block
+					 */
+					continue;
+				}
+			}
+#ifdef NAND_ECC_ENABLE
+			read_ecc = (ulong *)(((u32)oob_buf) + ECC_POS);
+			for (i = 0; i < ecc_count; i++) {
+				nand_correct_data(dst + i * ECC_BLOCK, (uchar *)(read_ecc + i), (uchar *)(calc_ecc + i));
+			}
+#endif
+
+			dst += page_size;
+
+		}
+
+		block++;
+		blockcopy_count++;
+	}
+
+	__nand_disable();
+
+	return 0;
+}
+
+void nand_boot(void)
+{
+	int boot_sel, ret;
+	void (*uboot)(void);
+
+	/*
+	 * Init hardware
+	 */
+	gpio_init();
+	serial_init();
+
+	serial_puts("\n\nNAND Secondary Program Loader\n\n");
+
+	pll_init();
+	sdram_init();
+
+	/*
+	 * Decode the CPU boot select
+	 */
+	boot_sel = (REG_EMC_NFCSR & 0x70) >> 4;
+	bus_width = (boot_sel & 0x1) ? 16 : 8;
+	page_size = (boot_sel & 0x2) ? 2048 : 512;
+	row_cycle = (boot_sel & 0x4) ? 3 : 2;
+	page_per_block = (page_size == 2048) ? 64 : 32;
+	bad_block_pos = (page_size == 2048) ? 0 : 5;
+	ecc_count = page_size / ECC_BLOCK;
+	oob_size = page_size / 32;
+	block_size = page_size * page_per_block;
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+	ret = nand_load(CFG_NAND_U_BOOT_OFFS, CFG_NAND_U_BOOT_SIZE,
+			(uchar *)CFG_NAND_U_BOOT_DST);
+
+	uboot = (void (*)(void))CFG_NAND_U_BOOT_START;
+
+	serial_puts("Starting U-Boot ...\n");
+
+	/*
+	 * Flush caches
+	 */
+	flush_cache_all();
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	(*uboot)();
+}
diff -urN /develop/source/01boot/u-boot-1.1.6/net/eth.c u-boot-1.1.6/net/eth.c
--- /develop/source/01boot/u-boot-1.1.6/net/eth.c	2007-10-31 00:43:50.000000000 +0800
+++ u-boot-1.1.6/net/eth.c	2008-01-23 12:09:27.000000000 +0800
@@ -32,6 +32,7 @@
 extern int gt6426x_eth_initialize(bd_t *bis);
 #endif
 
+extern int jz_enet_initialize(bd_t*);
 extern int au1x00_enet_initialize(bd_t*);
 extern int dc21x4x_initialize(bd_t*);
 extern int e1000_initialize(bd_t*);
@@ -215,6 +216,10 @@
 #if defined(FEC_ENET) || defined(CONFIG_ETHER_ON_FCC)
 	fec_initialize(bis);
 #endif
+#if defined(CONFIG_JZSOC)
+   	jz_enet_initialize(bis);
+#endif
+	
 #if defined(CONFIG_AU1X00)
 	au1x00_enet_initialize(bis);
 #endif
diff -urN /develop/source/01boot/u-boot-1.1.6/README.JZ u-boot-1.1.6/README.JZ
--- /develop/source/01boot/u-boot-1.1.6/README.JZ	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-1.1.6/README.JZ	2008-05-30 14:09:10.000000000 +0800
@@ -0,0 +1,119 @@
+
+		Ingenic U-Boot Release
+
+		(Updated: 2008-04-14)
+
+
+-------------------------
+* Install U-Boot Source *
+-------------------------
+
+To install the full source of u-boot-1.1.6, you need to download following
+two files from http://www.ingenic.cn:
+
+* u-boot-1.1.6.tar.bz2: the original u-boot source package.
+* u-boot-1.1.6-jz-yyyymmdd.patch.gz: the latest u-boot patch from ingenic.
+
+First, put the u-boot tarball in the working directory and unpack it:
+
+    $ tar -xjf u-boot-1.1.6.tar.bz2
+
+Then, apply the patch to the u-boot tree:
+
+    $ cd u-boot-1.1.6
+    $ gzip -cd ../u-boot-1.1.6-jz-yyyymmdd.patch.gz | patch -p1
+
+
+---------------
+* Quick Start *
+---------------
+
+To build u-boot-1.1.6, you needs MIPS GCC-3.3.1 or GCC-4.1.2.
+
+This release supports several platforms based on JZSOC. The platform
+names are listed below:
+
+  - LIBRA: JZ4730 development board
+  - PMPV1: JZ4730 PMP reference board version 1.x
+  - PMPV2: JZ4730 PMP reference board version 2.x
+  - GPS: JZ4730 GPS reference board
+  - LEO: JZ4740 development board
+  - PAVO: JZ4740 PMP reference board
+  - VIRGO: JZ4720 reference board
+  - DIPPER: JZ4725 reference board
+
+Configure and compile u-boot:
+
+For example,
+
+  - Build u-boot.bin for NOR flash boot:
+
+    $ make pmpv2_config (JZ4730-based PMP version 2.x board)
+    $ make pavo_config (JZ4740-based PAVO board)
+    $ make virgo_config (JZ4720-based VIRGO board)
+    $ make dipper_config (JZ4725-based DIPPER board)
+
+    $ make
+
+  - Build u-boot-nand.bin for NAND flash boot:
+
+    $ make pmpv2_nand_config (JZ4730-based PMP version 2.x board)
+    $ make pavo_nand_config (JZ4740-based PAVO board)
+    $ make virgo_nand_config (JZ4720-based VIRGO board)
+    $ make dipper_nand_config (JZ4725-based DIPPER board)
+
+    $ make
+
+---------------------------
+* Overview of source tree *
+---------------------------
+
+  - board/
+      - libra/		LIBRA board dependent files
+      - pmpv1/		PMP ver 1.x board dependent files
+      - pmpv2/		PMP ver 2.x board dependent files
+      - gps/		GPS board dependent files
+      - leo/		LEO board dependent files
+      - pavo/		PAVO board dependent files
+      - virgo/		VIRGO board dependent files
+      - dipper/		DIPPER board dependent files
+  - cpu/mips/
+      - start.S		MIPS32 start code
+      - cpu.c		cpu generic code
+      - jz4730.c	JZ4730 generic code
+      - jz4740.c	JZ4740 generic code
+      - jz_serial.c	jz serial driver
+      - jz_eth.c	jz on-chip ethernet driver
+      - jz_i2c.c	jz i2c driver
+      - jz_lcd.c	jz LCD driver
+      - jz_mmc.c	jz MMC/SD driver
+      - jz4730_nand.c	JZ4730 NAND flash driver
+      - jz4740_nand.c	JZ4740 NAND flash driver
+  - include/asm-mips/
+      - jz4730.h	JZ4730 generic headers
+      - jz4740.h	JZ4740 generic headers
+  - include/configs/
+      - libra.h		LIBRA board definitions
+      - pmpv1.h		PMP ver 1.x board definitions
+      - pmpv2.h		PMP ver 2.x board definitions
+      - gps.h		GPS board definitions
+      - leo.h		LEO board definitions
+      - pavo.h		PAVO board definitions
+      - virgo.h		VIRGO board definitions
+      - dipper.h	DIPPER board definitions
+  - lib_mips/
+      - board.c		generic board init code
+  - nand_spl/		NAND secondary program loader
+      - nand_boot_jz4730.c	jz4730 generic code
+      - nand_boot_jz4740.c	jz4740 generic code
+      - board/pmpv1/	PMP ver 1.x board dependent files	
+      - board/pmpv2/	PMP ver 1.x board dependent files
+      - board/leo/	LEO board dependent files
+      - board/pavo/	PAVO board dependent files
+      - board/virgo/	VIRGO board dependent files
+      - board/dipper/	DIPPER board dependent files
+
+
+-----------
+* Support *
+-----------
diff -urN /develop/source/01boot/u-boot-1.1.6/tools/bmp_logo.c u-boot-1.1.6/tools/bmp_logo.c
--- /develop/source/01boot/u-boot-1.1.6/tools/bmp_logo.c	2007-10-31 00:43:50.000000000 +0800
+++ u-boot-1.1.6/tools/bmp_logo.c	2007-10-25 10:05:43.000000000 +0800
@@ -11,6 +11,8 @@
 #endif
 #endif
 
+#include <config.h>
+
 typedef struct bitmap_s {		/* bitmap description */
 	uint16_t width;
 	uint16_t height;
@@ -18,6 +20,8 @@
 	uint8_t	*data;
 } bitmap_t;
 
+
+
 #define DEFAULT_CMAP_SIZE	16	/* size of default color map	*/
 
 /*
@@ -34,6 +38,19 @@
     return val;
 }
 
+uint32_t le_int(uint32_t x)
+{
+    uint32_t val;
+    uint8_t *p = (uint8_t *)(&x);
+
+    val =  (*p++ & 0xff) << 0;
+    val =  (*p++ & 0xff) << 8;
+    val =  (*p++ & 0xff) << 16;
+    val |= (*p & 0xff) << 24;
+
+    return val;
+}
+
 void skip_bytes (FILE *fp, int n)
 {
 	while (n-- > 0)
@@ -47,6 +64,13 @@
 	bitmap_t bmp;
 	bitmap_t *b = &bmp;
 	uint16_t data_offset, n_colors;
+#if defined(CONFIG_LCD)
+#if LCD_BPP==4
+	short val;
+#elif LCD_BPP==5
+	int val;
+#endif
+#endif
 
 	if (argc < 2) {
 		fprintf (stderr, "Usage: %s file\n", argv[0]);
@@ -86,10 +110,16 @@
 	n_colors = le_short(n_colors);
 
 	/* assume we are working with an 8-bit file */
+#if defined(CONFIG_LCD)
+	if ( n_colors > 256 ) {
+		n_colors = 256 ;
+	}
+#else
 	if ((n_colors == 0) || (n_colors > 256 - DEFAULT_CMAP_SIZE)) {
 		/* reserve DEFAULT_CMAP_SIZE color map entries for default map */
 		n_colors = 256 - DEFAULT_CMAP_SIZE;
 	}
+#endif
 
 	printf ("/*\n"
 		" * Automatically generated by \"tools/bmp_logo\"\n"
@@ -115,7 +145,7 @@
 	}
 
 	/* read and print the palette information */
-	printf ("unsigned short bmp_logo_palette[] = {\n");
+	printf ("unsigned int bmp_logo_palette[] = {\n");
 
 	for (i=0; i<n_colors; ++i) {
 		b->palette[(int)(i*3+2)] = fgetc(fp);
@@ -123,6 +153,27 @@
 		b->palette[(int)(i*3+0)] = fgetc(fp);
 		x=fgetc(fp);
 
+#if defined(CONFIG_LCD)
+		val = 0;
+
+#if LCD_BPP==4 
+		/* RGB565(16bits) */
+		val = 	((b->palette[(int)(i*3+0)] >> 3) & 0x1F )<< 11 | \
+			((b->palette[(int)(i*3+1)] >> 2) & 0x3F )<< 5  | \
+			((b->palette[(int)(i*3+2)] >> 3) & 0x1F );
+#elif LCD_BPP==5
+		/* RGB666(18bits) */
+		val = 	b->palette[(int)(i*3+0)] << 16 | \
+			b->palette[(int)(i*3+1)] << 8  | \
+			b->palette[(int)(i*3+2)] << 0 ;
+#endif 
+		printf ("%s0x%X,%s",
+			((i%8) == 0) ? "\t" : "  ",
+			val,
+			((i%8) == 7) ? "\n" : ""
+		);
+
+#else
 		printf ("%s0x0%X%X%X,%s",
 			((i%8) == 0) ? "\t" : "  ",
 			(b->palette[(int)(i*3+0)] >> 4) & 0x0F,
@@ -130,6 +181,7 @@
 			(b->palette[(int)(i*3+2)] >> 4) & 0x0F,
 			((i%8) == 7) ? "\n" : ""
 		);
+#endif
 	}
 
 	/* seek to offset indicated by file header */
@@ -142,8 +194,12 @@
 	printf ("unsigned char bmp_logo_bitmap[] = {\n");
 	for (i=(b->height-1)*b->width; i>=0; i-=b->width) {
 		for (x = 0; x < b->width; x++) {
+#if defined(CONFIG_LCD)
+			b->data[ i + x] = (uint8_t) fgetc (fp) ;
+#else
 			b->data[(uint16_t) i + x] = (uint8_t) fgetc (fp) \
 						+ DEFAULT_CMAP_SIZE;
+#endif
 		}
 	}
 	fclose (fp);
